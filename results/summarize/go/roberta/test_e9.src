5238	func ( u * URI ) Normalize ( ) string { scheme := u . scheme index := strings . Index ( scheme , "+" ) if index >= 0 { scheme = scheme [ : index ] } return fmt . Sprintf ( "%s://%s:%d" , scheme , u . host , u . port ) }
1507	func ( secret * ASMSecretResource ) retrieveASMSecretValue ( apiSecret apicontainer . Secret , iamCredentials credentials . IAMRoleCredentials , wg * sync . WaitGroup , errorEvents chan error ) { defer wg . Done ( ) asmClient := secret . asmClientCreator . NewASMClient ( apiSecret . Region , iamCredentials ) seelog . Infof ( "ASM secret resource: retrieving resource for secret %v in region %s for task: [%s]" , apiSecret . ValueFrom , apiSecret . Region , secret . taskARN ) secretValue , err := asm . GetSecretFromASM ( apiSecret . ValueFrom , asmClient ) if err != nil { errorEvents <- fmt . Errorf ( "fetching secret data from AWS Secrets Manager in region %s: %v" , apiSecret . Region , err ) return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secretKey := apiSecret . GetSecretResourceCacheKey ( ) secret . secretData [ secretKey ] = secretValue }
6658	func SupportedFunc ( opts * ServerOptions ) func ( * Request ) error { subjectMap := map [ SubjectType ] bool { } for _ , subjectType := range opts . SubjectTypes { subjectMap [ subjectType ] = true } identityMap := map [ string ] bool { } for _ , identity := range opts . Identities { identityMap [ string ( identity . Type ) + string ( identity . Format ) ] = true } return func ( req * Request ) error { if _ , ok := subjectMap [ req . SubjectRequestType ] ; ! ok { return ErrUnsupportedRequestType ( req . SubjectRequestType ) } for _ , identity := range req . SubjectIdentities { if _ , ok := identityMap [ string ( identity . Type ) + string ( identity . Format ) ] ; ! ok { return ErrUnsupportedIdentity ( identity ) } } return nil } }
6565	func ( r Record ) GetString ( column string ) ( string , error ) { v , err := r . getKey ( reflect . String , column ) if err != nil { return "" , err } return v . ( string ) , nil }
1452	func ( state * DockerTaskEngineState ) DockerIDByV3EndpointID ( v3EndpointID string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) dockerID , ok := state . v3EndpointIDToDockerID [ v3EndpointID ] return dockerID , ok }
4271	func setupRootfs ( config * configs . Config , console * linuxConsole ) ( err error ) { if err := prepareRoot ( config ) ; err != nil { return newSystemError ( err ) } for _ , m := range config . Mounts { for _ , precmd := range m . PremountCmds { if err := mountCmd ( precmd ) ; err != nil { return newSystemError ( err ) } } if err := mountToRootfs ( m , config . Rootfs , config . MountLabel ) ; err != nil { return newSystemError ( err ) } for _ , postcmd := range m . PostmountCmds { if err := mountCmd ( postcmd ) ; err != nil { return newSystemError ( err ) } } } if err := createDevices ( config ) ; err != nil { return newSystemError ( err ) } if err := setupPtmx ( config , console ) ; err != nil { return newSystemError ( err ) } if err := setupDevSymlinks ( config . Rootfs ) ; err != nil { return newSystemError ( err ) } if err := syscall . Chdir ( config . Rootfs ) ; err != nil { return newSystemError ( err ) } if config . NoPivotRoot { err = msMoveRoot ( config . Rootfs ) } else { err = pivotRoot ( config . Rootfs , config . PivotDir ) } if err != nil { return newSystemError ( err ) } if err := reOpenDevNull ( config . Rootfs ) ; err != nil { return newSystemError ( err ) } if config . Readonlyfs { if err := setReadonly ( ) ; err != nil { return newSystemError ( err ) } } syscall . Umask ( 0022 ) return nil }
5709	func ( s * Sentinel ) MasterAddr ( ) ( string , error ) { res , err := s . doUntilSuccess ( func ( c redis . Conn ) ( interface { } , error ) { return queryForMaster ( c , s . MasterName ) } ) if err != nil { return "" , err } return res . ( string ) , nil }
1654	func ( mr * MockTaskResourceMockRecorder ) MarshalJSON ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "MarshalJSON" , reflect . TypeOf ( ( * MockTaskResource ) ( nil ) . MarshalJSON ) ) }
2073	func GetCredentialsEventType ( roleType string ) string { switch roleType { case credentials . ApplicationRoleType : return getCredentialsEventType case credentials . ExecutionRoleType : return getCredentialsTaskExecutionEventType default : return getCredentialsInvalidRoleTypeEventType } }
5253	func ( c * Client ) ExportField ( field * Field ) ( io . Reader , error ) { span := c . tracer . StartSpan ( "Client.ExportField" ) defer span . Finish ( ) var shardsMax map [ string ] uint64 var err error status , err := c . Status ( ) if err != nil { return nil , err } shardsMax , err = c . shardsMax ( ) if err != nil { return nil , err } status . indexMaxShard = shardsMax shardURIs , err := c . statusToNodeShardsForIndex ( status , field . index . Name ( ) ) if err != nil { return nil , err } return newExportReader ( c , shardURIs , field ) , nil }
343	func ( rule * RecordingRule ) LastError ( ) error { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . lastError }
4911	func ( r * Reader ) ReadUint16 ( ) uint16 { if r . err != nil { return 0 } var n int n , r . err = io . ReadFull ( r . rd , r . b [ : 2 ] ) r . cnt += n if r . err != nil { return 0 } return binary . LittleEndian . Uint16 ( r . b [ : 2 ] ) }
5260	func OptClientSocketTimeout ( timeout time . Duration ) ClientOption { return func ( options * ClientOptions ) error { options . SocketTimeout = timeout return nil } }
4687	func newElementBase ( ln * line , rslt * result , src * source , parent element , opts * Options ) elementBase { return elementBase { ln : ln , rslt : rslt , src : src , parent : parent , opts : opts , } }
3392	func ( m * MetricMetadata ) GetStatsdInterval ( ) int { if m == nil || m . StatsdInterval == nil { return 0 } return * m . StatsdInterval }
2931	func flattenClusterDependencyRuleInfo ( d * schema . ResourceData , obj * types . ClusterDependencyRuleInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { "enabled" : obj . Enabled , "mandatory" : obj . Mandatory , "name" : obj . Name , "dependency_vm_group_name" : obj . DependsOnVmGroup , "vm_group_name" : obj . VmGroup , } ) }
3612	func ( t * TimeseriesDefinition ) HasShowLegend ( ) bool { if t != nil && t . ShowLegend != nil { return true } return false }
4298	func badPrefix ( fpath string ) error { var badprefixes = [ ] string { "/usr" } for _ , prefix := range badprefixes { if fpath == prefix || strings . HasPrefix ( fpath , fmt . Sprintf ( "%s/" , prefix ) ) { return fmt . Errorf ( "Relabeling content in %s is not allowed." , prefix ) } } return nil }
6572	func ChangeCustomSvcVar ( host_name string , service_description string , varname string , varvalue string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_CUSTOM_SVC_VAR" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , stringifyArg ( "varname" , "string" , varname ) , stringifyArg ( "varvalue" , "string" , varvalue ) , ) }
5349	func _Set ( filename , key , value string ) error { conf , err := shconf . ParseFile ( filename ) if err != nil { if err != os . ErrNotExist { return err } println ( "ErrNotExist" ) } else { if _ , err = conf . Get ( key ) ; err != shconf . ErrKey { panic ( "OPS" ) } } return file . AppendString ( filename , key + string ( conf . Separator ( ) ) + value ) }
28	func New ( logger log . Logger , conf * SDConfig ) ( * Discovery , error ) { tls , err := config_util . NewTLSConfig ( & conf . TLSConfig ) if err != nil { return nil , err } transport := & http . Transport { TLSClientConfig : tls , DialContext : conntrack . NewDialContextFunc ( conntrack . DialWithTracing ( ) , conntrack . DialWithName ( "triton_sd" ) , ) , } client := & http . Client { Transport : transport } d := & Discovery { client : client , interval : time . Duration ( conf . RefreshInterval ) , sdConfig : conf , } d . Discovery = refresh . NewDiscovery ( logger , "triton" , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d , nil }
2089	func ( mr * MockNetLinkMockRecorder ) LinkList ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "LinkList" , reflect . TypeOf ( ( * MockNetLink ) ( nil ) . LinkList ) ) }
2121	func ( v * Misc ) native ( ) * C . GtkMisc { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMisc ( p ) }
5093	func List ( c * gin . Context ) { db := c . MustGet ( "db" ) . ( * mgo . Database ) articles := [ ] models . Article { } err := db . C ( models . CollectionArticle ) . Find ( nil ) . Sort ( "-updated_on" ) . All ( & articles ) if err != nil { c . Error ( err ) } c . HTML ( http . StatusOK , "articles/list" , gin . H { "title" : "Articles" , "articles" : articles , } ) }
6840	func ( c * Client ) PushNote ( iden string , title , body string ) error { data := Note { Iden : iden , Type : "note" , Title : title , Body : body , } return c . Push ( "/pushes" , data ) }
2702	func ( c * Config ) vimSessionFile ( ) ( string , error ) { p , err := c . sessionFile ( ) if err != nil { return "" , err } return filepath . Join ( c . VimSessionPath , p ) , nil }
2347	func MipmapLevel ( det float32 ) int { if math . IsNaN ( float64 ( det ) ) { panic ( "graphicsutil: det must be finite" ) } if det == 0 { return - 1 } d := math . Abs ( float64 ( det ) ) level := 0 for d < 0.25 { level ++ d *= 4 } return level }
637	func NewIngressSource ( kubeClient kubernetes . Interface , namespace , annotationFilter string , fqdnTemplate string , combineFqdnAnnotation bool , ignoreHostnameAnnotation bool ) ( Source , error ) { var ( tmpl * template . Template err error ) if fqdnTemplate != "" { tmpl , err = template . New ( "endpoint" ) . Funcs ( template . FuncMap { "trimPrefix" : strings . TrimPrefix , } ) . Parse ( fqdnTemplate ) if err != nil { return nil , err } } informerFactory := kubeinformers . NewSharedInformerFactoryWithOptions ( kubeClient , 0 , kubeinformers . WithNamespace ( namespace ) ) ingressInformer := informerFactory . Extensions ( ) . V1beta1 ( ) . Ingresses ( ) ingressInformer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { } , } , ) informerFactory . Start ( wait . NeverStop ) err = wait . Poll ( time . Second , 60 * time . Second , func ( ) ( bool , error ) { return ingressInformer . Informer ( ) . HasSynced ( ) == true , nil } ) if err != nil { return nil , fmt . Errorf ( "failed to sync cache: %v" , err ) } sc := & ingressSource { client : kubeClient , namespace : namespace , annotationFilter : annotationFilter , fqdnTemplate : tmpl , combineFQDNAnnotation : combineFqdnAnnotation , ignoreHostnameAnnotation : ignoreHostnameAnnotation , ingressInformer : ingressInformer , } return sc , nil }
5592	func ( o * DeleteVMParams ) WithTimeout ( timeout time . Duration ) * DeleteVMParams { o . SetTimeout ( timeout ) return o }
4143	func ( n Network ) Equal ( n1 Network ) bool { return n . String ( ) == n1 . String ( ) }
6709	func ( c * Client ) ApplyFirewallPolicy ( policyId string , serverGroupId string ) ( * FirewallPolicy , error ) { policy := new ( FirewallPolicy ) _ , err := c . MakeApiRequest ( "POST" , "/1.0/firewall_policies/" + policyId + "/apply_to" , map [ string ] string { "server_group" : serverGroupId } , & policy ) if err != nil { return nil , err } return policy , nil }
3554	func ( s * SyntheticsTest ) GetModifiedByOk ( ) ( SyntheticsUser , bool ) { if s == nil || s . ModifiedBy == nil { return SyntheticsUser { } , false } return * s . ModifiedBy , true }
5641	func HexDecode ( str string ) [ ] byte { b , _ := hex . DecodeString ( str ) return b }
2498	func ( u * UserInterface ) setScreenSize ( width , height int , scale float64 , fullscreen bool , vsync bool ) bool { if u . width == width && u . height == height && u . scale == scale && u . isFullscreen ( ) == fullscreen && u . vsync == vsync { return false } u . forceSetScreenSize ( width , height , scale , fullscreen , vsync ) return true }
1711	func ( task * Task ) requiresASMDockerAuthData ( ) bool { for _ , container := range task . Containers { if container . ShouldPullWithASMAuth ( ) { return true } } return false }
3715	func ( w * Widget ) GetSizeVersion ( ) string { if w == nil || w . SizeVersion == nil { return "" } return * w . SizeVersion }
325	func ( r * sampleRing ) nthLast ( n int ) ( int64 , float64 , bool ) { if n > r . l { return 0 , 0 , false } t , v := r . at ( r . l - n ) return t , v , true }
5623	func NewPrivKeyLedgerSecp256k1 ( path DerivationPath ) ( PrivKey , error ) { var pk PrivKeyLedgerSecp256k1 pk . Path = path pubKey , err := pk . getPubKey ( ) if err != nil { return nil , err } pk . CachedPubKey = pubKey return & pk , err }
5868	func ( a * API ) FetchBrokers ( ) ( * [ ] Broker , error ) { result , err := a . Get ( config . BrokerPrefix ) if err != nil { return nil , err } var response [ ] Broker if err := json . Unmarshal ( result , & response ) ; err != nil { return nil , err } return & response , nil }
4457	func ( r Password ) MarshalJSON ( ) ( [ ] byte , error ) { var w jwriter . Writer r . MarshalEasyJSON ( & w ) return w . BuildBytes ( ) }
4910	func ( r * Reader ) ReadInt16 ( ) int16 { if r . err != nil { return 0 } var n int n , r . err = io . ReadFull ( r . rd , r . b [ : 2 ] ) r . cnt += n if r . err != nil { return 0 } return int16 ( binary . LittleEndian . Uint16 ( r . b [ : 2 ] ) ) }
1933	func ( m * MockTaskEngineState ) AddImageState ( arg0 * image . ImageState ) { m . ctrl . Call ( m , "AddImageState" , arg0 ) }
350	func ( r * ewmaRate ) incr ( incr int64 ) { atomic . AddInt64 ( & r . newEvents , incr ) }
5593	func ( o * DeleteVMParams ) WithContext ( ctx context . Context ) * DeleteVMParams { o . SetContext ( ctx ) return o }
573	func ( mx * Mux ) Delete ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mDELETE , pattern , handlerFn ) }
299	func MustNewRegexp ( s string ) Regexp { re , err := NewRegexp ( s ) if err != nil { panic ( err ) } return re }
6229	func ( h * Handler ) GetEndpoints ( tkn , channel , template string ) ( [ ] data . Endpoint , error ) { logger := h . logger . Add ( "method" , "GetEndpoints" , "channel" , channel , "template" , template ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } tail , args := h . getEndpointsConditions ( channel , template ) result , err := h . selectAllFrom ( logger , data . EndpointTable , tail , args ... ) if err != nil { return nil , err } endpoints := make ( [ ] data . Endpoint , len ( result ) ) for i , item := range result { endpoints [ i ] = * item . ( * data . Endpoint ) } return endpoints , nil }
4544	func ( n ImageName ) RegistryURL ( ) string { reg := n . Registry if reg == "" { reg = defaultRegistry } return fmt . Sprintf ( "https://%s" , reg ) }
5543	func ( c * Client ) Part ( roomId , name string ) { c . connection . MUCPart ( roomId + "/" + name ) }
6505	func ( c Client ) GetBalance ( ) ( float64 , error ) { balance := map [ string ] string { } if err := c . Get ( "account/balance" , nil , & balance ) ; err != nil { return 0.0 , err } balanceFloat , err := strconv . ParseFloat ( balance [ "amount" ] , 64 ) if err != nil { return 0 , err } return balanceFloat , nil }
5203	func ( idx * Index ) Fields ( ) map [ string ] * Field { result := make ( map [ string ] * Field ) for k , v := range idx . fields { result [ k ] = v . copy ( ) } return result }
3496	func ( s * Series ) HasAggr ( ) bool { if s != nil && s . Aggr != nil { return true } return false }
3768	func ( k * APIKey ) UnmarshalJSON ( data [ ] byte ) error { type Alias APIKey aux := & struct { Created * string `json:"created,omitempty"` * Alias } { Alias : ( * Alias ) ( k ) , } if err := json . Unmarshal ( data , & aux ) ; err != nil { return err } if created , err := time . Parse ( createdTimeLayout , * aux . Created ) ; err != nil { return err } else { k . Created = & created } return nil }
642	func ( l Labels ) Serialize ( withQuotes bool ) string { var tokens [ ] string tokens = append ( tokens , fmt . Sprintf ( "heritage=%s" , heritage ) ) var keys [ ] string for key := range l { keys = append ( keys , key ) } sort . Strings ( keys ) for _ , key := range keys { tokens = append ( tokens , fmt . Sprintf ( "%s/%s=%s" , heritage , key , l [ key ] ) ) } if withQuotes { return fmt . Sprintf ( "\"%s\"" , \" ) } \" }
4359	func FindKey ( in [ ] byte , pos int , k [ ] byte ) ( [ ] byte , error ) { pos , err := skipSpace ( in , pos ) if err != nil { return nil , err } if v := in [ pos ] ; v != '{' { return nil , newError ( pos , v ) } pos ++ for { pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } keyStart := pos pos , err = String ( in , pos ) if err != nil { return nil , err } key := in [ keyStart + 1 : pos - 1 ] match := bytes . Equal ( k , key ) pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } pos , err = expect ( in , pos , ':' ) if err != nil { return nil , err } pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } valueStart := pos pos , err = Any ( in , pos ) if err != nil { return nil , err } if match { return in [ valueStart : pos ] , nil } pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } switch in [ pos ] { case ',' : pos ++ case '}' : return nil , errKeyNotFound } } }
4877	func ( e * hdbErrors ) Level ( ) int { return int ( e . errors [ e . idx ] . errorLevel ) }
1076	func newQuiescence ( ch chan * template . Template , min , max time . Duration , t * template . Template ) * quiescence { return & quiescence { template : t , min : min , max : max , ch : ch , } }
6454	func ( t * TraceLocation ) match ( file string , line int ) bool { if t . line != line { return false } if i := strings . LastIndex ( file , "/" ) ; i >= 0 { file = file [ i + 1 : ] } return t . file == file }
4818	func ( r * Repo ) execThen ( ) error { var errs error for _ , command := range r . Then { err := command . Exec ( r . Path ) if err == nil { Logger ( ) . Printf ( "Command '%v' successful.\n" , \n ) } command . Command ( ) } errs = mergeErrors ( errs , err ) }
1842	func ( f * factory ) FindClientAPIVersion ( client sdkclient . Client ) dockerclient . DockerVersion { return dockerclient . DockerVersion ( client . ClientVersion ( ) ) }
3141	func ParseCarbonlinkRequest ( d [ ] byte ) ( * CarbonlinkRequest , error ) { if ! ( expectBytes ( & d , [ ] byte ( "\x80\x02}" ) ) && \x80 && \x02 ) pickleMaybeMemo ( & d ) expectBytes ( & d , [ ] byte ( "(" ) ) { return nil , badErr } req := NewCarbonlinkRequest ( ) var Metric , Type string var ok bool }
4070	func ColorToString ( attr term . Attribute ) string { var out string rawClr := attr & 15 if rawClr < 8 { for k , v := range colorMap { if v == rawClr { out += k + " " break } } } if attr & term . AttrBold != 0 { out += "bold " } if attr & term . AttrUnderline != 0 { out += "underline " } if attr & term . AttrReverse != 0 { out += "reverse " } return strings . TrimSpace ( out ) }
4129	func GoPaths ( ) [ ] string { gp := Get ( "GOPATH" , "" ) if runtime . GOOS == "windows" { return strings . Split ( gp , ";" ) } return strings . Split ( gp , ":" ) }
843	func ( c * ComputeUtil ) openFirewallPorts ( d * Driver ) error { log . Infof ( "Opening firewall ports" ) create := false rule , _ := c . firewallRule ( ) if rule == nil { create = true rule = & raw . Firewall { Name : firewallRule , Allowed : [ ] * raw . FirewallAllowed { } , SourceRanges : [ ] string { "0.0.0.0/0" } , TargetTags : [ ] string { firewallTargetTag } , Network : c . globalURL + "/networks/" + d . Network , } } portsUsed , err := c . portsUsed ( ) if err != nil { return err } missingPorts := missingOpenedPorts ( rule , portsUsed ) if len ( missingPorts ) == 0 { return nil } for proto , ports := range missingPorts { rule . Allowed = append ( rule . Allowed , & raw . FirewallAllowed { IPProtocol : proto , Ports : ports , } ) } var op * raw . Operation if create { op , err = c . service . Firewalls . Insert ( c . project , rule ) . Do ( ) } else { op , err = c . service . Firewalls . Update ( c . project , firewallRule , rule ) . Do ( ) } if err != nil { return err } return c . waitForGlobalOp ( op . Name ) }
2975	func ( r * DiskSubresource ) DiffExisting ( ) error { log . Printf ( "[DEBUG] %s: Beginning normalization of existing disk" , r ) name , err := diskLabelOrName ( r . data ) if err != nil { return err } olabel , nlabel := r . GetChange ( "label" ) if olabel != "" && nlabel == "" { return errors . New ( "cannot migrate from label to name" ) } if nlabel == "" { oname , _ := r . GetChange ( "name" ) r . Set ( "name" , oname . ( string ) ) } okey , _ := r . GetChange ( "key" ) odaddr , _ := r . GetChange ( "device_address" ) ouuid , _ := r . GetChange ( "uuid" ) r . Set ( "key" , okey ) r . Set ( "device_address" , odaddr ) r . Set ( "uuid" , ouuid ) if ! r . Get ( "attach" ) . ( bool ) { opath , _ := r . GetChange ( "path" ) r . Set ( "path" , opath . ( string ) ) } if r . Get ( "datastore_id" ) == "" { switch { case r . rdd . HasChange ( "datastore_id" ) : dsID := r . rdd . Get ( "datastore_id" ) . ( string ) if dsID == "" { r . Set ( "datastore_id" , diskDatastoreComputedName ) } else { r . Set ( "datastore_id" , dsID ) } default : if err = r . normalizeDiskDatastore ( ) ; err != nil { return err } } } osc , _ := r . GetChange ( "io_share_count" ) if r . Get ( "io_share_level" ) . ( string ) != string ( types . SharesLevelCustom ) { r . Set ( "io_share_count" , osc ) } osize , nsize := r . GetChange ( "size" ) if osize . ( int ) > nsize . ( int ) { return fmt . Errorf ( "virtual disk %q: virtual disks cannot be shrunk (old: %d new: %d)" , name , osize . ( int ) , nsize . ( int ) ) } if _ , err = r . GetWithVeto ( "eagerly_scrub" ) ; err != nil { return fmt . Errorf ( "virtual disk %q: %s" , name , err ) } if _ , err = r . GetWithVeto ( "thin_provisioned" ) ; err != nil { return fmt . Errorf ( "virtual disk %q: %s" , name , err ) } if _ , err = r . GetWithVeto ( "attach" ) ; err != nil { return fmt . Errorf ( "virtual disk %q: %s" , name , err ) } if r . HasChange ( "datastore_id" ) { if err = r . validateStorageRelocateDiff ( ) ; err != nil { return err } } log . Printf ( "[DEBUG] %s: Normalization of existing disk diff complete" , r ) return nil }
523	func ( h * ResponseHeader ) AppendBytes ( dst [ ] byte ) [ ] byte { statusCode := h . StatusCode ( ) if statusCode < 0 { statusCode = StatusOK } dst = append ( dst , statusLine ( statusCode ) ... ) server := h . Server ( ) if len ( server ) != 0 { dst = appendHeaderLine ( dst , strServer , server ) } dst = appendHeaderLine ( dst , strDate , serverDate . Load ( ) . ( [ ] byte ) ) if h . ContentLength ( ) != 0 || len ( h . contentType ) > 0 { dst = appendHeaderLine ( dst , strContentType , h . ContentType ( ) ) } if len ( h . contentLengthBytes ) > 0 { dst = appendHeaderLine ( dst , strContentLength , h . contentLengthBytes ) } for i , n := 0 , len ( h . h ) ; i < n ; i ++ { kv := & h . h [ i ] if ! bytes . Equal ( kv . key , strDate ) { dst = appendHeaderLine ( dst , kv . key , kv . value ) } } n := len ( h . cookies ) if n > 0 { for i := 0 ; i < n ; i ++ { kv := & h . cookies [ i ] dst = appendHeaderLine ( dst , strSetCookie , kv . value ) } } if h . ConnectionClose ( ) { dst = appendHeaderLine ( dst , strConnection , strClose ) } return append ( dst , strCRLF ... ) }
1857	func ( m * MockWebsocketConn ) ReadMessage ( ) ( int , [ ] byte , error ) { ret := m . ctrl . Call ( m , "ReadMessage" ) ret0 , _ := ret [ 0 ] . ( int ) ret1 , _ := ret [ 1 ] . ( [ ] byte ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 }
3101	func ( rm * routeMap ) getLeaf ( method , pattern string ) * Leaf { rm . lock . RLock ( ) defer rm . lock . RUnlock ( ) return rm . routes [ method ] [ pattern ] }
5644	func BTCAddrBytesFromPubKeyBytes ( pubKeyBytes [ ] byte ) ( addrBytes [ ] byte , checksum [ ] byte ) { versionPrefix := btcPrefixPubKeyHash h160 := CalcHash160 ( pubKeyBytes ) _h160 := append ( [ ] byte { versionPrefix } , h160 ... ) checksum = CalcHash256 ( _h160 ) [ : 4 ] return h160 , checksum }
4167	func ( c * GenerateConcoursePipelineCommand ) Execute ( [ ] string ) error { lo . G . Warning ( "This command has been deprecated use lastest cf-mgmt-config cli" ) const varsFileName = "vars.yml" const pipelineFileName = "pipeline.yml" const cfMgmtYml = "cf-mgmt.yml" const cfMgmtSh = "cf-mgmt.sh" var targetFile string fmt . Println ( "Generating pipeline...." ) if err := createFile ( pipelineFileName , pipelineFileName ) ; err != nil { lo . G . Error ( "Error creating pipeline.yml" , err ) return err } if err := createFile ( varsFileName , varsFileName ) ; err != nil { lo . G . Error ( "Error creating vars.yml" , err ) return err } if err := os . MkdirAll ( "ci/tasks" , 0755 ) ; err == nil { targetFile = filepath . Join ( "ci" , "tasks" , cfMgmtYml ) lo . G . Debug ( "Creating" , targetFile ) if err = createFile ( cfMgmtYml , targetFile ) ; err != nil { lo . G . Error ( "Error creating cf-mgmt.yml" , err ) return err } targetFile = filepath . Join ( "ci" , "tasks" , cfMgmtSh ) lo . G . Debug ( "Creating" , targetFile ) if err = createFile ( cfMgmtSh , targetFile ) ; err != nil { lo . G . Error ( "Error creating cf-mgmt.sh" , err ) return err } } else { lo . G . Error ( "Error making directories" , err ) return err } fmt . Println ( "1) Update vars.yml with the appropriate values" ) fmt . Println ( "2) Using following command to set your pipeline in concourse after you have checked all files in to git" ) fmt . Println ( "fly -t lite set-pipeline -p cf-mgmt -c pipeline.yml --load-vars-from=vars.yml" ) return nil }
1378	func NewMockControl ( ctrl * gomock . Controller ) * MockControl { mock := & MockControl { ctrl : ctrl } mock . recorder = & MockControlMockRecorder { mock } return mock }
218	func ( zl ZookeeperLogger ) Printf ( s string , i ... interface { } ) { level . Info ( zl . logger ) . Log ( "msg" , fmt . Sprintf ( s , i ... ) ) }
4405	func ( b * Base64 ) DeepCopy ( ) * Base64 { if b == nil { return nil } out := new ( Base64 ) b . DeepCopyInto ( out ) return out }
859	func ( a AzureClient ) CreateSubnet ( ctx * DeploymentContext , resourceGroup , virtualNetwork , name , subnetPrefix string ) error { subnet , err := a . GetSubnet ( resourceGroup , virtualNetwork , name ) if err == nil { log . Info ( "Subnet already exists." ) ctx . SubnetID = to . String ( subnet . ID ) return err } if err . ( autorest . DetailedError ) . StatusCode == 404 { log . Info ( "Configuring subnet." , logutil . Fields { "name" : name , "vnet" : virtualNetwork , "cidr" : subnetPrefix } ) _ , err = a . subnetsClient ( ) . CreateOrUpdate ( resourceGroup , virtualNetwork , name , network . Subnet { Properties : & network . SubnetPropertiesFormat { AddressPrefix : to . StringPtr ( subnetPrefix ) , } , } , nil ) if err != nil { return err } subnet , err = a . subnetsClient ( ) . Get ( resourceGroup , virtualNetwork , name , "" ) ctx . SubnetID = to . String ( subnet . ID ) return err } log . Warn ( "Create subnet operation error %v: " , err ) return err }
902	func ( d * Driver ) Remove ( ) error { if err := d . checkLegacyDriver ( false ) ; err != nil { return err } log . Info ( "NOTICE: Please check Azure portal/CLI to make sure you have no leftover resources to avoid unexpected charges." ) c , err := d . newAzureClient ( ) if err != nil { return err } if err := c . DeleteVirtualMachineIfExists ( d . ResourceGroup , d . naming ( ) . VM ( ) ) ; err != nil { return err } if err := c . DeleteNetworkInterfaceIfExists ( d . ResourceGroup , d . naming ( ) . NIC ( ) ) ; err != nil { return err } if err := c . DeletePublicIPAddressIfExists ( d . ResourceGroup , d . naming ( ) . IP ( ) ) ; err != nil { return err } if err := c . DeleteNetworkSecurityGroupIfExists ( d . ResourceGroup , d . naming ( ) . NSG ( ) ) ; err != nil { return err } if err := c . CleanupAvailabilitySetIfExists ( d . ResourceGroup , d . AvailabilitySet ) ; err != nil { return err } if err := c . CleanupSubnetIfExists ( d . ResourceGroup , d . VirtualNetwork , d . SubnetName ) ; err != nil { return err } err = c . CleanupVirtualNetworkIfExists ( d . ResourceGroup , d . VirtualNetwork ) return err }
5986	func NewMeasuredReader ( r io . Reader ) * MeasuredReader { return & MeasuredReader { wrap : r , rate : newCounter ( ) } }
6934	func ( r * Reservoir ) Snapshot ( ) Distribution { h := newHistogram ( defaultHistogramSize ) r . m . Lock ( ) h = r . hist . Copy ( h ) r . m . Unlock ( ) return h }
496	func ( h * RequestHeader ) Host ( ) [ ] byte { if len ( h . host ) > 0 { return h . host } if ! h . rawHeadersParsed { host := peekRawHeader ( h . rawHeaders , strHost ) if len ( host ) > 0 { h . host = append ( h . host [ : 0 ] , host ... ) return h . host } } h . parseRawHeaders ( ) return h . host }
3741	func ( w * WidgetApmOrLogQuery ) HasSearch ( ) bool { if w != nil && w . Search != nil { return true } return false }
5893	func ( r RSAMethod ) Sign ( rand io . Reader , priv * rsa . PrivateKey , hash crypto . Hash , buf [ ] byte ) ( [ ] byte , error ) { return r . SignFunc ( rand , priv , hash , buf ) }
2100	func ( eni * ENIAttachment ) StartTimer ( timeoutFunc func ( ) ) error { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) if eni . ackTimer != nil { return nil } now := time . Now ( ) duration := eni . ExpiresAt . Sub ( now ) if duration <= 0 { return errors . Errorf ( "eni attachment: timer expiration is in the past; expiration [%s] < now [%s]" , eni . ExpiresAt . String ( ) , now . String ( ) ) } seelog . Infof ( "Starting ENI ack timer with duration=%s, %s" , duration . String ( ) , eni . stringUnsafe ( ) ) eni . ackTimer = time . AfterFunc ( duration , timeoutFunc ) return nil }
2038	func ( client * ecrClient ) GetAuthorizationToken ( registryId string ) ( * ecrapi . AuthorizationData , error ) { log . Debugf ( "Calling GetAuthorizationToken for %q" , registryId ) output , err := client . sdkClient . GetAuthorizationToken ( & ecrapi . GetAuthorizationTokenInput { RegistryIds : [ ] * string { aws . String ( registryId ) } , } ) if err != nil { return nil , err } if len ( output . AuthorizationData ) != 1 { return nil , fmt . Errorf ( "unexpected number of results in AuthorizationData (%d)" , len ( output . AuthorizationData ) ) } return output . AuthorizationData [ 0 ] , nil }
271	func ( l * lexer ) linePosition ( ) int { lb := strings . LastIndex ( l . input [ : l . lastPos ] , "\n" ) \n if lb == - 1 { return 1 + int ( l . lastPos ) } }
4864	func ( r * RateLimiter ) Has ( id string ) ( bool , error ) { hash := r . hasher . Hash ( id ) return r . redisClient . Exists ( hash ) . Result ( ) }
5892	func ( b * Bearer ) Client ( ) * http . Client { return & http . Client { Transport : & oauth2 . Transport { Source : b , } , } }
7115	func ( c * Config ) AddComment ( sect , comment string ) { if sect == "" { c . comments = append ( c . comments , comment ) return } for i , s := range c . sections { if s . name == sect { c . sections [ i ] . comments = append ( s . comments , comment ) return } } c . sections = append ( c . sections , section { name : sect , comments : [ ] string { comment } , } ) }
6586	func EnableSvcFlapDetection ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "ENABLE_SVC_FLAP_DETECTION" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
1276	func ( m * MockManager ) RemoveCredentials ( arg0 string ) { m . ctrl . Call ( m , "RemoveCredentials" , arg0 ) }
534	func ( c * Cookie ) SetDomain ( domain string ) { c . domain = append ( c . domain [ : 0 ] , domain ... ) }
705	func NewRcodeZeroProvider ( domainFilter DomainFilter , dryRun bool , txtEnc bool ) ( * RcodeZeroProvider , error ) { client , err := rc0 . NewClient ( os . Getenv ( "RC0_API_KEY" ) ) if err != nil { return nil , err } value := os . Getenv ( "RC0_BASE_URL" ) if len ( value ) != 0 { client . BaseURL , err = url . Parse ( os . Getenv ( "RC0_BASE_URL" ) ) } if err != nil { return nil , fmt . Errorf ( "failed to initialize rcodezero provider: %v" , err ) } provider := & RcodeZeroProvider { Client : client , DomainFilter : domainFilter , DryRun : dryRun , TXTEncrypt : txtEnc , } if txtEnc { provider . Key = [ ] byte ( os . Getenv ( "RC0_ENC_KEY" ) ) } return provider , nil }
4756	func HTTPDelete ( url string ) ( statusCode int , statusText string , err error ) { request , err := http . NewRequest ( "DELETE" , url , nil ) if err != nil { return 0 , "" , err } response , err := http . DefaultClient . Do ( request ) if err != nil { return 0 , "" , err } return response . StatusCode , response . Status , nil }
2015	func ( manager * credentialsManager ) RemoveCredentials ( id string ) { manager . taskCredentialsLock . Lock ( ) defer manager . taskCredentialsLock . Unlock ( ) delete ( manager . idToTaskCredentials , id ) }
5311	func exist ( file string ) ( bool , error ) { _ , err := os . Stat ( file ) if err != nil { if err == os . ErrNotExist { return false , nil } return false , err } return true , nil }
5062	func ( server * mongoServer ) RecycleSocket ( socket * mongoSocket ) { server . Lock ( ) if ! server . closed { server . unusedSockets = append ( server . unusedSockets , socket ) } server . Unlock ( ) }
1000	func Parse ( s string ) ( * Config , error ) { var shadow interface { } if err := hcl . Decode ( & shadow , s ) ; err != nil { return nil , errors . Wrap ( err , "error decoding config" ) } parsed , ok := shadow . ( map [ string ] interface { } ) if ! ok { return nil , errors . New ( "error converting config" ) } flattenKeys ( parsed , [ ] string { "auth" , "consul" , "consul.auth" , "consul.retry" , "consul.ssl" , "consul.transport" , "deduplicate" , "env" , "exec" , "exec.env" , "ssl" , "syslog" , "vault" , "vault.retry" , "vault.ssl" , "vault.transport" , "wait" , } ) if templates , ok := parsed [ "template" ] . ( [ ] map [ string ] interface { } ) ; ok { for _ , template := range templates { flattenKeys ( template , [ ] string { "env" , "exec" , "exec.env" , "wait" , } ) } } var c Config var md mapstructure . Metadata decoder , err := mapstructure . NewDecoder ( & mapstructure . DecoderConfig { DecodeHook : mapstructure . ComposeDecodeHookFunc ( ConsulStringToStructFunc ( ) , StringToFileModeFunc ( ) , signals . StringToSignalFunc ( ) , StringToWaitDurationHookFunc ( ) , mapstructure . StringToSliceHookFunc ( "," ) , mapstructure . StringToTimeDurationHookFunc ( ) , ) , ErrorUnused : true , Metadata : & md , Result : & c , } ) if err != nil { return nil , errors . Wrap ( err , "mapstructure decoder creation failed" ) } if err := decoder . Decode ( parsed ) ; err != nil { return nil , errors . Wrap ( err , "mapstructure decode failed" ) } return & c , nil }
6667	func ( s * VecStack ) Pop ( ) ( value * Vec ) { if s . size > 0 { value , s . top = s . top . value , s . top . next s . size -- return } return nil }
2399	func NewGame ( ) ( * Game , error ) { g := & Game { input : NewInput ( ) , } var err error g . board , err = NewBoard ( boardSize ) if err != nil { return nil , err } return g , nil }
3627	func ( t * TraceServiceDefinition ) HasShowBreakdown ( ) bool { if t != nil && t . ShowBreakdown != nil { return true } return false }
2233	func ( v * Clipboard ) SetImage ( pixbuf * gdk . Pixbuf ) { C . gtk_clipboard_set_image ( v . native ( ) , ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) }
4123	func ( b * SparkChart ) SetHilitePeaks ( hilite bool ) { b . mtx . Lock ( ) defer b . mtx . Unlock ( ) b . hiliteMax = hilite }
792	func LoadOCIConfig ( path string ) ( * OCIConfig , error ) { contents , err := ioutil . ReadFile ( path ) if err != nil { return nil , errors . Wrapf ( err , "reading OCI config file %q" , path ) } cfg := OCIConfig { } if err := yaml . Unmarshal ( contents , & cfg ) ; err != nil { return nil , errors . Wrapf ( err , "parsing OCI config file %q" , path ) } return & cfg , nil }
1180	func ( m * MockContainerMetadataResolver ) ResolveContainer ( arg0 string ) ( * container . DockerContainer , error ) { ret := m . ctrl . Call ( m , "ResolveContainer" , arg0 ) ret0 , _ := ret [ 0 ] . ( * container . DockerContainer ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1448	func ( state * DockerTaskEngineState ) AddTaskIPAddress ( addr string , taskARN string ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) state . ipToTask [ addr ] = taskARN }
5400	func ( * Group ) lookUp ( line string , f field , value interface { } ) interface { } { _field := f . ( groupField ) allField := strings . Split ( line , ":" ) arrayField := make ( map [ int ] [ ] string ) intField := make ( map [ int ] int ) arrayField [ 3 ] = strings . Split ( allField [ 3 ] , "," ) var err error if intField [ 2 ] , err = strconv . Atoi ( allField [ 2 ] ) ; err != nil { panic ( atoiError { _GROUP_FILE , line , "GID" } ) } var isField bool if G_NAME & _field != 0 && allField [ 0 ] == value . ( string ) { isField = true } else if G_PASSWD & _field != 0 && allField [ 1 ] == value . ( string ) { isField = true } else if G_GID & _field != 0 && intField [ 2 ] == value . ( int ) { isField = true } else if G_MEMBER & _field != 0 && checkGroup ( arrayField [ 3 ] , value . ( string ) ) { isField = true } else if G_ALL & _field != 0 { isField = true } if isField { return & Group { Name : allField [ 0 ] , password : allField [ 1 ] , GID : intField [ 2 ] , UserList : arrayField [ 3 ] , } } return nil }
3949	func ( xxh * XXHZero ) Sum32 ( ) uint32 { h32 := uint32 ( xxh . totalLen ) if h32 >= 16 { h32 += rol1 ( xxh . v1 ) + rol7 ( xxh . v2 ) + rol12 ( xxh . v3 ) + rol18 ( xxh . v4 ) } else { h32 += prime32_5 } p := 0 n := xxh . bufused buf := xxh . buf for n := n - 4 ; p <= n ; p += 4 { h32 += binary . LittleEndian . Uint32 ( buf [ p : p + 4 ] ) * prime32_3 h32 = rol17 ( h32 ) * prime32_4 } for ; p < n ; p ++ { h32 += uint32 ( buf [ p ] ) * prime32_5 h32 = rol11 ( h32 ) * prime32_1 } h32 ^= h32 >> 15 h32 *= prime32_2 h32 ^= h32 >> 13 h32 *= prime32_3 h32 ^= h32 >> 16 return h32 }
2236	func ( v * Clipboard ) WaitForContents ( target gdk . Atom ) ( * SelectionData , error ) { c := C . gtk_clipboard_wait_for_contents ( v . native ( ) , C . GdkAtom ( unsafe . Pointer ( target ) ) ) if c == nil { return nil , nilPtrErr } p := & SelectionData { c } runtime . SetFinalizer ( p , ( * SelectionData ) . free ) return p , nil }
761	func createDesignateServiceClient ( ) ( * gophercloud . ServiceClient , error ) { opts , err := getAuthSettings ( ) if err != nil { return nil , err } log . Infof ( "Using OpenStack Keystone at %s" , opts . IdentityEndpoint ) authProvider , err := openstack . NewClient ( opts . IdentityEndpoint ) if err != nil { return nil , err } tlsConfig , err := tlsutils . CreateTLSConfig ( "OPENSTACK" ) if err != nil { return nil , err } transport := & http . Transport { Proxy : http . ProxyFromEnvironment , DialContext : ( & net . Dialer { Timeout : 30 * time . Second , KeepAlive : 30 * time . Second , } ) . DialContext , MaxIdleConns : 100 , IdleConnTimeout : 90 * time . Second , TLSHandshakeTimeout : 10 * time . Second , ExpectContinueTimeout : 1 * time . Second , TLSClientConfig : tlsConfig , } authProvider . HTTPClient . Transport = transport if err = openstack . Authenticate ( authProvider , opts ) ; err != nil { return nil , err } eo := gophercloud . EndpointOpts { Region : os . Getenv ( "OS_REGION_NAME" ) , } client , err := openstack . NewDNSV2 ( authProvider , eo ) if err != nil { return nil , err } log . Infof ( "Found OpenStack Designate service at %s" , client . Endpoint ) return client , nil }
4753	func ( list * ErrorList ) Collect ( args ... interface { } ) { for _ , a := range args { if err , _ := a . ( error ) ; err != nil { * list = append ( * list , err ) } } }
910	func streaming ( ) { log . SetDebug ( true ) client := libmachine . NewClient ( "/tmp/automatic" , "/tmp/automatic/certs" ) defer client . Close ( ) hostName := "myfunhost" driver := virtualbox . NewDriver ( hostName , "/tmp/automatic" ) data , err := json . Marshal ( driver ) if err != nil { log . Error ( err ) return } h , err := client . NewHost ( "virtualbox" , data ) if err != nil { log . Error ( err ) return } if err := client . Create ( h ) ; err != nil { log . Error ( err ) return } h . HostOptions . EngineOptions . StorageDriver = "overlay" sshClient , err := h . CreateSSHClient ( ) if err != nil { log . Error ( err ) return } stdout , stderr , err := sshClient . Start ( "yes | head -n 10000" ) if err != nil { log . Error ( err ) return } defer func ( ) { _ = stdout . Close ( ) _ = stderr . Close ( ) } ( ) scanner := bufio . NewScanner ( stdout ) for scanner . Scan ( ) { fmt . Println ( scanner . Text ( ) ) } if err := scanner . Err ( ) ; err != nil { log . Error ( err ) } if err := sshClient . Wait ( ) ; err != nil { log . Error ( err ) } fmt . Println ( "Powering down machine now..." ) if err := h . Stop ( ) ; err != nil { log . Error ( err ) return } }
3644	func ( t * TraceServiceDefinition ) GetSizeFormatOk ( ) ( string , bool ) { if t == nil || t . SizeFormat == nil { return "" , false } return * t . SizeFormat , true }
684	func NewCloudFlareProvider ( domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , zonesPerPage int , proxiedByDefault bool , dryRun bool ) ( * CloudFlareProvider , error ) { config , err := cloudflare . New ( os . Getenv ( "CF_API_KEY" ) , os . Getenv ( "CF_API_EMAIL" ) ) if err != nil { return nil , fmt . Errorf ( "failed to initialize cloudflare provider: %v" , err ) } provider := & CloudFlareProvider { Client : zoneService { config } , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , proxiedByDefault : proxiedByDefault , DryRun : dryRun , PaginationOptions : cloudflare . PaginationOptions { PerPage : zonesPerPage , Page : 1 , } , } return provider , nil }
2251	func ( v * AspectFrame ) native ( ) * C . GtkAspectFrame { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAspectFrame ( p ) }
4177	func ( s * Spaces ) Contains ( spaceName string ) bool { spaceNameToUpper := strings . ToUpper ( spaceName ) for _ , v := range s . Spaces { if strings . ToUpper ( v ) == spaceNameToUpper { return true } } return false }
3430	func ( o * Options ) HasNotifyAudit ( ) bool { if o != nil && o . NotifyAudit != nil { return true } return false }
2520	func flattenHostNetworkSecurityPolicy ( d * schema . ResourceData , obj * types . HostNetworkSecurityPolicy ) error { if obj . AllowPromiscuous != nil { d . Set ( "allow_promiscuous" , * obj . AllowPromiscuous ) } if obj . ForgedTransmits != nil { d . Set ( "allow_forged_transmits" , * obj . ForgedTransmits ) } if obj . MacChanges != nil { d . Set ( "allow_mac_changes" , * obj . MacChanges ) } return nil }
5526	func ( v * visitor ) mark ( val reflect . Value ) { ptr := val . Pointer ( ) if ptr == 0 { return } v . L . RawGeti ( lua . LUA_REGISTRYINDEX , v . index ) v . L . PushValue ( - 2 ) v . L . RawSeti ( - 2 , int ( ptr ) ) v . L . Pop ( 1 ) }
3690	func ( w * Widget ) HasMonitor ( ) bool { if w != nil && w . Monitor != nil { return true } return false }
1970	func ( m * MockClient ) ContainerCreate ( arg0 context . Context , arg1 * container . Config , arg2 * container . HostConfig , arg3 * network . NetworkingConfig , arg4 string ) ( container . ContainerCreateCreatedBody , error ) { ret := m . ctrl . Call ( m , "ContainerCreate" , arg0 , arg1 , arg2 , arg3 , arg4 ) ret0 , _ := ret [ 0 ] . ( container . ContainerCreateCreatedBody ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3350	func ( h * HostmapRequests ) GetFillOk ( ) ( HostmapRequest , bool ) { if h == nil || h . Fill == nil { return HostmapRequest { } , false } return * h . Fill , true }
854	func cmdOutput ( name string , args ... string ) ( string , error ) { cmd := exec . Command ( name , args ... ) log . Debugf ( "COMMAND: %v %v" , name , strings . Join ( args , " " ) ) stdout , err := cmd . Output ( ) if err != nil { return "" , err } log . Debugf ( "STDOUT:\n{\n%v}" , \n ) \n }
5588	func ( o ClientTLSOptions ) Validate ( ) error { if o . CertFile == "" { return bosherr . Error ( "Must provide a non-empty CertFile" ) } if o . KeyFile == "" { return bosherr . Error ( "Must provide a non-empty KeyFile" ) } return nil }
6024	func ( t Typed ) Bools ( key string ) [ ] bool { return t . BoolsOr ( key , nil ) }
4636	func ( points * PointsIndex ) Add ( point Point ) { points . Remove ( point . Id ( ) ) newSet := points . index . AddEntryAt ( point ) . ( set ) newSet . Add ( point . Id ( ) , point ) points . currentPosition [ point . Id ( ) ] = point }
2912	func findControllerForDevice ( l object . VirtualDeviceList , bvd types . BaseVirtualDevice ) ( types . BaseVirtualController , error ) { vd := bvd . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return nil , fmt . Errorf ( "could not find controller key %d for device %d" , vd . ControllerKey , vd . Key ) } return ctlr . ( types . BaseVirtualController ) , nil }
570	func ( mx * Mux ) Method ( method , pattern string , handler http . Handler ) { m , ok := methodMap [ strings . ToUpper ( method ) ] if ! ok { panic ( fmt . Sprintf ( "chi: '%s' http method is not supported." , method ) ) } mx . handle ( m , pattern , handler ) }
3654	func ( t * TriggeringValue ) HasToTs ( ) bool { if t != nil && t . ToTs != nil { return true } return false }
1626	func ( m * MockSecretsManagerAPI ) UpdateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . UpdateSecretInput , arg2 ... request . Option ) ( * secretsmanager . UpdateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "UpdateSecretWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UpdateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1163	func ( refreshHandler * refreshCredentialsHandler ) handleSingleMessage ( message * ecsacs . IAMRoleCredentialsMessage ) error { err := validateIAMRoleCredentialsMessage ( message ) if err != nil { seelog . Errorf ( "Error validating credentials message: %v" , err ) return err } taskArn := aws . StringValue ( message . TaskArn ) messageId := aws . StringValue ( message . MessageId ) task , ok := refreshHandler . taskEngine . GetTaskByArn ( taskArn ) if ! ok { seelog . Errorf ( "Task not found in the engine for the arn in credentials message, arn: %s, messageId: %s" , taskArn , messageId ) return fmt . Errorf ( "task not found in the engine for the arn in credentials message, arn: %s" , taskArn ) } roleType := aws . StringValue ( message . RoleType ) if ! validRoleType ( roleType ) { seelog . Errorf ( "Unknown RoleType for task in credentials message, roleType: %s arn: %s, messageId: %s" , roleType , taskArn , messageId ) } else { err = refreshHandler . credentialsManager . SetTaskCredentials ( & ( credentials . TaskIAMRoleCredentials { ARN : taskArn , IAMRoleCredentials : credentials . IAMRoleCredentialsFromACS ( message . RoleCredentials , roleType ) , } ) ) if err != nil { seelog . Errorf ( "Unable to update credentials for task, err: %v messageId: %s" , err , messageId ) return fmt . Errorf ( "unable to update credentials %v" , err ) } if roleType == credentials . ApplicationRoleType { task . SetCredentialsID ( aws . StringValue ( message . RoleCredentials . CredentialsId ) ) } if roleType == credentials . ExecutionRoleType { task . SetExecutionRoleCredentialsID ( aws . StringValue ( message . RoleCredentials . CredentialsId ) ) } } go func ( ) { response := & ecsacs . IAMRoleCredentialsAckRequest { Expiration : message . RoleCredentials . Expiration , MessageId : message . MessageId , CredentialsId : message . RoleCredentials . CredentialsId , } refreshHandler . ackRequest <- response } ( ) return nil }
6791	func ( hub * hub ) getChannel ( name string ) * channel { hub . Lock ( ) defer hub . Unlock ( ) cn , ok := hub . channels [ name ] if ok { return cn } cn = makeChannel ( hub , name ) hub . channels [ name ] = cn go cn . start ( ) return cn }
3899	func ( p * Package ) objectOf ( id * ast . Ident ) types . Object { if o := p . info . ObjectOf ( id ) ; o != nil { return o } panic ( fmt . Sprintf ( "no types.Object for ast.Ident %s @ %s" , id . Name , p . Prog . Fset . Position ( id . Pos ( ) ) ) ) }
6209	func ExeDirJoin ( elem ... string ) string { exe , err := os . Executable ( ) if err != nil { panic ( err ) } elem = append ( [ ] string { filepath . Dir ( exe ) } , elem ... ) return filepath . Join ( elem ... ) }
2255	func ( v * Layout ) GetSize ( ) ( width , height uint ) { var w , h C . guint C . gtk_layout_get_size ( v . native ( ) , & w , & h ) return uint ( w ) , uint ( h ) }
3460	func ( q * QueryConfig ) HasQueryString ( ) bool { if q != nil && q . QueryString != nil { return true } return false }
77	func ( s * Storage ) Querier ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { s . mtx . Lock ( ) queryables := s . queryables s . mtx . Unlock ( ) queriers := make ( [ ] storage . Querier , 0 , len ( queryables ) ) for _ , queryable := range queryables { q , err := queryable . Querier ( ctx , mint , maxt ) if err != nil { return nil , err } queriers = append ( queriers , q ) } return storage . NewMergeQuerier ( nil , queriers ) , nil }
3904	func Parse ( f string ) ( [ ] interface { } , error ) { var out [ ] interface { } for len ( f ) > 0 { if f [ 0 ] == '%' { v , n , err := ParseVerb ( f ) if err != nil { return nil , err } f = f [ n : ] out = append ( out , v ) } else { n := strings . IndexByte ( f , '%' ) if n > - 1 { out = append ( out , f [ : n ] ) f = f [ n : ] } else { out = append ( out , f ) f = "" } } } return out , nil }
650	func ( f ZoneTypeFilter ) Match ( zone * route53 . HostedZone ) bool { if f . zoneType == "" { return true } if zone . Config == nil { return f . zoneType == zoneTypePublic } switch f . zoneType { case zoneTypePublic : return ! aws . BoolValue ( zone . Config . PrivateZone ) case zoneTypePrivate : return aws . BoolValue ( zone . Config . PrivateZone ) } return false }
3200	func ( client * Client ) GetDashboards ( ) ( [ ] DashboardLite , error ) { var out reqGetDashboards if err := client . doJsonRequest ( "GET" , "/v1/dash" , nil , & out ) ; err != nil { return nil , err } return out . Dashboards , nil }
2404	func IsMouseButtonJustReleased ( button ebiten . MouseButton ) bool { theInputState . m . RLock ( ) r := theInputState . mouseButtonDurations [ button ] == 0 && theInputState . prevMouseButtonDurations [ button ] > 0 theInputState . m . RUnlock ( ) return r }
3356	func ( i * IntegrationAWSAccountDeleteRequest ) GetAccountIDOk ( ) ( string , bool ) { if i == nil || i . AccountID == nil { return "" , false } return * i . AccountID , true }
2653	func resourceVSphereComputeClusterApplyFolderChange ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) ( * object . ClusterComputeResource , error ) { log . Printf ( "[DEBUG] %s: Applying any folder changes (old path = %q)" , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) var changed bool var err error if d . HasChange ( "folder" ) { f := d . Get ( "folder" ) . ( string ) client := meta . ( * VSphereClient ) . vimClient if err = clustercomputeresource . MoveToFolder ( client , cluster , f ) ; err != nil { return nil , fmt . Errorf ( "could not move cluster to folder %q: %s" , f , err ) } changed = true } if changed { cluster , err = resourceVSphereComputeClusterGetCluster ( d , meta ) if err != nil { return nil , fmt . Errorf ( "error refreshing cluster after folder change: %s" , err ) } log . Printf ( "[DEBUG] %s: Folder changed, new path = %q" , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) } return cluster , nil }
6205	func NewConfig ( ) * Config { return & Config { CheckTimeout : 20000 , Timeout : 10000 , HTTPClient : & httpClientConf { DialTimeout : 5 , TLSHandshakeTimeout : 2 , ResponseHeaderTimeout : 8 , RequestTimeout : 10 , IdleConnTimeout : 30 , KeepAliveTimeout : 60 , } , } }
1785	func ( m * MockClientServer ) MakeRequest ( arg0 interface { } ) error { ret := m . ctrl . Call ( m , "MakeRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
2694	func ReconfigureVM ( client * govmomi . Client , vm * object . VirtualMachine , spec types . VirtualMachineConfigSpec , pod * object . StoragePod , ) error { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return err } if ! sdrsEnabled { return fmt . Errorf ( "storage DRS is not enabled on datastore cluster %q" , pod . Name ( ) ) } log . Printf ( "[DEBUG] Reconfiguring virtual machine %q through Storage DRS API, on datastore cluster %q" , vm . InventoryPath , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Type : string ( types . StoragePlacementSpecPlacementTypeReconfigure ) , PodSelectionSpec : types . StorageDrsPodSelectionSpec { InitialVmConfig : expandVMPodConfigForPlacement ( spec . DeviceChange , pod ) , } , Vm : types . NewReference ( vm . Reference ( ) ) , ConfigSpec : & spec , } _ , err = recommendAndApplySDRS ( client , sps , provider . DefaultAPITimeout ) return err }
273	func lex ( input string ) * lexer { l := & lexer { input : input , items : make ( chan item ) , } go l . run ( ) return l }
1603	func ( m * MockSecretsManagerAPI ) PutResourcePolicy ( arg0 * secretsmanager . PutResourcePolicyInput ) ( * secretsmanager . PutResourcePolicyOutput , error ) { ret := m . ctrl . Call ( m , "PutResourcePolicy" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3117	func Populate ( values ... interface { } ) error { var g Graph for _ , v := range values { if err := g . Provide ( & Object { Value : v } ) ; err != nil { return err } } return g . Populate ( ) }
5317	func backup ( filename string ) error { if DO_BACKUP { if _ , ok := _FILES_BACKUPED [ filename ] ; ! ok { if err := file . Backup ( filename ) ; err != nil { return err } _FILES_BACKUPED [ filename ] = struct { } { } } } return nil }
2968	func DiskCloneRelocateOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . VirtualMachineRelocateSpecDiskLocator , error ) { log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Generating full disk relocate spec list" ) devices := SelectDisks ( l , d . Get ( "scsi_controller_count" ) . ( int ) ) log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Disk devices located: %s" , DeviceListString ( devices ) ) devSort := virtualDeviceListSorter { Sort : devices , DeviceList : l , } sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Disk devices order after sort: %s" , DeviceListString ( devices ) ) curSet := d . Get ( subresourceTypeDisk ) . ( [ ] interface { } ) log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Current resource set: %s" , subresourceListString ( curSet ) ) sort . Sort ( virtualDiskSubresourceSorter ( curSet ) ) log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Resource set order after sort: %s" , subresourceListString ( curSet ) ) log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Generating relocators for source disks" ) var relocators [ ] types . VirtualMachineRelocateSpecDiskLocator for i , device := range devices { m := curSet [ i ] . ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return nil , fmt . Errorf ( "could not find controller with key %d" , vd . Key ) } m [ "key" ] = int ( vd . Key ) var err error m [ "device_address" ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return nil , fmt . Errorf ( "error computing device address: %s" , err ) } r := NewDiskSubresource ( c , d , m , nil , i ) if dsID := r . Get ( "datastore_id" ) ; dsID == "" || dsID == diskDatastoreComputedName { continue } relocator , err := r . Relocate ( l , true ) if err != nil { return nil , fmt . Errorf ( "%s: %s" , r . Addr ( ) , err ) } relocators = append ( relocators , relocator ) } log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Disk relocator list: %s" , diskRelocateListString ( relocators ) ) log . Printf ( "[DEBUG] DiskCloneRelocateOperation: Disk relocator generation complete" ) return relocators , nil }
5818	func ( cm * CheckManager ) createNewCheck ( ) ( * api . CheckBundle , * api . Broker , error ) { checkSecret := string ( cm . checkSecret ) if checkSecret == "" { secret , err := cm . makeSecret ( ) if err != nil { secret = "myS3cr3t" } checkSecret = secret } broker , err := cm . getBroker ( ) if err != nil { return nil , nil , err } chkcfg := & api . CheckBundle { Brokers : [ ] string { broker . CID } , Config : make ( map [ config . Key ] string ) , DisplayName : string ( cm . checkDisplayName ) , Metrics : [ ] api . CheckBundleMetric { } , MetricLimit : config . DefaultCheckBundleMetricLimit , Notes : cm . getNotes ( ) , Period : 60 , Status : statusActive , Tags : append ( cm . checkSearchTag , cm . checkTags ... ) , Target : string ( cm . checkTarget ) , Timeout : 10 , Type : string ( cm . checkType ) , } if len ( cm . customConfigFields ) > 0 { for fld , val := range cm . customConfigFields { chkcfg . Config [ config . Key ( fld ) ] = val } } if val , ok := chkcfg . Config [ config . AsyncMetrics ] ; ! ok || val == "" { chkcfg . Config [ config . AsyncMetrics ] = "true" } if val , ok := chkcfg . Config [ config . Secret ] ; ! ok || val == "" { chkcfg . Config [ config . Secret ] = checkSecret } checkBundle , err := cm . apih . CreateCheckBundle ( chkcfg ) if err != nil { return nil , nil , err } return checkBundle , broker , nil }
1451	func ( state * DockerTaskEngineState ) storeV3EndpointIDToDockerIDUnsafe ( v3EndpointID , dockerID string ) { state . v3EndpointIDToDockerID [ v3EndpointID ] = dockerID }
5515	func ( m * Messenger ) GetProfile ( userID string ) ( * Profile , error ) { resp , err := m . doRequest ( "GET" , fmt . Sprintf ( GraphAPI + "/v2.6/%s?fields=first_name,last_name,profile_pic,locale,timezone,gender" , userID ) , nil ) if err != nil { return nil , err } defer resp . Body . Close ( ) read , err := ioutil . ReadAll ( resp . Body ) if resp . StatusCode != http . StatusOK { er := new ( rawError ) json . Unmarshal ( read , er ) return nil , errors . New ( "Error occured: " + er . Error . Message ) } profile := new ( Profile ) return profile , json . Unmarshal ( read , profile ) }
1089	func executeTemplateFunc ( t * template . Template ) func ( string , ... interface { } ) ( string , error ) { return func ( s string , data ... interface { } ) ( string , error ) { var dot interface { } switch len ( data ) { case 0 : dot = nil case 1 : dot = data [ 0 ] default : return "" , fmt . Errorf ( "executeTemplate: wrong number of arguments, expected 1 or 2" + ", but got %d" , len ( data ) + 1 ) } var b bytes . Buffer if err := t . ExecuteTemplate ( & b , s , dot ) ; err != nil { return "" , err } return b . String ( ) , nil } }
2588	func Clone ( c * govmomi . Client , src * object . VirtualMachine , f * object . Folder , name string , spec types . VirtualMachineCloneSpec , timeout int ) ( * object . VirtualMachine , error ) { log . Printf ( "[DEBUG] Cloning virtual machine %q" , fmt . Sprintf ( "%s/%s" , f . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) task , err := src . Clone ( ctx , f , name , spec ) if err != nil { if ctx . Err ( ) == context . DeadlineExceeded { err = errors . New ( "timeout waiting for clone to complete" ) } return nil , err } result , err := task . WaitForResult ( ctx , nil ) if err != nil { if ctx . Err ( ) == context . DeadlineExceeded { err = errors . New ( "timeout waiting for clone to complete" ) } return nil , err } log . Printf ( "[DEBUG] Virtual machine %q: clone complete (MOID: %q)" , fmt . Sprintf ( "%s/%s" , f . InventoryPath , name ) , result . Result . ( types . ManagedObjectReference ) . Value ) return FromMOID ( c , result . Result . ( types . ManagedObjectReference ) . Value ) }
1789	func ( cs * ContainerStatus ) ShouldReportToBackend ( steadyStateStatus ContainerStatus ) bool { return * cs == steadyStateStatus || * cs == ContainerStopped }
5994	func ( ds * DNSServer ) GetA ( fqdn string ) * dns . A { ds . aMutex . RLock ( ) defer ds . aMutex . RUnlock ( ) val , ok := ds . aRecords [ fqdn ] if ok { return & dns . A { Hdr : dns . RR_Header { Name : fqdn , Rrtype : dns . TypeA , Class : dns . ClassINET , Ttl : 1 , } , A : val , } } return nil }
6649	func Vec3Dist2DSqr ( v1 , v2 Vec3 ) float32 { dx := v1 [ 0 ] - v2 [ 0 ] dz := v1 [ 2 ] - v2 [ 2 ] return dx * dx + dz * dz }
3782	func ( client * Client ) AddTagsToHost ( host , source string , tags [ ] string ) error { uri := "/v1/tags/hosts/" + host if source != "" { uri += "?source=" + source } return client . doJsonRequest ( "POST" , uri , reqGetHostTags { Tags : tags } , nil ) }
6269	func NewHTTPRequestWithURL ( method , url string , req * Request ) ( * http . Request , error ) { data , err := json . Marshal ( req ) if err != nil { return nil , err } return http . NewRequest ( method , url , bytes . NewReader ( data ) ) }
6553	func NewDataReadWriter ( rw io . ReadWriter ) ( * Data , error ) { d := newData ( ) d . r = rw d . w = rw d . cbs . read = C . gpgme_data_read_cb_t ( C . gogpgme_readfunc ) d . cbs . write = C . gpgme_data_write_cb_t ( C . gogpgme_writefunc ) cbc := callbackAdd ( d ) d . cbc = cbc return d , handleError ( C . gogpgme_data_new_from_cbs ( & d . dh , & d . cbs , C . uintptr_t ( cbc ) ) ) }
3272	func ( d * DashboardConditionalFormat ) GetInvertedOk ( ) ( bool , bool ) { if d == nil || d . Inverted == nil { return false , false } return * d . Inverted , true }
3946	func ( xxh XXHZero ) Sum ( b [ ] byte ) [ ] byte { h32 := xxh . Sum32 ( ) return append ( b , byte ( h32 ) , byte ( h32 >> 8 ) , byte ( h32 >> 16 ) , byte ( h32 >> 24 ) ) }
5187	func ( c * Cluster ) AddHost ( address * URI ) { c . mutex . Lock ( ) defer c . mutex . Unlock ( ) c . hosts = append ( c . hosts , address ) c . okList = append ( c . okList , true ) }
6316	func ( c * Controller ) RenderView ( templateStr string , vars interface { } ) [ ] byte { t , err := template . New ( "RenderView" ) . Parse ( templateStr ) if err != nil { panic ( err . Error ( ) ) } return c . RenderTemplate ( t , vars ) }
952	func getRandomIPinSubnet ( d * Driver , baseIP net . IP ) ( net . IP , error ) { var dhcpAddr net . IP nAddr := baseIP . To4 ( ) for i := 0 ; i < 5 ; i ++ { n := d . randomInter . RandomInt ( 24 ) + 1 if byte ( n ) != nAddr [ 3 ] { dhcpAddr = net . IPv4 ( nAddr [ 0 ] , nAddr [ 1 ] , nAddr [ 2 ] , byte ( n ) ) break } } if dhcpAddr == nil { return nil , ErrUnableToGenerateRandomIP } return dhcpAddr , nil }
5551	func ( t TabularDataMap ) NumRows ( ) int { if len ( t ) == 0 { return 0 } return len ( t [ reflect . ValueOf ( t ) . MapKeys ( ) [ 0 ] . String ( ) ] ) }
6257	func ( h * Handler ) setOfferingHash ( logger log . Logger , offering * data . Offering , template * data . Template , agent * data . Account ) error { handleErr := func ( err error ) error { logger . Error ( err . Error ( ) ) return ErrInternal } msg := offer . OfferingMessage ( agent , template , offering ) msgBytes , err := json . Marshal ( msg ) if err != nil { return handleErr ( err ) } agentKey , err := h . decryptKeyFunc ( agent . PrivateKey , h . pwdStorage . Get ( ) ) if err != nil { return handleErr ( err ) } packed , err := messages . PackWithSignature ( msgBytes , agentKey ) if err != nil { return handleErr ( err ) } offering . RawMsg = data . FromBytes ( packed ) hashBytes := common . BytesToHash ( crypto . Keccak256 ( packed ) ) offering . Hash = data . HexFromBytes ( hashBytes . Bytes ( ) ) return nil }
2626	func GetStringPolicy ( d * schema . ResourceData , key string ) * types . StringPolicy { v , e := d . GetOkExists ( key ) if e { return StringPolicy ( v . ( string ) ) } return nil }
6010	func ( t Typed ) IntMust ( key string ) int { i , exists := t . IntIf ( key ) if exists == false { panic ( "expected int value for " + key ) } return i }
3457	func ( q * QueryConfig ) HasQueryIsFailed ( ) bool { if q != nil && q . QueryIsFailed != nil { return true } return false }
4857	func GenPresto ( u * URL ) ( string , error ) { z := & url . URL { Scheme : "http" , Opaque : u . Opaque , User : u . User , Host : u . Host , RawQuery : u . RawQuery , Fragment : u . Fragment , } if strings . HasSuffix ( u . OriginalScheme , "s" ) { z . Scheme = "https" } if z . User == nil { z . User = url . User ( "user" ) } if z . Host == "" { z . Host = "localhost" } if hostport ( z . Host ) == "" { if z . Scheme == "http" { z . Host += ":8080" } else if z . Scheme == "https" { z . Host += ":8443" } } q := z . Query ( ) dbname , schema := strings . TrimPrefix ( u . Path , "/" ) , "" if dbname == "" { dbname = "default" } else if i := strings . Index ( dbname , "/" ) ; i != - 1 { schema , dbname = dbname [ i + 1 : ] , dbname [ : i ] } q . Set ( "catalog" , dbname ) if schema != "" { q . Set ( "schema" , schema ) } z . RawQuery = q . Encode ( ) return z . String ( ) , nil }
7141	func ( s PlayerStandings ) ByWinnings ( oldTieBreak bool ) { if oldTieBreak { sort . Sort ( sort . Reverse ( ByWinningsOld { s } ) ) } else { sort . Sort ( sort . Reverse ( ByWinnings { s } ) ) } }
6015	func ( t Typed ) StringOr ( key string , d string ) string { if value , exists := t . StringIf ( key ) ; exists { return value } return d }
3133	func ( d * Duration ) UnmarshalText ( text [ ] byte ) error { var err error d . Duration , err = time . ParseDuration ( string ( text ) ) return err }
4998	func ( d * Dataset ) SendSnapshot ( output io . Writer ) error { if d . Type != DatasetSnapshot { return errors . New ( "can only send snapshots" ) } c := command { Command : "zfs" , Stdout : output } _ , err := c . Run ( "send" , d . Name ) return err }
7301	func ( b Bucket ) OpenBucket ( folders [ ] [ ] byte , f func ( Bucket ) error ) error { bb := b . Bucket for _ , fld := range folders { bb = bb . Bucket ( fld ) if bb == nil { return nil } } return errorsp . WithStacks ( f ( Bucket { bb } ) ) }
5646	func PubKeyBytesFromPrivKeyBytes ( privKeyBytes [ ] byte , compress bool ) ( pubKeyBytes [ ] byte ) { x , y := btcec . S256 ( ) . ScalarBaseMult ( privKeyBytes ) pub := & btcec . PublicKey { Curve : btcec . S256 ( ) , X : x , Y : y , } if compress { return pub . SerializeCompressed ( ) } return pub . SerializeUncompressed ( ) }
864	func ( a AzureClient ) waitVMPowerState ( resourceGroup , name string , goalState VMPowerState , timeout time . Duration ) error { log . Debug ( "Waiting until VM reaches goal power state." , logutil . Fields { "vm" : name , "goalState" : goalState , "timeout" : timeout , } ) chErr := make ( chan error ) go func ( ch chan error ) { for { select { case <- ch : return default : state , err := a . GetVirtualMachinePowerState ( resourceGroup , name ) if err != nil { ch <- err return } if state != goalState { log . Debug ( fmt . Sprintf ( "Waiting %v..." , powerStatePollingInterval ) , logutil . Fields { "goalState" : goalState , "state" : state , } ) time . Sleep ( powerStatePollingInterval ) } else { log . Debug ( "Reached goal power state." , logutil . Fields { "state" : state } ) ch <- nil return } } } } ( chErr ) select { case <- time . After ( timeout ) : close ( chErr ) return fmt . Errorf ( "Waiting for goal state %q timed out after %v" , goalState , timeout ) case err := <- chErr : return err } }
3697	func ( w * Widget ) GetMustShowErrors ( ) bool { if w == nil || w . MustShowErrors == nil { return false } return * w . MustShowErrors }
2476	func ( i * InfiniteLoop ) Seek ( offset int64 , whence int ) ( int64 , error ) { if err := i . ensurePos ( ) ; err != nil { return 0 , err } next := int64 ( 0 ) switch whence { case io . SeekStart : next = offset case io . SeekCurrent : next = i . pos + offset case io . SeekEnd : return 0 , fmt . Errorf ( "audio: whence must be io.SeekStart or io.SeekCurrent for InfiniteLoop" ) } if next < 0 { return 0 , fmt . Errorf ( "audio: position must >= 0" ) } if next >= i . lstart { next = ( ( next - i . lstart ) % i . llength ) + i . lstart } if _ , err := i . src . Seek ( next , io . SeekStart ) ; err != nil { return 0 , err } i . pos = next return i . pos , nil }
1026	func ( d * DedupManager ) UpdateDeps ( t * template . Template , deps [ ] dep . Dependency ) error { dataPath := path . Join ( * d . config . Prefix , t . ID ( ) , "data" ) td := templateData { Version : version . Version , Data : make ( map [ string ] interface { } ) , } for _ , dp := range deps { if ! dp . CanShare ( ) { continue } val , ok := d . brain . Recall ( dp ) if ok { td . Data [ dp . String ( ) ] = val } } hash , err := hashstructure . Hash ( td , nil ) if err != nil { return fmt . Errorf ( "calculating hash failed: %v" , err ) } d . lastWriteLock . RLock ( ) existing , ok := d . lastWrite [ t ] d . lastWriteLock . RUnlock ( ) if ok && existing == hash { log . Printf ( "[INFO] (dedup) de-duplicate data '%s' already current" , dataPath ) return nil } var buf bytes . Buffer compress := lzw . NewWriter ( & buf , lzw . LSB , 8 ) enc := gob . NewEncoder ( compress ) if err := enc . Encode ( & td ) ; err != nil { return fmt . Errorf ( "encode failed: %v" , err ) } compress . Close ( ) kvPair := consulapi . KVPair { Key : dataPath , Value : buf . Bytes ( ) , Flags : templateDataFlag , } client := d . clients . Consul ( ) if _ , err := client . KV ( ) . Put ( & kvPair , nil ) ; err != nil { return fmt . Errorf ( "failed to write '%s': %v" , dataPath , err ) } log . Printf ( "[INFO] (dedup) updated de-duplicate data '%s'" , dataPath ) d . lastWriteLock . Lock ( ) d . lastWrite [ t ] = hash d . lastWriteLock . Unlock ( ) return nil }
1665	func ( event * DockerContainerChangeEvent ) String ( ) string { res := fmt . Sprintf ( "Status: %s, DockerID: %s" , event . Status . String ( ) , event . DockerID ) res += ", health: " + event . Health . Status . String ( ) if event . ExitCode != nil { res += fmt . Sprintf ( ", ExitCode: %d" , aws . IntValue ( event . ExitCode ) ) } if len ( event . PortBindings ) != 0 { res += fmt . Sprintf ( ", PortBindings: %v" , event . PortBindings ) } if event . Error != nil { res += ", Error: " + event . Error . Error ( ) } if len ( event . Volumes ) != 0 { res += fmt . Sprintf ( ", Volumes: %v" , event . Volumes ) } if len ( event . Labels ) != 0 { res += fmt . Sprintf ( ", Labels: %v" , event . Labels ) } if ! event . CreatedAt . IsZero ( ) { res += ", CreatedAt: " + event . CreatedAt . String ( ) } if ! event . StartedAt . IsZero ( ) { res += ", StartedAt: " + event . StartedAt . String ( ) } if ! event . FinishedAt . IsZero ( ) { res += ", FinishedAt: " + event . FinishedAt . String ( ) } return res }
1576	func ( m * MockSecretsManagerAPI ) CreateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . CreateSecretInput , arg2 ... request . Option ) ( * secretsmanager . CreateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "CreateSecretWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CreateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2801	func MoveToFolder ( client * govmomi . Client , cluster * object . ClusterComputeResource , relative string ) error { f , err := folder . HostFolderFromObject ( client , cluster , relative ) if err != nil { return err } return folder . MoveObjectTo ( cluster . Reference ( ) , f ) }
6129	func ( b * backendInstance ) CooperativeClose ( opts * bind . TransactOpts , agent common . Address , block uint32 , offeringHash [ common . HashLength ] byte , balance uint64 , balanceSig , closingSig [ ] byte ) ( * types . Transaction , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 tx , err := b . psc . CooperativeClose ( opts , agent , block , offeringHash , balance , balanceSig , closingSig ) if err != nil { return nil , fmt . Errorf ( "failed to do cooperative close: %s" , err ) } return tx , nil }
3445	func ( o * Options ) HasThresholdWindows ( ) bool { if o != nil && o . ThresholdWindows != nil { return true } return false }
461	func ( req * Request ) SetRequestURI ( requestURI string ) { req . Header . SetRequestURI ( requestURI ) req . parsedURI = false }
2269	func ( v * RadioButton ) native ( ) * C . GtkRadioButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRadioButton ( p ) }
5448	func ( c * CallService ) Hangup ( sid string ) ( * Call , error ) { data := url . Values { } data . Set ( "Status" , string ( StatusCompleted ) ) return c . Update ( context . Background ( ) , sid , data ) }
73	func ( b * Builder ) Del ( ns ... string ) * Builder { for _ , n := range ns { for i , a := range b . add { if a . Name == n { b . add = append ( b . add [ : i ] , b . add [ i + 1 : ] ... ) } } b . del = append ( b . del , n ) } return b }
1148	func ( m * MockImageManager ) AddAllImageStates ( arg0 [ ] * image . ImageState ) { m . ctrl . Call ( m , "AddAllImageStates" , arg0 ) }
6622	func NewSeeforRouter ( ) * Seefor { c4 := & Seefor { } c4 . afters = make ( [ ] After , 0 ) c4 . befores = make ( [ ] Before , 0 ) c4 . roots = make ( map [ string ] * rootNode ) c4 . HandleMethodNotAllowed = true return c4 }
415	func ( pc * PipeConns ) Close ( ) error { pc . stopChLock . Lock ( ) select { case <- pc . stopCh : default : close ( pc . stopCh ) } pc . stopChLock . Unlock ( ) return nil }
4906	func ( r * Reader ) Skip ( cnt int ) { if r . err != nil { return } var n int n , r . err = r . rd . Discard ( cnt ) r . cnt += n }
4493	func NewSeededFormats ( seeds [ ] knownFormat , normalizer NameNormalizer ) Registry { if normalizer == nil { normalizer = DefaultNameNormalizer } d := append ( [ ] knownFormat ( nil ) , seeds ... ) return & defaultFormats { data : d , normalizeName : normalizer , } }
884	func ( d * SerialDriver ) Start ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Start ( ) }
3581	func ( t * ThresholdCount ) GetUnknownOk ( ) ( json . Number , bool ) { if t == nil || t . Unknown == nil { return "" , false } return * t . Unknown , true }
222	func ( m * Manager ) Run ( ) error { go m . sender ( ) for range m . ctx . Done ( ) { m . cancelDiscoverers ( ) return m . ctx . Err ( ) } return nil }
2989	func ( s virtualDiskSubresourceSorter ) Swap ( i , j int ) { s [ i ] , s [ j ] = s [ j ] , s [ i ] }
678	func newNS1Changes ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * ns1Change { changes := make ( [ ] * ns1Change , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , & ns1Change { Action : action , Endpoint : endpoint , } , ) } return changes }
5813	func ( m * CirconusMetrics ) SetHistogramValue ( metric string , val float64 ) { hist := m . NewHistogram ( metric ) m . hm . Lock ( ) hist . rw . Lock ( ) hist . hist . RecordValue ( val ) hist . rw . Unlock ( ) m . hm . Unlock ( ) }
3462	func ( q * QueryConfig ) GetTimeRangeOk ( ) ( TimeRange , bool ) { if q == nil || q . TimeRange == nil { return TimeRange { } , false } return * q . TimeRange , true }
4360	func FindIndex ( in [ ] byte , pos , index int ) ( [ ] byte , error ) { pos , err := skipSpace ( in , pos ) if err != nil { return nil , err } if v := in [ pos ] ; v != '[' { return nil , newError ( pos , v ) } pos ++ idx := 0 for { pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } itemStart := pos pos , err = Any ( in , pos ) if err != nil { return nil , err } if index == idx { return in [ itemStart : pos ] , nil } pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } switch in [ pos ] { case ',' : pos ++ case ']' : return nil , errIndexOutOfBounds } idx ++ } }
4652	func ( queue * queue ) Pop ( ) interface { } { if queue . size == 0 { return nil } if queue . size < queue . cap / 4 && queue . size > 4 { queue . resize ( queue . cap / 2 ) } result := queue . elements [ queue . start % int64 ( queue . cap ) ] queue . start ++ queue . size -- return result }
7227	func ( logger * Logger ) Warningf ( format string , a ... interface { } ) { logger . log ( WARNING , format , a ... ) }
6800	func ( s * Session ) Ask ( question string ) ( string , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) s . Values . Set ( "input" , question ) s . clear ( ) req , err := http . NewRequest ( "GET" , apiURL + s . Values . Encode ( ) , nil ) if err != nil { return "" , err } req . Header . Set ( "User-Agent" , "cleverbot-go https://github.com/ugjka/cleverbot-go" ) resp , err := s . Client . Do ( req ) if err != nil { return "" , err } defer resp . Body . Close ( ) switch resp . StatusCode { case http . StatusUnauthorized : ErrKeyNotValid . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrKeyNotValid case http . StatusNotFound : ErrAPINotFound . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrAPINotFound case http . StatusRequestEntityTooLarge : ErrRequestTooLarge . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrRequestTooLarge case http . StatusBadGateway : ErrNoReply . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrNoReply case http . StatusGatewayTimeout : ErrNoReply . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrNoReply case http . StatusServiceUnavailable : ErrTooManyRequests . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrTooManyRequests default : if resp . StatusCode != http . StatusOK { ErrStatusNotOK . origin = fmt . Sprintf ( "status code %d" , resp . StatusCode ) return "" , ErrStatusNotOK } } if err := json . NewDecoder ( resp . Body ) . Decode ( & s . Decoded ) ; err != nil { ErrInvalidJSON . origin = err . Error ( ) return "" , ErrInvalidJSON } if _ , ok := s . Decoded [ "output" ] . ( string ) ; ! ok { return "" , fmt . Errorf ( "Cleverbot API: 'output' does not exist or is not a string" ) } if _ , ok := s . Decoded [ "cs" ] . ( string ) ; ! ok { return "" , fmt . Errorf ( "Cleverbot API: 'cs' does not exist or is not a string" ) } s . Values . Set ( "cs" , s . Decoded [ "cs" ] . ( string ) ) return s . Decoded [ "output" ] . ( string ) , nil }
706	func ( p * RcodeZeroProvider ) Zones ( ) ( [ ] * rc0 . Zone , error ) { var result [ ] * rc0 . Zone zones , err := p . fetchZones ( ) if err != nil { return nil , err } for _ , zone := range zones { if p . DomainFilter . Match ( zone . Domain ) { result = append ( result , zone ) } } return result , nil }
4528	func ( h * Hosts ) IsWritable ( ) bool { _ , err := os . OpenFile ( h . Path , os . O_WRONLY , 0660 ) if err != nil { return false } return true }
151	func NewDiscovery ( conf * SDConfig , logger log . Logger ) * Discovery { creds := credentials . NewStaticCredentials ( conf . AccessKey , string ( conf . SecretKey ) , "" ) if conf . AccessKey == "" && conf . SecretKey == "" { creds = nil } if logger == nil { logger = log . NewNopLogger ( ) } d := & Discovery { aws : & aws . Config { Endpoint : & conf . Endpoint , Region : & conf . Region , Credentials : creds , } , profile : conf . Profile , roleARN : conf . RoleARN , filters : conf . Filters , interval : time . Duration ( conf . RefreshInterval ) , port : conf . Port , } d . Discovery = refresh . NewDiscovery ( logger , "ec2" , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d }
4601	func ( s * Signature ) merge ( r * Signature ) * Signature { min := s . SleepMin if r . SleepMin < min { min = r . SleepMin } max := s . SleepMax if r . SleepMax > max { max = r . SleepMax } return & Signature { State : s . State , CreatedBy : s . CreatedBy , SleepMin : min , SleepMax : max , Stack : * s . Stack . merge ( & r . Stack ) , Locked : s . Locked || r . Locked , } }
5619	func Sum ( bz [ ] byte ) [ ] byte { hash := sha256 . Sum256 ( bz ) return hash [ : Size ] }
7081	func ( mp * MultiLog ) OuterLog ( level Level , tags ... string ) io . Writer { if mp . chouter != nil { return & outer { ch : mp . chouter , buf : make ( [ ] byte , 0 ) , } } mp . chclose = make ( chan chan struct { } ) mp . chouter = make ( chan [ ] byte ) if len ( mp . mp ) < 2 { return nil } f := mp . mp [ 0 ] . GetF ( ) logger := f . NewEntry ( mp ) . Tag ( "outer" ) . EntryLevel ( level ) go func ( ) { for { select { case buf := <- mp . chouter : logger . Tag ( tags ... ) . Println ( string ( buf ) ) case ch := <- mp . chclose : ch <- struct { } { } return } } } ( ) return & outer { ch : mp . chouter , buf : make ( [ ] byte , 0 ) , } }
129	func ( p * parser ) expectOneOf ( exp1 , exp2 ItemType , context string ) item { token := p . next ( ) if token . typ != exp1 && token . typ != exp2 { p . errorf ( "unexpected %s in %s, expected %s or %s" , token . desc ( ) , context , exp1 . desc ( ) , exp2 . desc ( ) ) } return token }
3858	func ( c * Cursor ) Format ( ) string { r := c . input return format ( r , c ) }
5544	func ( c * Client ) Say ( roomId , name , body string ) { c . connection . MUCSend ( "groupchat" , roomId , c . Id + "/" + name , body ) }
1633	func ( n * NvidiaGPUManager ) SetGPUIDs ( gpuIDs [ ] string ) { n . lock . Lock ( ) defer n . lock . Unlock ( ) n . GPUIDs = gpuIDs }
6402	func ( stack * Stack ) Pop ( ) ( interface { } , bool ) { stack . key . Lock ( ) defer stack . key . Unlock ( ) if nil == stack . underlyer { return nil , false } return stack . underlyer . RemoveFront ( ) }
6896	func Deinit ( ) { wait := make ( chan interface { } ) Queue ( func ( ) { termbox . Close ( ) focus = nil prevFocus = nil windows = make ( map [ int ] * Window ) rawMtx . Lock ( ) termRaw = false rawMtx . Unlock ( ) wait <- true } ) <- wait }
2219	func ( v * ColorButton ) native ( ) * C . GtkColorButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkColorButton ( p ) }
2186	func ( v * GLArea ) native ( ) * C . GtkGLArea { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkGLArea ( p ) }
5089	func ( v * Validate ) Field ( f interface { } , tag string ) * FieldError { return v . FieldWithValue ( nil , f , tag ) }
2672	func flattenClusterVMComponentProtectionSettings ( d * schema . ResourceData , obj * types . ClusterVmComponentProtectionSettings ) error { return structure . SetBatch ( d , map [ string ] interface { } { "ha_datastore_apd_recovery_action" : obj . VmReactionOnAPDCleared , "ha_datastore_apd_response" : obj . VmStorageProtectionForAPD , "ha_datastore_pdl_response" : obj . VmStorageProtectionForPDL , "ha_datastore_apd_response_delay" : obj . VmTerminateDelayForAPDSec , } ) }
3427	func ( o * Options ) HasNewHostDelay ( ) bool { if o != nil && o . NewHostDelay != nil { return true } return false }
4899	func ( s * Session ) Query ( stmtID uint64 , prmFieldSet * ParameterFieldSet , resultFieldSet * ResultFieldSet , args [ ] driver . NamedValue ) ( uint64 , * FieldValues , PartAttributes , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) s . statementID . id = & stmtID if err := s . writeRequest ( mtExecute , false , s . statementID , newInputParameters ( prmFieldSet . inputFields ( ) , args ) ) ; err != nil { return 0 , nil , nil , err } var rsetID uint64 fieldValues := newFieldValues ( ) f := func ( p replyPart ) { switch p := p . ( type ) { case * resultsetID : p . id = & rsetID case * resultset : p . s = s p . resultFieldSet = resultFieldSet p . fieldValues = fieldValues } } if err := s . readReply ( f ) ; err != nil { return 0 , nil , nil , err } return rsetID , fieldValues , s . ph . partAttributes , nil }
391	func decodeArgAppendNoPlus ( dst , src [ ] byte ) [ ] byte { if bytes . IndexByte ( src , '%' ) < 0 { return append ( dst , src ... ) } for i := 0 ; i < len ( src ) ; i ++ { c := src [ i ] if c == '%' { if i + 2 >= len ( src ) { return append ( dst , src [ i : ] ... ) } x2 := hex2intTable [ src [ i + 2 ] ] x1 := hex2intTable [ src [ i + 1 ] ] if x1 == 16 || x2 == 16 { dst = append ( dst , '%' ) } else { dst = append ( dst , x1 << 4 | x2 ) i += 2 } } else { dst = append ( dst , c ) } } return dst }
3093	func ( ctx * Context ) ServeContent ( name string , r io . ReadSeeker , params ... interface { } ) { modtime := time . Now ( ) for _ , p := range params { switch v := p . ( type ) { case time . Time : modtime = v } } ctx . setRawContentHeader ( ) http . ServeContent ( ctx . Resp , ctx . Req . Request , name , modtime , r ) }
6861	func ( dl * DefaultLogger ) Debug ( message string , params ... interface { } ) { dl . logger . Debugf ( fmt . Sprintf ( "%s %s" , caller ( ) , message ) , params ... ) }
4219	func NewMemoryKeyCacher ( maxKeyAge time . Duration , maxCacheSize int ) KeyCacher { return & memoryKeyCacher { entries : map [ string ] keyCacherEntry { } , maxKeyAge : maxKeyAge , maxCacheSize : maxCacheSize , } }
7094	func ( m * SuffixMatcher ) Match ( str string ) ( offset int , matchStr string ) { offset = - 1 d := len ( str ) - len ( m . suffix ) if d < 1 { return } for i , r := range str { if i > d { return } if i != 0 && m . suffix == str [ i : i + len ( m . suffix ) ] { offset = i + len ( m . suffix ) matchStr = str [ : i ] return } if ! m . matcher . MatchRune ( r ) { return } } return }
3757	func ( t * templateData ) dump ( ) error { if len ( t . Accessors ) == 0 { logf ( "No accessors for %v; skipping." , t . Filename ) return nil } sort . Sort ( byName ( t . Accessors ) ) var buf bytes . Buffer if err := sourceTmpl . Execute ( & buf , t ) ; err != nil { return err } clean , err := format . Source ( buf . Bytes ( ) ) if err != nil { return err } outFile := filepath . Join ( filepath . Dir ( t . sourceFile ) , t . Filename ) logf ( "Writing %v..." , outFile ) return ioutil . WriteFile ( outFile , clean , 0644 ) }
6751	func ( ch * Channel ) recvMsgPacket ( packet msgPacket ) ( [ ] byte , error ) { if ch . desc . RecvMessageCapacity < len ( ch . recving ) + len ( packet . Bytes ) { return nil , wire . ErrBinaryReadOverflow } ch . recving = append ( ch . recving , packet . Bytes ... ) if packet . EOF == byte ( 0x01 ) { msgBytes := ch . recving ch . recving = ch . recving [ : 0 ] return msgBytes , nil } return nil , nil }
3349	func ( h * HostmapRequests ) GetFill ( ) HostmapRequest { if h == nil || h . Fill == nil { return HostmapRequest { } } return * h . Fill }
2087	func ( mr * MockNetLinkMockRecorder ) LinkByName ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "LinkByName" , reflect . TypeOf ( ( * MockNetLink ) ( nil ) . LinkByName ) , arg0 ) }
1533	func newDisconnectionTimer ( client wsclient . ClientServer , timeout time . Duration , jitter time . Duration ) ttime . Timer { timer := time . AfterFunc ( retry . AddJitter ( timeout , jitter ) , func ( ) { seelog . Warn ( "ACS Connection hasn't had any activity for too long; closing connection" ) if err := client . Close ( ) ; err != nil { seelog . Warnf ( "Error disconnecting: %v" , err ) } seelog . Info ( "Disconnected from ACS" ) } ) return timer }
5652	func ( kb dbKeybase ) List ( ) ( [ ] Info , error ) { var res [ ] Info iter := kb . db . Iterator ( nil , nil ) defer iter . Close ( ) for ; iter . Valid ( ) ; iter . Next ( ) { info , err := readInfo ( iter . Value ( ) ) if err != nil { return nil , err } res = append ( res , info ) } return res , nil }
3553	func ( s * SyntheticsTest ) GetModifiedBy ( ) SyntheticsUser { if s == nil || s . ModifiedBy == nil { return SyntheticsUser { } } return * s . ModifiedBy }
1312	func main ( ) { versionStr , _ := ioutil . ReadFile ( filepath . Join ( ".." , ".." , "VERSION" ) ) info := versionInfo { Version : strings . TrimSpace ( string ( versionStr ) ) , Dirty : true , Hash : "UNKNOWN" , } if strings . TrimSpace ( os . Getenv ( "ECS_RELEASE" ) ) == "cleanbuild" { info . Dirty = gitDirty ( ) } if os . Getenv ( "ECS_UNKNOWN_VERSION" ) == "" { info . Hash = gitHash ( ) } outFile , err := os . Create ( "version.go" ) if err != nil { log . Fatalf ( "Unable to create output version file: %v" , err ) } t := template . Must ( template . New ( "version" ) . Parse ( versiongoTemplate ) ) err = t . Execute ( outFile , info ) if err != nil { log . Fatalf ( "Error applying template: %v" , err ) } }
3111	func NewResponseWriter ( method string , rw http . ResponseWriter ) ResponseWriter { return & responseWriter { method , rw , 0 , 0 , nil } }
5978	func ( pool * WriterPool ) Get ( w io . Writer ) ( writer io . Writer , release func ( ) ) { wr := ThrottledWriter ( w , 0 , pool . maxBurst ) pool . mu . Lock ( ) pool . givenOut [ wr ] = struct { } { } pool . setSharedRates ( ) pool . mu . Unlock ( ) return wr , func ( ) { pool . mu . Lock ( ) delete ( pool . givenOut , wr ) pool . setSharedRates ( ) pool . mu . Unlock ( ) } }
2145	func ( m * Matrix ) native ( ) * C . cairo_matrix_t { return ( * C . cairo_matrix_t ) ( unsafe . Pointer ( m ) ) }
6574	func ChangeHostModattr ( host_name string , value string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_HOST_MODATTR" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "value" , "string" , value ) , ) }
1171	func ( payloadHandler * payloadRequestHandler ) addTasks ( payload * ecsacs . PayloadMessage , tasks [ ] * apitask . Task , skipAddTask skipAddTaskComparatorFunc ) ( [ ] * ecsacs . IAMRoleCredentialsAckRequest , bool ) { allTasksOK := true var credentialsAcks [ ] * ecsacs . IAMRoleCredentialsAckRequest for _ , task := range tasks { if skipAddTask ( task . GetDesiredStatus ( ) ) { continue } payloadHandler . taskEngine . AddTask ( task ) ackCredentials := func ( id string , description string ) { ack , err := payloadHandler . ackCredentials ( payload . MessageId , id ) if err != nil { allTasksOK = false seelog . Errorf ( "Failed to acknowledge %s credentials for task: %s, err: %v" , description , task . String ( ) , err ) return } credentialsAcks = append ( credentialsAcks , ack ) } taskCredentialsID := task . GetCredentialsID ( ) if taskCredentialsID != "" { ackCredentials ( taskCredentialsID , "task iam role" ) } taskExecutionCredentialsID := task . GetExecutionCredentialsID ( ) if taskExecutionCredentialsID != "" { ackCredentials ( taskExecutionCredentialsID , "task execution role" ) } } return credentialsAcks , allTasksOK }
818	func ( d * Driver ) GetSSHUsername ( ) string { if d . SSHUser == "" { name := strings . ToLower ( d . Image ) if strings . Contains ( name , "ubuntu" ) { return "ubuntu" } if strings . Contains ( name , "centos" ) { return "centos" } if strings . Contains ( name , "redhat" ) { return "cloud-user" } if strings . Contains ( name , "fedora" ) { return "fedora" } if strings . Contains ( name , "coreos" ) { return "core" } if strings . Contains ( name , "debian" ) { return "debian" } return defaultSSHUser } return d . SSHUser }
3226	func ( a * APIKey ) GetKeyOk ( ) ( string , bool ) { if a == nil || a . Key == nil { return "" , false } return * a . Key , true }
6001	func JsonReader ( reader io . Reader ) ( Typed , error ) { if data , err := ioutil . ReadAll ( reader ) ; err != nil { return nil , err } else { return Json ( data ) } }
924	func ( d * Driver ) IsVTXDisabledInTheVM ( ) ( bool , error ) { lines , err := d . readVBoxLog ( ) if err != nil { return true , err } for _ , line := range lines { if strings . Contains ( line , "VT-x is disabled" ) && ! strings . Contains ( line , "Falling back to raw-mode: VT-x is disabled in the BIOS for all CPU modes" ) { return true , nil } if strings . Contains ( line , "the host CPU does NOT support HW virtualization" ) { return true , nil } if strings . Contains ( line , "VERR_VMX_UNABLE_TO_START_VM" ) { return true , nil } if strings . Contains ( line , "Power up failed" ) && strings . Contains ( line , "VERR_VMX_NO_VMX" ) { return true , nil } } return false , nil }
5939	func ( r * BasicReporter ) PostValueTime ( statKey , userKey string , value float64 , timestamp int64 ) error { x := newClassicStatValue ( statKey , userKey , value ) x . Timestamp = timestamp r . add ( x ) return nil }
6485	func ( e * Entry ) Reset ( statusCode int , contentType string , body [ ] byte , lifeChanger LifeChanger ) { if e . response == nil { e . response = & Response { } } if statusCode > 0 { e . response . statusCode = statusCode } if contentType != "" { e . response . contentType = contentType } e . response . body = body if lifeChanger != nil { e . ChangeLifetime ( lifeChanger ) } e . expiresAt = time . Now ( ) . Add ( e . life ) }
3738	func ( w * WidgetApmOrLogQuery ) HasIndex ( ) bool { if w != nil && w . Index != nil { return true } return false }
4334	func ( c * Client ) Unique ( bucket string , value string ) { if c . skip ( ) { return } c . conn . unique ( c . prefix , bucket , value , c . tags ) }
3303	func ( e * Event ) HasEventType ( ) bool { if e != nil && e . EventType != nil { return true } return false }
2853	func soapFault ( err error ) ( * soap . Fault , bool ) { if soap . IsSoapFault ( err ) { return soap . ToSoapFault ( err ) , true } return nil , false }
2745	func expandSliceOfDistributedVirtualSwitchHostMemberConfigSpec ( d * schema . ResourceData ) [ ] types . DistributedVirtualSwitchHostMemberConfigSpec { var specs [ ] types . DistributedVirtualSwitchHostMemberConfigSpec o , n := d . GetChange ( "host" ) os := o . ( * schema . Set ) ns := n . ( * schema . Set ) is := os . Intersection ( ns ) os = os . Difference ( is ) ns = ns . Difference ( is ) for _ , oe := range os . List ( ) { om := oe . ( map [ string ] interface { } ) var found bool for _ , ne := range ns . List ( ) { nm := ne . ( map [ string ] interface { } ) if nm [ "host_system_id" ] == om [ "host_system_id" ] { found = true } } if ! found { spec := expandDistributedVirtualSwitchHostMemberConfigSpec ( om ) spec . Operation = string ( types . ConfigSpecOperationRemove ) specs = append ( specs , spec ) } } for _ , ne := range ns . List ( ) { nm := ne . ( map [ string ] interface { } ) var found bool for _ , oe := range os . List ( ) { om := oe . ( map [ string ] interface { } ) if om [ "host_system_id" ] == nm [ "host_system_id" ] { found = true } } spec := expandDistributedVirtualSwitchHostMemberConfigSpec ( nm ) if ! found { spec . Operation = string ( types . ConfigSpecOperationAdd ) } else { spec . Operation = string ( types . ConfigSpecOperationEdit ) } specs = append ( specs , spec ) } return specs }
6684	func ErrUnsupportedIdentity ( id Identity ) error { return ErrorResponse { Code : http . StatusNotImplemented , Message : fmt . Sprintf ( "unsupported identity: %s/%s" , id . Type , id . Format ) , } }
5633	func SignBTCMessage ( privKey string , message string , compress bool ) string { prefixBytes := [ ] byte ( "Bitcoin Signed Message:\n" ) \n messageBytes := [ ] byte ( message ) bytes := [ ] byte { } bytes = append ( bytes , byte ( len ( prefixBytes ) ) ) bytes = append ( bytes , prefixBytes ... ) bytes = append ( bytes , byte ( len ( messageBytes ) ) ) bytes = append ( bytes , messageBytes ... ) privKeyBytes := HexDecode ( privKey ) x , y := btcec . S256 ( ) . ScalarBaseMult ( privKeyBytes ) ecdsaPubKey := ecdsa . PublicKey { Curve : btcec . S256 ( ) , X : x , Y : y , } ecdsaPrivKey := & btcec . PrivateKey { PublicKey : ecdsaPubKey , D : new ( big . Int ) . SetBytes ( privKeyBytes ) , } sigbytes , err := btcec . SignCompact ( btcec . S256 ( ) , ecdsaPrivKey , CalcHash256 ( bytes ) , compress ) if err != nil { panic ( err ) } }
6881	func ( l * Label ) SetText ( format string , args ... interface { } ) { l . text = fmt . Sprintf ( format , args ... ) }
1631	func parseNetworkMetadata ( settings * types . NetworkSettings , hostConfig * dockercontainer . HostConfig ) ( NetworkMetadata , error ) { if settings == nil { err := fmt . Errorf ( "parse network metadata: could not find network settings" ) return NetworkMetadata { } , err } if hostConfig == nil { err := fmt . Errorf ( "parse network metadata: could not find host configuration" ) return NetworkMetadata { } , err } ipv4AddressFromSettings := settings . IPAddress networkModeFromHostConfig := string ( hostConfig . NetworkMode ) networkList := make ( [ ] Network , 0 ) if len ( settings . Networks ) > 0 { for modeFromSettings , containerNetwork := range settings . Networks { networkMode := modeFromSettings ipv4Addresses := [ ] string { containerNetwork . IPAddress } network := Network { NetworkMode : networkMode , IPv4Addresses : ipv4Addresses } networkList = append ( networkList , network ) } } else { ipv4Addresses := [ ] string { ipv4AddressFromSettings } network := Network { NetworkMode : networkModeFromHostConfig , IPv4Addresses : ipv4Addresses } networkList = append ( networkList , network ) } return NetworkMetadata { networks : networkList , } , nil }
1635	func ( n * NvidiaGPUManager ) GetDriverVersion ( ) string { n . lock . RLock ( ) defer n . lock . RUnlock ( ) return n . DriverVersion }
4916	func ( r * Reader ) ReadFloat32 ( ) float32 { if r . err != nil { return 0 } var n int n , r . err = io . ReadFull ( r . rd , r . b [ : 4 ] ) r . cnt += n if r . err != nil { return 0 } bits := binary . LittleEndian . Uint32 ( r . b [ : 4 ] ) return math . Float32frombits ( bits ) }
1043	func ( c * ClientSet ) Vault ( ) * vaultapi . Client { c . RLock ( ) defer c . RUnlock ( ) return c . vault . client }
5524	func unsizedKind ( v reflect . Value ) reflect . Kind { switch v . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return reflect . Int64 case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 , reflect . Uintptr : return reflect . Uint64 case reflect . Float64 , reflect . Float32 : return reflect . Float64 case reflect . Complex128 , reflect . Complex64 : return reflect . Complex128 } return v . Kind ( ) }
2094	func ( mr * MockCNIMockRecorder ) DelNetwork ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "DelNetwork" , reflect . TypeOf ( ( * MockCNI ) ( nil ) . DelNetwork ) , arg0 , arg1 ) }
5711	func ( s * Slave ) Addr ( ) string { return net . JoinHostPort ( s . ip , s . port ) }
3837	func ( uuid * UUID ) UnmarshalBinary ( data [ ] byte ) error { if len ( data ) != 16 { return fmt . Errorf ( "invalid UUID (got %d bytes)" , len ( data ) ) } copy ( uuid [ : ] , data ) return nil }
6115	func NewFileLogger ( conf * FileConfig ) ( Logger , io . Closer , error ) { now := time . Now ( ) if conf . UTC { now = now . UTC ( ) } file , err := os . OpenFile ( timeutil . Strftime ( & now , conf . Filename ) , os . O_APPEND | os . O_CREATE | os . O_WRONLY , conf . FileMode ) if err != nil { return nil , nil , err } logger , err := NewWriterLogger ( conf . WriterConfig , file ) if err != nil { file . Close ( ) return nil , nil , err } return logger , file , nil }
3201	func ( client * Client ) CreateDashboard ( dash * Dashboard ) ( * Dashboard , error ) { var out reqGetDashboard if err := client . doJsonRequest ( "POST" , "/v1/dash" , dash , & out ) ; err != nil { return nil , err } return out . Dashboard , nil }
5151	func AddColor ( askColor , errorColor , infoColor , logColor , outputColor , responseColor , runningColor , successColor , warnColor Color , ui UI ) * ColorUI { return & ColorUI { LogFGColor : logColor , LogBGColor : None , OutputFGColor : outputColor , OutputBGColor : None , SuccessFGColor : successColor , SuccessBGColor : None , InfoFGColor : infoColor , InfoBGColor : None , ErrorFGColor : errorColor , ErrorBGColor : None , WarnFGColor : warnColor , WarnBGColor : None , RunningFGColor : runningColor , RunningBGColor : None , AskFGColor : askColor , AskBGColor : None , ResponseFGColor : responseColor , ResponseBGColor : None , UI : ui , } }
4556	func MarkdownHelper ( body string , help HelperContext ) ( template . HTML , error ) { var err error if help . HasBlock ( ) { body , err = help . Block ( ) if err != nil { return "" , err } } b := github_flavored_markdown . Markdown ( [ ] byte ( body ) ) return template . HTML ( b ) , err }
3656	func ( w * Widget ) GetAlertIDOk ( ) ( int , bool ) { if w == nil || w . AlertID == nil { return 0 , false } return * w . AlertID , true }
5048	func ( q * Query ) LogReplay ( ) * Query { q . m . Lock ( ) q . op . flags |= flagLogReplay q . m . Unlock ( ) return q }
6421	func split ( head * llNode ) ( left , right * llNode ) { left = head if head == nil || head . next == nil { return } right = head sprinter := head prev := head for sprinter != nil && sprinter . next != nil { prev = right right = right . next sprinter = sprinter . next . next } prev . next = nil return }
2217	func ( v * Assistant ) native ( ) * C . GtkAssistant { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAssistant ( p ) }
6570	func ChangeCustomContactVar ( contact_name string , varname string , varvalue string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_CUSTOM_CONTACT_VAR" , stringifyArg ( "contact_name" , "string" , contact_name ) , stringifyArg ( "varname" , "string" , varname ) , stringifyArg ( "varvalue" , "string" , varvalue ) , ) }
5207	func ( idx * Index ) RawQuery ( query string ) * PQLBaseQuery { q := NewPQLBaseQuery ( query , idx , nil ) q . hasKeys = true return q }
2792	func BaseFromPath ( client * govmomi . Client , path string ) ( BaseComputeResource , error ) { finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) list , err := finder . ManagedObjectList ( ctx , path , "ComputeResource" , "ClusterComputeResource" ) if err != nil { return nil , err } if len ( list ) < 1 { return nil , fmt . Errorf ( "no compute resources found at path %q" , path ) } if len ( list ) > 1 { return nil , fmt . Errorf ( "multiple results returned for path %q" , path ) } if ! strings . HasSuffix ( list [ 0 ] . Path , path ) { return nil , fmt . Errorf ( "returned object path %q does not properly match search path %q" , list [ 0 ] . Path , path ) } return BaseFromReference ( client , list [ 0 ] . Object . Reference ( ) ) }
4730	func ( v Value ) Type ( ) string { var str string var ok bool if str , ok = v . Data . ( string ) ; ! ok { return fmt . Sprintf ( "%T" , v . Data ) } if isRegex ( str ) { return "regex" } return "string" }
1384	func ( queue * Queue ) GetLastStat ( ) * types . StatsJSON { queue . lock . RLock ( ) defer queue . lock . RUnlock ( ) return queue . lastStat }
4236	func ( id * streamID ) header ( tag uint64 ) uint64 { header := id . id << 3 | tag if ! id . initiator { header -- } return header }
964	func ( v * View ) DataAndLastIndex ( ) ( interface { } , uint64 ) { v . dataLock . RLock ( ) defer v . dataLock . RUnlock ( ) return v . data , v . lastIndex }
4019	func ( d * dbCache ) value ( row , col int ) string { rowId := row - d . firstRow if rowId >= len ( d . data ) { return "" } rowValues := d . data [ rowId ] if col >= len ( rowValues ) { return "" } return rowValues [ col ] }
4513	func ( s * SortFilter ) Text ( n int ) * SortFilter { s . add ( func ( a , b string ) int { a1 , a2 := column ( a , n ) b1 , b2 := column ( b , n ) switch { case a1 < b1 : return - 1 case a1 > b1 : return + 1 case a2 < b2 : return - 1 case a2 > b2 : return + 1 } return 0 } ) return s }
6853	func ( c * cachedLoader ) MustGetBool ( key string ) bool { b , err := c . Get ( key ) if err != nil { panic ( fmt . Sprintf ( "Could not fetch config (%s) %v" , key , err ) ) } var ret bool err = json . Unmarshal ( b , & ret ) if err != nil { panic ( fmt . Sprintf ( "Could not unmarshal config (%s) %v" , key , err ) ) } return ret }
4747	func AsError ( r interface { } ) error { if r == nil { return nil } if err , ok := r . ( error ) ; ok { return err } return fmt . Errorf ( "%v" , r ) }
5366	func ( u * User ) IsOfSystem ( ) bool { if u . UID > config . login . SYS_UID_MIN && u . UID < config . login . SYS_UID_MAX { return true } return false }
4102	func ( l * TextView ) SetText ( text [ ] string ) { l . lines = make ( [ ] string , len ( text ) ) copy ( l . lines , text ) l . applyLimit ( ) l . calculateVirtualSize ( ) if l . autoscroll { l . end ( ) } }
4633	func NewExpiringPointsIndex ( resolution Meters , expiration Minutes ) * PointsIndex { currentPosition := make ( map [ string ] Point ) newExpiringSet := func ( ) interface { } { set := newExpiringSet ( expiration ) set . OnExpire ( func ( id string , value interface { } ) { point := value . ( Point ) delete ( currentPosition , point . Id ( ) ) } ) return set } return & PointsIndex { newGeoIndex ( resolution , newExpiringSet ) , currentPosition } }
3964	func Fuzz ( data [ ] byte ) int { d , err := ioutil . ReadAll ( lz4 . NewReader ( bytes . NewReader ( data ) ) ) if err != nil { return 0 } buf := bytes . NewBuffer ( nil ) zw := lz4 . NewWriter ( buf ) n , err := zw . Write ( d ) if err != nil { panic ( err ) } if n != len ( d ) { panic ( "short write" ) } err = zw . Close ( ) if err != nil { panic ( err ) } ud , err := ioutil . ReadAll ( lz4 . NewReader ( buf ) ) if err != nil { panic ( err ) } if bytes . Compare ( d , ud ) != 0 { panic ( "not equal" ) } return 1 }
2148	func ( m * Matrix ) InitRotate ( radians float64 ) { C . cairo_matrix_init_rotate ( m . native ( ) , C . double ( radians ) ) }
2283	func ( v * Separator ) native ( ) * C . GtkSeparator { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSeparator ( p ) }
3963	func Compress ( fs * flag . FlagSet ) cmdflag . Handler { var blockMaxSize string fs . StringVar ( & blockMaxSize , "size" , "4M" , "block max size [64K,256K,1M,4M]" ) var blockChecksum bool fs . BoolVar ( & blockChecksum , "bc" , false , "enable block checksum" ) var streamChecksum bool fs . BoolVar ( & streamChecksum , "sc" , false , "disable stream checksum" ) var level int fs . IntVar ( & level , "l" , 0 , "compression level (0=fastest)" ) return func ( args ... string ) error { sz , err := bytefmt . ToBytes ( blockMaxSize ) if err != nil { return err } zw := lz4 . NewWriter ( nil ) zw . Header = lz4 . Header { BlockChecksum : blockChecksum , BlockMaxSize : int ( sz ) , NoChecksum : streamChecksum , CompressionLevel : level , } if len ( args ) == 0 { zw . Reset ( os . Stdout ) _ , err := io . Copy ( zw , os . Stdin ) if err != nil { return err } return zw . Close ( ) } for _ , filename := range args { file , err := os . Open ( filename ) if err != nil { return err } finfo , err := file . Stat ( ) if err != nil { return err } mode := finfo . Mode ( ) var ( zsize int size = finfo . Size ( ) ) if size > 0 { numBlocks := int ( size ) / zw . Header . BlockMaxSize bar := progressbar . NewOptions ( numBlocks , progressbar . OptionSetRenderBlankState ( true ) , progressbar . OptionSetDescription ( filename ) , progressbar . OptionClearOnFinish ( ) , ) zw . OnBlockDone = func ( n int ) { _ = bar . Add ( 1 ) zsize += n } } zfilename := fmt . Sprintf ( "%s%s" , filename , lz4 . Extension ) zfile , err := os . OpenFile ( zfilename , os . O_CREATE | os . O_WRONLY , mode ) if err != nil { return err } zw . Reset ( zfile ) _ , err = io . Copy ( zw , file ) if err != nil { return err } for _ , c := range [ ] io . Closer { zw , zfile } { err := c . Close ( ) if err != nil { return err } } if size > 0 { fmt . Printf ( "%s %.02f%%\n" , \n , zfilename ) } } float64 ( zsize ) * 100 / float64 ( size ) } }
5173	func ( t * tx ) ReportError ( exceptionType , errorMessage , stackTrace , stackFrameDelim string ) error { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) _ , err := t . Reporter . ReportError ( t . id , exceptionType , errorMessage , stackTrace , stackFrameDelim ) return err }
3010	func ( b * EnvironmentBrowser ) OSFamily ( ctx context . Context , guest string ) ( string , error ) { var eb mo . EnvironmentBrowser err := b . Properties ( ctx , b . Reference ( ) , nil , & eb ) if err != nil { return "" , err } req := types . QueryConfigOption { This : b . Reference ( ) , } res , err := methods . QueryConfigOption ( ctx , b . Client ( ) , & req ) if err != nil { return "" , err } if res . Returnval == nil { return "" , errors . New ( "no config options were found for the supplied criteria" ) } for _ , osd := range res . Returnval . GuestOSDescriptor { if osd . Id == guest { family := osd . Family log . Printf ( "[DEBUG] OSFamily: family for %q is %q" , guest , family ) return family , nil } } return "" , fmt . Errorf ( "could not find guest ID %q" , guest ) }
6654	func ( v Vec3 ) Cross ( v1 Vec3 ) Vec3 { return Vec3 { v [ 1 ] * v1 [ 2 ] - v [ 2 ] * v1 [ 1 ] , v [ 2 ] * v1 [ 0 ] - v [ 0 ] * v1 [ 2 ] , v [ 0 ] * v1 [ 1 ] - v [ 1 ] * v1 [ 0 ] , } }
2143	func ( v * StyleContext ) native ( ) * C . GtkStyleContext { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStyleContext ( p ) }
6162	func Print ( run bool , commit , version string ) { if run { fmt . Println ( Message ( commit , version ) ) os . Exit ( 0 ) } }
2267	func ( v * Paned ) native ( ) * C . GtkPaned { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkPaned ( p ) }
2341	func ( s * Stream ) Length ( ) int64 { if s . resampling != nil { return s . resampling . Length ( ) } return s . orig . Length ( ) }
6625	func ( c4 * Seefor ) After ( middleware ... After ) { c4 . afters = append ( c4 . afters , middleware ... ) }
1392	func ( m * MockCNIClient ) SetupNS ( arg0 context . Context , arg1 * ecscni . Config , arg2 time . Duration ) ( * current . Result , error ) { ret := m . ctrl . Call ( m , "SetupNS" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( * current . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3346	func ( h * HostActionMute ) GetOverride ( ) bool { if h == nil || h . Override == nil { return false } return * h . Override }
4025	func CreateRadioGroup ( ) * RadioGroup { c := new ( RadioGroup ) c . items = make ( [ ] * Radio , 0 ) return c }
1555	func ( m * MockUdev ) Monitor ( arg0 chan * udev . UEvent ) chan bool { ret := m . ctrl . Call ( m , "Monitor" , arg0 ) ret0 , _ := ret [ 0 ] . ( chan bool ) return ret0 }
672	func ( n NS1DomainService ) UpdateRecord ( r * dns . Record ) ( * http . Response , error ) { return n . service . Records . Update ( r ) }
3524	func ( s * SyntheticsLocation ) GetRegionOk ( ) ( string , bool ) { if s == nil || s . Region == nil { return "" , false } return * s . Region , true }
6730	func FromURL ( src * url . URL , w io . Writer , options Options ) error { httpClient := getHTTPClient ( options ) var ( err error resp * http . Response ) downloader := func ( ) error { resp , err = httpClient . Get ( src . String ( ) ) if err != nil { return & retriableError { errors . Wrap ( err , "Temporary download error" ) } } if resp . StatusCode != http . StatusOK { defer func ( ) { _ = resp . Body . Close ( ) } ( ) return errors . Errorf ( "received invalid status code: %d (expected %d)" , resp . StatusCode , http . StatusOK ) } return nil } retries := options . Retries if retries == 0 { retries = 5 } if err = retryAfter ( retries , downloader , options . RetryInterval ) ; err != nil { return errors . Wrap ( err , "download failed" ) } defer func ( ) { _ = resp . Body . Close ( ) } ( ) var ( validator checksumValidator reader io . Reader = resp . Body ) if options . ProgressBars != nil && resp . ContentLength > 0 { bar := newProgressBar ( resp . ContentLength , options . ProgressBars . MaxWidth , options . ProgressBars . Writer ) bar . Start ( ) reader = bar . NewProxyReader ( reader ) defer func ( ) { <- time . After ( bar . RefreshRate ) fmt . Println ( ) } ( ) } validator , reader , err = createValidatorReader ( reader , options . ChecksumHash , httpClient , options . Checksum , path . Base ( src . Path ) ) if err != nil { return err } if _ , err = io . Copy ( w , reader ) ; err != nil { return errors . Wrap ( err , "failed to copy contents" ) } if ! validator . validate ( ) { return errors . New ( "checksum validation failed" ) } return nil }
1975	func ( m * MockClient ) ContainerStats ( arg0 context . Context , arg1 string , arg2 bool ) ( types . ContainerStats , error ) { ret := m . ctrl . Call ( m , "ContainerStats" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( types . ContainerStats ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
79	func RateLimit ( next log . Logger , limit rate . Limit ) log . Logger { return & ratelimiter { limiter : rate . NewLimiter ( limit , int ( limit ) ) , next : next , } }
2932	func resourceVSphereComputeClusterVMDependencyRuleParseID ( id string ) ( string , int32 , error ) { parts := strings . SplitN ( id , ":" , 3 ) if len ( parts ) < 2 { return "" , 0 , fmt . Errorf ( "bad ID %q" , id ) } key , err := strconv . Atoi ( parts [ 1 ] ) if err != nil { return "" , 0 , fmt . Errorf ( "bad key in ID %q: %s" , parts [ 1 ] , err ) } return parts [ 0 ] , int32 ( key ) , nil }
465	func ( resp * Response ) BodyWriter ( ) io . Writer { resp . w . r = resp return & resp . w }
6348	func LoadFromEnv ( v interface { } , prefix string ) ( result [ ] MarshalledEnvironmentVar ) { pointerValue := reflect . ValueOf ( v ) structValue := pointerValue . Elem ( ) structType := structValue . Type ( ) for i := 0 ; i < structValue . NumField ( ) ; i ++ { structField := structType . Field ( i ) fieldValue := structValue . Field ( i ) if fieldValue . CanSet ( ) { envKey := strings . ToUpper ( prefix ) + gocase . ToUpperSnake ( structField . Name ) envVal := os . Getenv ( envKey ) if envVal != "" { jsonStr := "" if fieldValue . Kind ( ) == reflect . String { jsonStr = fmt . Sprintf ( `{"%s": "%s"}` , structField . Name , envVal ) } else { jsonStr = fmt . Sprintf ( `{"%s": %s}` , structField . Name , envVal ) } err := json . Unmarshal ( [ ] byte ( jsonStr ) , v ) result = append ( result , MarshalledEnvironmentVar { envKey , envVal , structField . Name , err } ) } } } return }
3121	func ( g * Graph ) Objects ( ) [ ] * Object { objects := make ( [ ] * Object , 0 , len ( g . unnamed ) + len ( g . named ) ) for _ , o := range g . unnamed { if ! o . embedded { objects = append ( objects , o ) } } for _ , o := range g . named { if ! o . embedded { objects = append ( objects , o ) } } for i := 0 ; i < len ( objects ) ; i ++ { j := rand . Intn ( i + 1 ) objects [ i ] , objects [ j ] = objects [ j ] , objects [ i ] } return objects }
1972	func ( m * MockClient ) ContainerList ( arg0 context . Context , arg1 types . ContainerListOptions ) ( [ ] types . Container , error ) { ret := m . ctrl . Call ( m , "ContainerList" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( [ ] types . Container ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1386	func ( queue * Queue ) getCWStatsSet ( f getUsageFunc ) ( * ecstcs . CWStatsSet , error ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queueLength := len ( queue . buffer ) if queueLength < 2 { return nil , fmt . Errorf ( "No data in the queue" ) } var min , max , sum float64 var sampleCount int64 min = math . MaxFloat64 max = - math . MaxFloat64 sum = 0 sampleCount = 0 for _ , stat := range queue . buffer { perc := f ( & stat ) if math . IsNaN ( perc ) { continue } min = math . Min ( min , perc ) max = math . Max ( max , perc ) sampleCount ++ sum += perc } return & ecstcs . CWStatsSet { Max : & max , Min : & min , SampleCount : & sampleCount , Sum : & sum , } , nil }
4365	func String ( in [ ] byte , pos int ) ( int , error ) { pos , err := skipSpace ( in , pos ) if err != nil { return 0 , err } max := len ( in ) if v := in [ pos ] ; v != '"' { return 0 , newError ( pos , v ) } pos ++ for { switch in [ pos ] { case '\\' : if in [ pos + 1 ] == '"' { pos ++ } case '"' : return pos + 1 , nil } pos ++ if pos >= max { break } } return 0 , errors . New ( "unclosed string" ) }
6754	func ( ps * PeerSet ) List ( ) [ ] * Peer { ps . mtx . Lock ( ) defer ps . mtx . Unlock ( ) return ps . list }
6554	func NewDataReadWriteSeeker ( rw io . ReadWriteSeeker ) ( * Data , error ) { d := newData ( ) d . r = rw d . w = rw d . s = rw d . cbs . read = C . gpgme_data_read_cb_t ( C . gogpgme_readfunc ) d . cbs . write = C . gpgme_data_write_cb_t ( C . gogpgme_writefunc ) d . cbs . seek = C . gpgme_data_seek_cb_t ( C . gogpgme_seekfunc ) cbc := callbackAdd ( d ) d . cbc = cbc return d , handleError ( C . gogpgme_data_new_from_cbs ( & d . dh , & d . cbs , C . uintptr_t ( cbc ) ) ) }
6142	func ( b * backendInstance ) FilterLogs ( ctx context . Context , q ethereum . FilterQuery ) ( [ ] types . Log , error ) { return b . conn . ethClient ( ) . FilterLogs ( ctx , q ) }
6839	func ( c * Client ) Push ( endPoint string , data interface { } ) error { req := c . buildRequest ( endPoint , data ) resp , err := c . Client . Do ( req ) if err != nil { return err } defer resp . Body . Close ( ) if resp . StatusCode != http . StatusOK { var errResponse errorResponse dec := json . NewDecoder ( resp . Body ) err = dec . Decode ( & errResponse ) if err == nil { return & errResponse . ErrResponse } return errors . New ( resp . Status ) } return nil }
713	func ( p * AlibabaCloudProvider ) privateZoneRecords ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . getPrivateZones ( ) if err != nil { return nil , err } for _ , zone := range zones { recordMap := p . groupPrivateZoneRecords ( zone ) for _ , recordList := range recordMap { name := p . getDNSName ( recordList [ 0 ] . Rr , zone . ZoneName ) recordType := recordList [ 0 ] . Type ttl := recordList [ 0 ] . Ttl if ttl == defaultAlibabaCloudPrivateZoneRecordTTL { ttl = 0 } var targets [ ] string for _ , record := range recordList { target := record . Value if recordType == "TXT" { target = p . unescapeTXTRecordValue ( target ) } targets = append ( targets , target ) } ep := endpoint . NewEndpointWithTTL ( name , recordType , endpoint . TTL ( ttl ) , targets ... ) endpoints = append ( endpoints , ep ) } } return endpoints , nil }
4778	func LoadTOML ( conf interface { } , configPaths ... string ) error { return loadWithFunc ( conf , configPaths , nil , toml . Unmarshal ) }
5669	func ( at * ArrayType ) printDimension ( ps * printState ) { space := " " for len ( ps . inner ) > 0 { in := ps . inner [ len ( ps . inner ) - 1 ] if twq , ok := in . ( * TypeWithQualifiers ) ; ok { in = twq . Base } if _ , ok := in . ( * ArrayType ) ; ok { if in == ps . inner [ len ( ps . inner ) - 1 ] { space = "" } ps . printOneInner ( nil ) } else { ps . writeString ( " (" ) ps . printInner ( false ) ps . writeByte ( ')' ) } } ps . writeString ( space ) ps . writeByte ( '[' ) ps . print ( at . Dimension ) ps . writeByte ( ']' ) }
5390	func lookupCrypter ( ) ( crypt . Crypter , error ) { f , err := os . Open ( _SHADOW_FILE ) if err != nil { return nil , err } defer f . Close ( ) buf := bufio . NewReader ( f ) for { line , _ , err := buf . ReadLine ( ) if err != nil { if err == io . EOF { return nil , ErrShadowPasswd } log . Print ( err ) continue } shadow , err := parseShadow ( string ( line ) ) if err != nil { log . Print ( err ) continue } if shadow . password [ 0 ] == '$' { return crypt . NewFromHash ( shadow . password ) , nil } } return nil , ErrShadowPasswd }
1464	func ( c * Container ) GetKnownExitCode ( ) * int { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . KnownExitCodeUnsafe }
2134	func ( v * LevelBar ) native ( ) * C . GtkLevelBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLevelBar ( p ) }
1728	func ( task * Task ) applyENIHostname ( dockerConfig * dockercontainer . Config ) * dockercontainer . Config { eni := task . GetTaskENI ( ) if eni == nil { return dockerConfig } hostname := eni . GetHostname ( ) if hostname == "" { return dockerConfig } dockerConfig . Hostname = hostname return dockerConfig }
2489	func ( i * Image ) Fill ( clr color . Color ) error { i . copyCheck ( ) if i . isDisposed ( ) { return nil } if i . isSubImage ( ) { panic ( "ebiten: render to a subimage is not implemented (Fill)" ) } i . resolvePendingPixels ( false ) r16 , g16 , b16 , a16 := clr . RGBA ( ) r , g , b , a := uint8 ( r16 >> 8 ) , uint8 ( g16 >> 8 ) , uint8 ( b16 >> 8 ) , uint8 ( a16 >> 8 ) i . mipmap . original ( ) . Fill ( r , g , b , a ) i . disposeMipmaps ( ) return nil }
305	func ( sp * scrapePool ) sync ( targets [ ] * Target ) { sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) var ( uniqueTargets = map [ uint64 ] struct { } { } interval = time . Duration ( sp . config . ScrapeInterval ) timeout = time . Duration ( sp . config . ScrapeTimeout ) limit = int ( sp . config . SampleLimit ) honorLabels = sp . config . HonorLabels honorTimestamps = sp . config . HonorTimestamps mrc = sp . config . MetricRelabelConfigs ) for _ , t := range targets { t := t hash := t . hash ( ) uniqueTargets [ hash ] = struct { } { } if _ , ok := sp . activeTargets [ hash ] ; ! ok { s := & targetScraper { Target : t , client : sp . client , timeout : timeout } l := sp . newLoop ( scrapeLoopOptions { target : t , scraper : s , limit : limit , honorLabels : honorLabels , honorTimestamps : honorTimestamps , mrc : mrc , } ) sp . activeTargets [ hash ] = t sp . loops [ hash ] = l go l . run ( interval , timeout , nil ) } else { sp . activeTargets [ hash ] . SetDiscoveredLabels ( t . DiscoveredLabels ( ) ) } } var wg sync . WaitGroup for hash := range sp . activeTargets { if _ , ok := uniqueTargets [ hash ] ; ! ok { wg . Add ( 1 ) go func ( l loop ) { l . stop ( ) wg . Done ( ) } ( sp . loops [ hash ] ) delete ( sp . loops , hash ) delete ( sp . activeTargets , hash ) } } wg . Wait ( ) }
1083	func ( w * WaitVar ) String ( ) string { return fmt . Sprintf ( "%s:%s" , w . Min , w . Max ) }
669	func ValidateConfig ( cfg * externaldns . Config ) error { if cfg . LogFormat != "text" && cfg . LogFormat != "json" { return fmt . Errorf ( "unsupported log format: %s" , cfg . LogFormat ) } if len ( cfg . Sources ) == 0 { return errors . New ( "no sources specified" ) } if cfg . Provider == "" { return errors . New ( "no provider specified" ) } if cfg . Provider == "azure" { if cfg . AzureConfigFile == "" { return errors . New ( "no Azure config file specified" ) } } if cfg . Provider == "infoblox" { if cfg . InfobloxGridHost == "" { return errors . New ( "no Infoblox Grid Manager host specified" ) } if cfg . InfobloxWapiPassword == "" { return errors . New ( "no Infoblox WAPI password specified" ) } } if cfg . Provider == "dyn" { if cfg . DynUsername == "" { return errors . New ( "no Dyn username specified" ) } if cfg . DynCustomerName == "" { return errors . New ( "no Dyn customer name specified" ) } if cfg . DynMinTTLSeconds < 0 { return errors . New ( "TTL specified for Dyn is negative" ) } } if cfg . IgnoreHostnameAnnotation && cfg . FQDNTemplate == "" { return errors . New ( "FQDN Template must be set if ignoring annotations" ) } return nil }
3754	func ( y * Yaxis ) GetIncludeUnits ( ) bool { if y == nil || y . IncludeUnits == nil { return false } return * y . IncludeUnits }
1309	func setTaskChangeSent ( event * sendableEvent ) { taskChangeStatus := event . taskChange . Status task := event . taskChange . Task if task != nil && task . GetSentStatus ( ) < taskChangeStatus { task . SetSentStatus ( taskChangeStatus ) } for _ , containerStateChange := range event . taskChange . Containers { container := containerStateChange . Container containerChangeStatus := containerStateChange . Status if container . GetSentStatus ( ) < containerChangeStatus { container . SetSentStatus ( containerStateChange . Status ) } } }
1029	func NewFileQuery ( s string ) ( * FileQuery , error ) { s = strings . TrimSpace ( s ) if s == "" { return nil , fmt . Errorf ( "file: invalid format: %q" , s ) } return & FileQuery { stopCh : make ( chan struct { } , 1 ) , path : s , } , nil }
2458	func NewTile ( value int , x , y int ) * Tile { return & Tile { current : TileData { value : value , x : x , y : y , } , startPoppingCount : maxPoppingCount , } }
4741	func StringFilter ( f func ( string ) bool , data [ ] string ) [ ] string { result := make ( [ ] string , 0 , 0 ) for _ , element := range data { if f ( element ) { result = append ( result , element ) } } return result }
1220	func ( imageState * ImageState ) HasImageName ( containerImageName string ) bool { for _ , imageName := range imageState . Image . Names { if imageName == containerImageName { return true } } return false }
1169	func ( payloadHandler * payloadRequestHandler ) handleSingleMessage ( payload * ecsacs . PayloadMessage ) error { if aws . StringValue ( payload . MessageId ) == "" { seelog . Criticalf ( "Received a payload with no message id" ) return fmt . Errorf ( "received a payload with no message id" ) } seelog . Debugf ( "Received payload message, message id: %s" , aws . StringValue ( payload . MessageId ) ) credentialsAcks , allTasksHandled := payloadHandler . addPayloadTasks ( payload ) err := payloadHandler . saver . Save ( ) if err != nil { seelog . Errorf ( "Error saving state for payload message! err: %v, messageId: %s" , err , aws . StringValue ( payload . MessageId ) ) return fmt . Errorf ( "error saving state for payload message, with messageId: %s" , aws . StringValue ( payload . MessageId ) ) } if ! allTasksHandled { return fmt . Errorf ( "did not handle all tasks" ) } go func ( ) { for _ , credentialsAck := range credentialsAcks { payloadHandler . refreshHandler . ackMessage ( credentialsAck ) } payloadHandler . ackRequest <- * payload . MessageId } ( ) return nil }
6899	func focusWindow ( w * Window ) { if w == nil { return } _ , found := windows [ w . id ] if ! found { return } if focus == w { return } prevFocus = focus focus = w resizeAndRender ( w ) }
5212	func ( idx * Index ) GroupBy ( rowsQueries ... * PQLRowsQuery ) * PQLBaseQuery { if len ( rowsQueries ) < 1 { return NewPQLBaseQuery ( "" , idx , errors . New ( "there should be at least one rows query" ) ) } text := fmt . Sprintf ( "GroupBy(%s)" , strings . Join ( serializeGroupBy ( rowsQueries ... ) , "," ) ) return NewPQLBaseQuery ( text , idx , nil ) }
2225	func ( v * CheckButton ) native ( ) * C . GtkCheckButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCheckButton ( p ) }
3796	func ( e * Error ) SetError ( v interface { } ) { b , err := json . Marshal ( v ) if err != nil { panic ( "Error.SetData: " + err . Error ( ) ) } e . Data = ( * json . RawMessage ) ( & b ) }
5153	func NewMongoStore ( c * mgo . Collection , maxAge int , ensureTTL bool , keyPairs ... [ ] byte ) * MongoStore { store := & MongoStore { Codecs : securecookie . CodecsFromPairs ( keyPairs ... ) , Options : & sessions . Options { Path : "/" , MaxAge : maxAge , } , Token : & CookieToken { } , coll : c , } store . MaxAge ( maxAge ) if ensureTTL { c . EnsureIndex ( mgo . Index { Key : [ ] string { "modified" } , Background : true , Sparse : true , ExpireAfter : time . Duration ( maxAge ) * time . Second , } ) } return store }
5399	func parseGroup ( row string ) ( * Group , error ) { fields := strings . Split ( row , ":" ) if len ( fields ) != 4 { return nil , rowError { _GROUP_FILE , row } } gid , err := strconv . Atoi ( fields [ 2 ] ) if err != nil { return nil , atoiError { _GROUP_FILE , row , "GID" } } return & Group { Name : fields [ 0 ] , password : fields [ 1 ] , GID : gid , UserList : strings . Split ( fields [ 3 ] , "," ) , } , nil }
4291	func AddToBridge ( iface , master * net . Interface ) error { return ifIoctBridge ( iface , master , SIOC_BRADDIF ) }
2511	func ( c * newScreenFramebufferImageCommand ) Exec ( indexOffset int ) error { var err error c . result . image , err = theGraphicsDriver . NewScreenFramebufferImage ( c . width , c . height ) return err }
4975	func SortRecent ( messages [ ] * events . LogMessage ) [ ] * events . LogMessage { sort . Stable ( logMessageSlice ( messages ) ) return messages }
4886	func RuneLen ( r rune ) int { switch { case r < 0 : return - 1 case r <= rune1Max : return 1 case r <= rune2Max : return 2 case r <= rune3Max : return 3 case r <= utf8 . MaxRune : return CESUMax } return - 1 }
352	func CheckConfig ( files ... string ) int { failed := false for _ , f := range files { ruleFiles , err := checkConfig ( f ) if err != nil { fmt . Fprintln ( os . Stderr , " FAILED:" , err ) failed = true } else { fmt . Printf ( " SUCCESS: %d rule files found\n" , \n ) } len ( ruleFiles ) fmt . Println ( ) } for _ , rf := range ruleFiles { if n , err := checkRules ( rf ) ; err != nil { fmt . Fprintln ( os . Stderr , " FAILED:" , err ) failed = true } else { fmt . Printf ( " SUCCESS: %d rules found\n" , \n ) } n } fmt . Println ( ) }
2221	func ( v * CellRendererSpinner ) native ( ) * C . GtkCellRendererSpinner { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRendererSpinner ( p ) }
5838	func ( m * CirconusMetrics ) SetText ( metric string , val string ) { m . SetTextValue ( metric , val ) }
3568	func ( t * ThresholdCount ) GetCritical ( ) json . Number { if t == nil || t . Critical == nil { return "" } return * t . Critical }
2066	func ( buffer * InfiniteBuffer ) Consume ( in chan <- * events . Message ) { for { buffer . lock . Lock ( ) if len ( buffer . events ) == 0 { buffer . empty = true buffer . waitForEvent . Add ( 1 ) buffer . lock . Unlock ( ) buffer . waitForEvent . Wait ( ) } else { event := buffer . events [ 0 ] buffer . events = buffer . events [ 1 : ] buffer . lock . Unlock ( ) in <- event } } }
585	func ( mx * Mux ) MethodNotAllowedHandler ( ) http . HandlerFunc { if mx . methodNotAllowedHandler != nil { return mx . methodNotAllowedHandler } return methodNotAllowedHandler }
574	func ( mx * Mux ) Get ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mGET , pattern , handlerFn ) }
1761	func ( task * Task ) SetTerminalReason ( reason string ) { seelog . Infof ( "Task [%s]: attempting to set terminal reason for task [%s]" , task . Arn , reason ) task . terminalReasonOnce . Do ( func ( ) { seelog . Infof ( "Task [%s]: setting terminal reason for task [%s]" , task . Arn , reason ) words := strings . Fields ( reason ) words [ 0 ] = strings . Title ( words [ 0 ] ) task . terminalReason = strings . Join ( words , " " ) } ) }
4617	func ( m * Mutex ) Unlock ( ) { m . mu . Unlock ( ) if ! Opts . Disable { postUnlock ( m ) } }
2979	func ( r * DiskSubresource ) String ( ) string { p := diskPathOrName ( r . data ) if p == "" { p = "<unknown>" } return fmt . Sprintf ( "%s (%s)" , r . Subresource . String ( ) , p ) }
2381	func ( s * Stream ) Seek ( offset int64 , whence int ) ( int64 , error ) { return s . decoded . Seek ( offset , whence ) }
4250	func newEncoding ( encoder string ) * encoding { e := new ( encoding ) e . encode = encoder for i := 0 ; i < len ( e . decode ) ; i ++ { e . decode [ i ] = 0xff } for i := 0 ; i < len ( encoder ) ; i ++ { e . decode [ encoder [ i ] ] = byte ( i ) } return e }
5571	func ( o * OrderVMByFilterParams ) WithBody ( body * models . VMFilter ) * OrderVMByFilterParams { o . SetBody ( body ) return o }
6746	func ( c * MConnection ) sendRoutine ( ) { defer c . _recover ( ) FOR_LOOP : for { var n int var err error select { case <- c . flushTimer . Ch : c . flush ( ) case <- c . chStatsTimer . Ch : for _ , channel := range c . channels { channel . updateStats ( ) } case <- c . pingTimer . Ch : log . Debug ( "Send Ping" ) wire . WriteByte ( packetTypePing , c . bufWriter , & n , & err ) c . sendMonitor . Update ( int ( n ) ) c . flush ( ) case <- c . pong : log . Debug ( "Send Pong" ) wire . WriteByte ( packetTypePong , c . bufWriter , & n , & err ) c . sendMonitor . Update ( int ( n ) ) c . flush ( ) case <- c . quit : break FOR_LOOP case <- c . send : eof := c . sendSomeMsgPackets ( ) if ! eof { select { case c . send <- struct { } { } : default : } } } if ! c . IsRunning ( ) { break FOR_LOOP } if err != nil { log . Warn ( "Connection failed @ sendRoutine" , "conn" , c , "error" , err ) c . stopForError ( err ) break FOR_LOOP } } }
3541	func ( s * SyntheticsRequest ) GetMethod ( ) string { if s == nil || s . Method == nil { return "" } return * s . Method }
4256	func ( c * linuxConsole ) mount ( rootfs , mountLabel string , uid , gid int ) error { oldMask := syscall . Umask ( 0000 ) defer syscall . Umask ( oldMask ) if err := label . SetFileLabel ( c . slavePath , mountLabel ) ; err != nil { return err } dest := filepath . Join ( rootfs , "/dev/console" ) f , err := os . Create ( dest ) if err != nil && ! os . IsExist ( err ) { return err } if f != nil { f . Close ( ) } return syscall . Mount ( c . slavePath , dest , "bind" , syscall . MS_BIND , "" ) }
5107	func hasMinOf ( top interface { } , current interface { } , field interface { } , param string ) bool { return isGte ( top , current , field , param ) }
6704	func ( c * Client ) AddNodesToLoadBalancer ( loadBalancerID string , nodes [ ] LoadBalancerNode ) ( * LoadBalancer , error ) { lb := new ( LoadBalancer ) _ , err := c . MakeApiRequest ( "POST" , "/1.0/load_balancers/" + loadBalancerID + "/add_nodes" , nodes , & lb ) if err != nil { return nil , err } return lb , nil }
2485	func ( i * Input ) Update ( ) { switch i . mouseState { case mouseStateNone : if ebiten . IsMouseButtonPressed ( ebiten . MouseButtonLeft ) { x , y := ebiten . CursorPosition ( ) i . mouseInitPosX = x i . mouseInitPosY = y i . mouseState = mouseStatePressing } case mouseStatePressing : if ! ebiten . IsMouseButtonPressed ( ebiten . MouseButtonLeft ) { x , y := ebiten . CursorPosition ( ) dx := x - i . mouseInitPosX dy := y - i . mouseInitPosY d , ok := vecToDir ( dx , dy ) if ! ok { i . mouseState = mouseStateNone break } i . mouseDir = d i . mouseState = mouseStateSettled } case mouseStateSettled : i . mouseState = mouseStateNone } switch i . touchState { case touchStateNone : ts := ebiten . TouchIDs ( ) if len ( ts ) == 1 { i . touchID = ts [ 0 ] x , y := ebiten . TouchPosition ( ts [ 0 ] ) i . touchInitPosX = x i . touchInitPosY = y i . touchLastPosX = x i . touchLastPosX = y i . touchState = touchStatePressing } case touchStatePressing : ts := ebiten . TouchIDs ( ) if len ( ts ) >= 2 { break } if len ( ts ) == 1 { if ts [ 0 ] != i . touchID { i . touchState = touchStateInvalid } else { x , y := ebiten . TouchPosition ( ts [ 0 ] ) i . touchLastPosX = x i . touchLastPosY = y } break } if len ( ts ) == 0 { dx := i . touchLastPosX - i . touchInitPosX dy := i . touchLastPosY - i . touchInitPosY d , ok := vecToDir ( dx , dy ) if ! ok { i . touchState = touchStateNone break } i . touchDir = d i . touchState = touchStateSettled } case touchStateSettled : i . touchState = touchStateNone case touchStateInvalid : if len ( ebiten . TouchIDs ( ) ) == 0 { i . touchState = touchStateNone } } }
4479	func ( d * Duration ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { tt , err := ParseDuration ( data ) if err != nil { in . AddError ( err ) return } * d = Duration ( tt ) } }
1997	func ( engine * DockerStatsEngine ) addToStatsContainerMapUnsafe ( taskARN , containerID string , statsContainer * StatsContainer , statsMapToUpdate func ( ) map [ string ] map [ string ] * StatsContainer ) bool { taskToContainerMap := statsMapToUpdate ( ) _ , taskExists := taskToContainerMap [ taskARN ] if taskExists { _ , containerExists := taskToContainerMap [ taskARN ] [ containerID ] if containerExists { seelog . Debugf ( "Container already being watched, ignoring, id: %s" , containerID ) return false } } else { taskToContainerMap [ taskARN ] = make ( map [ string ] * StatsContainer ) } taskToContainerMap [ taskARN ] [ containerID ] = statsContainer return true }
6461	func ( l * Log ) putBuffer ( b * buffer ) { if b . Len ( ) >= 256 { return } l . freeListMu . Lock ( ) b . next = l . freeList l . freeList = b l . freeListMu . Unlock ( ) }
6562	func ( r Record ) GetBool ( column string ) ( bool , error ) { v , err := r . getKey ( reflect . Float64 , column ) if err != nil { return false , err } return v == 1.0 , nil }
5101	func ( id ObjectId ) byteSlice ( start , end int ) [ ] byte { if len ( id ) != 12 { panic ( fmt . Sprintf ( "Invalid ObjectId: %q" , string ( id ) ) ) } return [ ] byte ( string ( id ) [ start : end ] ) }
7018	func NewErrorStatus ( status int , err string ) error { return & errStatus { error : errors . New ( err ) , status : status , } }
6151	func ( w * Worker ) AgentAfterUncooperativeClose ( job * data . Job ) error { logger := w . logger . Add ( "method" , "AgentAfterUncooperativeClose" , "job" , job ) channel , err := w . relatedChannel ( logger , job , data . JobAgentAfterUncooperativeClose ) if err != nil { return err } if channel . ServiceStatus != data . ServiceTerminated { _ , err = w . processor . TerminateChannel ( channel . ID , data . JobTask , true ) if err != nil { logger . Error ( err . Error ( ) ) return ErrTerminateChannel } } channel . ChannelStatus = data . ChannelClosedUncoop if err = w . db . Update ( channel ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } if err := w . incrementCurrentSupply ( logger , w . db . Querier , channel . Offering ) ; err != nil { return err } agent , err := w . account ( logger , channel . Agent ) if err != nil { return err } return w . addJob ( logger , nil , data . JobAccountUpdateBalances , data . JobAccount , agent . ID ) }
4357	func FindRange ( in [ ] byte , pos , from , to int ) ( [ ] byte , error ) { if to < from { return nil , errToLessThanFrom } pos , err := skipSpace ( in , pos ) if err != nil { return nil , err } if v := in [ pos ] ; v != '[' { return nil , newError ( pos , v ) } pos ++ idx := 0 itemStart := pos for { pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } if idx == from { itemStart = pos } pos , err = Any ( in , pos ) if err != nil { return nil , err } if idx == to { data := in [ itemStart : pos ] result := make ( [ ] byte , 0 , len ( data ) + 2 ) result = append ( result , '[' ) result = append ( result , data ... ) result = append ( result , ']' ) return result , nil } pos , err = skipSpace ( in , pos ) if err != nil { return nil , err } switch in [ pos ] { case ',' : pos ++ case ']' : return nil , errIndexOutOfBounds } idx ++ } }
1521	func ( imageManager * dockerImageManager ) removeImageState ( imageStateToBeRemoved * image . ImageState ) { for i , imageState := range imageManager . imageStates { if imageState . Image . ImageID == imageStateToBeRemoved . Image . ImageID { seelog . Infof ( "Removing Image State: [%s] from Image Manager" , imageState . String ( ) ) imageManager . imageStates = append ( imageManager . imageStates [ : i ] , imageManager . imageStates [ i + 1 : ] ... ) return } } }
6891	func EscapedLen ( s string ) int { if len ( s ) == 0 { return 0 } var rw , total int for i := 0 ; i < len ( s ) ; i += rw { v , width := utf8 . DecodeRuneInString ( s [ i : ] ) if v == '\x1b' { _ , skip , err := DecodeColor ( s [ i : ] ) if err == nil { rw = skip total += skip continue } } rw = width } return total }
5706	func ( s * Sentinel ) putToBottom ( addr string ) { addrs := s . Addrs if addrs [ len ( addrs ) - 1 ] == addr { return } newAddrs := [ ] string { } for _ , a := range addrs { if a == addr { continue } newAddrs = append ( newAddrs , a ) } newAddrs = append ( newAddrs , addr ) s . Addrs = newAddrs }
4866	func ( r * RateLimiter ) Left ( id string ) ( int64 , error ) { attempted , err := r . Attempted ( id ) if err != nil { return 0 , err } left := r . max - attempted if left < 0 { return 0 , nil } return left , nil }
3431	func ( o * Options ) GetQueryConfig ( ) QueryConfig { if o == nil || o . QueryConfig == nil { return QueryConfig { } } return * o . QueryConfig }
6451	func ( l * Level ) set ( val Level ) { atomic . StoreInt32 ( ( * int32 ) ( l ) , int32 ( val ) ) }
4950	func NewScanner ( str string ) * Scanner { s , _ := scannerPool . Get ( ) . ( * Scanner ) if s == nil { s = & Scanner { rd : strings . NewReader ( str ) } } else { s . rd . Reset ( str ) } s . ch = - 2 s . err = nil return s }
7126	func ApplyRuleIfElse ( condition , rule , el Ruler ) Ruler { return & applyelse { condition : condition , rule : rule , el : el , } }
4823	func ( g GitOS ) MkdirAll ( path string , perm os . FileMode ) error { return os . MkdirAll ( path , perm ) }
2456	func ( t * Tile ) Pos ( ) ( int , int ) { return t . current . x , t . current . y }
2206	func ( v * Action ) GetState ( ) * Variant { c := C . g_action_get_state ( v . native ( ) ) if c == nil { return nil } return newVariant ( ( * C . GVariant ) ( c ) ) }
231	func FuzzParseStmts ( in [ ] byte ) int { _ , err := ParseStmts ( string ( in ) ) if err == nil { return fuzzInteresting } return fuzzMeh }
3246	func ( c * ChannelSlackRequest ) HasChannelName ( ) bool { if c != nil && c . ChannelName != nil { return true } return false }
4593	func ( c * Call ) PkgSrc ( ) string { return filepath . Join ( filepath . Base ( filepath . Dir ( c . SrcPath ) ) , c . SrcName ( ) ) }
2150	func ( m * Matrix ) Scale ( sx , sy float64 ) { C . cairo_matrix_scale ( m . native ( ) , C . double ( sx ) , C . double ( sy ) ) }
6132	func ( b * backendInstance ) PTCBalanceOf ( opts * bind . CallOpts , owner common . Address ) ( * big . Int , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 val , err := b . ptc . BalanceOf ( opts , owner ) if err != nil { err = fmt . Errorf ( "failed to get PTC balance: %s" , err ) } return val , err }
1054	func ( c * Child ) Start ( ) error { log . Printf ( "[INFO] (child) spawning: %s" , c . Command ( ) ) c . Lock ( ) defer c . Unlock ( ) return c . start ( ) }
680	func allLogLevelsAsStrings ( ) [ ] string { var levels [ ] string for _ , level := range logrus . AllLevels { levels = append ( levels , level . String ( ) ) } return levels }
3432	func ( o * Options ) GetQueryConfigOk ( ) ( QueryConfig , bool ) { if o == nil || o . QueryConfig == nil { return QueryConfig { } , false } return * o . QueryConfig , true }
851	func ( c * ComputeUtil ) waitForRegionalOp ( name string ) error { return c . waitForOp ( func ( ) ( * raw . Operation , error ) { return c . service . ZoneOperations . Get ( c . project , c . zone , name ) . Do ( ) } ) }
1564	func NewMultiError ( errs ... error ) error { errors := make ( [ ] error , 0 , len ( errs ) ) for _ , err := range errs { if err != nil { errors = append ( errors , err ) } } return MultiErr { errors } }
3749	func ( w * WidgetMetadata ) GetAliasNameOk ( ) ( string , bool ) { if w == nil || w . AliasName == nil { return "" , false } return * w . AliasName , true }
6548	func NewData ( ) ( * Data , error ) { d := newData ( ) return d , handleError ( C . gpgme_data_new ( & d . dh ) ) }
953	func Detect ( ) ( string , error ) { shell := os . Getenv ( "SHELL" ) if shell == "" { fmt . Printf ( "The default lines below are for a sh/bash shell, you can specify the shell you're using, with the --shell flag.\n\n" ) \n } \n }
3969	func New ( ) Bus { b := & EventBus { make ( map [ string ] [ ] * eventHandler ) , sync . Mutex { } , sync . WaitGroup { } , } return Bus ( b ) }
4482	func DateValue ( v * strfmt . Date ) strfmt . Date { if v == nil { return strfmt . Date { } } return * v }
3727	func ( w * Widget ) GetTitleText ( ) string { if w == nil || w . TitleText == nil { return "" } return * w . TitleText }
2119	func ( v * PixbufFormat ) native ( ) * C . GdkPixbufFormat { if v == nil { return nil } return v . format }
6336	func NewSprocketsServer ( target * url . URL ) ( * SprocketsServer , error ) { s := SprocketsServer { Handler : httputil . NewSingleHostReverseProxy ( target ) , target : target , } return & s , nil }
4572	func NewContextWithContext ( ctx context . Context ) * Context { c := NewContext ( ) c . Context = ctx return c }
3259	func ( c * ConditionalFormat ) GetImageURL ( ) string { if c == nil || c . ImageURL == nil { return "" } return * c . ImageURL }
6760	func ( a * AddrBook ) Save ( ) { log . Info ( "Saving AddrBook to file" , "size" , a . Size ( ) ) a . saveToFile ( a . filePath ) }
1115	func plugin ( name string , args ... string ) ( string , error ) { if name == "" { return "" , nil } stdout , stderr := new ( bytes . Buffer ) , new ( bytes . Buffer ) jsons := make ( [ ] string , 0 , len ( args ) ) for _ , arg := range args { if v := strings . TrimSpace ( arg ) ; v != "" { jsons = append ( jsons , v ) } } cmd := exec . Command ( name , jsons ... ) cmd . Stdout = stdout cmd . Stderr = stderr if err := cmd . Start ( ) ; err != nil { return "" , fmt . Errorf ( "exec %q: %s\n\nstdout:\n\n%s\n\nstderr:\n\n%s" , \n , \n , \n , \n ) } \n \n \n \n }
6189	func EncryptedKey ( pkey * ecdsa . PrivateKey , auth string ) ( Base64String , error ) { key := keystore . NewKeyForDirectICAP ( rand . Reader ) key . Address = crypto . PubkeyToAddress ( pkey . PublicKey ) key . PrivateKey = pkey encryptedBytes , err := keystore . EncryptKey ( key , auth , keystore . StandardScryptN , keystore . StandardScryptP ) if err != nil { return "" , err } return FromBytes ( encryptedBytes ) , nil }
1126	func modulo ( b , a interface { } ) ( interface { } , error ) { av := reflect . ValueOf ( a ) bv := reflect . ValueOf ( b ) switch av . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return av . Int ( ) % bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Int ( ) % int64 ( bv . Uint ( ) ) , nil default : return nil , fmt . Errorf ( "modulo: unknown type for %q (%T)" , bv , b ) } case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return int64 ( av . Uint ( ) ) % bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Uint ( ) % bv . Uint ( ) , nil default : return nil , fmt . Errorf ( "modulo: unknown type for %q (%T)" , bv , b ) } default : return nil , fmt . Errorf ( "modulo: unknown type for %q (%T)" , av , a ) } }
249	func ( q requiredMatchersQuerier ) Select ( p * storage . SelectParams , matchers ... * labels . Matcher ) ( storage . SeriesSet , storage . Warnings , error ) { ms := q . requiredMatchers for _ , m := range matchers { for i , r := range ms { if m . Type == labels . MatchEqual && m . Name == r . Name && m . Value == r . Value { ms = append ( ms [ : i ] , ms [ i + 1 : ] ... ) break } } if len ( ms ) == 0 { break } } if len ( ms ) > 0 { return storage . NoopSeriesSet ( ) , nil , nil } return q . Querier . Select ( p , matchers ... ) }
6642	func ( r Rectangle ) String ( ) string { return fmt . Sprintf ( "(Min:%v,Max:%v)" , r . Min , r . Max ) }
186	func ( r * AlertingRule ) GetEvaluationDuration ( ) time . Duration { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . evaluationDuration }
3677	func ( w * Widget ) GetManageStatusShowTitleOk ( ) ( bool , bool ) { if w == nil || w . ManageStatusShowTitle == nil { return false , false } return * w . ManageStatusShowTitle , true }
5529	func GoToLua ( L * lua . State , a interface { } ) { visited := newVisitor ( L ) goToLua ( L , a , false , visited ) visited . close ( ) }
3213	func NewClient ( apiKey , appKey string ) * Client { baseUrl := os . Getenv ( "DATADOG_HOST" ) if baseUrl == "" { baseUrl = "https://app.datadoghq.com" } return & Client { apiKey : apiKey , appKey : appKey , baseUrl : baseUrl , HttpClient : http . DefaultClient , RetryTimeout : time . Duration ( 60 * time . Second ) , } }
413	func NewWriter ( dstW io . Writer , newWriter NewWriterFunc ) Writer { w := & writer { dstW : dstW , } w . zw = newWriter ( & w . xw ) return w }
5398	func ( g * Group ) IsOfSystem ( ) bool { if g . GID > config . login . SYS_GID_MIN && g . GID < config . login . SYS_GID_MAX { return true } return false }
1732	func ( task * Task ) UpdateDesiredStatus ( ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . updateTaskDesiredStatusUnsafe ( ) task . updateContainerDesiredStatusUnsafe ( task . DesiredStatusUnsafe ) task . updateResourceDesiredStatusUnsafe ( task . DesiredStatusUnsafe ) }
4755	func HTTPPostJSON ( url string , data interface { } ) error { b , err := json . MarshalIndent ( data , "" , " " ) if err != nil { return err } response , err := http . Post ( url , "application/json" , bytes . NewBuffer ( b ) ) if err == nil && ( response . StatusCode < 200 || response . StatusCode > 299 ) { err = errors . New ( response . Status ) } return err }
4724	func ( r * Runner ) RunGroup ( groups ... * parse . Group ) { for _ , group := range groups { r . runGroup ( group ) } }
440	func ( ctx * RequestCtx ) IfModifiedSince ( lastModified time . Time ) bool { ifModStr := ctx . Request . Header . peek ( strIfModifiedSince ) if len ( ifModStr ) == 0 { return true } ifMod , err := ParseHTTPDate ( ifModStr ) if err != nil { return true } lastModified = lastModified . Truncate ( time . Second ) return ifMod . Before ( lastModified ) }
4507	func UniqWithCount ( ) Filter { return FilterFunc ( func ( arg Arg ) error { current := "" count := 0 for s := range arg . In { if s != current { if count > 0 { arg . Out <- fmt . Sprintf ( "%d %s" , count , current ) } count = 0 current = s } count ++ } if count > 0 { arg . Out <- fmt . Sprintf ( "%d %s" , count , current ) } return nil } ) }
3438	func ( o * Options ) GetRequireFullWindowOk ( ) ( bool , bool ) { if o == nil || o . RequireFullWindow == nil { return false , false } return * o . RequireFullWindow , true }
6104	func ( h * Handler ) GetAccounts ( tkn string ) ( [ ] data . Account , error ) { logger := h . logger . Add ( "method" , "GetAccounts" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } accounts , err := h . selectAllFrom ( logger , data . AccountTable , "" ) if err != nil { return nil , err } result := make ( [ ] data . Account , len ( accounts ) ) for k , v := range accounts { result [ k ] = * v . ( * data . Account ) } return result , nil }
6304	func ( di * dependencyInjector ) cachedCreateFromType ( atype reflect . Type ) reflect . Value { _ , exists := di . instances [ atype ] if ! exists { di . instances [ atype ] = di . createFromType ( atype ) } return di . instances [ atype ] }
4156	func ( b * bruteRanger ) Contains ( ip net . IP ) ( bool , error ) { entries , err := b . getEntriesByVersion ( ip ) if err != nil { return false , err } for _ , entry := range entries { network := entry . Network ( ) if network . Contains ( ip ) { return true , nil } } return false , nil }
6398	func NewStack ( entries ... interface { } ) * Stack { retval := & Stack { } retval . underlyer = NewLinkedList ( ) for _ , entry := range entries { retval . Push ( entry ) } return retval }
3281	func ( d * Downtime ) GetActiveOk ( ) ( bool , bool ) { if d == nil || d . Active == nil { return false , false } return * d . Active , true }
2885	func Properties ( host * object . HostSystem ) ( * mo . HostSystem , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . HostSystem if err := host . Properties ( ctx , host . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
3655	func ( w * Widget ) GetAlertID ( ) int { if w == nil || w . AlertID == nil { return 0 } return * w . AlertID }
6406	func ( list * LinkedList ) AddBack ( entry interface { } ) { toAppend := & llNode { payload : entry , } list . key . Lock ( ) defer list . key . Unlock ( ) list . length ++ if list . first == nil { list . first = toAppend list . last = toAppend return } list . last . next = toAppend list . last = toAppend }
2787	func flattenHostPortGroupSpec ( d * schema . ResourceData , obj * types . HostPortGroupSpec ) error { d . Set ( "vlan_id" , obj . VlanId ) if err := flattenHostNetworkPolicy ( d , & obj . Policy ) ; err != nil { return err } return nil }
6560	func ( r Record ) Columns ( ) [ ] string { cols := [ ] string { } for k := range r { cols = append ( cols , k ) } sort . Strings ( cols ) return cols }
1211	func ( dg * dockerGoClient ) ListContainers ( ctx context . Context , all bool , timeout time . Duration ) ListContainersResponse { ctx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) response := make ( chan ListContainersResponse , 1 ) go func ( ) { response <- dg . listContainers ( ctx , all ) } ( ) select { case resp := <- response : return resp case <- ctx . Done ( ) : err := ctx . Err ( ) if err == context . DeadlineExceeded { return ListContainersResponse { Error : & DockerTimeoutError { timeout , "listing" } } } return ListContainersResponse { Error : & CannotListContainersError { err } } } }
5277	func ( r * exportReader ) Read ( p [ ] byte ) ( n int , err error ) { if r . currentShard >= r . shardCount { err = io . EOF return } if r . body == nil { uri , _ := r . shardURIs [ r . currentShard ] headers := map [ string ] string { "Accept" : "text/csv" , } path := fmt . Sprintf ( "/export?index=%s&field=%s&shard=%d" , r . field . index . Name ( ) , r . field . Name ( ) , r . currentShard ) resp , err := r . client . doRequest ( uri , "GET" , path , headers , nil ) if err = anyError ( resp , err ) ; err != nil { return 0 , errors . Wrap ( err , "doing export request" ) } defer resp . Body . Close ( ) r . body , err = ioutil . ReadAll ( resp . Body ) if err != nil { return 0 , errors . Wrap ( err , "reading response body" ) } r . bodyIndex = 0 } n = copy ( p , r . body [ r . bodyIndex : ] ) r . bodyIndex += n if n >= len ( r . body ) { r . body = nil r . currentShard ++ } return }
5840	func ( m * CirconusMetrics ) RemoveText ( metric string ) { m . tm . Lock ( ) defer m . tm . Unlock ( ) delete ( m . text , metric ) }
1743	func ( task * Task ) SetSentStatus ( status apitaskstatus . TaskStatus ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . SentStatusUnsafe = status }
1769	func ( task * Task ) AssociationsByTypeAndContainer ( associationType , containerName string ) [ ] string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) var associationNames [ ] string for _ , association := range task . Associations { if association . Type == associationType { for _ , associatedContainerName := range association . Containers { if associatedContainerName == containerName { associationNames = append ( associationNames , association . Name ) } } } } return associationNames }
981	func NewTemplate ( i * NewTemplateInput ) ( * Template , error ) { if i == nil { i = & NewTemplateInput { } } if i . Source != "" && i . Contents != "" { return nil , ErrTemplateContentsAndSource } else if i . Source == "" && i . Contents == "" { return nil , ErrTemplateMissingContentsAndSource } var t Template t . source = i . Source t . contents = i . Contents t . leftDelim = i . LeftDelim t . rightDelim = i . RightDelim t . errMissingKey = i . ErrMissingKey if i . Source != "" { contents , err := ioutil . ReadFile ( i . Source ) if err != nil { return nil , errors . Wrap ( err , "failed to read template" ) } t . contents = string ( contents ) } hash := md5 . Sum ( [ ] byte ( t . contents ) ) t . hexMD5 = hex . EncodeToString ( hash [ : ] ) return & t , nil }
1218	func ( imageState * ImageState ) UpdateImageState ( container * apicontainer . Container ) { imageState . AddImageName ( container . Image ) imageState . UpdateContainerReference ( container ) }
5950	func ( h Host ) ToString ( ) ( out string ) { out += fmt . Sprintf ( "%s is %s\n" , \n , h . Address ) h . State if len ( h . Hostnames ) != 0 { out += "Hostnames:\n" \n } for _ , hostname := range h . Hostnames { out += fmt . Sprintf ( " %s/%s\n" , \n , hostname . Name ) } }
4725	func ParseFile ( files ... string ) ( [ ] * Group , error ) { var groups [ ] * Group for _ , file := range files { if err := func ( file string ) error { f , err := os . Open ( file ) if err != nil { return err } defer f . Close ( ) gs , err := Parse ( file , f ) if err != nil { return err } groups = append ( groups , gs ... ) return nil } ( file ) ; err != nil { return nil , err } } return groups , nil }
5394	func ChGPasswd ( group string , key [ ] byte ) error { gshadow , err := LookupGShadow ( group ) if err != nil { return err } gshadow . Passwd ( key ) return edit ( group , gshadow ) }
3407	func ( n * NoteDefinition ) GetShowTick ( ) bool { if n == nil || n . ShowTick == nil { return false } return * n . ShowTick }
4772	func WaitForStdin ( println ... interface { } ) byte { if len ( println ) > 0 { fmt . Println ( println ... ) } buffer := make ( [ ] byte , 1 ) os . Stdin . Read ( buffer ) return buffer [ 0 ] }
989	func ( s * Scratch ) Set ( k string , v interface { } ) string { s . init ( ) s . Lock ( ) defer s . Unlock ( ) s . values [ k ] = v return "" }
2357	func ( b * Board ) Move ( dir Dir ) error { for t := range b . tiles { t . stopAnimation ( ) } if ! MoveTiles ( b . tiles , b . size , dir ) { return nil } b . tasks = append ( b . tasks , func ( ) error { for t := range b . tiles { if t . IsMoving ( ) { return nil } } return taskTerminated } ) b . tasks = append ( b . tasks , func ( ) error { nextTiles := map [ * Tile ] struct { } { } for t := range b . tiles { if t . IsMoving ( ) { panic ( "not reach" ) } if t . next . value != 0 { panic ( "not reach" ) } if t . current . value == 0 { continue } nextTiles [ t ] = struct { } { } } b . tiles = nextTiles if err := addRandomTile ( b . tiles , b . size ) ; err != nil { return err } return taskTerminated } ) return nil }
671	func ( n NS1DomainService ) DeleteRecord ( zone string , domain string , t string ) ( * http . Response , error ) { return n . service . Records . Delete ( zone , domain , t ) }
4038	func InClipRect ( x , y int ) bool { return x >= canvas . clipX && y >= canvas . clipY && x < canvas . clipX + canvas . clipW && y < canvas . clipY + canvas . clipH }
4628	func Is ( e error , original error ) bool { if e == original { return true } if e , ok := e . ( * Error ) ; ok { return Is ( e . Err , original ) } if original , ok := original . ( * Error ) ; ok { return Is ( e , original . Err ) } return false }
5454	func ( c * CallService ) GetRecordings ( ctx context . Context , callSid string , data url . Values ) ( * RecordingPage , error ) { if data == nil { data = url . Values { } } data . Set ( "CallSid" , callSid ) return c . client . Recordings . GetPage ( ctx , data ) }
5310	func IsExist ( err error ) bool { if err == ErrUserExist || err == ErrGroupExist { return true } return false }
2406	func JustConnectedGamepadIDs ( ) [ ] int { var ids [ ] int theInputState . m . RLock ( ) for id := range theInputState . gamepadIDs { if _ , ok := theInputState . prevGamepadIDs [ id ] ; ! ok { ids = append ( ids , id ) } } theInputState . m . RUnlock ( ) sort . Ints ( ids ) return ids }
5564	func FindPerformanceIOPSPrice ( productPackage datatypes . Product_Package , size int , iops int ) ( datatypes . Product_Item_Price , error ) { for _ , item := range productPackage . Items { if int ( * item . Capacity ) != int ( iops ) { continue } for _ , price := range item . Prices { if price . LocationGroupId != nil { continue } if ! hasCategory ( price . Categories , "performance_storage_iops" ) { continue } min , err := strconv . Atoi ( * price . CapacityRestrictionMinimum ) if err != nil { return datatypes . Product_Item_Price { } , bosherr . Errorf ( "Unable to find price for %d iops for the given volume" , iops ) } if size < int ( min ) { continue } max , err := strconv . Atoi ( * price . CapacityRestrictionMaximum ) if err != nil { return datatypes . Product_Item_Price { } , bosherr . Errorf ( "Unable to find price for %d iops for the given volume" , iops ) } if size > int ( max ) { continue } return price , nil } } return datatypes . Product_Item_Price { } , bosherr . Errorf ( "Unable to find price for %d iops for the given volume" , iops ) }
4162	func ( c * Client ) Depart ( channel string ) { if c . connActive . get ( ) { go c . send ( fmt . Sprintf ( "PART #%s" , channel ) ) } c . channelsMtx . Lock ( ) delete ( c . channels , channel ) c . channelUserlistMutex . Lock ( ) delete ( c . channelUserlist , channel ) c . channelUserlistMutex . Unlock ( ) c . channelsMtx . Unlock ( ) }
3779	func ( client * Client ) RevokeScreenboard ( id int ) error { return client . doJsonRequest ( "DELETE" , fmt . Sprintf ( "/v1/screen/share/%d" , id ) , nil , nil ) }
3974	func ( bus * EventBus ) Publish ( topic string , args ... interface { } ) { bus . lock . Lock ( ) defer bus . lock . Unlock ( ) if handlers , ok := bus . handlers [ topic ] ; ok && 0 < len ( handlers ) { copyHandlers := make ( [ ] * eventHandler , 0 , len ( handlers ) ) copyHandlers = append ( copyHandlers , handlers ... ) for i , handler := range copyHandlers { if handler . flagOnce { bus . removeHandler ( topic , i ) } if ! handler . async { bus . doPublish ( handler , topic , args ... ) } else { bus . wg . Add ( 1 ) if handler . transactional { handler . Lock ( ) } go bus . doPublishAsync ( handler , topic , args ... ) } } } }
281	func ( l * lexer ) scanNumber ( ) bool { digits := "0123456789" if ! l . seriesDesc && l . accept ( "0" ) && l . accept ( "xX" ) { digits = "0123456789abcdefABCDEF" } l . acceptRun ( digits ) if l . accept ( "." ) { l . acceptRun ( digits ) } if l . accept ( "eE" ) { l . accept ( "+-" ) l . acceptRun ( "0123456789" ) } if r := l . peek ( ) ; ( l . seriesDesc && r == 'x' ) || ! isAlphaNumeric ( r ) { return true } return false }
3166	func ( client * Client ) DeleteIntegrationAWS ( awsAccount * IntegrationAWSAccountDeleteRequest ) error { return client . doJsonRequest ( "DELETE" , "/v1/integration/aws" , awsAccount , nil ) }
6997	func ( r * Router ) Middleware ( ctx * neptulon . ReqCtx ) error { if handler , ok := r . routes [ ctx . Method ] ; ok { return handler ( ctx ) } return ctx . Next ( ) }
4228	func ( s * Spinner ) Start ( ) { s . lock . Lock ( ) if s . active { s . lock . Unlock ( ) return } if s . HideCursor && runtime . GOOS != "windows" { fmt . Print ( "\033[?25l" ) } \033 s . active = true s . lock . Unlock ( ) }
4635	func ( points * PointsIndex ) GetAll ( ) map [ string ] Point { newpoints := make ( map [ string ] Point , 0 ) for i , p := range points . currentPosition { newpoints [ i ] = p } return newpoints }
3785	func ( client * Client ) doRequestWithRetries ( req * http . Request , maxTime time . Duration ) ( * http . Response , error ) { var ( err error resp * http . Response bo = backoff . NewExponentialBackOff ( ) body [ ] byte ) bo . MaxElapsedTime = maxTime if req . Body != nil { body , err = ioutil . ReadAll ( req . Body ) if err != nil { return resp , err } } operation := func ( ) error { if body != nil { r := bytes . NewReader ( body ) req . Body = ioutil . NopCloser ( r ) } resp , err = client . HttpClient . Do ( req ) if err != nil { return err } if resp . StatusCode >= 200 && resp . StatusCode < 300 { return nil } else if resp . StatusCode >= 400 && resp . StatusCode < 500 { return nil } return fmt . Errorf ( "Received HTTP status code %d" , resp . StatusCode ) } err = backoff . Retry ( operation , bo ) return resp , err }
2729	func ( p * nasDatastoreMountProcessor ) processMountOperations ( ) ( * object . Datastore , error ) { hosts := p . diffNewOld ( ) if len ( hosts ) < 1 { return p . ds , nil } if len ( hosts ) > 1 { if err := viapi . ValidateVirtualCenter ( p . client ) ; err != nil { return p . ds , fmt . Errorf ( "cannot mount on multiple hosts: %s" , err ) } } for _ , hsID := range hosts { dss , err := hostDatastoreSystemFromHostSystemID ( p . client , hsID ) if err != nil { return p . ds , fmt . Errorf ( "host %q: %s" , hostsystem . NameOrID ( p . client , hsID ) , err ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) ds , err := dss . CreateNasDatastore ( ctx , * p . volSpec ) if err != nil { return p . ds , fmt . Errorf ( "host %q: %s" , hostsystem . NameOrID ( p . client , hsID ) , err ) } if err := p . validateDatastore ( ds ) ; err != nil { return p . ds , fmt . Errorf ( "datastore validation error on host %q: %s" , hostsystem . NameOrID ( p . client , hsID ) , err ) } } return p . ds , nil }
6902	func Exit ( format string , args ... interface { } ) { termbox . Close ( ) fmt . Fprintf ( os . Stderr , format + "\n" , \n ) args ... }
6285	func ( t * BTTracer ) SetOutputPath ( path string , perm os . FileMode ) error { return nil }
6994	func LogFactory ( name string , logType LogType , writer io . Writer ) Logger { log := & logger { Name : name , LogLevel : minLogLevel , Writer : writer } if logType == Lager { return NewLager ( log ) } return NewLager ( log ) }
5523	func pushNumberValue ( L * lua . State , a interface { } , t1 , t2 reflect . Type ) { v := reflect . ValueOf ( a ) isComplex := unsizedKind ( v ) == reflect . Complex128 mt := cNumberMeta if isComplex { mt = cComplexMeta } if t1 == t2 || isPredeclaredType ( t2 ) { makeValueProxy ( L , v . Convert ( t1 ) , mt ) } else if isPredeclaredType ( t1 ) { makeValueProxy ( L , v . Convert ( t2 ) , mt ) } else if isComplex { complexType := reflect . TypeOf ( 0i ) makeValueProxy ( L , v . Convert ( complexType ) , cComplexMeta ) } else { L . PushNumber ( valueToNumber ( L , v ) ) } }
3573	func ( t * ThresholdCount ) HasCriticalRecovery ( ) bool { if t != nil && t . CriticalRecovery != nil { return true } return false }
3249	func ( c * ChannelSlackRequest ) HasTransferAllUserComments ( ) bool { if c != nil && c . TransferAllUserComments != nil { return true } return false }
867	func osDiskStorageContainerURL ( account * storage . AccountProperties , vmName string ) string { return fmt . Sprintf ( "%s%s/" , to . String ( account . PrimaryEndpoints . Blob ) , osDiskStorageContainerName ( vmName ) ) }
6850	func ( c * cachedLoader ) Initialize ( ) error { pairs , _ , err := c . consulKV . List ( c . namespace , nil ) if err != nil { return fmt . Errorf ( "Could not pull config from consul: %v" , err ) } c . cacheLock . Lock ( ) defer c . cacheLock . Unlock ( ) c . cache = make ( map [ string ] [ ] byte ) for _ , kv := range pairs { c . cache [ kv . Key ] = kv . Value } return nil }
4423	func ( u CIDR ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
1868	func ( m * MockManager ) Clean ( arg0 string ) error { ret := m . ctrl . Call ( m , "Clean" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
5605	func ( o * ListVMParams ) WithTimeout ( timeout time . Duration ) * ListVMParams { o . SetTimeout ( timeout ) return o }
3059	func buildAndSelectGuestIPs ( ctx context . Context , vm * object . VirtualMachine ) ( [ ] string , error ) { logger . Printf ( "[DEBUG] Discovering addresses for virtual machine %q" , vm . Name ( ) ) var addrs [ ] string props , err := virtualMachineProperties ( ctx , vm , [ ] string { "guest.net" } ) if err != nil { return nil , fmt . Errorf ( "cannot fetch properties for VM %q: %s" , vm . Name ( ) , err ) } if props . Guest == nil || props . Guest . Net == nil { logger . Printf ( "[WARN] No networking stack information available for %q or VMware tools not running" , vm . Name ( ) ) return nil , nil } for _ , n := range props . Guest . Net { if n . IpConfig != nil { for _ , addr := range n . IpConfig . IpAddress { if skipIPAddr ( net . ParseIP ( addr . IpAddress ) ) { continue } addrs = append ( addrs , addr . IpAddress ) } } } logger . Printf ( "[INFO] Discovered IP addresses for virtual machine %q: %s" , vm . Name ( ) , strings . Join ( addrs , "," ) ) return addrs , nil }
5219	func ( f * Field ) Row ( rowIDOrKey interface { } ) * PQLRowQuery { rowStr , err := formatIDKeyBool ( rowIDOrKey ) if err != nil { return NewPQLRowQuery ( "" , f . index , err ) } text := fmt . Sprintf ( "Row(%s=%s)" , f . name , rowStr ) q := NewPQLRowQuery ( text , f . index , nil ) return q }
1277	func ( m * MockManager ) SetTaskCredentials ( arg0 * credentials . TaskIAMRoleCredentials ) error { ret := m . ctrl . Call ( m , "SetTaskCredentials" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
3856	func ( c * Cursor ) correctPosition ( ) { if c . Position > len ( c . input ) { c . Position = len ( c . input ) } if c . Position < 0 { c . Position = 0 } }
1272	func ( tp * TransportProtocol ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == "null" { * tp = TransportProtocolTCP seelog . Warn ( "Unmarshalled nil TransportProtocol as TCP" ) return nil } switch string ( b ) { case `"tcp"` : * tp = TransportProtocolTCP case `"udp"` : * tp = TransportProtocolUDP default : * tp = TransportProtocolTCP return errors . New ( "TransportProtocol must be \"tcp\" or \"udp\"; Got " + \" ) } \" }
278	func lexSpace ( l * lexer ) stateFn { for isSpace ( l . peek ( ) ) { l . next ( ) } l . ignore ( ) return lexStatements }
6945	func ( r * Registry ) AddTags ( tags ... string ) { r . mutex . Lock ( ) r . tags = append ( r . tags , tags ... ) r . mutex . Unlock ( ) }
6693	func ( c * Client ) LockServer ( identifier string ) error { return c . LockResource ( Server { Id : identifier } ) }
2168	func ( v * Label ) native ( ) * C . GtkLabel { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLabel ( p ) }
3693	func ( w * Widget ) HasMustShowBreakdown ( ) bool { if w != nil && w . MustShowBreakdown != nil { return true } return false }
1947	func ( m * MockTaskEngineState ) UnmarshalJSON ( arg0 [ ] byte ) error { ret := m . ctrl . Call ( m , "UnmarshalJSON" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
2364	func GetGraphicsResetStatus ( ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetGraphicsResetStatus , 0 , 0 , 0 , 0 ) return ( uint32 ) ( ret ) }
2997	func networkObjectFromHostSystem ( client * govmomi . Client , hs * object . HostSystem , name string ) ( * object . Network , error ) { if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , err } finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) nets , err := finder . NetworkList ( ctx , "*/" + name ) if err != nil { return nil , err } for _ , n := range nets { net , ok := n . ( * object . Network ) if ! ok { continue } props , err := network . Properties ( net ) if err != nil { return nil , err } for _ , hsRef := range props . Host { if hsRef . Value == hs . Reference ( ) . Value { return net , nil } } } return nil , fmt . Errorf ( "could not find a matching %q on host ID %q" , name , hs . Reference ( ) . Value ) }
3599	func ( t * TileDefRequest ) GetTextFilterOk ( ) ( string , bool ) { if t == nil || t . TextFilter == nil { return "" , false } return * t . TextFilter , true }
331	func NewTimestampCollector ( ) * TimestampCollector { return & TimestampCollector { Description : prometheus . NewDesc ( "prometheus_sd_file_mtime_seconds" , "Timestamp (mtime) of files read by FileSD. Timestamp is set at read time." , [ ] string { "filename" } , nil , ) , discoverers : make ( map [ * Discovery ] struct { } ) , } }
1514	func ( c * control ) Exists ( cgroupPath string ) bool { seelog . Debugf ( "Checking existence of cgroup: %s" , cgroupPath ) controller , err := c . Load ( cgroups . V1 , cgroups . StaticPath ( cgroupPath ) ) if err != nil || controller == nil { return false } return true }
1473	func ( c * Container ) SetStartedAt ( startedAt time . Time ) { if startedAt . IsZero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . startedAt = startedAt }
2936	func resourceVSphereDatastoreClusterReadTags ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( "[DEBUG] %s: Reading tags" , resourceVSphereDatastoreClusterIDString ( d ) ) if err := readTagsForResource ( tagsClient , pod , d ) ; err != nil { return err } } else { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping tag read" , resourceVSphereDatastoreClusterIDString ( d ) ) } return nil }
707	func ( p * RcodeZeroProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone := range zones { rrset , err := p . fetchRecords ( zone . Domain ) if err != nil { return nil , err } for _ , r := range rrset { if supportedRecordType ( r . Type ) { if p . TXTEncrypt && ( p . Key != nil ) && strings . EqualFold ( r . Type , "TXT" ) { p . Client . RRSet . DecryptTXT ( p . Key , r ) } if len ( r . Records ) > 1 { for _ , _r := range r . Records { if ! _r . Disabled { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , _r . Content ) ) } } } else { if ! r . Records [ 0 ] . Disabled { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , r . Records [ 0 ] . Content ) ) } } } } } return endpoints , nil }
7150	func ( s * ImageMongoDB ) RunLight ( cfg * RunConfig ) ( * Container , error ) { cfg . AddArgs ( "--smallfiles" , "--nojournal" ) return s . Image . Run ( cfg ) }
6725	func ( c * Client ) DatabaseSnapshots ( ) ( [ ] DatabaseSnapshot , error ) { var database_snapshot [ ] DatabaseSnapshot _ , err := c . MakeApiRequest ( "GET" , "/1.0/database_snapshots" , nil , & database_snapshot ) if err != nil { return nil , err } return database_snapshot , err }
4925	func ( w * Writer ) WriteBool ( v bool ) { if w . err != nil { return } if v { w . wr . WriteByte ( 1 ) } else { w . wr . WriteByte ( 0 ) } }
5968	func ( otp * HOTP ) QR ( label string ) ( [ ] byte , error ) { u := otp . URL ( label ) code , err := qr . Encode ( u , qr . Q ) if err != nil { return nil , err } return code . PNG ( ) , nil }
3394	func ( m * MetricMetadata ) HasStatsdInterval ( ) bool { if m != nil && m . StatsdInterval != nil { return true } return false }
7132	func ( s * HttpHeader ) SetValue ( value string ) * HttpHeader { s . Value = value return s }
2591	func Relocate ( vm * object . VirtualMachine , spec types . VirtualMachineRelocateSpec , timeout int ) error { log . Printf ( "[DEBUG] Beginning migration of virtual machine %q (timeout %d)" , vm . InventoryPath , timeout ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) task , err := vm . Relocate ( ctx , spec , "" ) if err != nil { return err } if err := task . Wait ( ctx ) ; err != nil { if ctx . Err ( ) == context . DeadlineExceeded { return errors . New ( "timeout waiting for migration to complete" ) } } return nil }
4226	func validColor ( c string ) bool { valid := false if validColors [ c ] { valid = true } return valid }
2943	func resourceVSphereDatastoreClusterSaveNameAndPath ( d * schema . ResourceData , pod * object . StoragePod ) error { log . Printf ( "[DEBUG] %s: Saving name and path data for datastore cluster %q" , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) if err := d . Set ( "name" , pod . Name ( ) ) ; err != nil { return fmt . Errorf ( "error saving name: %s" , err ) } f , err := folder . RootPathParticleDatastore . SplitRelativeFolder ( pod . InventoryPath ) if err != nil { return fmt . Errorf ( "error parsing datastore cluster path %q: %s" , pod . InventoryPath , err ) } if err := d . Set ( "folder" , folder . NormalizePath ( f ) ) ; err != nil { return fmt . Errorf ( "error saving folder: %s" , err ) } return nil }
5416	func ( w * World ) Update ( dt float32 ) { for _ , system := range w . Systems ( ) { system . Update ( dt ) } }
4413	func ( e * Email ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { * e = Email ( data ) } }
7246	func ( l * logger ) Infof ( format string , vals ... interface { } ) { l . mut . Lock ( ) defer l . mut . Unlock ( ) s := fmt . Sprintf ( format , vals ... ) l . logger . Output ( 2 , "INFO: " + s ) l . callHandlers ( LevelInfo , s ) }
5019	func ( s * Session ) LiveServers ( ) ( addrs [ ] string ) { s . m . RLock ( ) addrs = s . cluster ( ) . LiveServers ( ) s . m . RUnlock ( ) return addrs }
4174	func ( c * UpdateSpaceUsersCommand ) Execute ( [ ] string ) error { if cfMgmt , err := InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { if err := cfMgmt . UserManager . InitializeLdap ( c . LdapUser , c . LdapPassword , c . LdapServer ) ; err != nil { return err } defer cfMgmt . UserManager . DeinitializeLdap ( ) return cfMgmt . UserManager . UpdateSpaceUsers ( ) } return nil }
802	func ( n * hostOnlyNetwork ) SaveIPv4 ( vbox VBoxManager ) error { if n . IPv4 . IP != nil && n . IPv4 . Mask != nil { if runtime . GOOS == "windows" { log . Warn ( "Windows might ask for the permission to configure a network adapter. Sometimes, such confirmation window is minimized in the taskbar." ) } if err := vbox . vbm ( "hostonlyif" , "ipconfig" , n . Name , "--ip" , n . IPv4 . IP . String ( ) , "--netmask" , net . IP ( n . IPv4 . Mask ) . String ( ) ) ; err != nil { return err } } return nil }
5511	func ( f * FileLogger ) Println ( v ... interface { } ) { _ , file , line , _ := runtime . Caller ( 1 ) f . logChan <- fmt . Sprintf ( "[%v:%v]" , shortFileName ( file ) , line ) + fmt . Sprintln ( v ... ) }
6665	func NewClient ( opts * ClientOptions ) * Client { cli := opts . Client if cli == nil { cli = http . DefaultClient } client := & Client { caller : & defaultCaller { client : cli , headers : map [ string ] string { "GDPR-Version" : ApiVersion , "Content-Type" : "Application/JSON" , } , } , endpoint : opts . Endpoint , verifier : opts . Verifier , } return client }
7096	func ( m * FixedLengthMatcher ) Match ( s string ) ( offset int , matchStr string ) { if len ( s ) < m . length || ! m . match ( s ) { offset = - 1 return } return m . length , s [ : m . length ] }
3302	func ( e * Event ) GetEventTypeOk ( ) ( string , bool ) { if e == nil || e . EventType == nil { return "" , false } return * e . EventType , true }
3400	func ( m * Monitor ) HasOverallStateModified ( ) bool { if m != nil && m . OverallStateModified != nil { return true } return false }
5080	func ( socket * mongoSocket ) Server ( ) * mongoServer { socket . Lock ( ) server := socket . server socket . Unlock ( ) return server }
2374	func DecodeConfig ( r io . Reader ) ( image . Config , error ) { d := & decoder { r : r , crc : crc32 . NewIEEE ( ) , } if err := d . checkHeader ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return image . Config { } , err } for { if err := d . parseChunk ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return image . Config { } , err } paletted := cbPaletted ( d . cb ) if d . stage == dsSeenIHDR && ! paletted { break } if d . stage == dsSeenPLTE && paletted { break } } var cm color . Model switch d . cb { case cbG1 , cbG2 , cbG4 , cbG8 : cm = color . GrayModel case cbGA8 : cm = color . NRGBAModel case cbTC8 : cm = color . RGBAModel case cbP1 , cbP2 , cbP4 , cbP8 : cm = d . palette case cbTCA8 : cm = color . NRGBAModel case cbG16 : cm = color . Gray16Model case cbGA16 : cm = color . NRGBA64Model case cbTC16 : cm = color . RGBA64Model case cbTCA16 : cm = color . NRGBA64Model } return image . Config { ColorModel : cm , Width : d . width , Height : d . height , } , nil }
646	func BuildWithConfig ( source string , p ClientGenerator , cfg * Config ) ( Source , error ) { switch source { case "service" : client , err := p . KubeClient ( ) if err != nil { return nil , err } return NewServiceSource ( client , cfg . Namespace , cfg . AnnotationFilter , cfg . FQDNTemplate , cfg . CombineFQDNAndAnnotation , cfg . Compatibility , cfg . PublishInternal , cfg . PublishHostIP , cfg . ServiceTypeFilter , cfg . IgnoreHostnameAnnotation ) case "ingress" : client , err := p . KubeClient ( ) if err != nil { return nil , err } return NewIngressSource ( client , cfg . Namespace , cfg . AnnotationFilter , cfg . FQDNTemplate , cfg . CombineFQDNAndAnnotation , cfg . IgnoreHostnameAnnotation ) case "istio-gateway" : kubernetesClient , err := p . KubeClient ( ) if err != nil { return nil , err } istioClient , err := p . IstioClient ( ) if err != nil { return nil , err } return NewIstioGatewaySource ( kubernetesClient , istioClient , cfg . IstioIngressGatewayServices , cfg . Namespace , cfg . AnnotationFilter , cfg . FQDNTemplate , cfg . CombineFQDNAndAnnotation , cfg . IgnoreHostnameAnnotation ) case "fake" : return NewFakeSource ( cfg . FQDNTemplate ) case "connector" : return NewConnectorSource ( cfg . ConnectorServer ) case "crd" : client , err := p . KubeClient ( ) if err != nil { return nil , err } crdClient , scheme , err := NewCRDClientForAPIVersionKind ( client , cfg . KubeConfig , cfg . KubeMaster , cfg . CRDSourceAPIVersion , cfg . CRDSourceKind ) if err != nil { return nil , err } return NewCRDSource ( crdClient , cfg . Namespace , cfg . CRDSourceKind , scheme ) } return nil , ErrSourceNotFound }
1638	func ( m * MockLicenseProvider ) GetText ( ) ( string , error ) { ret := m . ctrl . Call ( m , "GetText" ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6989	func ( ctx * ReqCtx ) Params ( v interface { } ) error { if ctx . params == nil { return errors . New ( "ctx: request did not have any request parameters" ) } if err := json . Unmarshal ( ctx . params , v ) ; err != nil { return fmt . Errorf ( "ctx: cannot deserialize request params: %v" , err ) } return nil }
6752	func hash24 ( input [ ] byte ) ( res * [ 24 ] byte ) { hasher := ripemd160 . New ( ) hasher . Write ( input ) resSlice := hasher . Sum ( nil ) res = new ( [ 24 ] byte ) copy ( res [ : ] , resSlice ) return }
3306	func ( e * Event ) HasPriority ( ) bool { if e != nil && e . Priority != nil { return true } return false }
4244	func BoundingBoxIntWithPrecision ( hash uint64 , bits uint ) Box { fullHash := hash << ( 64 - bits ) latInt , lngInt := deinterleave ( fullHash ) lat := decodeRange ( latInt , 90 ) lng := decodeRange ( lngInt , 180 ) latErr , lngErr := errorWithPrecision ( bits ) return Box { MinLat : lat , MaxLat : lat + latErr , MinLng : lng , MaxLng : lng + lngErr , } }
6647	func ApproxEpsilon ( x , y float64 , eps float64 ) bool { return math . Abs ( x - y ) < eps * ( 1.0 + math . Max ( math . Abs ( x ) , math . Abs ( y ) ) ) }
4216	func ( j * JWKClient ) GetSecret ( r * http . Request ) ( interface { } , error ) { token , err := j . extractor . Extract ( r ) if err != nil { return nil , err } if len ( token . Headers ) < 1 { return nil , ErrNoJWTHeaders } header := token . Headers [ 0 ] return j . GetKey ( header . KeyID ) }
5542	func ( c * Client ) Join ( roomId , resource string ) { c . connection . MUCPresence ( roomId + "/" + resource , c . Id ) }
5584	func ( o * UpdateVMParams ) WithBody ( body * models . VM ) * UpdateVMParams { o . SetBody ( body ) return o }
3255	func ( c * Check ) HasTimestamp ( ) bool { if c != nil && c . Timestamp != nil { return true } return false }
2675	func expandClusterDpmConfigInfo ( d * schema . ResourceData ) * types . ClusterDpmConfigInfo { obj := & types . ClusterDpmConfigInfo { DefaultDpmBehavior : types . DpmBehavior ( d . Get ( "dpm_automation_level" ) . ( string ) ) , Enabled : structure . GetBool ( d , "dpm_enabled" ) , HostPowerActionRate : int32 ( d . Get ( "dpm_threshold" ) . ( int ) ) , } return obj }
1318	func NewMockOS ( ctrl * gomock . Controller ) * MockOS { mock := & MockOS { ctrl : ctrl } mock . recorder = & MockOSMockRecorder { mock } return mock }
3373	func ( i * IntegrationGCPCreateRequest ) GetPrivateKeyID ( ) string { if i == nil || i . PrivateKeyID == nil { return "" } return * i . PrivateKeyID }
3413	func ( o * Options ) GetEscalationMessage ( ) string { if o == nil || o . EscalationMessage == nil { return "" } return * o . EscalationMessage }
4750	func AsErrorList ( err error ) ErrorList { if list , ok := err . ( ErrorList ) ; ok { return list } return ErrorList { err } }
5313	func ContainString ( filename , s string ) ( bool , error ) { f , err := os . Open ( filename ) if err != nil { return false , fmt . Errorf ( "ContainString: %s" , err ) } defer f . Close ( ) buf := bufio . NewReader ( f ) for { line , err := buf . ReadString ( '\n' ) if err == io . EOF { break } if strings . Contains ( line , s ) { return true , nil } } return false , nil }
1741	func ( task * Task ) SetDesiredStatus ( status apitaskstatus . TaskStatus ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . DesiredStatusUnsafe = status }
6848	func NewCachedLoader ( namespace string , consulAddr string ) ( config . Loader , error ) { config := api . DefaultConfig ( ) config . Address = consulAddr consul , err := api . NewClient ( config ) if err != nil { return nil , fmt . Errorf ( "Could not connect to consul: %v" , err ) } return & cachedLoader { namespace : namespace , consulKV : consul . KV ( ) } , nil }
2610	func FileExists ( ds * object . Datastore , name string ) ( bool , error ) { files , err := SearchDatastore ( ds , name ) if err != nil { return false , err } if len ( files ) > 1 { return false , fmt . Errorf ( "multiple results returned for %q in datastore %q, use a more specific search" , name , ds ) } if len ( files ) < 1 { return false , nil } return path . Base ( name ) == files [ 0 ] . Path , nil }
628	func ( df DomainFilter ) IsConfigured ( ) bool { if len ( df . filters ) == 1 { return df . filters [ 0 ] != "" } return len ( df . filters ) > 0 }
63	func ( ls Labels ) Hash ( ) uint64 { b := make ( [ ] byte , 0 , 1024 ) for _ , v := range ls { b = append ( b , v . Name ... ) b = append ( b , sep ) b = append ( b , v . Value ... ) b = append ( b , sep ) } return xxhash . Sum64 ( b ) }
7223	func ( logger * Logger ) Emergencyf ( format string , a ... interface { } ) { logger . log ( EMERGENCY , format , a ... ) }
2512	func schemaHostNetworkPolicy ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { "check_beacon" : { Type : schema . TypeBool , Optional : true , Description : "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used only." , } , "active_nics" : { Type : schema . TypeList , Description : "List of active network adapters used for load balancing." , Elem : & schema . Schema { Type : schema . TypeString } , } , "standby_nics" : { Type : schema . TypeList , Description : "List of standby network adapters used for failover." , Elem : & schema . Schema { Type : schema . TypeString } , } , "teaming_policy" : { Type : schema . TypeString , Optional : true , Description : "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or failover_explicit." , ValidateFunc : validation . StringInSlice ( hostNetworkPolicyNicTeamingPolicyAllowedValues , false ) , } , "notify_switches" : { Type : schema . TypeBool , Optional : true , Description : "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates." , } , "failback" : { Type : schema . TypeBool , Optional : true , Description : "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up." , } , "allow_promiscuous" : { Type : schema . TypeBool , Optional : true , Description : "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port." , } , "allow_forged_transmits" : { Type : schema . TypeBool , Optional : true , Description : "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own." , } , "allow_mac_changes" : { Type : schema . TypeBool , Optional : true , Description : "Controls whether or not the Media Access Control (MAC) address can be changed." , } , "shaping_average_bandwidth" : { Type : schema . TypeInt , Optional : true , Description : "The average bandwidth in bits per second if traffic shaping is enabled." , } , "shaping_burst_size" : { Type : schema . TypeInt , Optional : true , Description : "The maximum burst size allowed in bytes if traffic shaping is enabled." , } , "shaping_enabled" : { Type : schema . TypeBool , Optional : true , Description : "Enable traffic shaping on this virtual switch or port group." , } , "shaping_peak_bandwidth" : { Type : schema . TypeInt , Optional : true , Description : "The peak bandwidth during bursts in bits per second if traffic shaping is enabled." , } , } }
6523	func ( c Client ) GetTransfers ( page int ) ( * transfers , error ) { params := map [ string ] int { "page" : page , } holder := transfersHolder { } if err := c . Get ( "transfers" , params , & holder ) ; err != nil { return nil , err } transfers := transfers { paginationStats : holder . paginationStats , } for _ , t := range holder . Transfers { transfers . Transfers = append ( transfers . Transfers , t . Transfer ) } return & transfers , nil }
7024	func URLPart ( ctx context . Context , r * http . Request , i int ) ( context . Context , string , bool ) { ctx , parts := URLParts ( ctx , r ) if len ( parts ) > i && i >= 0 { return ctx , parts [ i ] , true } return ctx , "" , false }
6908	func ( s * Session ) makeAuthorizationHeaders ( ) ( string , * Error ) { if s . Username == "" { return "" , NewBambouError ( "Invalid Credentials" , "No username given" ) } if s . root == nil { return "" , NewBambouError ( "Invalid Credentials" , "No root user set" ) } key := s . root . APIKey ( ) if s . Password == "" && key == "" { return "" , NewBambouError ( "Invalid Credentials" , "No password or authentication token given" ) } if key == "" { key = s . Password } return "XREST " + base64 . StdEncoding . EncodeToString ( [ ] byte ( s . Username + ":" + key ) ) , nil }
937	func NewDriver ( machineName , storePath string ) drivers . Driver { log . Debug ( "Instantiating Rackspace driver." , map [ string ] string { "machineName" : machineName } ) inner := openstack . NewDerivedDriver ( machineName , storePath ) driver := & Driver { Driver : inner , } inner . SetClient ( & Client { driver : driver , } ) return driver }
2679	func expandResourceVSphereComputeClusterDrsAdvancedOptions ( d * schema . ResourceData ) [ ] types . BaseOptionValue { var opts [ ] types . BaseOptionValue m := d . Get ( "drs_advanced_options" ) . ( map [ string ] interface { } ) for k , v := range m { opts = append ( opts , & types . OptionValue { Key : k , Value : types . AnyType ( v ) , } ) } return opts }
6526	func ( c Client ) GetTransaction ( id string ) ( * transaction , error ) { holder := transactionHolder { } if err := c . Get ( "transactions/" + id , nil , & holder ) ; err != nil { return nil , err } if err := checkApiErrors ( holder . response , "GetTransaction" ) ; err != nil { return nil , err } return & holder . Transaction , nil }
6871	func ( e * execStreamerBuilder ) Args ( args ... string ) ExecStreamerBuilder { e . d . Args = args return e }
6035	func ( n Base64BigInt ) MarshalJSON ( ) ( [ ] byte , error ) { buf , err := ToBytes ( Base64String ( n ) ) if err != nil { return nil , fmt . Errorf ( "could not decode base64: %v" , err ) } v := big . NewInt ( 0 ) v . SetBytes ( buf ) return [ ] byte ( v . String ( ) ) , nil }
3332	func ( g * GroupData ) GetLastNotifiedTsOk ( ) ( int , bool ) { if g == nil || g . LastNotifiedTs == nil { return 0 , false } return * g . LastNotifiedTs , true }
4230	func ( s * Spinner ) Reverse ( ) { s . lock . Lock ( ) defer s . lock . Unlock ( ) for i , j := 0 , len ( s . chars ) - 1 ; i < j ; i , j = i + 1 , j - 1 { s . chars [ i ] , s . chars [ j ] = s . chars [ j ] , s . chars [ i ] } }
1782	func ( mr * MockClientServerMockRecorder ) Connect ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Connect" , reflect . TypeOf ( ( * MockClientServer ) ( nil ) . Connect ) ) }
1886	func timeoutAndMoveOn ( fp loiterFunc , timeout time . Duration ) { ch := time . After ( timeout ) for { select { case <- ch : return default : fp ( ) } } }
2276	func ( v * ScrolledWindow ) native ( ) * C . GtkScrolledWindow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScrolledWindow ( p ) }
1143	func ( m * MockTaskEngine ) MarshalJSON ( ) ( [ ] byte , error ) { ret := m . ctrl . Call ( m , "MarshalJSON" ) ret0 , _ := ret [ 0 ] . ( [ ] byte ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2403	func KeyPressDuration ( key ebiten . Key ) int { theInputState . m . RLock ( ) s := theInputState . keyDurations [ key ] theInputState . m . RUnlock ( ) return s }
5440	func ( bot * Bot ) Close ( ) error { if bot . unixlist != nil { return bot . unixlist . Close ( ) } return nil }
1921	func ( m * MockFileSystem ) Open ( arg0 string ) ( io . ReadWriteCloser , error ) { ret := m . ctrl . Call ( m , "Open" , arg0 ) ret0 , _ := ret [ 0 ] . ( io . ReadWriteCloser ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6955	func ( s * Set ) AddAll ( values ... interface { } ) { s . Lock ( ) defer s . Unlock ( ) for _ , value := range values { s . m [ value ] = struct { } { } } }
5155	func ( s * SegmentStack ) Push ( id int64 ) { s . Lock ( ) defer s . Unlock ( ) s . s = append ( s . s , id ) }
1718	func ( task * Task ) getAllASMSecretRequirements ( ) map [ string ] apicontainer . Secret { reqs := make ( map [ string ] apicontainer . Secret ) for _ , container := range task . Containers { for _ , secret := range container . Secrets { if secret . Provider == apicontainer . SecretProviderASM { secretKey := secret . GetSecretResourceCacheKey ( ) if _ , ok := reqs [ secretKey ] ; ! ok { reqs [ secretKey ] = secret } } } } return reqs }
6231	func ( h * Handler ) SetGUISettings ( tkn string , v map [ string ] interface { } ) error { logger := h . logger . Add ( "method" , "SetGUISettings" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } d , err := json . Marshal ( & v ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } _ , err = h . db . Exec ( ` UPDATE settings SET value = $1 WHERE key=$2` , string ( d ) , data . SettingGUI ) if err != nil { logger . Error ( fmt . Sprintf ( "failed to set gui settings: %v" , err ) ) return ErrInternal } return nil }
4708	func ( l * line ) isComment ( ) bool { return len ( l . tokens ) > 0 && l . tokens [ 0 ] == slash }
4815	func ( r * Repo ) Prepare ( ) error { fs , err := gos . ReadDir ( r . Path ) if err != nil || len ( fs ) == 0 { return gos . MkdirAll ( r . Path , os . FileMode ( 0755 ) ) } isGit := false for _ , f := range fs { if f . IsDir ( ) && f . Name ( ) == ".git" { isGit = true break } } if isGit { var repoURL string if repoURL , err = r . originURL ( ) ; err == nil { if strings . TrimSuffix ( repoURL , ".git" ) == strings . TrimSuffix ( r . URL . Val ( ) , ".git" ) { r . pulled = true return nil } } if err != nil { return fmt . Errorf ( "cannot retrieve repo url for %v Error: %v" , r . Path , err ) } return fmt . Errorf ( "another git repo '%v' exists at %v" , repoURL , r . Path ) } return fmt . Errorf ( "cannot git clone into %v, directory not empty" , r . Path ) }
4984	func ( c * Consumer ) FilteredFirehose ( subscriptionId string , authToken string , filter EnvelopeFilter , ) ( <- chan * events . Envelope , <- chan error ) { return c . firehose ( newFirehose ( subscriptionId , authToken , WithEnvelopeFilter ( filter ) , ) ) }
2362	func DebugMessageCallback ( callback unsafe . Pointer , userParam unsafe . Pointer ) { syscall . Syscall ( gpDebugMessageCallback , 2 , syscall . NewCallback ( callback ) , uintptr ( userParam ) , 0 ) }
2228	func ( v * Clipboard ) WaitIsTextAvailable ( ) bool { c := C . gtk_clipboard_wait_is_text_available ( v . native ( ) ) return gobool ( c ) }
739	func ( p * AWSSDProvider ) isAWSLoadBalancer ( hostname string ) bool { return strings . HasSuffix ( hostname , sdElbHostnameSuffix ) }
3083	func ( ctx * Context ) GetFile ( name string ) ( multipart . File , * multipart . FileHeader , error ) { return ctx . Req . FormFile ( name ) }
6415	func ( list * LinkedList ) Sort ( comparator Comparator ) error { list . key . Lock ( ) defer list . key . Unlock ( ) var err error list . first , err = mergeSort ( list . first , comparator ) if err != nil { return err } list . last = findLast ( list . first ) return err }
2596	func UUIDsForManagedObjectReferences ( client * govmomi . Client , refs [ ] types . ManagedObjectReference ) ( MOIDForUUIDResults , error ) { var moids [ ] string for _ , ref := range refs { moids = append ( moids , ref . Value ) } return UUIDsForMOIDs ( client , moids ) }
1078	func findCommand ( c * config . TemplateConfig , templates [ ] * config . TemplateConfig ) * config . TemplateConfig { needle := config . StringVal ( c . Exec . Command ) for _ , t := range templates { if needle == config . StringVal ( t . Exec . Command ) { return t } } return nil }
1178	func ( m * MockProvider ) Retrieve ( ) ( credentials . Value , error ) { ret := m . ctrl . Call ( m , "Retrieve" ) ret0 , _ := ret [ 0 ] . ( credentials . Value ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6401	func ( stack * Stack ) Push ( entry interface { } ) { stack . key . Lock ( ) defer stack . key . Unlock ( ) if nil == stack . underlyer { stack . underlyer = NewLinkedList ( ) } stack . underlyer . AddFront ( entry ) }
2103	func ( eni * ENIAttachment ) StopAckTimer ( ) { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) eni . ackTimer . Stop ( ) }
4809	func ( r RepoURL ) String ( ) string { u , err := url . Parse ( string ( r ) ) if err != nil { return string ( r ) } if u . User != nil { u . User = url . User ( u . User . Username ( ) ) } return u . String ( ) }
3613	func ( t * TimeseriesRequestStyle ) GetLineType ( ) string { if t == nil || t . LineType == nil { return "" } return * t . LineType }
6367	func ( w * Writer ) IsSuppressed ( level string ) bool { _ , ok := w . suppressMap [ level ] return ok }
4386	func ISBN13Value ( v * strfmt . ISBN13 ) strfmt . ISBN13 { if v == nil { return strfmt . ISBN13 ( "" ) } return * v }
1010	func ( w * Watcher ) Stop ( ) { w . Lock ( ) defer w . Unlock ( ) log . Printf ( "[DEBUG] (watcher) stopping all views" ) for _ , view := range w . depViewMap { if view == nil { continue } log . Printf ( "[TRACE] (watcher) stopping %s" , view . Dependency ( ) ) view . stop ( ) } w . depViewMap = make ( map [ string ] * View ) w . clients . Stop ( ) }
2055	func WriteTaskStatsResponse ( w http . ResponseWriter , taskARN string , state dockerstate . TaskEngineState , statsEngine stats . Engine ) { taskStatsResponse , err := NewTaskStatsResponse ( taskARN , state , statsEngine ) if err != nil { seelog . Warnf ( "Unable to get task stats for task '%s': %v" , taskARN , err ) errResponseJSON , _ := json . Marshal ( "Unable to get task stats for: " + taskARN ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskStats ) return } responseJSON , _ := json . Marshal ( taskStatsResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeTaskStats ) }
1841	func NewFactory ( ctx context . Context , endpoint string ) Factory { return & factory { endpoint : endpoint , clients : findDockerVersions ( ctx , endpoint ) , } }
844	func ( c * ComputeUtil ) instance ( ) ( * raw . Instance , error ) { return c . service . Instances . Get ( c . project , c . zone , c . instanceName ) . Do ( ) }
904	func ( d * Driver ) GetURL ( ) ( string , error ) { if err := drivers . MustBeRunning ( d ) ; err != nil { return "" , err } ip , err := d . GetIP ( ) if err != nil { return "" , err } u := ( & url . URL { Scheme : "tcp" , Host : net . JoinHostPort ( ip , fmt . Sprintf ( "%d" , d . DockerPort ) ) , } ) . String ( ) log . Debugf ( "Machine URL is resolved to: %s" , u ) return u , nil }
2191	func IdleAdd ( f interface { } , args ... interface { } ) ( SourceHandle , error ) { rf := reflect . ValueOf ( f ) if rf . Type ( ) . Kind ( ) != reflect . Func { return 0 , errors . New ( "f is not a function" ) } idleSrc := C . g_idle_source_new ( ) if idleSrc == nil { return 0 , errNilPtr } return sourceAttach ( idleSrc , rf , args ... ) }
1628	func ( manager * metadataManager ) parseMetadataAtContainerCreate ( task * apitask . Task , containerName string ) Metadata { return Metadata { cluster : manager . cluster , taskMetadata : TaskMetadata { containerName : containerName , taskARN : task . Arn , taskDefinitionFamily : task . Family , taskDefinitionRevision : task . Version , } , containerInstanceARN : manager . containerInstanceARN , metadataStatus : MetadataInitial , availabilityZone : manager . availabilityZone , hostPublicIPv4Address : manager . hostPublicIPv4Address , } }
6148	func ( w * Worker ) AgentAfterChannelCreate ( job * data . Job ) error { if w . isJobInvalid ( job , data . JobAgentAfterChannelCreate , data . JobChannel ) { return ErrInvalidJob } logger := w . logger . Add ( "method" , "AgentAfterChannelCreate" , "job" , job ) ethLog , err := w . ethLog ( logger , job ) if err != nil { return err } ethLogTx , err := w . ethLogTx ( logger , ethLog ) if err != nil { return err } client , newUser , err := w . newUser ( logger , ethLogTx ) if err != nil { return err } logger = logger . Add ( "client" , client ) tx , err := w . db . Begin ( ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } defer tx . Rollback ( ) if newUser { if err := tx . Insert ( client ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } } logChannelCreated , err := extractLogChannelCreated ( logger , ethLog ) if err != nil { return err } offering , err := w . offeringByHash ( logger , logChannelCreated . offeringHash ) if err != nil { return err } offering . CurrentSupply -- if err := tx . Update ( offering ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } channel := & data . Channel { ID : job . RelatedID , Client : data . HexFromBytes ( logChannelCreated . clientAddr . Bytes ( ) ) , Agent : data . HexFromBytes ( logChannelCreated . agentAddr . Bytes ( ) ) , TotalDeposit : logChannelCreated . deposit . Uint64 ( ) , ChannelStatus : data . ChannelActive , ServiceStatus : data . ServicePending , Offering : offering . ID , Block : uint32 ( ethLog . Block ) , } if err := tx . Insert ( channel ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } if err := w . addJob ( logger , tx , data . JobAgentPreEndpointMsgCreate , data . JobChannel , channel . ID ) ; err != nil { return err } if err := tx . Commit ( ) ; err != nil { logger . Error ( "unable to commit changes: " + err . Error ( ) ) return ErrInternal } return nil }
2056	func WriteContainerStatsResponse ( w http . ResponseWriter , taskARN string , containerID string , statsEngine stats . Engine ) { dockerStats , err := statsEngine . ContainerDockerStats ( taskARN , containerID ) if err != nil { errResponseJSON , _ := json . Marshal ( "Unable to get container stats for: " + containerID ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerStats ) return } responseJSON , _ := json . Marshal ( dockerStats ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeContainerStats ) }
3521	func ( s * SyntheticsDevice ) GetUserAgentOk ( ) ( string , bool ) { if s == nil || s . UserAgent == nil { return "" , false } return * s . UserAgent , true }
1669	func ( f * factory ) GetClient ( version dockerclient . DockerVersion ) ( sdkclient . Client , error ) { for _ , v := range getWindowsReplaceableVersions ( ) { if v == version { version = minDockerAPIVersion break } } return f . getClient ( version ) }
4274	func remountReadonly ( path string ) error { for i := 0 ; i < 5 ; i ++ { if err := syscall . Mount ( "" , path , "" , syscall . MS_REMOUNT | syscall . MS_RDONLY , "" ) ; err != nil && ! os . IsNotExist ( err ) { switch err { case syscall . EINVAL : if err := syscall . Mount ( path , path , "" , syscall . MS_BIND , "" ) ; err != nil { return err } return syscall . Mount ( path , path , "" , syscall . MS_BIND | syscall . MS_REMOUNT | syscall . MS_RDONLY | syscall . MS_REC | defaultMountFlags , "" ) case syscall . EBUSY : time . Sleep ( 100 * time . Millisecond ) continue default : return err } } return nil } return fmt . Errorf ( "unable to mount %s as readonly max retries reached" , path ) }
5908	func ( gsa * GServiceAccount ) Signer ( ) ( jwt . Signer , error ) { gsa . mu . Lock ( ) defer gsa . mu . Unlock ( ) if gsa . signer == nil { keyset , err := pemutil . DecodeBytes ( [ ] byte ( gsa . PrivateKey ) ) if err != nil { return nil , fmt . Errorf ( "jwt/gserviceaccount: could not decode private key: %v" , err ) } keyset . AddPublicKeys ( ) s , err := DefaultAlgorithm . New ( keyset ) if err != nil { return nil , err } gsa . signer = s } return gsa . signer , nil }
6356	func ( dict Dictionary ) Enumerate ( cancel <- chan struct { } ) Enumerator { if dict . root == nil { return Empty . Enumerate ( cancel ) } return dict . root . Enumerate ( cancel ) }
6041	func ( w * Worker ) PreAccountAddBalance ( job * data . Job ) error { logger := w . logger . Add ( "method" , "PreAccountAddBalance" , "job" , job ) acc , err := w . relatedAccount ( logger , job , data . JobPreAccountAddBalance ) if err != nil { return err } jobData , err := w . approvedBalanceData ( logger , job ) if err != nil { return err } key , err := w . key ( logger , acc . PrivateKey ) if err != nil { return err } auth := bind . NewKeyedTransactor ( key ) auth . GasLimit = w . gasConf . PSC . AddBalanceERC20 auth . GasPrice = new ( big . Int ) . SetUint64 ( jobData . GasPrice ) tx , err := w . ethBack . PSCAddBalanceERC20 ( auth , uint64 ( jobData . Amount ) ) if err != nil { logger . Error ( err . Error ( ) ) return ErrPSCAddBalance } return w . saveEthTX ( logger , job , tx , "PSCAddBalanceERC20" , job . RelatedType , job . RelatedID , acc . EthAddr , data . HexFromBytes ( w . pscAddr . Bytes ( ) ) ) }
5247	func ( c * Client ) EnsureField ( field * Field ) error { err := c . CreateField ( field ) if err == ErrFieldExists { return nil } return err }
5814	func ( m * CirconusMetrics ) RemoveHistogram ( metric string ) { m . hm . Lock ( ) delete ( m . histograms , metric ) m . hm . Unlock ( ) }
1185	func New ( arguments [ ] string ) ( * Args , error ) { flagset := flag . NewFlagSet ( "Amazon ECS Agent" , flag . ContinueOnError ) args := & Args { Version : flagset . Bool ( versionFlagName , false , versionUsage ) , LogLevel : flagset . String ( logLevelFlagName , "" , logLevelUsage ) , AcceptInsecureCert : flagset . Bool ( acceptInsecureCertFlagName , false , acceptInsecureCertUsage ) , License : flagset . Bool ( licenseFlagName , false , licenseUsage ) , BlackholeEC2Metadata : flagset . Bool ( blackholeEC2MetadataFlagName , false , blacholeEC2MetadataUsage ) , ECSAttributes : flagset . Bool ( ecsAttributesFlagName , false , ecsAttributesUsage ) , WindowsService : flagset . Bool ( windowsServiceFlagName , false , windowsServiceUsage ) , } err := flagset . Parse ( arguments ) if err != nil { return nil , err } return args , nil }
3223	func ( a * Alert ) HasState ( ) bool { if a != nil && a . State != nil { return true } return false }
683	func ( c * Controller ) Run ( stopChan <- chan struct { } ) { ticker := time . NewTicker ( c . Interval ) defer ticker . Stop ( ) for { err := c . RunOnce ( ) if err != nil { log . Error ( err ) } select { case <- ticker . C : case <- stopChan : log . Info ( "Terminating main controller loop" ) return } } }
6820	func ( t * trace ) SetTraceInfo ( traceID uint64 , spanID uint64 ) { t . trace . SetTraceInfo ( traceID , spanID ) }
7159	func ( h * Handler ) Handle ( record * logging . Record ) error { switch record . Level { case logging . EMERGENCY : h . Counter . emergencyCounter . Inc ( ) case logging . ALERT : h . Counter . alertCounter . Inc ( ) case logging . CRITICAL : h . Counter . criticalCounter . Inc ( ) case logging . ERROR : h . Counter . errorCounter . Inc ( ) case logging . WARNING : h . Counter . warningCounter . Inc ( ) case logging . NOTICE : h . Counter . noticeCounter . Inc ( ) case logging . INFO : h . Counter . infoCounter . Inc ( ) case logging . DEBUG : h . Counter . debugCounter . Inc ( ) } return nil }
2859	func IsResourceInUseError ( err error ) bool { if f , ok := vimSoapFault ( err ) ; ok { if _ , ok := f . ( types . ResourceInUse ) ; ok { return true } } return false }
5017	func DialWithTimeout ( url string , timeout time . Duration ) ( * Session , error ) { info , err := ParseURL ( url ) if err != nil { return nil , err } info . Timeout = timeout return DialWithInfo ( info ) }
2176	func BindProperty ( source * Object , sourceProperty string , target * Object , targetProperty string , flags BindingFlags ) * Binding { srcStr := ( * C . gchar ) ( C . CString ( sourceProperty ) ) defer C . free ( unsafe . Pointer ( srcStr ) ) tgtStr := ( * C . gchar ) ( C . CString ( targetProperty ) ) defer C . free ( unsafe . Pointer ( tgtStr ) ) obj := C . g_object_bind_property ( C . gpointer ( source . GObject ) , srcStr , C . gpointer ( target . GObject ) , tgtStr , C . GBindingFlags ( flags ) , ) if obj == nil { return nil } return & Binding { wrapObject ( unsafe . Pointer ( obj ) ) } }
5292	func braceIndices ( s string ) ( [ ] int , error ) { var level , idx int idxs := make ( [ ] int , 0 ) for i := 0 ; i < len ( s ) ; i ++ { switch s [ i ] { case '{' : if level ++ ; level == 1 { idx = i } case '}' : if level -- ; level == 0 { idxs = append ( idxs , idx , i + 1 ) } else if level < 0 { return nil , fmt . Errorf ( "mux: unbalanced braces in %q" , s ) } } } if level != 0 { return nil , fmt . Errorf ( "mux: unbalanced braces in %q" , s ) } return idxs , nil }
1063	func ( c * RetryConfig ) RetryFunc ( ) RetryFunc { return func ( retry int ) ( bool , time . Duration ) { if ! BoolVal ( c . Enabled ) { return false , 0 } if IntVal ( c . Attempts ) > 0 && retry > IntVal ( c . Attempts ) - 1 { return false , 0 } baseSleep := TimeDurationVal ( c . Backoff ) maxSleep := TimeDurationVal ( c . MaxBackoff ) if maxSleep > 0 { attemptsTillMaxBackoff := int ( math . Log2 ( maxSleep . Seconds ( ) / baseSleep . Seconds ( ) ) ) if retry > attemptsTillMaxBackoff { return true , maxSleep } } base := math . Pow ( 2 , float64 ( retry ) ) sleep := time . Duration ( base ) * baseSleep return true , sleep } }
2742	func flattenDVSContactInfo ( d * schema . ResourceData , obj types . DVSContactInfo ) error { d . Set ( "contact_name" , obj . Name ) d . Set ( "conatct_detail" , obj . Contact ) return nil }
1765	func ( task * Task ) PopulateSecrets ( hostConfig * dockercontainer . HostConfig , container * apicontainer . Container ) * apierrors . DockerClientConfigError { var ssmRes * ssmsecret . SSMSecretResource var asmRes * asmsecret . ASMSecretResource if container . ShouldCreateWithSSMSecret ( ) { resource , ok := task . getSSMSecretsResource ( ) if ! ok { return & apierrors . DockerClientConfigError { Msg : "task secret data: unable to fetch SSM Secrets resource" } } ssmRes = resource [ 0 ] . ( * ssmsecret . SSMSecretResource ) } if container . ShouldCreateWithASMSecret ( ) { resource , ok := task . getASMSecretsResource ( ) if ! ok { return & apierrors . DockerClientConfigError { Msg : "task secret data: unable to fetch ASM Secrets resource" } } asmRes = resource [ 0 ] . ( * asmsecret . ASMSecretResource ) } envVars := make ( map [ string ] string ) logDriverTokenName := "" logDriverTokenSecretValue := "" for _ , secret := range container . Secrets { secretVal := "" if secret . Provider == apicontainer . SecretProviderSSM { k := secret . GetSecretResourceCacheKey ( ) if secretValue , ok := ssmRes . GetCachedSecretValue ( k ) ; ok { secretVal = secretValue } } if secret . Provider == apicontainer . SecretProviderASM { k := secret . GetSecretResourceCacheKey ( ) if secretValue , ok := asmRes . GetCachedSecretValue ( k ) ; ok { secretVal = secretValue } } if secret . Type == apicontainer . SecretTypeEnv { envVars [ secret . Name ] = secretVal continue } if secret . Target == apicontainer . SecretTargetLogDriver { logDriverTokenName = secret . Name logDriverTokenSecretValue = secretVal if hostConfig . LogConfig . Type != "" && logDriverTokenName != "" && logDriverTokenSecretValue != "" { hostConfig . LogConfig . Config [ logDriverTokenName ] = logDriverTokenSecretValue } } } container . MergeEnvironmentVariables ( envVars ) return nil }
1588	func ( m * MockSecretsManagerAPI ) GetRandomPasswordWithContext ( arg0 aws . Context , arg1 * secretsmanager . GetRandomPasswordInput , arg2 ... request . Option ) ( * secretsmanager . GetRandomPasswordOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "GetRandomPasswordWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetRandomPasswordOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5424	func ( g * Group ) Leave ( leaving * Member ) error { g . memberLock . Lock ( ) memberIndex := - 1 for index , member := range g . members { if member == leaving { memberIndex = index break } } if memberIndex == - 1 { g . memberLock . Unlock ( ) return errors . New ( "Could not find provided member for removal" ) } g . members = append ( g . members [ : memberIndex ] , g . members [ memberIndex + 1 : ] ... ) leaving . close <- true close ( leaving . Read ) g . memberLock . Unlock ( ) return nil }
100	func ( t * Target ) LastScrape ( ) time . Time { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . lastScrape }
226	func NewNerveDiscovery ( conf * NerveSDConfig , logger log . Logger ) ( * Discovery , error ) { return NewDiscovery ( conf . Servers , time . Duration ( conf . Timeout ) , conf . Paths , logger , parseNerveMember ) }
147	func ( p * Pool ) Put ( s interface { } ) { slice := reflect . ValueOf ( s ) if slice . Kind ( ) != reflect . Slice { panic ( fmt . Sprintf ( "%+v is not a slice" , slice ) ) } for i , size := range p . sizes { if slice . Cap ( ) > size { continue } p . buckets [ i ] . Put ( slice . Slice ( 0 , 0 ) . Interface ( ) ) return } }
659	func NewExoscaleProvider ( endpoint , apiKey , apiSecret string , dryRun bool , opts ... ExoscaleOption ) * ExoscaleProvider { client := egoscale . NewClient ( endpoint , apiKey , apiSecret ) return NewExoscaleProviderWithClient ( endpoint , apiKey , apiSecret , client , dryRun , opts ... ) }
653	func NewServiceSource ( kubeClient kubernetes . Interface , namespace , annotationFilter string , fqdnTemplate string , combineFqdnAnnotation bool , compatibility string , publishInternal bool , publishHostIP bool , serviceTypeFilter [ ] string , ignoreHostnameAnnotation bool ) ( Source , error ) { var ( tmpl * template . Template err error ) if fqdnTemplate != "" { tmpl , err = template . New ( "endpoint" ) . Funcs ( template . FuncMap { "trimPrefix" : strings . TrimPrefix , } ) . Parse ( fqdnTemplate ) if err != nil { return nil , err } } informerFactory := kubeinformers . NewSharedInformerFactoryWithOptions ( kubeClient , 0 , kubeinformers . WithNamespace ( namespace ) ) serviceInformer := informerFactory . Core ( ) . V1 ( ) . Services ( ) podInformer := informerFactory . Core ( ) . V1 ( ) . Pods ( ) nodeInformer := informerFactory . Core ( ) . V1 ( ) . Nodes ( ) serviceInformer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { log . Debug ( "service added" ) } , } , ) podInformer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { log . Debug ( "pod added" ) } , } , ) nodeInformer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { log . Debug ( "node added" ) } , } , ) informerFactory . Start ( wait . NeverStop ) err = wait . Poll ( time . Second , 60 * time . Second , func ( ) ( bool , error ) { return serviceInformer . Informer ( ) . HasSynced ( ) == true , nil } ) if err != nil { return nil , fmt . Errorf ( "failed to sync cache: %v" , err ) } serviceTypes := make ( map [ string ] struct { } ) for _ , serviceType := range serviceTypeFilter { serviceTypes [ serviceType ] = struct { } { } } return & serviceSource { client : kubeClient , namespace : namespace , annotationFilter : annotationFilter , compatibility : compatibility , fqdnTemplate : tmpl , combineFQDNAnnotation : combineFqdnAnnotation , ignoreHostnameAnnotation : ignoreHostnameAnnotation , publishInternal : publishInternal , publishHostIP : publishHostIP , serviceInformer : serviceInformer , podInformer : podInformer , nodeInformer : nodeInformer , serviceTypeFilter : serviceTypes , } , nil }
2704	func ( c * Config ) SaveVimClient ( client * govmomi . Client ) error { if ! c . Persist { return nil } p , err := c . vimSessionFile ( ) if err != nil { return err } log . Printf ( "[DEBUG] Will persist SOAP client session data to %q" , p ) err = os . MkdirAll ( filepath . Dir ( p ) , 0700 ) if err != nil { return err } f , err := os . OpenFile ( p , os . O_CREATE | os . O_WRONLY , 0600 ) if err != nil { return err } defer func ( ) { if err = f . Close ( ) ; err != nil { log . Printf ( "[DEBUG] Error closing SOAP client session file %q: %s" , p , err ) } } ( ) err = json . NewEncoder ( f ) . Encode ( client . Client ) if err != nil { return err } return nil }
6947	func New ( apiKey string ) * Reporter { hostname , _ := os . Hostname ( ) return & Reporter { Client : NewClient ( apiKey ) , Hostname : hostname , refs : make ( map [ string ] int8 ) , } }
2535	func resourceVSphereComputeClusterHostGroupFlattenID ( cluster * object . ClusterComputeResource , name string ) ( string , error ) { clusterID := cluster . Reference ( ) . Value return strings . Join ( [ ] string { clusterID , name } , ":" ) , nil }
1800	func ( m * MockDockerClient ) CreateContainer ( arg0 context . Context , arg1 * container0 . Config , arg2 * container0 . HostConfig , arg3 string , arg4 time . Duration ) dockerapi . DockerContainerMetadata { ret := m . ctrl . Call ( m , "CreateContainer" , arg0 , arg1 , arg2 , arg3 , arg4 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerContainerMetadata ) return ret0 }
3923	func ( d * directiveParser ) Unmatched ( ) map [ string ] ignoredRanges { unmatched := map [ string ] ignoredRanges { } for path , ranges := range d . files { for _ , ignore := range ranges { if ! ignore . matched { unmatched [ path ] = append ( unmatched [ path ] , ignore ) } } } return unmatched }
1096	func secretsFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( [ ] string , error ) { return func ( s string ) ( [ ] string , error ) { var result [ ] string if len ( s ) == 0 { return result , nil } d , err := dep . NewVaultListQuery ( s ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { result = value . ( [ ] string ) return result , nil } missing . Add ( d ) return result , nil } }
5635	func ComputeWIF ( privKey string , compress bool ) string { return WIFFromPrivKeyBytes ( HexDecode ( privKey ) , compress ) }
1016	func deepCopyAndSortTags ( tags [ ] string ) [ ] string { newTags := make ( [ ] string , 0 , len ( tags ) ) for _ , tag := range tags { newTags = append ( newTags , tag ) } sort . Strings ( newTags ) return newTags }
4952	func RandomIdentifier ( prefix string ) Identifier { b := make ( [ ] byte , 16 ) if _ , err := io . ReadFull ( rand . Reader , b ) ; err != nil { panic ( err . Error ( ) ) } return Identifier ( fmt . Sprintf ( "%s%x" , prefix , b ) ) }
6973	func loadPath ( ) ( string , error ) { path := "" if len ( * cpath ) == 0 { path = os . Getenv ( "GC_PATH" ) } else { path = * cpath } if len ( path ) == 0 { gp , err := getGoPath ( ) if err != nil { return "" , err } path = gp + "/config" } log . Printf ( "Loading configuration file from path %s\n" , \n ) path }
4103	func ( l * TextView ) SetWordWrap ( wrap bool ) { if wrap != l . wordWrap { l . wordWrap = wrap l . calculateVirtualSize ( ) l . recalculateTopLine ( ) l . Draw ( ) } }
181	func ( r * AlertingRule ) LastError ( ) error { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . lastError }
240	func getFqdn ( ) ( string , error ) { hostname , err := os . Hostname ( ) if err != nil { return "" , err } ips , err := net . LookupIP ( hostname ) if err != nil { return hostname , nil } lookup := func ( ipStr encoding . TextMarshaler ) ( string , error ) { ip , err := ipStr . MarshalText ( ) if err != nil { return "" , err } hosts , err := net . LookupAddr ( string ( ip ) ) if err != nil || len ( hosts ) == 0 { return "" , err } return hosts [ 0 ] , nil } for _ , addr := range ips { if ip := addr . To4 ( ) ; ip != nil { if fqdn , err := lookup ( ip ) ; err == nil { return fqdn , nil } } if ip := addr . To16 ( ) ; ip != nil { if fqdn , err := lookup ( ip ) ; err == nil { return fqdn , nil } } } return hostname , nil }
209	func ( m * Manager ) AlertingRules ( ) [ ] * AlertingRule { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) alerts := [ ] * AlertingRule { } for _ , rule := range m . Rules ( ) { if alertingRule , ok := rule . ( * AlertingRule ) ; ok { alerts = append ( alerts , alertingRule ) } } return alerts }
6480	func New ( addr string , store Store ) * http . Server { if store == nil { store = NewMemoryStore ( ) } h := & Handler { store : store } return & http . Server { Addr : addr , Handler : h , } }
1435	func ( state * DockerTaskEngineState ) GetAllContainerIDs ( ) [ ] string { state . lock . RLock ( ) defer state . lock . RUnlock ( ) var ids [ ] string for id := range state . idToTask { ids = append ( ids , id ) } return ids }
2394	func ( w * World ) init ( maxLiveCells int ) { for i := 0 ; i < maxLiveCells ; i ++ { x := rand . Intn ( w . width ) y := rand . Intn ( w . height ) w . area [ y * w . width + x ] = true } }
919	func ( d * BaseDriver ) GetSSHKeyPath ( ) string { if d . SSHKeyPath == "" { d . SSHKeyPath = d . ResolveStorePath ( "id_rsa" ) } return d . SSHKeyPath }
3470	func ( r * reqAPIKey ) GetAPIKey ( ) APIKey { if r == nil || r . APIKey == nil { return APIKey { } } return * r . APIKey }
2689	func Rename ( pod * object . StoragePod , name string ) error { log . Printf ( "[DEBUG] Renaming storage pod %q to %s" , pod . InventoryPath , name ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := pod . Rename ( ctx , name ) if err != nil { return err } return task . Wait ( ctx ) }
4471	func ( t * DateTime ) DeepCopy ( ) * DateTime { if t == nil { return nil } out := new ( DateTime ) t . DeepCopyInto ( out ) return out }
6886	func ( w * Window ) render ( ) { w . mgr . Render ( w ) for _ , widget := range w . widgets { widget . Render ( ) } w . focusWidget ( ) }
6153	func ( w * Worker ) AgentPreServiceSuspend ( job * data . Job ) error { logger := w . logger . Add ( "method" , "AgentPreServiceSuspend" , "job" , job ) _ , err := w . agentUpdateServiceStatus ( logger , job , data . JobAgentPreServiceSuspend ) return err }
5108	func hasMaxOf ( top interface { } , current interface { } , field interface { } , param string ) bool { return isLte ( top , current , field , param ) }
4039	func SetScreenSize ( width int , height int ) { if canvas . width == width && canvas . height == height { return } canvas . width = width canvas . height = height canvas . clipStack = make ( [ ] rect , 0 ) SetClipRect ( 0 , 0 , width , height ) }
6324	func ( r * Request ) UrlValue ( key string ) string { return mux . Vars ( r . Request ) [ key ] }
121	func ( p * parser ) parseExpr ( ) ( expr Expr , err error ) { defer p . recover ( & err ) for p . peek ( ) . typ != ItemEOF { if p . peek ( ) . typ == ItemComment { continue } if expr != nil { p . errorf ( "could not parse remaining input %.15q..." , p . lex . input [ p . lex . lastPos : ] ) } expr = p . expr ( ) } if expr == nil { p . errorf ( "no expression found in input" ) } return }
1876	func WriteContainerMetadataResponse ( w http . ResponseWriter , containerID string , state dockerstate . TaskEngineState ) { containerResponse , err := NewContainerResponse ( containerID , state ) if err != nil { errResponseJSON , _ := json . Marshal ( "Unable to generate metadata for container '" + containerID + "'" ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerMetadata ) return } responseJSON , _ := json . Marshal ( containerResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeContainerMetadata ) }
6695	func ( c * Client ) SnapshotServer ( identifier string ) ( * Image , error ) { res , err := c . MakeApiRequest ( "POST" , "/1.0/servers/" + identifier + "/snapshot" , nil , nil ) if err != nil { return nil , err } imageID := getLinkRel ( res . Header . Get ( "Link" ) , "img" , "snapshot" ) if imageID != nil { img := new ( Image ) img . Id = * imageID return img , nil } return nil , nil }
4237	func NewMultiplex ( con net . Conn , initiator bool ) * Multiplex { mp := & Multiplex { con : con , initiator : initiator , buf : bufio . NewReader ( con ) , channels : make ( map [ streamID ] * Stream ) , closed : make ( chan struct { } ) , shutdown : make ( chan struct { } ) , wrTkn : make ( chan struct { } , 1 ) , nstreams : make ( chan * Stream , 16 ) , } go mp . handleIncoming ( ) mp . wrTkn <- struct { } { } return mp }
402	func ( u * URI ) SetQueryStringBytes ( queryString [ ] byte ) { u . queryString = append ( u . queryString [ : 0 ] , queryString ... ) u . parsedQueryArgs = false }
6146	func NewHandler ( db * reform . DB , logger log . Logger ) * Handler { return & Handler { db : db , logger : logger . Add ( "type" , "tor-somc.Handler" ) } }
836	func tenantIDPath ( subscriptionID string ) string { return filepath . Join ( azureCredsPath ( ) , fmt . Sprintf ( "%s.tenantid" , subscriptionID ) ) }
2414	func ( i * Image ) viewportSize ( ) ( int , int ) { if i . screen { return i . width , i . height } return graphics . InternalImageSize ( i . width ) , graphics . InternalImageSize ( i . height ) }
5522	func commonKind ( v1 , v2 reflect . Value ) reflect . Kind { k1 := unsizedKind ( v1 ) k2 := unsizedKind ( v2 ) if k1 == k2 && ( k1 == reflect . Uint64 || k1 == reflect . Int64 ) { return k1 } if k1 == reflect . Complex128 || k2 == reflect . Complex128 { return reflect . Complex128 } return reflect . Float64 }
2831	func resourceVSphereDRSVMOverrideParseID ( id string ) ( string , string , error ) { parts := strings . SplitN ( id , ":" , 3 ) if len ( parts ) < 2 { return "" , "" , fmt . Errorf ( "bad ID %q" , id ) } return parts [ 0 ] , parts [ 1 ] , nil }
3486	func ( r * Rule ) GetThresholdOk ( ) ( json . Number , bool ) { if r == nil || r . Threshold == nil { return "" , false } return * r . Threshold , true }
7155	func ( s * Container ) NetworkNodes ( ) ( [ ] NetworkNode , error ) { inspect , err := s . Inspect ( ) if err != nil { return nil , err } if len ( inspect ) == 0 { return nil , fmt . Errorf ( "Container inspect is empty" ) } nodes := make ( [ ] NetworkNode , 0 ) for _ , i := range inspect { ip := i . NetworkSettings . IPAddress if ip == "" { continue } if len ( i . NetworkSettings . Ports ) == 0 { nodes = append ( nodes , NetworkNode { IpAddress : ip , } ) } else { for k , _ := range i . NetworkSettings . Ports { node := NetworkNode { } node . IpAddress = ip node . SetFromDocker ( k ) nodes = append ( nodes , node ) } } } return nodes , nil }
5432	func ( bot * Bot ) handleIncomingMessages ( ) { scan := bufio . NewScanner ( bot . con ) for scan . Scan ( ) { bot . con . SetDeadline ( time . Now ( ) . Add ( bot . PingTimeout ) ) msg := ParseMessage ( scan . Text ( ) ) bot . Debug ( "Incoming" , "raw" , scan . Text ( ) , "msg.To" , msg . To , "msg.From" , msg . From , "msg.Params" , msg . Params , "msg.Trailing" , msg . Trailing ) go func ( ) { for _ , h := range bot . handlers { if h . Handle ( bot , msg ) { break } } } ( ) bot . Incoming <- msg } close ( bot . Incoming ) }
5044	func ( c * Collection ) DropCollection ( ) error { return c . Database . Run ( bson . D { { "drop" , c . Name } } , nil ) }
6479	func ( s * Handler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { key := getURLParam ( r , cfg . QueryCacheKey ) if key == "" { w . WriteHeader ( cfg . FailStatus ) return } entry := s . store . Get ( key ) if entry == nil && r . Method != methodPost { w . WriteHeader ( cfg . FailStatus ) return } switch r . Method { case methodGet : { res , ok := entry . Response ( ) if ! ok { w . WriteHeader ( cfg . FailStatus ) return } w . Header ( ) . Set ( cfg . ContentTypeHeader , res . ContentType ( ) ) w . WriteHeader ( res . StatusCode ( ) ) w . Write ( res . Body ( ) ) } case methodPost : { body , err := ioutil . ReadAll ( r . Body ) if err != nil || len ( body ) == 0 { w . WriteHeader ( cfg . FailStatus ) return } statusCode , _ := getURLParamInt ( r , cfg . QueryCacheStatusCode ) contentType := getURLParam ( r , cfg . QueryCacheContentType ) if entry == nil { expirationSeconds , err := getURLParamInt64 ( r , cfg . QueryCacheDuration ) if expirationSeconds <= 0 || err != nil { expirationSeconds = int64 ( nethttp . GetMaxAge ( r ) ( ) . Seconds ( ) ) } if expirationSeconds <= 0 { expirationSeconds = int64 ( cfg . MinimumCacheDuration . Seconds ( ) ) } cacheDuration := time . Duration ( expirationSeconds ) * time . Second s . store . Set ( key , statusCode , contentType , body , cacheDuration ) } else { entry . Reset ( statusCode , contentType , body , nethttp . GetMaxAge ( r ) ) } w . WriteHeader ( cfg . SuccessStatus ) } case methodDelete : { s . store . Remove ( key ) w . WriteHeader ( cfg . SuccessStatus ) } default : w . WriteHeader ( cfg . FailStatus ) } }
1208	func DockerStateToState ( state * types . ContainerState ) apicontainerstatus . ContainerStatus { if state . Running { return apicontainerstatus . ContainerRunning } if state . Dead { return apicontainerstatus . ContainerStopped } startTime , _ := time . Parse ( time . RFC3339 , state . StartedAt ) if startTime . IsZero ( ) && state . Error == "" { return apicontainerstatus . ContainerCreated } return apicontainerstatus . ContainerStopped }
3539	func ( s * SyntheticsRequest ) GetBodyOk ( ) ( string , bool ) { if s == nil || s . Body == nil { return "" , false } return * s . Body , true }
4504	func Repeat ( s string , n int ) Filter { return FilterFunc ( func ( arg Arg ) error { for i := 0 ; i < n ; i ++ { arg . Out <- s } return nil } ) }
1845	func ( h * handler ) runAgent ( ctx context . Context ) uint32 { agentCtx , cancel := context . WithCancel ( ctx ) indicator := newTermHandlerIndicator ( ) terminationHandler := func ( saver statemanager . Saver , taskEngine engine . TaskEngine ) { defer indicator . finish ( ) indicator . setInvoked ( ) <- agentCtx . Done ( ) if ! indicator . isAgentRunning ( ) { return } seelog . Info ( "Termination handler received signal to stop" ) err := sighandlers . FinalSave ( saver , taskEngine ) if err != nil { seelog . Criticalf ( "Error saving state before final shutdown: %v" , err ) } } h . ecsAgent . setTerminationHandler ( terminationHandler ) go func ( ) { defer cancel ( ) exitCode := h . ecsAgent . start ( ) if exitCode == exitcodes . ExitTerminal { seelog . Critical ( "Terminal exit code received from agent. Windows SCM will not restart the AmazonECS service." ) exitCode = 0 } indicator . agentStopped ( exitCode ) } ( ) sleepCtx ( agentCtx , time . Minute ) return indicator . wait ( ) }
4252	func InitArgs ( args ... string ) func ( * LinuxFactory ) error { return func ( l * LinuxFactory ) error { name := args [ 0 ] if filepath . Base ( name ) == name { if lp , err := exec . LookPath ( name ) ; err == nil { name = lp } } l . InitPath = name l . InitArgs = append ( [ ] string { name } , args [ 1 : ] ... ) return nil } }
4060	func SysColor ( color string ) term . Attribute { thememtx . RLock ( ) sch , ok := themeManager . themes [ themeManager . current ] if ! ok { sch = themeManager . themes [ defaultTheme ] } thememtx . RUnlock ( ) clr , okclr := sch . colors [ color ] if ! okclr { visited := make ( map [ string ] int , 0 ) visited [ themeManager . current ] = 1 if ! ok { visited [ defaultTheme ] = 1 } for { if sch . parent == "" { break } themeManager . loadTheme ( sch . parent ) thememtx . RLock ( ) sch = themeManager . themes [ sch . parent ] clr , okclr = sch . colors [ color ] thememtx . RUnlock ( ) if ok { break } else { if _ , okSch := visited [ sch . parent ] ; okSch { panic ( "Color + " + color + ". Theme loop detected: " + sch . title + " + sch . parent ) } else { visited [ sch . parent ] = 1 } } } } return clr }
4294	func getSelinuxMountPoint ( ) string { if selinuxfs != "unknown" { return selinuxfs } selinuxfs = "" mounts , err := mount . GetMounts ( ) if err != nil { return selinuxfs } for _ , mount := range mounts { if mount . Fstype == "selinuxfs" { selinuxfs = mount . Mountpoint break } } if selinuxfs != "" { var buf syscall . Statfs_t syscall . Statfs ( selinuxfs , & buf ) if ( buf . Flags & stRdOnly ) == 1 { selinuxfs = "" } } return selinuxfs }
6300	func NewDecoder ( enc * Encoding , r io . Reader ) io . Reader { return & decoder { enc : enc , r : r , buf : bytes . NewBuffer ( nil ) , leftovers : bytes . NewBuffer ( nil ) } }
5727	func ( pl * processLink ) ChildClosing ( ) <- chan struct { } { pl . Lock ( ) child := pl . child pl . Unlock ( ) if child == nil { return closedCh } return child . Closing ( ) }
93	func ( t * Target ) hash ( ) uint64 { h := fnv . New64a ( ) h . Write ( [ ] byte ( fmt . Sprintf ( "%016d" , t . labels . Hash ( ) ) ) ) h . Write ( [ ] byte ( t . URL ( ) . String ( ) ) ) return h . Sum64 ( ) }
3094	func ( ctx * Context ) ServeFileContent ( file string , names ... string ) { var name string if len ( names ) > 0 { name = names [ 0 ] } else { name = path . Base ( file ) } f , err := os . Open ( file ) if err != nil { if Env == PROD { http . Error ( ctx . Resp , "Internal Server Error" , 500 ) } else { http . Error ( ctx . Resp , err . Error ( ) , 500 ) } return } defer f . Close ( ) ctx . setRawContentHeader ( ) http . ServeContent ( ctx . Resp , ctx . Req . Request , name , time . Now ( ) , f ) }
4312	func ( c * Client ) GetProject ( account , repo string ) ( * Project , error ) { projects , err := c . ListProjects ( ) if err != nil { return nil , err } for _ , project := range projects { if account == project . Username && repo == project . Reponame { return project , nil } } return nil , nil }
3414	func ( o * Options ) GetEscalationMessageOk ( ) ( string , bool ) { if o == nil || o . EscalationMessage == nil { return "" , false } return * o . EscalationMessage , true }
6604	func NewClient ( network , address string ) * Client { return NewClientWithDialer ( network , address , new ( net . Dialer ) ) }
1955	func ( m * MockResponseWriter ) WriteHeader ( arg0 int ) { m . ctrl . Call ( m , "WriteHeader" , arg0 ) }
4658	func NewExpiringCountIndex ( resolution Meters , expiration Minutes ) * CountIndex { newExpiringCounter := func ( ) interface { } { return newExpiringCounter ( expiration ) } return & CountIndex { newGeoIndex ( resolution , newExpiringCounter ) , make ( map [ string ] Point ) } }
1146	func ( mr * MockTaskEngineMockRecorder ) Version ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Version" , reflect . TypeOf ( ( * MockTaskEngine ) ( nil ) . Version ) ) }
4118	func ( w * Window ) OnKeyDown ( fn func ( Event , interface { } ) bool , data interface { } ) { if fn == nil { w . onKeyDown = nil } else { w . onKeyDown = & keyDownCb { data : data , fn : fn } } }
1542	func ( s * SequentialWaitGroup ) Done ( sequence int64 ) { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) _ , ok := s . semaphores [ sequence ] if ok { s . semaphores [ sequence ] -- if s . semaphores [ sequence ] == 0 { delete ( s . semaphores , sequence ) s . change . Broadcast ( ) } } }
6757	func ( a * AddrBook ) OnStart ( ) error { a . BaseService . OnStart ( ) a . loadFromFile ( a . filePath ) a . wg . Add ( 1 ) go a . saveRoutine ( ) return nil }
5502	func NewDefaultLogger ( fileDir , fileName string ) * FileLogger { return NewSizeLogger ( fileDir , fileName , "" , DEFAULT_FILE_COUNT , DEFAULT_FILE_SIZE , DEFAULT_FILE_UNIT , DEFAULT_LOG_SCAN , DEFAULT_LOG_SEQ ) }
2870	func expandClusterVMGroup ( d * schema . ResourceData , meta interface { } , name string ) ( * types . ClusterVmGroup , error ) { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return nil , err } results , err := virtualmachine . MOIDsForUUIDs ( client , structure . SliceInterfacesToStrings ( d . Get ( "virtual_machine_ids" ) . ( * schema . Set ) . List ( ) ) , ) if err != nil { return nil , err } obj := & types . ClusterVmGroup { ClusterGroupInfo : types . ClusterGroupInfo { Name : name , UserCreated : structure . BoolPtr ( true ) , } , Vm : results . ManagedObjectReferences ( ) , } return obj , nil }
754	func ( d * dynProviderState ) fetchAllRecordsInZone ( zone string ) ( * dynectsoap . GetAllRecordsResponseType , error ) { var err error client := dynectsoap . NewClient ( "https://api2.dynect.net/SOAP/" ) service := dynectsoap . NewDynect ( client ) sessionRequest := dynectsoap . SessionLoginRequestType { Customer_name : d . CustomerName , User_name : d . Username , Password : d . Password , Fault_incompat : 0 , } resp := dynectsoap . SessionLoginResponseType { } err = apiRetryLoop ( func ( ) error { return service . Do ( & sessionRequest , & resp ) } ) if err != nil { return nil , err } token := resp . Data . Token logoutRequest := dynectsoap . SessionLogoutRequestType { Token : token , Fault_incompat : 0 , } logoutResponse := dynectsoap . SessionLogoutResponseType { } defer service . Do ( & logoutRequest , & logoutResponse ) req := dynectsoap . GetAllRecordsRequestType { Token : token , Zone : zone , Fault_incompat : 0 , } records := dynectsoap . GetAllRecordsResponseType { } err = apiRetryLoop ( func ( ) error { return service . Do ( & req , & records ) } ) if err != nil { return nil , err } log . Debugf ( "Got all Records, status is %s" , records . Status ) if strings . ToLower ( records . Status ) == "incomplete" { jobRequest := dynectsoap . GetJobRequestType { Token : token , Job_id : records . Job_id , Fault_incompat : 0 , } jobResults := dynectsoap . GetJobResponseType { } err = apiRetryLoop ( func ( ) error { return service . GetJobRetry ( & jobRequest , & jobResults ) } ) if err != nil { return nil , err } return jobResults . Data . ( * dynectsoap . GetAllRecordsResponseType ) , nil } return & records , nil }
3692	func ( w * Widget ) GetMustShowBreakdownOk ( ) ( bool , bool ) { if w == nil || w . MustShowBreakdown == nil { return false , false } return * w . MustShowBreakdown , true }
3897	func ( b * builder ) buildFuncDecl ( pkg * Package , decl * ast . FuncDecl ) { id := decl . Name if isBlankIdent ( id ) { return } fn := pkg . values [ pkg . info . Defs [ id ] ] . ( * Function ) if decl . Recv == nil && id . Name == "init" { var v Call v . Call . Value = fn v . setType ( types . NewTuple ( ) ) pkg . init . emit ( & v ) } b . buildFunction ( fn ) }
5679	func ( st * state ) copy ( ) * state { n := new ( state ) * n = * st return n }
3268	func ( d * DashboardConditionalFormat ) GetCustomImageUrl ( ) string { if d == nil || d . CustomImageUrl == nil { return "" } return * d . CustomImageUrl }
5580	func ( o * FindVmsByDeploymentParams ) WithContext ( ctx context . Context ) * FindVmsByDeploymentParams { o . SetContext ( ctx ) return o }
4438	func ( u * ISBN ) DeepCopy ( ) * ISBN { if u == nil { return nil } out := new ( ISBN ) u . DeepCopyInto ( out ) return out }
6533	func ( c * secureConn ) ReleaseMsg ( m [ ] byte ) { c . secure . ReadWriter ( ) . ReleaseMsg ( m ) }
6012	func ( t Typed ) FloatOr ( key string , d float64 ) float64 { if value , exists := t . FloatIf ( key ) ; exists { return value } return d }
2288	func ( v * Statusbar ) native ( ) * C . GtkStatusbar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStatusbar ( p ) }
1365	func processCredentialsRequest ( credentialsManager credentials . Manager , r * http . Request , credentialsID string , errPrefix string ) ( [ ] byte , string , string , * handlersutils . ErrorMessage , error ) { if credentialsID == "" { errText := errPrefix + "No ID in the request" seelog . Infof ( "%s. Request IP Address: %s" , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrNoIDInRequest , Message : errText , HTTPErrorCode : http . StatusBadRequest , } return nil , "" , "" , msg , errors . New ( errText ) } credentials , ok := credentialsManager . GetTaskCredentials ( credentialsID ) if ! ok { errText := errPrefix + "ID not found" seelog . Infof ( "%s. Request IP Address: %s" , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrInvalidIDInRequest , Message : errText , HTTPErrorCode : http . StatusBadRequest , } return nil , "" , "" , msg , errors . New ( errText ) } if utils . ZeroOrNil ( credentials . ARN ) && utils . ZeroOrNil ( credentials . IAMRoleCredentials ) { errText := errPrefix + "Credentials uninitialized for ID" seelog . Infof ( "%s. Request IP Address: %s" , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrCredentialsUninitialized , Message : errText , HTTPErrorCode : http . StatusServiceUnavailable , } return nil , "" , "" , msg , errors . New ( errText ) } credentialsJSON , err := json . Marshal ( credentials . IAMRoleCredentials ) if err != nil { errText := errPrefix + "Error marshaling credentials" seelog . Errorf ( "%s. Request IP Address: %s" , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrInternalServer , Message : "Internal server error" , HTTPErrorCode : http . StatusInternalServerError , } return nil , "" , "" , msg , errors . New ( errText ) } return credentialsJSON , credentials . ARN , credentials . IAMRoleCredentials . RoleType , nil , nil }
1269	func ( mr * MockClientCreatorMockRecorder ) NewASMClient ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "NewASMClient" , reflect . TypeOf ( ( * MockClientCreator ) ( nil ) . NewASMClient ) , arg0 , arg1 ) }
5367	func parseUser ( row string ) ( * User , error ) { fields := strings . Split ( row , ":" ) if len ( fields ) != 7 { return nil , rowError { _USER_FILE , row } } uid , err := strconv . Atoi ( fields [ 2 ] ) if err != nil { return nil , atoiError { _USER_FILE , row , "UID" } } gid , err := strconv . Atoi ( fields [ 3 ] ) if err != nil { return nil , atoiError { _USER_FILE , row , "GID" } } return & User { Name : fields [ 0 ] , password : fields [ 1 ] , UID : uid , GID : gid , Gecos : fields [ 4 ] , Dir : fields [ 5 ] , Shell : fields [ 6 ] , } , nil }
301	func sum64 ( hash [ md5 . Size ] byte ) uint64 { var s uint64 for i , b := range hash { shift := uint64 ( ( md5 . Size - i - 1 ) * 8 ) s |= uint64 ( b ) << shift } return s }
7092	func hasDatePrefix ( s string ) bool { if len ( s ) < 10 { return false } var count int for i , r := range s { if count != i { return false } switch i { case 4 , 7 : if r != '-' { return false } default : if ! isDigit ( r ) { return false } } if i == 9 { if s [ 5 ] == '1' { if s [ 6 ] > '2' { return false } } else if s [ 5 ] == '0' { if s [ 6 ] == '0' { return false } } else { return false } if s [ 8 ] == '0' { if s [ 9 ] == '0' { return false } } else if s [ 8 ] == '3' { if s [ 9 ] > '1' { return false } } else if s [ 8 ] != '1' && s [ 8 ] != '2' { return false } return true } count += 1 } return true }
264	func ( i ItemType ) isAggregatorWithParam ( ) bool { return i == ItemTopK || i == ItemBottomK || i == ItemCountValues || i == ItemQuantile }
5135	func ( ui * ColorUI ) Success ( message string ) { ct . ChangeColor ( ui . SuccessFGColor . Code , ui . SuccessFGColor . Bright , ui . SuccessBGColor . Code , ui . SuccessBGColor . Bright ) ui . UI . Success ( message ) ct . ResetColor ( ) }
2837	func resourceVSphereDatastoreReadFolderOrStorageClusterPath ( d * schema . ResourceData , ds * object . Datastore ) error { props , err := datastore . Properties ( ds ) if err != nil { return fmt . Errorf ( "error fetching datastore properties while parsing path: %s" , err ) } switch props . Parent . Type { case "Folder" : return resourceVSphereDatastoreReadFolderOrStorageClusterPathAsFolder ( d , ds ) case "StoragePod" : return resourceVSphereDatastoreReadFolderOrStorageClusterPathSetAttributes ( d , "" , props . Parent . Value ) } return fmt . Errorf ( "unknown datastore parent type %q while parsing inventory path" , props . Parent . Type ) }
15	func signatureFunc ( on bool , names ... string ) func ( labels . Labels ) uint64 { if on { return func ( lset labels . Labels ) uint64 { return lset . HashForLabels ( names ... ) } } return func ( lset labels . Labels ) uint64 { return lset . HashWithoutLabels ( names ... ) } }
3025	func Properties ( folder * object . Folder ) ( * mo . Folder , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Folder if err := folder . Properties ( ctx , folder . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
6031	func ( t Typed ) ObjectsIf ( key string ) ( [ ] Typed , bool ) { value , exists := t [ key ] if exists == true { switch t := value . ( type ) { case [ ] interface { } : l := len ( t ) n := make ( [ ] Typed , l ) for i := 0 ; i < l ; i ++ { switch it := t [ i ] . ( type ) { case map [ string ] interface { } : n [ i ] = Typed ( it ) case Typed : n [ i ] = it } } return n , true case [ ] map [ string ] interface { } : l := len ( t ) n := make ( [ ] Typed , l ) for i := 0 ; i < l ; i ++ { n [ i ] = Typed ( t [ i ] ) } return n , true case [ ] Typed : return t , true } } return nil , false }
6723	func ( c * Client ) Collaborations ( ) ( [ ] Collaboration , error ) { var cl [ ] Collaboration _ , err := c . MakeApiRequest ( "GET" , "/1.0/user/collaborations" , nil , & cl ) if err != nil { return nil , err } return cl , err }
1196	func ( m * MockTime ) AfterFunc ( arg0 time . Duration , arg1 func ( ) ) ttime . Timer { ret := m . ctrl . Call ( m , "AfterFunc" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( ttime . Timer ) return ret0 }
5497	func ( cpnps * CountryPhoneNumberPriceService ) GetPage ( ctx context . Context , data url . Values ) ( * CountriesPricePage , error ) { return cpnps . GetPageIterator ( data ) . Next ( ctx ) }
5748	func New ( ac * Config ) ( * API , error ) { if ac == nil { return nil , errors . New ( "Invalid API configuration (nil)" ) } key := TokenKeyType ( ac . TokenKey ) if key == "" { return nil , errors . New ( "API Token is required" ) } app := TokenAppType ( ac . TokenApp ) if app == "" { app = defaultAPIApp } acctID := TokenAccountIDType ( ac . TokenAccountID ) au := string ( ac . URL ) if au == "" { au = defaultAPIURL } if ! strings . Contains ( au , "/" ) { au = fmt . Sprintf ( "https://%s/v2" , ac . URL ) } if last := len ( au ) - 1 ; last >= 0 && au [ last ] == '/' { au = au [ : last ] } apiURL , err := url . Parse ( au ) if err != nil { return nil , err } a := & API { apiURL : apiURL , key : key , app : app , accountID : acctID , caCert : ac . CACert , tlsConfig : ac . TLSConfig , Debug : ac . Debug , Log : ac . Log , useExponentialBackoff : false , } a . Debug = ac . Debug a . Log = ac . Log if a . Debug && a . Log == nil { a . Log = log . New ( os . Stderr , "" , log . LstdFlags ) } if a . Log == nil { a . Log = log . New ( ioutil . Discard , "" , log . LstdFlags ) } return a , nil }
5591	func ( o * FindVmsByFiltersParams ) WithBody ( body * models . VMFilter ) * FindVmsByFiltersParams { o . SetBody ( body ) return o }
3118	func ( o * Object ) String ( ) string { var buf bytes . Buffer fmt . Fprint ( & buf , o . reflectType ) if o . Name != "" { fmt . Fprintf ( & buf , " named %s" , o . Name ) } return buf . String ( ) }
2734	func tagsSchema ( ) * schema . Schema { return & schema . Schema { Type : schema . TypeSet , Description : "A list of tag IDs to apply to this object." , Optional : true , Elem : & schema . Schema { Type : schema . TypeString } , } }
6502	func ApiKeyClient ( key string , secret string ) Client { c := Client { rpc : rpc { auth : apiKeyAuth ( key , secret ) , mock : false , } , } return c }
1697	func ( eni * ENI ) GetIPV4Addresses ( ) [ ] string { var addresses [ ] string for _ , addr := range eni . IPV4Addresses { addresses = append ( addresses , addr . Address ) } return addresses }
4820	func ( g * gitCmd ) Stdout ( stdout io . Writer ) { g . Cmd . Stdout = stdout }
3418	func ( o * Options ) HasEvaluationDelay ( ) bool { if o != nil && o . EvaluationDelay != nil { return true } return false }
4330	func ( c * Client ) Count ( bucket string , n interface { } ) { if c . skip ( ) { return } c . conn . metric ( c . prefix , bucket , n , "c" , c . rate , c . tags ) }
5130	func ( e * FileCacheEntry ) readCloser ( ) ( * CachedFile , error ) { var f * os . File var err error if e . fileDoesNotExist ( ) { f , err = os . Create ( e . FilePath ) if err != nil { return nil , err } err = compressor . WriteTar ( e . ExpandedDirectoryPath + "/" , f ) if err != nil { return nil , err } if e . directoryInUseCount == 0 { err = os . RemoveAll ( e . ExpandedDirectoryPath ) if err != nil { fmt . Fprintln ( os . Stderr , "Unable to remove cached directory" , err ) } } else { e . Size = e . Size * 2 } } else { f , err = os . Open ( e . FilePath ) if err != nil { return nil , err } } e . incrementFileInUseCount ( ) if _ , err := f . Seek ( 0 , os . SEEK_SET ) ; err != nil { return nil , err } readCloser := NewFileCloser ( f , func ( filePath string ) { lock . Lock ( ) e . decrementFileInUseCount ( ) lock . Unlock ( ) } ) return readCloser , nil }
5938	func ( r * BasicReporter ) PostValue ( statKey , userKey string , value float64 ) error { r . add ( newClassicStatValue ( statKey , userKey , value ) ) return nil }
6901	func Panic ( format string , args ... interface { } ) { termbox . Close ( ) msg := fmt . Sprintf ( format , args ... ) panic ( msg ) }
5971	func GenerateHOTP ( digits int , randCounter bool ) ( * HOTP , error ) { key := make ( [ ] byte , sha1 . Size ) _ , err := io . ReadFull ( PRNG , key ) if err != nil { return nil , err } var counter uint64 if randCounter { ctr , err := rand . Int ( PRNG , big . NewInt ( int64 ( math . MaxInt64 ) ) ) if err != nil { return nil , err } counter = ctr . Uint64 ( ) } return NewHOTP ( key , counter , digits ) , nil }
2035	func ( retriever * macAddressRetriever ) retrieveOnce ( ) error { dev := filepath . Base ( retriever . dev ) link , err := retriever . netlinkClient . LinkByName ( dev ) if err != nil { return apierrors . NewRetriableError ( apierrors . NewRetriable ( false ) , err ) } retriever . macAddress = link . Attrs ( ) . HardwareAddr . String ( ) return nil }
6590	func StopObsessingOverSvc ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "STOP_OBSESSING_OVER_SVC" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
4684	func CompileResultWithTemplate ( t * template . Template , rslt * result , opts * Options ) ( * template . Template , error ) { opts = InitializeOptions ( opts ) var err error baseBf := bytes . NewBuffer ( nil ) innerBf := bytes . NewBuffer ( nil ) includeBfs := make ( map [ string ] * bytes . Buffer ) for _ , e := range rslt . base { if _ , err := e . WriteTo ( baseBf ) ; err != nil { return nil , err } } for _ , e := range rslt . inner { if _ , err = e . WriteTo ( innerBf ) ; err != nil { return nil , err } } for path , elements := range rslt . includes { bf := bytes . NewBuffer ( nil ) bf . WriteString ( fmt . Sprintf ( actionDefine , opts . DelimLeft , path , opts . DelimRight ) ) for _ , e := range elements { if _ , err = e . WriteTo ( bf ) ; err != nil { return nil , err } } bf . WriteString ( fmt . Sprintf ( actionEnd , opts . DelimLeft , opts . DelimRight ) ) includeBfs [ path ] = bf } t . Delims ( opts . DelimLeft , opts . DelimRight ) t . Funcs ( template . FuncMap { preDefinedFuncNameHTML : func ( s string ) template . HTML { return template . HTML ( s ) } , } ) t . Funcs ( opts . FuncMap ) t , err = t . Parse ( baseBf . String ( ) ) if err != nil { return nil , err } t , err = t . Parse ( innerBf . String ( ) ) if err != nil { return nil , err } for _ , bf := range includeBfs { t , err = t . Parse ( bf . String ( ) ) if err != nil { return nil , err } } return t , nil }
3049	func newRestSession ( ctx context . Context , u * url . URL , insecure bool ) ( * tags . RestClient , error ) { logger . Printf ( "[DEBUG] Creating new CIS REST API session on endpoint %s" , u . Host ) client := tags . NewClient ( u , insecure , "" ) if err := client . Login ( ctx ) ; err != nil { return nil , fmt . Errorf ( "error connecting to CIS REST endpoint: %s" , err ) } logger . Println ( "[DEBUG] CIS REST API session creation successful" ) return client , nil }
250	func ( q externalLabelsQuerier ) addExternalLabels ( ms [ ] * labels . Matcher ) ( [ ] * labels . Matcher , labels . Labels ) { el := make ( labels . Labels , len ( q . externalLabels ) ) copy ( el , q . externalLabels ) for _ , m := range ms { for i := 0 ; i < len ( el ) ; { if el [ i ] . Name == m . Name { el = el [ : i + copy ( el [ i : ] , el [ i + 1 : ] ) ] continue } i ++ } } for _ , l := range el { m , err := labels . NewMatcher ( labels . MatchEqual , l . Name , l . Value ) if err != nil { panic ( err ) } ms = append ( ms , m ) } return ms , el }
735	func ( p * AWSSDProvider ) DeregisterInstance ( service * sd . Service , ep * endpoint . Endpoint ) error { for _ , target := range ep . Targets { log . Infof ( "De-registering an instance \"%s\" for service \"%s\" (%s)" , \" , \" , \" ) \" } target }
3887	func ( b * builder ) expr ( fn * Function , e ast . Expr ) Value { e = unparen ( e ) tv := fn . Pkg . info . Types [ e ] if tv . Value != nil { return NewConst ( tv . Value , tv . Type ) } var v Value if tv . Addressable ( ) { v = b . addr ( fn , e , false ) . load ( fn ) } else { v = b . expr0 ( fn , e , tv ) } if fn . debugInfo ( ) { emitDebugRef ( fn , e , v , false ) } return v }
5538	func ( lo * LuaObject ) Iter ( ) ( * LuaTableIter , error ) { L := lo . l lo . Push ( ) defer L . Pop ( 1 ) if L . IsTable ( - 1 ) { return & LuaTableIter { lo : lo , keyRef : lua . LUA_NOREF , iterRef : lua . LUA_NOREF } , nil } else if L . GetMetaField ( - 1 , "__pairs" ) { L . PushValue ( - 2 ) err := L . Call ( 1 , 1 ) if err != nil { L . Pop ( 1 ) return nil , err } ref := L . Ref ( lua . LUA_REGISTRYINDEX ) return & LuaTableIter { lo : lo , keyRef : lua . LUA_NOREF , iterRef : ref } , nil } else { return nil , ErrLuaObjectIndexable } }
5660	func CompareHashAndPassword ( hashedPassword , password [ ] byte ) error { p , err := newFromHash ( hashedPassword ) if err != nil { return err } otherHash , err := bcrypt ( password , p . cost , p . salt ) if err != nil { return err } otherP := & hashed { otherHash , p . salt , p . cost , p . major , p . minor } if subtle . ConstantTimeCompare ( p . Hash ( ) , otherP . Hash ( ) ) == 1 { return nil } return ErrMismatchedHashAndPassword }
2920	func ReadSCSIBusType ( l object . VirtualDeviceList , count int ) string { ctlrs := make ( [ ] types . BaseVirtualSCSIController , count ) for _ , dev := range l { if sc , ok := dev . ( types . BaseVirtualSCSIController ) ; ok && sc . GetVirtualSCSIController ( ) . BusNumber < int32 ( count ) { ctlrs [ sc . GetVirtualSCSIController ( ) . BusNumber ] = sc } } log . Printf ( "[DEBUG] ReadSCSIBusType: SCSI controller layout for first %d controllers: %s" , count , scsiControllerListString ( ctlrs ) ) if ctlrs [ 0 ] == nil { return subresourceControllerTypeUnknown } last := l . Type ( ctlrs [ 0 ] . ( types . BaseVirtualDevice ) ) for _ , ctlr := range ctlrs [ 1 : ] { if ctlr == nil || l . Type ( ctlr . ( types . BaseVirtualDevice ) ) != last { return subresourceControllerTypeMixed } } return last }
1992	func ( engine * DockerStatsEngine ) addAndStartStatsContainer ( containerID string ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) statsContainer , err := engine . addContainerUnsafe ( containerID ) if err != nil { seelog . Debugf ( "Adding container to stats watch list failed, container: %s, err: %v" , containerID , err ) return } if engine . disableMetrics || statsContainer == nil { return } statsContainer . StartStatsCollection ( ) }
1786	func ( m * MockClientServer ) SetAnyRequestHandler ( arg0 wsclient . RequestHandler ) { m . ctrl . Call ( m , "SetAnyRequestHandler" , arg0 ) }
3464	func ( r * Recurrence ) GetUntilDate ( ) int { if r == nil || r . UntilDate == nil { return 0 } return * r . UntilDate }
2869	func ( v VSphereVersion ) Equal ( other VSphereVersion ) bool { return v . ProductEqual ( other ) && ! v . Older ( other ) && ! v . Newer ( other ) }
2928	func scsiControllerListString ( ctlrs [ ] types . BaseVirtualSCSIController ) string { var l object . VirtualDeviceList for _ , ctlr := range ctlrs { if ctlr == nil { l = append ( l , types . BaseVirtualDevice ( nil ) ) } else { l = append ( l , ctlr . ( types . BaseVirtualDevice ) ) } } return DeviceListString ( l ) }
5036	func ( s * Session ) Safe ( ) ( safe * Safe ) { s . m . Lock ( ) defer s . m . Unlock ( ) if s . safeOp != nil { cmd := s . safeOp . query . ( * getLastError ) safe = & Safe { WTimeout : cmd . WTimeout , FSync : cmd . FSync , J : cmd . J } switch w := cmd . W . ( type ) { case string : safe . WMode = w case int : safe . W = w } } return }
7263	func routeSplitFunc ( data [ ] byte , atEOF bool ) ( int , [ ] byte , error ) { if atEOF || data == nil { return 0 , nil , io . EOF } r , _ := utf8 . DecodeRune ( data ) if r == '<' { i := bytes . IndexRune ( data , '>' ) if i == - 1 { return 0 , nil , NoClosingBracket } return ( i + 1 ) , data [ : ( i + 1 ) ] , nil } if len ( data ) == 1 { return 1 , data , nil } slashIndex := bytes . IndexRune ( data [ 1 : ] , '/' ) if slashIndex != - 1 { slashIndex ++ } matchIndex := bytes . IndexRune ( data , '<' ) if slashIndex == - 1 && matchIndex == - 1 { return len ( data ) , data , nil } if matchIndex != - 1 && ( slashIndex == - 1 || slashIndex > matchIndex ) { return matchIndex , data [ : matchIndex ] , nil } return slashIndex + 1 , data [ : ( slashIndex + 1 ) ] , nil }
2701	func ( c * Config ) sessionFile ( ) ( string , error ) { u , err := c . vimURLWithoutPassword ( ) if err != nil { return "" , err } key := fmt . Sprintf ( "%s#insecure=%t" , u . String ( ) , c . InsecureFlag ) name := fmt . Sprintf ( "%040x" , sha1 . Sum ( [ ] byte ( key ) ) ) return name , nil }
2018	func ( mr * MockOSMockRecorder ) Getpid ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Getpid" , reflect . TypeOf ( ( * MockOS ) ( nil ) . Getpid ) ) }
1529	func ( acsSession * session ) startACSSession ( client wsclient . ClientServer ) error { cfg := acsSession . agentConfig refreshCredsHandler := newRefreshCredentialsHandler ( acsSession . ctx , cfg . Cluster , acsSession . containerInstanceARN , client , acsSession . credentialsManager , acsSession . taskEngine ) defer refreshCredsHandler . clearAcks ( ) refreshCredsHandler . start ( ) defer refreshCredsHandler . stop ( ) client . AddRequestHandler ( refreshCredsHandler . handlerFunc ( ) ) eniAttachHandler := newAttachENIHandler ( acsSession . ctx , cfg . Cluster , acsSession . containerInstanceARN , client , acsSession . state , acsSession . stateManager , ) eniAttachHandler . start ( ) defer eniAttachHandler . stop ( ) client . AddRequestHandler ( eniAttachHandler . handlerFunc ( ) ) payloadHandler := newPayloadRequestHandler ( acsSession . ctx , acsSession . taskEngine , acsSession . ecsClient , cfg . Cluster , acsSession . containerInstanceARN , client , acsSession . stateManager , refreshCredsHandler , acsSession . credentialsManager , acsSession . taskHandler ) defer payloadHandler . clearAcks ( ) payloadHandler . start ( ) defer payloadHandler . stop ( ) client . AddRequestHandler ( payloadHandler . handlerFunc ( ) ) client . AddRequestHandler ( func ( * ecsacs . HeartbeatMessage ) { } ) updater . AddAgentUpdateHandlers ( client , cfg , acsSession . stateManager , acsSession . taskEngine ) err := client . Connect ( ) if err != nil { seelog . Errorf ( "Error connecting to ACS: %v" , err ) return err } seelog . Info ( "Connected to ACS endpoint" ) timer := newDisconnectionTimer ( client , acsSession . heartbeatTimeout ( ) , acsSession . heartbeatJitter ( ) ) client . SetAnyRequestHandler ( anyMessageHandler ( timer , client ) ) defer timer . Stop ( ) acsSession . resources . connectedToACS ( ) backoffResetTimer := time . AfterFunc ( retry . AddJitter ( acsSession . heartbeatTimeout ( ) , acsSession . heartbeatJitter ( ) ) , func ( ) { acsSession . backoff . Reset ( ) } ) defer backoffResetTimer . Stop ( ) serveErr := make ( chan error , 1 ) go func ( ) { serveErr <- client . Serve ( ) } ( ) for { select { case <- acsSession . ctx . Done ( ) : return acsSession . ctx . Err ( ) case err := <- serveErr : return err } } }
2196	func ( v * Object ) GetPropertyType ( name string ) ( Type , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) paramSpec := C . g_object_class_find_property ( C . _g_object_get_class ( v . native ( ) ) , ( * C . gchar ) ( cstr ) ) if paramSpec == nil { return TYPE_INVALID , errors . New ( "couldn't find Property" ) } return Type ( paramSpec . value_type ) , nil }
4134	func ( n NetworkNumber ) ToIP ( ) net . IP { ip := make ( net . IP , len ( n ) * BytePerUint32 ) for i := 0 ; i < len ( n ) ; i ++ { idx := i * net . IPv4len binary . BigEndian . PutUint32 ( ip [ idx : idx + net . IPv4len ] , n [ i ] ) } if len ( ip ) == net . IPv4len { ip = net . IPv4 ( ip [ 0 ] , ip [ 1 ] , ip [ 2 ] , ip [ 3 ] ) } return ip }
3937	func ( p * Pinger ) Network ( network string ) ( string , error ) { origNet := p . network switch network { case "ip" : fallthrough case "udp" : p . network = network default : return origNet , errors . New ( network + " can't be used as ICMP endpoint" ) } return origNet , nil }
700	func ( p * GoogleProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } f := func ( resp * dns . ResourceRecordSetsListResponse ) error { for _ , r := range resp . Rrsets { if ! supportedRecordType ( r . Type ) { continue } endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . Ttl ) , r . Rrdatas ... ) ) } return nil } for _ , z := range zones { if err := p . resourceRecordSetsClient . List ( p . project , z . Name ) . Pages ( context . TODO ( ) , f ) ; err != nil { return nil , err } } return endpoints , nil }
1719	func ( task * Task ) BuildCNIConfig ( ) ( * ecscni . Config , error ) { if ! task . isNetworkModeVPC ( ) { return nil , errors . New ( "task config: task has no ENIs associated with it, unable to generate cni config" ) } cfg := & ecscni . Config { } convertENIToCNIConfig ( task . GetTaskENI ( ) , cfg ) if task . GetAppMesh ( ) != nil { convertAppMeshToCNIConfig ( task . GetAppMesh ( ) , cfg ) } return cfg , nil }
7037	func ( c * Conn ) SendRequestArr ( method string , resHandler func ( res * ResCtx ) error , params ... interface { } ) ( reqID string , err error ) { return c . SendRequest ( method , params , resHandler ) }
3531	func ( s * SyntheticsOptions ) HasMinFailureDuration ( ) bool { if s != nil && s . MinFailureDuration != nil { return true } return false }
2069	func NewMockECRSDK ( ctrl * gomock . Controller ) * MockECRSDK { mock := & MockECRSDK { ctrl : ctrl } mock . recorder = & MockECRSDKMockRecorder { mock } return mock }
7077	func ( d * Directive ) MarshalBinary ( ) ( [ ] byte , error ) { if len ( d . MAC ) != 6 { return nil , ErrorBadArgumentParameter } b := make ( [ ] byte , directiveLen ) b [ 1 ] = uint8 ( d . Command ) copy ( b [ 2 : ] , d . MAC ) return b , nil }
6855	func ( c * cachedLoader ) MustGetDuration ( key string ) time . Duration { s := c . MustGetString ( key ) ret , err := time . ParseDuration ( s ) if err != nil { panic ( fmt . Sprintf ( "Could not parse config (%s) into a duration: %v" , key , err ) ) } return ret }
6299	func ( d * decoder ) nextSpecialChar ( p [ ] byte ) ( i int ) { for i = 0 ; i < len ( p ) ; i ++ { if p [ i ] == byte ( '=' ) || ( d . enc . isText && p [ i ] == byte ( '\r' ) ) { return i } } return i }
6409	func ( list * LinkedList ) IsEmpty ( ) bool { list . key . RLock ( ) defer list . key . RUnlock ( ) return list . first == nil }
1627	func createBindsEnv ( binds [ ] string , env [ ] string , dataDirOnHost string , metadataDirectoryPath string ) ( [ ] string , [ ] string ) { randID := uuid . New ( ) instanceBind := fmt . Sprintf ( `%s/%s:%s/%s` , dataDirOnHost , metadataDirectoryPath , mountPoint , randID ) metadataEnvVariable := fmt . Sprintf ( "%s=%s/%s/%s" , metadataEnvironmentVariable , mountPoint , randID , metadataFile ) binds = append ( binds , instanceBind ) env = append ( env , metadataEnvVariable ) return binds , env }
477	func ( req * Request ) SwapBody ( body [ ] byte ) [ ] byte { bb := req . bodyBuffer ( ) if req . bodyStream != nil { bb . Reset ( ) _ , err := copyZeroAlloc ( bb , req . bodyStream ) req . closeBodyStream ( ) if err != nil { bb . Reset ( ) bb . SetString ( err . Error ( ) ) } } oldBody := bb . B bb . B = body return oldBody }
3699	func ( w * Widget ) HasMustShowErrors ( ) bool { if w != nil && w . MustShowErrors != nil { return true } return false }
906	func ( d * Driver ) Start ( ) error { if err := d . checkLegacyDriver ( true ) ; err != nil { return err } c , err := d . newAzureClient ( ) if err != nil { return err } return c . StartVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) ) }
3078	func ( ctx * Context ) QueryBool ( name string ) bool { v , _ := strconv . ParseBool ( ctx . Query ( name ) ) return v }
7113	func ( c * Config ) OptionMap ( section string ) map [ string ] string { options := make ( map [ string ] string ) for _ , sect := range c . sections { if sect . name == section { for _ , opt := range sect . options { options [ opt . name ] = opt . value } break } } return options }
52	func ( d * Discovery ) getDatacenter ( ) error { if d . clientDatacenter != "" { return nil } info , err := d . client . Agent ( ) . Self ( ) if err != nil { level . Error ( d . logger ) . Log ( "msg" , "Error retrieving datacenter name" , "err" , err ) rpcFailuresCount . Inc ( ) return err } dc , ok := info [ "Config" ] [ "Datacenter" ] . ( string ) if ! ok { err := errors . Errorf ( "invalid value '%v' for Config.Datacenter" , info [ "Config" ] [ "Datacenter" ] ) level . Error ( d . logger ) . Log ( "msg" , "Error retrieving datacenter name" , "err" , err ) return err } d . clientDatacenter = dc return nil }
696	func ( p * dnsimpleProvider ) DeleteRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . submitChanges ( newDnsimpleChanges ( dnsimpleDelete , endpoints ) ) }
4709	func ( l * line ) isHTMLComment ( ) bool { return len ( l . tokens ) > 0 && l . tokens [ 0 ] == slash + slash }
128	func ( p * parser ) expect ( exp ItemType , context string ) item { token := p . next ( ) if token . typ != exp { p . errorf ( "unexpected %s in %s, expected %s" , token . desc ( ) , context , exp . desc ( ) ) } return token }
940	func ( d * Driver ) newAzureClient ( ) ( * azureutil . AzureClient , error ) { env , ok := environments [ d . Environment ] if ! ok { valid := make ( [ ] string , 0 , len ( environments ) ) for k := range environments { valid = append ( valid , k ) } return nil , fmt . Errorf ( "Invalid Azure environment: %q, supported values: %s" , d . Environment , strings . Join ( valid , ", " ) ) } var ( token * azure . ServicePrincipalToken err error ) if d . ClientID != "" && d . ClientSecret != "" { log . Debug ( "Using Azure service principal authentication." ) token , err = azureutil . AuthenticateServicePrincipal ( env , d . SubscriptionID , d . ClientID , d . ClientSecret ) if err != nil { return nil , fmt . Errorf ( "Failed to authenticate using service principal credentials: %+v" , err ) } } else { log . Debug ( "Using Azure device flow authentication." ) token , err = azureutil . AuthenticateDeviceFlow ( env , d . SubscriptionID ) if err != nil { return nil , fmt . Errorf ( "Error creating Azure client: %v" , err ) } } return azureutil . New ( env , d . SubscriptionID , token ) , nil }
6156	func ( w * Worker ) AgentAfterOfferingMsgBCPublish ( job * data . Job ) error { logger := w . logger . Add ( "method" , "AgentAfterOfferingMsgBCPublish" , "job" , job ) offering , err := w . relatedOffering ( logger , job , data . JobAgentAfterOfferingMsgBCPublish ) if err != nil { return err } ethLog , err := w . ethLog ( logger , job ) if err != nil { return err } logger = logger . Add ( "ethLog" , ethLog ) offering . Status = data . OfferRegistered offering . BlockNumberUpdated = ethLog . Block if err = w . db . Update ( offering ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } agent , err := w . account ( logger , offering . Agent ) if err != nil { return err } return w . addJob ( logger , nil , data . JobAccountUpdateBalances , data . JobAccount , agent . ID ) }
5590	func ( o * FindVmsByFiltersParams ) WithContext ( ctx context . Context ) * FindVmsByFiltersParams { o . SetContext ( ctx ) return o }
2132	func ( s Status ) String ( ) string { str := StatusToString ( s ) str = strings . Replace ( str , "CAIRO_STATUS_" , "" , 1 ) str = strings . Replace ( str , "_" , " " , 0 ) return strings . ToLower ( str ) }
3891	func ( b * builder ) arrayLen ( fn * Function , elts [ ] ast . Expr ) int64 { var max int64 = - 1 var i int64 = - 1 for _ , e := range elts { if kv , ok := e . ( * ast . KeyValueExpr ) ; ok { i = b . expr ( fn , kv . Key ) . ( * Const ) . Int64 ( ) } else { i ++ } if i > max { max = i } } return max + 1 }
5688	func ( st * state ) javaResource ( ) AST { off := st . off ln := st . number ( ) if ln <= 1 { st . failEarlier ( "java resource length less than 1" , st . off - off ) } if len ( st . str ) == 0 || st . str [ 0 ] != '_' { st . fail ( "expected _ after number" ) } st . advance ( 1 ) ln -- if len ( st . str ) < ln { st . fail ( "not enough characters for java resource length" ) } str := st . str [ : ln ] final := "" st . advance ( ln ) for i := 0 ; i < len ( str ) ; i ++ { if str [ i ] != '$' { final += string ( str [ i ] ) } else { if len ( str ) <= i + 1 { st . failEarlier ( "java resource escape at end of string" , 1 ) } i ++ r , ok := map [ byte ] string { 'S' : "/" , '_' : "." , '$' : "$" , } [ str [ i ] ] if ! ok { st . failEarlier ( "unrecognized java resource escape" , ln - i - 1 ) } final += r } } return & Special { Prefix : "java resource " , Val : & Name { Name : final } } }
3195	func GetStringOk ( v * string ) ( string , bool ) { if v != nil { return * v , true } return "" , false }
5070	func ( r * Render ) Validate ( ) { if ! strings . HasSuffix ( r . TemplatesDir , "/" ) { r . TemplatesDir = r . TemplatesDir + "/" } if ok , _ := exists ( r . TemplatesDir ) ; ! ok { panic ( r . TemplatesDir + " directory for rendering templates does not exist.\n Configure this by setting htmlRender.TemplatesDir = \"your-tpl-dir/\"" ) } \n \" }
711	func NewAlibabaCloudProvider ( configFile string , domainFilter DomainFilter , zoneIDFileter ZoneIDFilter , zoneType string , dryRun bool ) ( * AlibabaCloudProvider , error ) { cfg := alibabaCloudConfig { } if configFile != "" { contents , err := ioutil . ReadFile ( configFile ) if err != nil { return nil , fmt . Errorf ( "Failed to read Alibaba Cloud config file '%s': %v" , configFile , err ) } err = yaml . Unmarshal ( contents , & cfg ) if err != nil { return nil , fmt . Errorf ( "Failed to parse Alibaba Cloud config file '%s': %v" , configFile , err ) } } else { var tmpError error cfg , tmpError = getCloudConfigFromStsToken ( ) if tmpError != nil { return nil , fmt . Errorf ( "Failed to getCloudConfigFromStsToken: %v" , tmpError ) } } var dnsClient AlibabaCloudDNSAPI var err error if cfg . RoleName == "" { dnsClient , err = alidns . NewClientWithAccessKey ( cfg . RegionID , cfg . AccessKeyID , cfg . AccessKeySecret , ) } else { dnsClient , err = alidns . NewClientWithStsToken ( cfg . RegionID , cfg . AccessKeyID , cfg . AccessKeySecret , cfg . StsToken , ) } if err != nil { return nil , fmt . Errorf ( "failed to create Alibaba Cloud DNS client: %v" , err ) } var pvtzClient AlibabaCloudPrivateZoneAPI if cfg . RoleName == "" { pvtzClient , err = pvtz . NewClientWithAccessKey ( "cn-hangzhou" , cfg . AccessKeyID , cfg . AccessKeySecret , ) } else { pvtzClient , err = pvtz . NewClientWithStsToken ( cfg . RegionID , cfg . AccessKeyID , cfg . AccessKeySecret , cfg . StsToken , ) } if err != nil { return nil , err } provider := & AlibabaCloudProvider { domainFilter : domainFilter , zoneIDFilter : zoneIDFileter , vpcID : cfg . VPCID , dryRun : dryRun , dnsClient : dnsClient , pvtzClient : pvtzClient , privateZone : zoneType == "private" , } if cfg . RoleName != "" { provider . setNextExpire ( cfg . ExpireTime ) go provider . refreshStsToken ( 1 * time . Second ) } return provider , nil }
5835	func ( a * API ) CreateDashboard ( cfg * Dashboard ) ( * Dashboard , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid dashboard config [nil]" ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] create dashboard, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Post ( config . DashboardPrefix , jsonCfg ) if err != nil { return nil , err } dashboard := & Dashboard { } if err := json . Unmarshal ( result , dashboard ) ; err != nil { return nil , err } return dashboard , nil }
5601	func ( o * AddVMParams ) WithTimeout ( timeout time . Duration ) * AddVMParams { o . SetTimeout ( timeout ) return o }
3574	func ( t * ThresholdCount ) GetOk ( ) json . Number { if t == nil || t . Ok == nil { return "" } return * t . Ok }
3063	func validateAndWrapHandlers ( handlers [ ] Handler , wrappers ... func ( Handler ) Handler ) [ ] Handler { var wrapper func ( Handler ) Handler if len ( wrappers ) > 0 { wrapper = wrappers [ 0 ] } wrappedHandlers := make ( [ ] Handler , len ( handlers ) ) for i , h := range handlers { h = validateAndWrapHandler ( h ) if wrapper != nil && ! inject . IsFastInvoker ( h ) { h = wrapper ( h ) } wrappedHandlers [ i ] = h } return wrappedHandlers }
3611	func ( t * TimeseriesDefinition ) GetShowLegendOk ( ) ( bool , bool ) { if t == nil || t . ShowLegend == nil { return false , false } return * t . ShowLegend , true }
2864	func parseVersionFromAboutInfo ( info types . AboutInfo ) VSphereVersion { v , err := parseVersion ( info . Name , info . Version , info . Build ) if err != nil { panic ( err ) } return v }
2779	func Update ( rp * object . ResourcePool , name string , spec * types . ResourceConfigSpec ) error { log . Printf ( "[DEBUG] Updating resource pool %q" , fmt . Sprintf ( "%s" , rp . InventoryPath ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return rp . UpdateConfig ( ctx , name , spec ) }
2833	func resourceVSphereComputeClusterVMAntiAffinityRuleFlattenID ( cluster * object . ClusterComputeResource , key int32 ) ( string , error ) { clusterID := cluster . Reference ( ) . Value return strings . Join ( [ ] string { clusterID , strconv . Itoa ( int ( key ) ) } , ":" ) , nil }
5261	func OptClientConnectTimeout ( timeout time . Duration ) ClientOption { return func ( options * ClientOptions ) error { options . ConnectTimeout = timeout return nil } }
2698	func NewConfig ( d * schema . ResourceData ) ( * Config , error ) { server := d . Get ( "vsphere_server" ) . ( string ) if server == "" { server = d . Get ( "vcenter_server" ) . ( string ) } if server == "" { return nil , fmt . Errorf ( "one of vsphere_server or [deprecated] vcenter_server must be provided" ) } c := & Config { User : d . Get ( "user" ) . ( string ) , Password : d . Get ( "password" ) . ( string ) , InsecureFlag : d . Get ( "allow_unverified_ssl" ) . ( bool ) , VSphereServer : server , Debug : d . Get ( "client_debug" ) . ( bool ) , DebugPathRun : d . Get ( "client_debug_path_run" ) . ( string ) , DebugPath : d . Get ( "client_debug_path" ) . ( string ) , Persist : d . Get ( "persist_session" ) . ( bool ) , VimSessionPath : d . Get ( "vim_session_path" ) . ( string ) , RestSessionPath : d . Get ( "rest_session_path" ) . ( string ) , } return c , nil }
2809	func expandVmwareDistributedVirtualSwitchTrunkVlanSpec ( d * schema . ResourceData ) * types . VmwareDistributedVirtualSwitchTrunkVlanSpec { var ranges [ ] types . NumericRange data := d . Get ( "vlan_range" ) . ( * schema . Set ) . List ( ) for _ , v := range data { log . Printf ( "[DEBUG] processing range: %#v" , v ) r := v . ( map [ string ] interface { } ) min := r [ "min_vlan" ] . ( int ) max := r [ "max_vlan" ] . ( int ) rng := types . NumericRange { Start : int32 ( min ) , End : int32 ( max ) , } ranges = append ( ranges , rng ) } if len ( ranges ) < 1 { return nil } obj := & types . VmwareDistributedVirtualSwitchTrunkVlanSpec { VlanId : ranges , } return obj }
894	func ( d * Driver ) GetState ( ) ( state . State , error ) { c , err := newComputeUtil ( d ) if err != nil { return state . None , err } instance , _ := c . instance ( ) if instance == nil { disk , _ := c . disk ( ) if disk == nil { return state . None , nil } return state . Stopped , nil } switch instance . Status { case "PROVISIONING" , "STAGING" : return state . Starting , nil case "RUNNING" : return state . Running , nil case "STOPPING" , "STOPPED" , "TERMINATED" : return state . Stopped , nil } return state . None , nil }
3752	func ( w * WidgetProcessQuery ) GetSearchByOk ( ) ( string , bool ) { if w == nil || w . SearchBy == nil { return "" , false } return * w . SearchBy , true }
4426	func ( u * MAC ) DeepCopy ( ) * MAC { if u == nil { return nil } out := new ( MAC ) u . DeepCopyInto ( out ) return out }
7056	func ( r * Router ) Handle ( pattern string , handlers ... interface { } ) * Router { c := r . pattern ( pattern ) clone := r . clone ( c ) clone . handle ( handlers ) return clone }
5795	func ( a * API ) DeleteOutlierReport ( cfg * OutlierReport ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid outlier report config [nil]" ) } return a . DeleteOutlierReportByCID ( CIDType ( & cfg . CID ) ) }
5195	func ( s * Schema ) HasIndex ( indexName string ) bool { _ , ok := s . indexes [ indexName ] return ok }
1247	func signRequestFunc ( url , region string , credentialProvider * credentials . Credentials ) wsclient . MakeRequestHookFunc { return func ( payload [ ] byte ) ( [ ] byte , error ) { reqBody := bytes . NewReader ( payload ) request , err := http . NewRequest ( "GET" , url , reqBody ) if err != nil { return nil , err } err = utils . SignHTTPRequest ( request , region , "ecs" , credentialProvider , reqBody ) if err != nil { return nil , err } request . Header . Add ( "Host" , request . Host ) var dataBuffer bytes . Buffer request . Header . Write ( & dataBuffer ) io . WriteString ( & dataBuffer , "\r\n" ) \r \n data := dataBuffer . Bytes ( ) } }
5554	func BuildAndRunDirWithGoBuildTags ( dir string , filters [ ] string , goBuildTags string ) error { return buildAndRunDir ( dir , filters , goBuildTags ) }
553	func ( x * Context ) URLParam ( key string ) string { for k := len ( x . URLParams . Keys ) - 1 ; k >= 0 ; k -- { if x . URLParams . Keys [ k ] == key { return x . URLParams . Values [ k ] } } return "" }
1850	func ( eventStream * EventStream ) Unsubscribe ( name string ) { eventStream . handlersLock . Lock ( ) defer eventStream . handlersLock . Unlock ( ) for handler := range eventStream . handlers { if handler == name { seelog . Debugf ( "Unsubscribing event handler %s from event stream %s" , handler , eventStream . name ) delete ( eventStream . handlers , handler ) return } } }
448	func ( s * Server ) ListenAndServeTLS ( addr , certFile , keyFile string ) error { ln , err := net . Listen ( "tcp4" , addr ) if err != nil { return err } if s . TCPKeepalive { if tcpln , ok := ln . ( * net . TCPListener ) ; ok { return s . ServeTLS ( tcpKeepaliveListener { TCPListener : tcpln , keepalivePeriod : s . TCPKeepalivePeriod , } , certFile , keyFile ) } } return s . ServeTLS ( ln , certFile , keyFile ) }
2967	func DiskMigrateRelocateOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . VirtualMachineRelocateSpecDiskLocator , bool , error ) { log . Printf ( "[DEBUG] DiskMigrateRelocateOperation: Generating any necessary disk relocate specs" ) ods , nds := d . GetChange ( subresourceTypeDisk ) var relocators [ ] types . VirtualMachineRelocateSpecDiskLocator var relocateOK bool for ni , ne := range nds . ( [ ] interface { } ) { nm := ne . ( map [ string ] interface { } ) var name string var err error if name , err = diskLabelOrName ( nm ) ; err != nil { return nil , false , fmt . Errorf ( "disk.%d: %s" , ni , err ) } if name == diskDeletedName || name == diskDetachedName { continue } for _ , oe := range ods . ( [ ] interface { } ) { om := oe . ( map [ string ] interface { } ) if nm [ "uuid" ] == om [ "uuid" ] { if nm [ "datastore_id" ] == om [ "datastore_id" ] && ! d . HasChange ( "datastore_id" ) { break } relocateOK = true if nm [ "datastore_id" ] == "" || nm [ "datastore_id" ] == diskDatastoreComputedName { break } r := NewDiskSubresource ( c , d , nm , om , ni ) relocator , err := r . Relocate ( l , false ) if err != nil { return nil , false , fmt . Errorf ( "%s: %s" , r . Addr ( ) , err ) } if d . Get ( "datastore_id" ) . ( string ) == relocator . Datastore . Value { log . Printf ( "[DEBUG] %s: Datastore in spec is same as default, dropping in favor of implicit relocation" , r . Addr ( ) ) break } relocators = append ( relocators , relocator ) } } } if ! relocateOK { log . Printf ( "[DEBUG] DiskMigrateRelocateOperation: Disk relocation not necessary" ) return nil , false , nil } log . Printf ( "[DEBUG] DiskMigrateRelocateOperation: Disk relocator list: %s" , diskRelocateListString ( relocators ) ) log . Printf ( "[DEBUG] DiskMigrateRelocateOperation: Disk relocator generation complete" ) return relocators , true , nil }
869	func ( kp * KeyPair ) Fingerprint ( ) string { b , _ := base64 . StdEncoding . DecodeString ( string ( kp . PublicKey ) ) h := md5 . New ( ) io . WriteString ( h , string ( b ) ) return fmt . Sprintf ( "%x" , h . Sum ( nil ) ) }
4355	func Number ( in [ ] byte , pos int ) ( int , error ) { pos , err := skipSpace ( in , pos ) if err != nil { return 0 , err } max := len ( in ) for { v := in [ pos ] switch v { case '-' , '+' , '.' , 'e' , 'E' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' : pos ++ default : return pos , nil } if pos >= max { return pos , nil } } return pos , nil }
4643	func newGeoIndex ( resolution Meters , newEntry func ( ) interface { } ) * geoIndex { return & geoIndex { resolution , make ( map [ cell ] interface { } ) , newEntry } }
709	func ( p * RcodeZeroProvider ) NewRcodezeroChanges ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * rc0 . RRSetChange { changes := make ( [ ] * rc0 . RRSetChange , 0 , len ( endpoints ) ) for _ , _endpoint := range endpoints { changes = append ( changes , p . NewRcodezeroChange ( action , _endpoint ) ) } return changes }
1656	func ( m * MockTaskResource ) SetAppliedStatus ( arg0 status0 . ResourceStatus ) bool { ret := m . ctrl . Call ( m , "SetAppliedStatus" , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 }
6260	func ( h * Handler ) CreateOffering ( tkn string , offering * data . Offering ) ( * string , error ) { logger := h . logger . Add ( "method" , "CreateOffering" , "offering" , offering ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } err := h . prepareOffering ( logger , offering ) if err != nil { return nil , err } err = insert ( logger , h . db . Querier , offering ) if err != nil { return nil , err } return & offering . ID , nil }
4924	func ( w * Writer ) WriteB ( b byte ) { if w . err != nil { return } w . wr . WriteByte ( b ) }
3740	func ( w * WidgetApmOrLogQuery ) GetSearchOk ( ) ( ApmOrLogQuerySearch , bool ) { if w == nil || w . Search == nil { return ApmOrLogQuerySearch { } , false } return * w . Search , true }
829	func NewVBoxManager ( ) * VBoxCmdManager { return & VBoxCmdManager { runCmd : func ( cmd * exec . Cmd ) error { return cmd . Run ( ) } , } }
2806	func MoveHostsOutOf ( cluster * object . ClusterComputeResource , hosts [ ] * object . HostSystem , timeout int ) error { for _ , host := range hosts { if err := moveHostOutOf ( cluster , host , timeout ) ; err != nil { return err } } return nil }
6784	func ( c HubConfig ) GetInt ( key string , defval int ) int { val , ok := c [ key ] if ok { i , ok := val . ( int ) if ok { return i } s := c . GetString ( key , "" ) if len ( s ) > 0 { i , err := strconv . Atoi ( s ) if err != nil { return defval } return i } } return defval }
4626	func ( a * alphabet ) Index ( t string ) ( int64 , error ) { for i , char := range a . chars { if char == t { return int64 ( i ) , nil } } return 0 , fmt . Errorf ( "Element '%v' is not part of the alphabet" , t ) }
6423	func ( q * Queue ) Enumerate ( cancel <- chan struct { } ) Enumerator { q . key . RLock ( ) defer q . key . RUnlock ( ) return q . underlyer . Enumerate ( cancel ) }
1456	func NewContainerWithSteadyState ( steadyState apicontainerstatus . ContainerStatus ) * Container { steadyStateStatus := steadyState return & Container { SteadyStateStatusUnsafe : & steadyStateStatus , } }
1454	func v1HandlersSetup ( serverMux * http . ServeMux , containerInstanceArn * string , taskEngine handlersutils . DockerStateResolver , cfg * config . Config ) { serverMux . HandleFunc ( v1 . AgentMetadataPath , v1 . AgentMetadataHandler ( containerInstanceArn , cfg ) ) serverMux . HandleFunc ( v1 . TaskContainerMetadataPath , v1 . TaskContainerMetadataHandler ( taskEngine ) ) serverMux . HandleFunc ( v1 . LicensePath , v1 . LicenseHandler ) }
1518	func ( imageManager * dockerImageManager ) RecordContainerReference ( container * apicontainer . Container ) error { defer imageManager . saver . ForceSave ( ) if container . ImageID != "" { if ! imageManager . addContainerReferenceToExistingImageState ( container ) { return fmt . Errorf ( "Failed to add container to existing image state" ) } return nil } if container . Image == "" { return fmt . Errorf ( "Invalid container reference: Empty image name" ) } imageInspected , err := imageManager . client . InspectImage ( container . Image ) if err != nil { seelog . Errorf ( "Error inspecting image %v: %v" , container . Image , err ) return err } container . ImageID = imageInspected . ID added := imageManager . addContainerReferenceToExistingImageState ( container ) if ! added { imageManager . addContainerReferenceToNewImageState ( container , imageInspected . Size ) } return nil }
5532	func NewLuaObjectFromValue ( L * lua . State , val interface { } ) * LuaObject { GoToLua ( L , val ) return NewLuaObject ( L , - 1 ) }
4766	func BytesMap ( f func ( byte ) byte , data [ ] byte ) [ ] byte { size := len ( data ) result := make ( [ ] byte , size , size ) for i := 0 ; i < size ; i ++ { result [ i ] = f ( data [ i ] ) } return result }
2812	func flattenVmwareDistributedVirtualSwitchPvlanSpec ( d * schema . ResourceData , obj * types . VmwareDistributedVirtualSwitchPvlanSpec ) error { d . Set ( "port_private_secondary_vlan_id" , obj . PvlanId ) return nil }
193	func NewAdapter ( ctx context . Context , file string , name string , d discovery . Discoverer , logger log . Logger ) * Adapter { return & Adapter { ctx : ctx , disc : d , groups : make ( map [ string ] * customSD ) , manager : discovery . NewManager ( ctx , logger ) , output : file , name : name , logger : logger , } }
6615	func NewCmdWithRunner ( cmdName string , runner func ( ) ) ( * CmdWithRunner , error ) { if cmdName == "" { return nil , errors . New ( "cmdName cannot be blank" ) } for _ , r := range cmdName { if unicode . IsSpace ( r ) { return nil , errors . Errorf ( "cmdName cannot contain whitespace: %q" , cmdName ) } } return & CmdWithRunner { cmdName : cmdName , runner : runner , } , nil }
779	func ( in * DNSEndpointStatus ) DeepCopy ( ) * DNSEndpointStatus { if in == nil { return nil } out := new ( DNSEndpointStatus ) in . DeepCopyInto ( out ) return out }
1724	func ( task * Task ) DockerConfig ( container * apicontainer . Container , apiVersion dockerclient . DockerVersion ) ( * dockercontainer . Config , * apierrors . DockerClientConfigError ) { return task . dockerConfig ( container , apiVersion ) }
1594	func ( m * MockSecretsManagerAPI ) GetSecretValueWithContext ( arg0 aws . Context , arg1 * secretsmanager . GetSecretValueInput , arg2 ... request . Option ) ( * secretsmanager . GetSecretValueOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "GetSecretValueWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6359	func causer ( e * errorT ) Error { if e . err == nil { return e } return & causerT { errorT : e , } }
1748	func ( task * Task ) GetStopSequenceNumber ( ) int64 { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . StopSequenceNumber }
5806	func ( a * API ) UpdateAcknowledgement ( cfg * Acknowledgement ) ( * Acknowledgement , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid acknowledgement config [nil]" ) } acknowledgementCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . AcknowledgementCIDRegex , acknowledgementCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid acknowledgement CID [%s]" , acknowledgementCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] acknowledgement update, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( acknowledgementCID , jsonCfg ) if err != nil { return nil , err } acknowledgement := & Acknowledgement { } if err := json . Unmarshal ( result , acknowledgement ) ; err != nil { return nil , err } return acknowledgement , nil }
4379	func MACValue ( v * strfmt . MAC ) strfmt . MAC { if v == nil { return strfmt . MAC ( "" ) } return * v }
4114	func ( b * BarChart ) SetShowTitles ( show bool ) { b . mtx . Lock ( ) defer b . mtx . Unlock ( ) b . showTitles = show }
6090	func ( q * queue ) Subscribe ( subKeys [ ] string , subID string , subFunc SubFunc ) error { q . subsMtx . Lock ( ) defer q . subsMtx . Unlock ( ) for i , v := range subKeys { if err := q . subscribe ( v , subID , subFunc ) ; err != nil { for j := 0 ; j < i ; j ++ { q . unsubscribe ( subKeys [ j ] , subID ) } return err } } return nil }
6621	func CmderWithPrependedArgs ( r Cmder , prependedArgs ... string ) Cmder { return & wrappedCmder { inner : r , prependedArgs : prependedArgs , } }
2921	func ReadSCSIBusSharing ( l object . VirtualDeviceList , count int ) string { ctlrs := make ( [ ] types . BaseVirtualSCSIController , count ) for _ , dev := range l { if sc , ok := dev . ( types . BaseVirtualSCSIController ) ; ok && sc . GetVirtualSCSIController ( ) . BusNumber < int32 ( count ) { ctlrs [ sc . GetVirtualSCSIController ( ) . BusNumber ] = sc } } log . Printf ( "[DEBUG] ReadSCSIBusSharing: SCSI controller layout for first %d controllers: %s" , count , scsiControllerListString ( ctlrs ) ) if ctlrs [ 0 ] == nil { return subresourceControllerSharingUnknown } last := ctlrs [ 0 ] . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus for _ , ctlr := range ctlrs [ 1 : ] { if ctlr == nil || ctlr . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus != last { return subresourceControllerSharingMixed } } return string ( last ) }
5363	func ( gs * GShadow ) Add ( key [ ] byte ) ( err error ) { loadConfig ( ) gshadow , err := LookupGShadow ( gs . Name ) if err != nil { if _ , ok := err . ( NoFoundError ) ; ! ok { return } } if gshadow != nil { return ErrGroupExist } if gs . Name == "" { return RequiredError ( "Name" ) } if err = backup ( _GSHADOW_FILE ) ; err != nil { return } db , err := openDBFile ( _GSHADOW_FILE , os . O_WRONLY | os . O_APPEND ) if err != nil { return } defer func ( ) { e := db . close ( ) if e != nil && err == nil { err = e } } ( ) if key != nil { gs . password , _ = config . crypter . Generate ( key , nil ) } else { gs . password = "*" } _ , err = db . file . WriteString ( gs . String ( ) ) return }
4777	func LoadJSON ( conf interface { } , configPaths ... string ) error { return loadWithFunc ( conf , configPaths , nil , json . Unmarshal ) }
6382	func ( iter Enumerator ) Select ( transform Transform ) Enumerator { retval := make ( chan interface { } ) go func ( ) { for item := range iter { retval <- transform ( item ) } close ( retval ) } ( ) return retval }
2816	func flattenDVSFailureCriteria ( d * schema . ResourceData , obj * types . DVSFailureCriteria ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , "check_beacon" , obj . CheckBeacon ) return nil }
965	func ( v * View ) poll ( viewCh chan <- * View , errCh chan <- error ) { var retries int for { doneCh := make ( chan struct { } , 1 ) successCh := make ( chan struct { } , 1 ) fetchErrCh := make ( chan error , 1 ) go v . fetch ( doneCh , successCh , fetchErrCh ) WAIT : select { case <- doneCh : retries = 0 log . Printf ( "[TRACE] (view) %s received data" , v . dependency ) select { case <- v . stopCh : return case viewCh <- v : } if v . once { return } case <- successCh : log . Printf ( "[TRACE] (view) %s successful contact, resetting retries" , v . dependency ) retries = 0 goto WAIT case err := <- fetchErrCh : if v . retryFunc != nil { retry , sleep := v . retryFunc ( retries ) if retry { log . Printf ( "[WARN] (view) %s (retry attempt %d after %q)" , err , retries + 1 , sleep ) select { case <- time . After ( sleep ) : retries ++ continue case <- v . stopCh : return } } } log . Printf ( "[ERR] (view) %s (exceeded maximum retries)" , err ) select { case <- v . stopCh : return case errCh <- err : return } case <- v . stopCh : log . Printf ( "[TRACE] (view) %s stopping poll (received on view stopCh)" , v . dependency ) return } } }
1851	func ( eventStream * EventStream ) WriteToEventStream ( event interface { } ) error { eventStream . statusLock . RLock ( ) defer eventStream . statusLock . RUnlock ( ) if ! eventStream . open { return fmt . Errorf ( "Event stream is closed" ) } eventStream . event <- event return nil }
5848	func ( a * API ) DeleteRuleSet ( cfg * RuleSet ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid rule set config [nil]" ) } return a . DeleteRuleSetByCID ( CIDType ( & cfg . CID ) ) }
2838	func CdromSubresourceSchema ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { "datastore_id" : { Type : schema . TypeString , Optional : true , Description : "The datastore ID the ISO is located on." , } , "path" : { Type : schema . TypeString , Optional : true , Description : "The path to the ISO file on the datastore." , } , "client_device" : { Type : schema . TypeBool , Optional : true , Description : "Indicates whether the device should be mapped to a remote client device" , } , } structure . MergeSchema ( s , subresourceSchema ( ) ) return s }
1827	func ( mtask * managedTask ) waitEvent ( stopWaiting <- chan struct { } ) bool { seelog . Debugf ( "Managed task [%s]: waiting for event for task" , mtask . Arn ) select { case acsTransition := <- mtask . acsMessages : seelog . Debugf ( "Managed task [%s]: got acs event" , mtask . Arn ) mtask . handleDesiredStatusChange ( acsTransition . desiredStatus , acsTransition . seqnum ) return false case dockerChange := <- mtask . dockerMessages : seelog . Debugf ( "Managed task [%s]: got container [%s] event: [%s]" , mtask . Arn , dockerChange . container . Name , dockerChange . event . Status . String ( ) ) mtask . handleContainerChange ( dockerChange ) return false case resChange := <- mtask . resourceStateChangeEvent : res := resChange . resource seelog . Debugf ( "Managed task [%s]: got resource [%s] event: [%s]" , mtask . Arn , res . GetName ( ) , res . StatusString ( resChange . nextState ) ) mtask . handleResourceStateChange ( resChange ) return false case <- stopWaiting : seelog . Debugf ( "Managed task [%s]: no longer waiting" , mtask . Arn ) return true } }
4133	func NewNetworkNumber ( ip net . IP ) NetworkNumber { if ip == nil { return nil } coercedIP := ip . To4 ( ) parts := 1 if coercedIP == nil { coercedIP = ip . To16 ( ) parts = 4 } if coercedIP == nil { return nil } nn := make ( NetworkNumber , parts ) for i := 0 ; i < parts ; i ++ { idx := i * net . IPv4len nn [ i ] = binary . BigEndian . Uint32 ( coercedIP [ idx : idx + net . IPv4len ] ) } return nn }
3694	func ( w * Widget ) GetMustShowDistribution ( ) bool { if w == nil || w . MustShowDistribution == nil { return false } return * w . MustShowDistribution }
1649	func ( m * MockTaskResource ) Cleanup ( ) error { ret := m . ctrl . Call ( m , "Cleanup" ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
3695	func ( w * Widget ) GetMustShowDistributionOk ( ) ( bool , bool ) { if w == nil || w . MustShowDistribution == nil { return false , false } return * w . MustShowDistribution , true }
4691	func findIncludePaths ( data [ ] byte , opts * Options , f * File ) ( [ ] string , error ) { var includePaths [ ] string for i , str := range strings . Split ( formatLF ( string ( data ) ) , lf ) { ln := newLine ( i + 1 , str , opts , f ) if ln . isHelperMethodOf ( helperMethodNameInclude ) { if len ( ln . tokens ) < 3 { return nil , fmt . Errorf ( "no template name is specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } includePaths = append ( includePaths , ln . tokens [ 2 ] ) } } return includePaths , nil }
517	func ( h * ResponseHeader ) PeekBytes ( key [ ] byte ) [ ] byte { h . bufKV . key = append ( h . bufKV . key [ : 0 ] , key ... ) normalizeHeaderKey ( h . bufKV . key , h . disableNormalizing ) return h . peek ( h . bufKV . key ) }
1144	func ( m * MockTaskEngine ) MustInit ( arg0 context . Context ) { m . ctrl . Call ( m , "MustInit" , arg0 ) }
1659	func ( m * MockTaskResource ) SetDesiredStatus ( arg0 status0 . ResourceStatus ) { m . ctrl . Call ( m , "SetDesiredStatus" , arg0 ) }
5087	func ( e * StructErrors ) Error ( ) string { buff := bytes . NewBufferString ( fmt . Sprintf ( structErrMsg , e . Struct ) ) for _ , err := range e . Errors { buff . WriteString ( err . Error ( ) ) buff . WriteString ( "\n" ) } \n for _ , err := range e . StructErrors { buff . WriteString ( err . Error ( ) ) } }
2387	func ( f * Field ) flushableLine ( j int ) bool { for i := 0 ; i < fieldBlockNumX ; i ++ { if f . blocks [ i ] [ j ] == BlockTypeNone { return false } } return true }
3755	func ( y * Yaxis ) GetIncludeUnitsOk ( ) ( bool , bool ) { if y == nil || y . IncludeUnits == nil { return false , false } return * y . IncludeUnits , true }
1232	func ( client * cniClient ) del ( runtimeConfig libcni . RuntimeConf , cfg * Config , pluginConfigFunc func ( * Config ) ( string , * libcni . NetworkConfig , error ) ) error { deviceName , networkConfig , err := pluginConfigFunc ( cfg ) if err != nil { return err } runtimeConfig . IfName = deviceName return client . libcni . DelNetwork ( networkConfig , & runtimeConfig ) }
2163	func ( v * ActionMap ) RemoveAction ( actionName string ) { C . g_action_map_remove_action ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) }
321	func ( b * BufferedSeriesIterator ) Seek ( t int64 ) bool { t0 := t - b . buf . delta if t0 > b . lastTime { b . buf . reset ( ) b . ok = b . it . Seek ( t0 ) if ! b . ok { return false } b . lastTime , _ = b . Values ( ) } if b . lastTime >= t { return true } for b . Next ( ) { if b . lastTime >= t { return true } } return false }
4559	func ( h * HelperMap ) AddMany ( helpers map [ string ] interface { } ) error { for k , v := range helpers { err := h . Add ( k , v ) if err != nil { return err } } return nil }
6976	func ( mr * Reader ) Get ( ext string ) string { var err error if len ( ext ) == 0 { return "" } if ext [ 0 ] == '.' { ext = ext [ 1 : ] } mr . mu . Lock ( ) defer mr . mu . Unlock ( ) if mr . mimetypes == nil { mr . mimetypes , err = readMimetypes ( mr . filename ) if err != nil { if mime , ok := fallback [ ext ] ; ok { return mime } return "" } } if mime , ok := mr . mimetypes [ ext ] ; ok { return mime } if mime , ok := fallback [ ext ] ; ok { return mime } return "" }
204	func ( m * Manager ) Stop ( ) { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) level . Info ( m . logger ) . Log ( "msg" , "Stopping rule manager..." ) for _ , eg := range m . groups { eg . stop ( ) } level . Info ( m . logger ) . Log ( "msg" , "Rule manager stopped" ) }
7173	func OpenStack ( filename string ) ( * Stack , error ) { file , err := os . OpenFile ( filename , os . O_CREATE | os . O_RDWR , 0755 ) if err != nil { return nil , err } return NewStack ( file ) }
3048	func newVimSession ( ctx context . Context , u * url . URL , insecure bool ) ( * govmomi . Client , error ) { logger . Printf ( "[DEBUG] Creating new SOAP API session on endpoint %s" , u . Host ) client , err := govmomi . NewClient ( ctx , u , insecure ) if err != nil { return nil , fmt . Errorf ( "error setting up new vSphere SOAP client: %s" , err ) } logger . Println ( "[DEBUG] SOAP API session creation successful" ) return client , nil }
2197	func ( v * InitiallyUnowned ) Native ( ) uintptr { if v == nil || v . Object == nil { return uintptr ( unsafe . Pointer ( nil ) ) } return v . Object . Native ( ) }
35	func ( c * Client ) Describe ( ch chan <- * prometheus . Desc ) { ch <- c . ignoredSamples . Desc ( ) }
6307	func ( s * prefixPipeline ) AssetUrl ( name string ) ( url string , err error ) { url , err = s . AssetPipeline . AssetUrl ( name ) if err == nil { url = s . prefix + url } return }
6988	func CertAtuh ( ctx * neptulon . ReqCtx ) error { if _ , ok := ctx . Session . GetOk ( "userid" ) ; ok { return ctx . Next ( ) } return ctx . Next ( ) }
1614	func ( m * MockSecretsManagerAPI ) RotateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . RotateSecretInput , arg2 ... request . Option ) ( * secretsmanager . RotateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "RotateSecretWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
799	func ( c * defaultDiskCreator ) Create ( size int , publicSSHKeyPath , diskPath string ) error { log . Debugf ( "Creating %d MB hard disk image..." , size ) tarBuf , err := mcnutils . MakeDiskImage ( publicSSHKeyPath ) if err != nil { return err } log . Debug ( "Calling inner createDiskImage" ) return createDiskImage ( diskPath , size , tarBuf ) }
2344	func Touches ( ) [ ] Touch { var ts [ ] Touch for _ , id := range TouchIDs ( ) { x , y := TouchPosition ( id ) ts = append ( ts , & touch { id : id , x : x , y : y , } ) } return ts }
4402	func ( b * Base64 ) UnmarshalJSON ( data [ ] byte ) error { l := jlexer . Lexer { Data : data } b . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
78	func ( s * Storage ) Close ( ) error { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) for _ , q := range s . queues { q . Stop ( ) } return nil }
4519	func ( s * SortFilter ) RunFilter ( arg Arg ) error { state := sortState { s . cmp , nil } for item := range arg . In { state . data = append ( state . data , item ) } sort . Sort ( state ) for _ , item := range state . data { arg . Out <- item } return nil }
5020	func ( s * Session ) DB ( name string ) * Database { if name == "" { name = s . defaultdb } return & Database { s , name } }
4767	func BytesFilter ( f func ( byte ) bool , data [ ] byte ) [ ] byte { result := make ( [ ] byte , 0 , 0 ) for _ , element := range data { if f ( element ) { result = append ( result , element ) } } return result }
4991	func ( e Error ) Error ( ) string { return fmt . Sprintf ( "%s: %q => %s" , e . Err , e . Debug , e . Stderr ) }
5615	func MustLoadCodec ( bank string ) * WordCodec { codec , err := LoadCodec ( bank ) if err != nil { panic ( err ) } return codec }
885	func ( d * SerialDriver ) Stop ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Stop ( ) }
124	func ( p * parser ) next ( ) item { if p . peekCount > 0 { p . peekCount -- } else { t := p . lex . nextItem ( ) for t . typ == ItemComment { t = p . lex . nextItem ( ) } p . token [ 0 ] = t } if p . token [ p . peekCount ] . typ == ItemError { p . errorf ( "%s" , p . token [ p . peekCount ] . val ) } return p . token [ p . peekCount ] }
6102	func ( p * Processor ) TerminateChannel ( id , jobCreator string , agent bool ) ( string , error ) { var jobType string if agent { jobType = data . JobAgentPreServiceTerminate } else { jobType = data . JobClientPreServiceTerminate } return p . alterServiceStatus ( id , jobCreator , jobType , jobType , terminateTransitions , true ) }
4212	func ( v * JWTValidator ) Claims ( r * http . Request , token * jwt . JSONWebToken , values ... interface { } ) error { key , err := v . config . secretProvider . GetSecret ( r ) if err != nil { return err } return token . Claims ( key , values ... ) }
6931	func ( r * Rate ) Snapshot ( ) float64 { now := time . Now ( ) . UnixNano ( ) dur := time . Duration ( now - atomic . SwapInt64 ( & r . time , now ) ) return r . count . Snapshot ( ) / dur . Seconds ( ) * r . unit }
6495	func ( o OAuth ) RefreshTokens ( oldTokens map [ string ] interface { } ) ( * oauthTokens , error ) { refresh_token := oldTokens [ "refresh_token" ] . ( string ) return o . GetTokens ( refresh_token , "refresh_token" ) }
5555	func assembleImportPath ( file string ) string { a , _ := filepath . Abs ( filepath . Dir ( file ) ) absPath , fullPkg := filepath . ToSlash ( a ) , "" greedy := 0 for _ , p := range filepath . SplitList ( os . Getenv ( "GOPATH" ) ) { a , _ = filepath . Abs ( p ) p = filepath . ToSlash ( a ) symlink , _ := filepath . EvalSymlinks ( p ) if ( strings . HasPrefix ( absPath , p ) || strings . HasPrefix ( absPath , symlink ) ) && len ( p ) > greedy { prefixPath := filepath . ToSlash ( filepath . Join ( p , "src" ) ) fullPkg , _ = filepath . Rel ( prefixPath , absPath ) greedy = len ( p ) } } return filepath . ToSlash ( fullPkg ) }
5120	func ( file * GridFile ) Read ( b [ ] byte ) ( n int , err error ) { file . assertMode ( gfsReading ) file . m . Lock ( ) debugf ( "GridFile %p: reading at offset %d into buffer of length %d" , file , file . offset , len ( b ) ) defer file . m . Unlock ( ) if file . offset == file . doc . Length { return 0 , io . EOF } for err == nil { i := copy ( b , file . rbuf ) n += i file . offset += int64 ( i ) file . rbuf = file . rbuf [ i : ] if i == len ( b ) || file . offset == file . doc . Length { break } b = b [ i : ] file . rbuf , err = file . getChunk ( ) } return n , err }
1018	func regexpMatch ( re * regexp . Regexp , q string ) map [ string ] string { names := re . SubexpNames ( ) match := re . FindAllStringSubmatch ( q , - 1 ) if len ( match ) == 0 { return map [ string ] string { } } m := map [ string ] string { } for i , n := range match [ 0 ] { if names [ i ] != "" { m [ names [ i ] ] = n } } return m }
7005	func ( h * Hello ) World ( ctx context . Context , w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( "Hello World!" ) ) }
2530	func flattenVMwareDVSPortgroupPolicy ( d * schema . ResourceData , obj * types . VMwareDVSPortgroupPolicy ) error { d . Set ( "block_override_allowed" , obj . BlockOverrideAllowed ) d . Set ( "shaping_override_allowed" , obj . ShapingOverrideAllowed ) d . Set ( "live_port_moving_allowed" , obj . LivePortMovingAllowed ) d . Set ( "port_config_reset_at_disconnect" , obj . PortConfigResetAtDisconnect ) d . Set ( "vlan_override_allowed" , obj . VlanOverrideAllowed ) d . Set ( "uplink_teaming_override_allowed" , obj . UplinkTeamingOverrideAllowed ) d . Set ( "security_policy_override_allowed" , obj . SecurityPolicyOverrideAllowed ) structure . SetBoolPtr ( d , "network_resource_pool_override_allowed" , obj . NetworkResourcePoolOverrideAllowed ) structure . SetBoolPtr ( d , "traffic_filter_override_allowed" , obj . TrafficFilterOverrideAllowed ) structure . SetBoolPtr ( d , "netflow_override_allowed" , obj . IpfixOverrideAllowed ) return nil }
7287	func ( s SyslogFacility ) Priority ( ) syslog . Priority { return syslogPriorities [ strings . ToLower ( s . String ( ) ) ] }
4637	func ( points * PointsIndex ) Remove ( id string ) { if prevPoint , ok := points . currentPosition [ id ] ; ok { set := points . index . GetEntryAt ( prevPoint ) . ( set ) set . Remove ( prevPoint . Id ( ) ) delete ( points . currentPosition , prevPoint . Id ( ) ) } }
7304	func ( b Bucket ) GobValue ( k [ ] [ ] byte , f func ( interface { } ) error ) error { return b . Value ( k , func ( bs bytesp . Slice ) error { var v interface { } if err := gob . NewDecoder ( & bs ) . Decode ( & v ) ; err != nil { return errorsp . WithStacksAndMessage ( err , "decoding %d bytes buffer failed" , len ( bs ) ) } return f ( v ) } ) }
6028	func ( t Typed ) Floats ( key string ) [ ] float64 { return t . FloatsOr ( key , nil ) }
2629	func GetLongPolicy ( d * schema . ResourceData , key string ) * types . LongPolicy { v , e := d . GetOkExists ( key ) if e { return LongPolicy ( v ) } return nil }
5618	func ( c * WordCodec ) GetIndex ( word string ) ( int , error ) { if c . bytes == nil { b := map [ string ] int { } for i , w := range c . words { if _ , ok := b [ w ] ; ok { return - 1 , errors . Errorf ( "Duplicate word in list: %s" , w ) } b [ w ] = i } c . bytes = b } rem , ok := c . bytes [ word ] if ! ok { return - 1 , errors . Errorf ( "Unrecognized word: %s" , word ) } return rem , nil }
2900	func controllerTypeToClass ( c types . BaseVirtualController ) ( string , error ) { var t string switch c . ( type ) { case * types . VirtualIDEController : t = SubresourceControllerTypeIDE case * types . VirtualAHCIController : t = SubresourceControllerTypeSATA case * types . VirtualPCIController : t = SubresourceControllerTypePCI case * types . ParaVirtualSCSIController , * types . VirtualBusLogicController , * types . VirtualLsiLogicController , * types . VirtualLsiLogicSASController : t = SubresourceControllerTypeSCSI default : return subresourceControllerTypeUnknown , fmt . Errorf ( "unsupported controller type %T" , c ) } return t , nil }
4320	func ( c * Client ) ClearCache ( account , repo string ) ( string , error ) { status := & struct { Status string `json:"status"` } { } err := c . request ( "DELETE" , fmt . Sprintf ( "project/%s/%s/build-cache" , account , repo ) , status , nil , nil ) if err != nil { return "" , err } return status . Status , nil }
5501	func indexesOutsideRange ( start time . Time , end time . Time , results [ ] time . Time ) [ ] int { if start . After ( end ) { panic ( "start date is after end date" ) } indexes := make ( [ ] int , 0 , len ( results ) ) for i , result := range results { if result . Equal ( end ) || result . After ( end ) { indexes = append ( indexes , i ) } if result . Before ( start ) { indexes = append ( indexes , i ) } } return indexes }
5298	func ( r * Regexp ) Values ( s string ) url . Values { match := r . compiled . FindStringSubmatch ( s ) if match != nil { values := url . Values { } for k , v := range r . groups { values . Add ( v , match [ r . indices [ k ] ] ) } return values } return nil }
6993	func MiddlewareList ( middlware [ ] Middleware ) Middleware { return Middleware ( func ( next Handler ) Handler { for _ , m := range middlware { next = m ( next ) } return next } ) }
4026	func ( c * RadioGroup ) Selected ( ) int { selected := - 1 for id , item := range c . items { if item . Selected ( ) { selected = id break } } return selected }
3859	func ( c * Cursor ) FormatMask ( mask rune ) string { r := make ( [ ] rune , len ( c . input ) ) for i := range r { r [ i ] = mask } return format ( r , c ) }
1071	func ( r * Runner ) allTemplatesRendered ( ) bool { r . renderEventsLock . RLock ( ) defer r . renderEventsLock . RUnlock ( ) for _ , tmpl := range r . templates { event , rendered := r . renderEvents [ tmpl . ID ( ) ] if ! rendered { return false } if event . ForQuiescence { continue } if ! event . DidRender && ! event . WouldRender { return false } } return true }
1380	func ( mr * MockControlMockRecorder ) Init ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Init" , reflect . TypeOf ( ( * MockControl ) ( nil ) . Init ) ) }
4616	func ( t * Template ) Reset ( template , startTag , endTag string ) error { t . template = template t . startTag = startTag t . endTag = endTag t . texts = t . texts [ : 0 ] t . tags = t . tags [ : 0 ] if len ( startTag ) == 0 { panic ( "startTag cannot be empty" ) } if len ( endTag ) == 0 { panic ( "endTag cannot be empty" ) } s := unsafeString2Bytes ( template ) a := unsafeString2Bytes ( startTag ) b := unsafeString2Bytes ( endTag ) tagsCount := bytes . Count ( s , a ) if tagsCount == 0 { return nil } if tagsCount + 1 > cap ( t . texts ) { t . texts = make ( [ ] [ ] byte , 0 , tagsCount + 1 ) } if tagsCount > cap ( t . tags ) { t . tags = make ( [ ] string , 0 , tagsCount ) } for { n := bytes . Index ( s , a ) if n < 0 { t . texts = append ( t . texts , s ) break } t . texts = append ( t . texts , s [ : n ] ) s = s [ n + len ( a ) : ] n = bytes . Index ( s , b ) if n < 0 { return fmt . Errorf ( "Cannot find end tag=%q in the template=%q starting from %q" , endTag , template , s ) } t . tags = append ( t . tags , unsafeBytes2String ( s [ : n ] ) ) s = s [ n + len ( b ) : ] } return nil }
1425	func ( cs * ClientServerImpl ) Disconnect ( ... interface { } ) error { cs . writeLock . Lock ( ) defer cs . writeLock . Unlock ( ) if cs . conn == nil { return fmt . Errorf ( "websocker client: no connection to close" ) } if err := cs . conn . SetWriteDeadline ( time . Now ( ) . Add ( cs . RWTimeout ) ) ; err != nil { seelog . Warnf ( "Unable to set write deadline for websocket connection: %v for %s" , err , cs . URL ) } return cs . conn . Close ( ) }
5213	func ( idx * Index ) GroupByLimit ( limit int64 , rowsQueries ... * PQLRowsQuery ) * PQLBaseQuery { if len ( rowsQueries ) < 1 { return NewPQLBaseQuery ( "" , idx , errors . New ( "there should be at least one rows query" ) ) } if limit < 0 { return NewPQLBaseQuery ( "" , idx , errors . New ( "limit must be non-negative" ) ) } text := fmt . Sprintf ( "GroupBy(%s,limit=%d)" , strings . Join ( serializeGroupBy ( rowsQueries ... ) , "," ) , limit ) return NewPQLBaseQuery ( text , idx , nil ) }
3726	func ( w * Widget ) HasTileDef ( ) bool { if w != nil && w . TileDef != nil { return true } return false }
2286	func ( v * SpinButton ) native ( ) * C . GtkSpinButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSpinButton ( p ) }
5948	func ( h Host ) Rescan ( ) ( scan Scan ) { return Init ( ) . AddPorts ( h . parentScan . configPorts ... ) . AddTCPPorts ( h . parentScan . configTCPPorts ... ) . AddUDPPorts ( h . parentScan . configUDPPorts ... ) . AddHosts ( h . Address ) . AddFlags ( h . parentScan . configOpts ... ) }
369	func ( a * Args ) DelBytes ( key [ ] byte ) { a . args = delAllArgs ( a . args , b2s ( key ) ) }
393	func AppendIPv4 ( dst [ ] byte , ip net . IP ) [ ] byte { ip = ip . To4 ( ) if ip == nil { return append ( dst , "non-v4 ip passed to AppendIPv4" ... ) } dst = AppendUint ( dst , int ( ip [ 0 ] ) ) for i := 1 ; i < 4 ; i ++ { dst = append ( dst , '.' ) dst = AppendUint ( dst , int ( ip [ i ] ) ) } return dst }
4277	func ( p * setnsProcess ) execSetns ( ) error { err := p . cmd . Start ( ) p . childPipe . Close ( ) if err != nil { return newSystemError ( err ) } status , err := p . cmd . Process . Wait ( ) if err != nil { p . cmd . Wait ( ) return newSystemError ( err ) } if ! status . Success ( ) { p . cmd . Wait ( ) return newSystemError ( & exec . ExitError { ProcessState : status } ) } var pid * pid if err := json . NewDecoder ( p . parentPipe ) . Decode ( & pid ) ; err != nil { p . cmd . Wait ( ) return newSystemError ( err ) } process , err := os . FindProcess ( pid . Pid ) if err != nil { return err } p . cmd . Process = process return nil }
6465	func ( l * Log ) exit ( err error ) { fmt . Fprintf ( os . Stderr , "log: exiting because of error: %s\n" , \n ) err if logExitFunc != nil { logExitFunc ( err ) return } l . flushAll ( ) }
807	func listDHCPServers ( vbox VBoxManager ) ( map [ string ] * dhcpServer , error ) { out , err := vbox . vbmOut ( "list" , "dhcpservers" ) if err != nil { return nil , err } m := map [ string ] * dhcpServer { } dhcp := & dhcpServer { } err = parseKeyValues ( out , reColonLine , func ( key , val string ) error { switch key { case "NetworkName" : dhcp = & dhcpServer { } m [ val ] = dhcp dhcp . NetworkName = val case "IP" : dhcp . IPv4 . IP = net . ParseIP ( val ) case "upperIPAddress" : dhcp . UpperIP = net . ParseIP ( val ) case "lowerIPAddress" : dhcp . LowerIP = net . ParseIP ( val ) case "NetworkMask" : dhcp . IPv4 . Mask = parseIPv4Mask ( val ) case "Enabled" : dhcp . Enabled = ( val == "Yes" ) } return nil } ) if err != nil { return nil , err } return m , nil }
7179	func ( s * SessionCache ) Delete ( token string ) error { err := s . cache . Delete ( token ) if err != nil { return s . getInvalidTokenError ( token ) } return nil }
2674	func flattenClusterVMToolsMonitoringSettings ( d * schema . ResourceData , obj * types . ClusterVmToolsMonitoringSettings ) error { return structure . SetBatch ( d , map [ string ] interface { } { "ha_vm_failure_interval" : obj . FailureInterval , "ha_vm_maximum_resets" : obj . MaxFailures , "ha_vm_maximum_failure_window" : obj . MaxFailureWindow , "ha_vm_minimum_uptime" : obj . MinUpTime , "ha_vm_monitoring" : obj . VmMonitoring , } ) }
6462	func ( l * Log ) output ( s Severity , buf * buffer , file string , line int ) { l . mu . Lock ( ) if l . traceLocation . isSet ( ) { if l . traceLocation . match ( file , line ) { buf . Write ( stacks ( false , l . maxStackBufSize ) ) } } data := buf . Bytes ( ) if l . toStderr { os . Stderr . Write ( data ) } else { if l . alsoToStderr || s >= l . stderrThreshold . get ( ) { os . Stderr . Write ( data ) } if l . file [ s ] == nil { if err := l . createFiles ( s ) ; err != nil { os . Stderr . Write ( data ) l . exit ( err ) } } switch s { case FatalLog : l . file [ FatalLog ] . Write ( data ) fallthrough case ErrorLog : l . file [ ErrorLog ] . Write ( data ) fallthrough case WarningLog : l . file [ WarningLog ] . Write ( data ) fallthrough case InfoLog : l . file [ InfoLog ] . Write ( data ) } } if s == FatalLog { if ! l . toStderr { os . Stderr . Write ( stacks ( false , l . maxStackBufSize ) ) } trace := stacks ( true , l . maxStackBufSize ) logExitFunc = func ( error ) { } for log := FatalLog ; log >= InfoLog ; log -- { if f := l . file [ log ] ; f != nil { f . Write ( trace ) } } l . mu . Unlock ( ) timeoutFlush ( l , 10 * time . Second ) os . Exit ( 255 ) } l . putBuffer ( buf ) l . mu . Unlock ( ) if stats := l . severityStats [ s ] ; stats != nil { atomic . AddInt64 ( & stats . lines , 1 ) atomic . AddInt64 ( & stats . bytes , int64 ( len ( data ) ) ) } }
3758	func newAccessor ( receiverType , fieldName , fieldType , zeroValue string ) * accessor { return & accessor { sortVal : strings . ToLower ( receiverType ) + "." + strings . ToLower ( fieldName ) , ReceiverVar : strings . ToLower ( receiverType [ : 1 ] ) , ReceiverType : receiverType , FieldName : fieldName , FieldType : fieldType , ZeroValue : zeroValue , } }
532	func ( c * Cookie ) SetPath ( path string ) { c . buf = append ( c . buf [ : 0 ] , path ... ) c . path = normalizePath ( c . path , c . buf ) }
5802	func ( a * API ) FetchMetrics ( ) ( * [ ] Metric , error ) { result , err := a . Get ( config . MetricPrefix ) if err != nil { return nil , err } var metrics [ ] Metric if err := json . Unmarshal ( result , & metrics ) ; err != nil { return nil , err } return & metrics , nil }
4264	func ( c * linuxContainer ) addUidGidMappings ( sys * syscall . SysProcAttr ) error { if c . config . UidMappings != nil { sys . UidMappings = make ( [ ] syscall . SysProcIDMap , len ( c . config . UidMappings ) ) for i , um := range c . config . UidMappings { sys . UidMappings [ i ] . ContainerID = um . ContainerID sys . UidMappings [ i ] . HostID = um . HostID sys . UidMappings [ i ] . Size = um . Size } } if c . config . GidMappings != nil { sys . GidMappings = make ( [ ] syscall . SysProcIDMap , len ( c . config . GidMappings ) ) for i , gm := range c . config . GidMappings { sys . GidMappings [ i ] . ContainerID = gm . ContainerID sys . GidMappings [ i ] . HostID = gm . HostID sys . GidMappings [ i ] . Size = gm . Size } } return nil }
3760	func ( t * templateData ) addSelectorExpr ( x * ast . SelectorExpr , receiverType , fieldName string ) { if strings . ToLower ( fieldName [ : 1 ] ) == fieldName [ : 1 ] { return } var xX string if xx , ok := x . X . ( * ast . Ident ) ; ok { xX = xx . String ( ) } switch xX { case "time" , "json" : if xX == "json" { t . Imports [ "encoding/json" ] = "encoding/json" } else { t . Imports [ xX ] = xX } fieldType := fmt . Sprintf ( "%v.%v" , xX , x . Sel . Name ) zeroValue := fmt . Sprintf ( "%v.%v{}" , xX , x . Sel . Name ) if xX == "json" && x . Sel . Name == "Number" { zeroValue = `""` } if xX == "time" && x . Sel . Name == "Duration" { zeroValue = "0" } t . Accessors = append ( t . Accessors , newAccessor ( receiverType , fieldName , fieldType , zeroValue ) ) default : logf ( "addSelectorExpr: xX %q, type %q, field %q: unknown x=%+v; skipping." , xX , receiverType , fieldName , x ) } }
1967	func ( mr * MockResultMockRecorder ) GetAsVersion ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "GetAsVersion" , reflect . TypeOf ( ( * MockResult ) ( nil ) . GetAsVersion ) , arg0 ) }
3728	func ( w * Widget ) GetTitleTextOk ( ) ( string , bool ) { if w == nil || w . TitleText == nil { return "" , false } return * w . TitleText , true }
2789	func portGroupPortSchema ( ) * schema . Resource { return & schema . Resource { Schema : map [ string ] * schema . Schema { "key" : { Type : schema . TypeString , Description : "The linkable identifier for this port entry." , Computed : true , } , "mac_addresses" : { Type : schema . TypeList , Description : "The MAC addresses of the network service of the virtual machine connected on this port." , Computed : true , Elem : & schema . Schema { Type : schema . TypeString } , } , "type" : { Type : schema . TypeString , Description : "Type type of the entity connected on this port. Possible values are host (VMKkernel), systemManagement (service console), virtualMachine, or unknown." , Computed : true , } , } , } }
4803	func ( g GithubHook ) handleSignature ( r * http . Request , body [ ] byte , secret string ) error { signature := r . Header . Get ( "X-Hub-Signature" ) if signature != "" { if secret == "" { Logger ( ) . Print ( "Unable to verify request signature. Secret not set in caddyfile!\n" ) } else \n } { mac := hmac . New ( sha1 . New , [ ] byte ( secret ) ) mac . Write ( body ) expectedMac := hex . EncodeToString ( mac . Sum ( nil ) ) if signature [ 5 : ] != expectedMac { return errors . New ( "could not verify request signature. The signature is invalid" ) } } }
670	func ( n NS1DomainService ) CreateRecord ( r * dns . Record ) ( * http . Response , error ) { return n . service . Records . Create ( r ) }
3558	func ( s * SyntheticsTest ) HasMonitorStatus ( ) bool { if s != nil && s . MonitorStatus != nil { return true } return false }
7203	func ( self * Salter ) BToken ( size int ) [ ] byte { mac := hmac . New ( sha256 . New , self . salt ) for _ , v := range self . rndSources { itemSize := float32 ( size ) * ( float32 ( v . Weight ) / float32 ( self . sumWeight ) ) mac . Write ( getRandomBytes ( v . Reader , int ( itemSize ) ) ) } macSum := mac . Sum ( nil ) self . salt = macSum return macSum }
1390	func ( m * MockCNIClient ) CleanupNS ( arg0 context . Context , arg1 * ecscni . Config , arg2 time . Duration ) error { ret := m . ctrl . Call ( m , "CleanupNS" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
334	func ( d * Discovery ) watchFiles ( ) { if d . watcher == nil { panic ( "no watcher configured" ) } for _ , p := range d . paths { if idx := strings . LastIndex ( p , "/" ) ; idx > - 1 { p = p [ : idx ] } else { p = "./" } if err := d . watcher . Add ( p ) ; err != nil { level . Error ( d . logger ) . Log ( "msg" , "Error adding file watch" , "path" , p , "err" , err ) } } }
604	func DeleteArticle ( w http . ResponseWriter , r * http . Request ) { var err error article := r . Context ( ) . Value ( "article" ) . ( * Article ) article , err = dbRemoveArticle ( article . ID ) if err != nil { render . Render ( w , r , ErrInvalidRequest ( err ) ) return } render . Render ( w , r , NewArticleResponse ( article ) ) }
970	func NewVaultListQuery ( s string ) ( * VaultListQuery , error ) { s = strings . TrimSpace ( s ) s = strings . Trim ( s , "/" ) if s == "" { return nil , fmt . Errorf ( "vault.list: invalid format: %q" , s ) } return & VaultListQuery { stopCh : make ( chan struct { } , 1 ) , path : s , } , nil }
4608	func ( p * Palette ) BucketHeader ( bucket * stack . Bucket , fullPath , multipleBuckets bool ) string { extra := "" if s := bucket . SleepString ( ) ; s != "" { extra += " [" + s + "]" } if bucket . Locked { extra += " [locked]" } if c := bucket . CreatedByString ( fullPath ) ; c != "" { extra += p . CreatedBy + " [Created by " + c + "]" } return fmt . Sprintf ( "%s%d: %s%s%s\n" , \n , p . routineColor ( bucket , multipleBuckets ) , len ( bucket . IDs ) , bucket . State , extra ) }
4430	func ( u UUID3 ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
2181	func ( v * FontButton ) native ( ) * C . GtkFontButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFontButton ( p ) }
214	func ( w * WALWatcher ) findSegmentForIndex ( index int ) ( int , error ) { refs , err := w . segments ( w . walDir ) if err != nil { return - 1 , nil } for _ , r := range refs { if r >= index { return r , nil } } return - 1 , errors . New ( "failed to find segment for index" ) }
4669	func Load ( basePath , innerPath string , opts * Options ) ( * template . Template , error ) { opts = InitializeOptions ( opts ) name := basePath + colon + innerPath if ! opts . DynamicReload { if tpl , ok := getCache ( name ) ; ok { return & tpl , nil } } src , err := readFiles ( basePath , innerPath , opts ) if err != nil { return nil , err } rslt , err := ParseSource ( src , opts ) if err != nil { return nil , err } tpl , err := CompileResult ( name , rslt , opts ) if err != nil { return nil , err } if ! opts . DynamicReload { setCache ( name , * tpl ) } return tpl , nil }
745	func digitalOceanChangesByZone ( zones [ ] godo . Domain , changeSet [ ] * DigitalOceanChange ) map [ string ] [ ] * DigitalOceanChange { changes := make ( map [ string ] [ ] * DigitalOceanChange ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( z . Name , z . Name ) changes [ z . Name ] = [ ] * DigitalOceanChange { } } for _ , c := range changeSet { zone , _ := zoneNameIDMapper . FindZone ( c . ResourceRecordSet . Name ) if zone == "" { log . Debugf ( "Skipping record %s because no hosted zone matching record DNS Name was detected " , c . ResourceRecordSet . Name ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes }
215	func ( w * WALWatcher ) watch ( segmentNum int , tail bool ) error { segment , err := wal . OpenReadSegment ( wal . SegmentName ( w . walDir , segmentNum ) ) if err != nil { return err } defer segment . Close ( ) reader := wal . NewLiveReader ( w . logger , segment ) readTicker := time . NewTicker ( readPeriod ) defer readTicker . Stop ( ) checkpointTicker := time . NewTicker ( checkpointPeriod ) defer checkpointTicker . Stop ( ) segmentTicker := time . NewTicker ( segmentCheckPeriod ) defer segmentTicker . Stop ( ) size := int64 ( math . MaxInt64 ) if ! tail { segmentTicker . Stop ( ) checkpointTicker . Stop ( ) var err error size , err = getSegmentSize ( w . walDir , segmentNum ) if err != nil { return errors . Wrap ( err , "getSegmentSize" ) } } for { select { case <- w . quit : return nil case <- checkpointTicker . C : if err := w . garbageCollectSeries ( segmentNum ) ; err != nil { level . Warn ( w . logger ) . Log ( "msg" , "error process checkpoint" , "err" , err ) } case <- segmentTicker . C : _ , last , err := w . firstAndLast ( ) if err != nil { return errors . Wrap ( err , "segments" ) } if last <= segmentNum { continue } err = w . readSegment ( reader , segmentNum , tail ) if ! tail { if err != nil && err != io . EOF { level . Warn ( w . logger ) . Log ( "msg" , "ignoring error reading to end of segment, may have dropped data" , "err" , err ) } else if reader . Offset ( ) != size { level . Warn ( w . logger ) . Log ( "msg" , "expected to have read whole segment, may have dropped data" , "segment" , segmentNum , "read" , reader . Offset ( ) , "size" , size ) } return nil } if err != io . EOF { return err } return nil case <- readTicker . C : err = w . readSegment ( reader , segmentNum , tail ) if ! tail { if err != nil && err != io . EOF { level . Warn ( w . logger ) . Log ( "msg" , "ignoring error reading to end of segment, may have dropped data" , "segment" , segmentNum , "err" , err ) } else if reader . Offset ( ) != size { level . Warn ( w . logger ) . Log ( "msg" , "expected to have read whole segment, may have dropped data" , "segment" , segmentNum , "read" , reader . Offset ( ) , "size" , size ) } return nil } if err != io . EOF { return err } } } }
3124	func New ( configFilename string ) * App { app := & App { ConfigFilename : configFilename , Config : NewConfig ( ) , PromRegistry : prometheus . NewPedanticRegistry ( ) , exit : make ( chan bool ) , } return app }
1625	func ( mr * MockSecretsManagerAPIMockRecorder ) UpdateSecretVersionStageWithContext ( arg0 , arg1 interface { } , arg2 ... interface { } ) * gomock . Call { varargs := append ( [ ] interface { } { arg0 , arg1 } , arg2 ... ) return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "UpdateSecretVersionStageWithContext" , reflect . TypeOf ( ( * MockSecretsManagerAPI ) ( nil ) . UpdateSecretVersionStageWithContext ) , varargs ... ) }
2446	func ( i * Image ) readPixelsFromGPU ( ) { pix := i . image . Pixels ( ) i . basePixels = & Pixels { pixels : pix , length : len ( pix ) , } i . drawTrianglesHistory = nil i . stale = false }
6061	func NewServer ( conf * Config , logger log . Logger , db * reform . DB ) * Server { s := & Server { Server : srv . NewServer ( conf . Config ) , logger : logger . Add ( "type" , "pay.Server" ) , db : db , } s . HandleFunc ( payPath , s . RequireHTTPMethods ( s . logger , s . handlePay , http . MethodPost ) ) return s }
1330	func ( m * MockEC2MetadataClient ) InstanceIdentityDocument ( ) ( ec2metadata . EC2InstanceIdentityDocument , error ) { ret := m . ctrl . Call ( m , "InstanceIdentityDocument" ) ret0 , _ := ret [ 0 ] . ( ec2metadata . EC2InstanceIdentityDocument ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3077	func ( ctx * Context ) QueryEscape ( name string ) string { return template . HTMLEscapeString ( ctx . Query ( name ) ) }
5071	func tokenFor ( t * transaction ) token { nonce := t . Nonce if nonce == "" { nonce = newNonce ( ) } return token ( t . Id . Hex ( ) + "_" + nonce ) }
4805	func parseURL ( repoURL string , private bool ) ( * url . URL , error ) { urlParts := strings . Split ( repoURL , "://" ) switch { case strings . HasPrefix ( repoURL , "https://" ) : case strings . HasPrefix ( repoURL , "http://" ) : case strings . HasPrefix ( repoURL , "ssh://" ) : case len ( urlParts ) > 1 : return nil , fmt . Errorf ( "Invalid url scheme %s. If url contains port, scheme is required" , urlParts [ 0 ] ) default : if private { repoURL = "ssh://" + repoURL } else { repoURL = "https://" + repoURL } } u , err := url . Parse ( repoURL ) if err != nil { return nil , err } return u , nil }
3037	func ( d * Discover ) Names ( ) [ ] string { d . once . Do ( d . initProviders ) var names [ ] string for n := range d . Providers { names = append ( names , n ) } sort . Strings ( names ) return names }
6116	func ( b * ClientBuilder ) NewClient ( somcType uint8 , somcData data . Base64String ) ( Client , error ) { if somcType == data . OfferingSOMCTor { hostnameBytes , err := data . ToBytes ( somcData ) if err != nil { return nil , err } torClient , err := tor . NewHTTPClient ( b . torSocks ) return somcsrv . NewClient ( torClient , string ( hostnameBytes ) ) , nil } return nil , ErrUnknownSOMCType }
6701	func ( c * Client ) MoveServersToServerGroup ( src string , dst string , serverIds [ ] string ) ( * ServerGroup , error ) { group := new ( ServerGroup ) opts := serverGroupMemberOptions { Destination : dst } for _ , id := range serverIds { opts . Servers = append ( opts . Servers , serverGroupMember { Server : id } ) } _ , err := c . MakeApiRequest ( "POST" , "/1.0/server_groups/" + src + "/move_servers" , opts , & group ) if err != nil { return nil , err } return group , nil }
934	func ( api * Client ) Create ( h * host . Host ) error { if err := cert . BootstrapCertificates ( h . AuthOptions ( ) ) ; err != nil { return fmt . Errorf ( "Error generating certificates: %s" , err ) } log . Info ( "Running pre-create checks..." ) if err := h . Driver . PreCreateCheck ( ) ; err != nil { return mcnerror . ErrDuringPreCreate { Cause : err , } } if err := api . Save ( h ) ; err != nil { return fmt . Errorf ( "Error saving host to store before attempting creation: %s" , err ) } log . Info ( "Creating machine..." ) if err := api . performCreate ( h ) ; err != nil { return fmt . Errorf ( "Error creating machine: %s" , err ) } log . Debug ( "Reticulating splines..." ) return nil }
4737	func StringJoin ( values interface { } , sep string ) string { v := reflect . ValueOf ( values ) if v . Kind ( ) != reflect . Slice { panic ( "values is not a slice" ) } var buffer bytes . Buffer for i := 0 ; i < v . Len ( ) ; i ++ { if i > 0 { buffer . WriteString ( sep ) } buffer . WriteString ( fmt . Sprint ( v . Index ( i ) . Interface ( ) ) ) } return buffer . String ( ) }
888	func getNameAndItsPpid ( pid int ) ( exefile string , parentid int , err error ) { pe , err := getProcessEntry ( pid ) if err != nil { return "" , 0 , err } name := syscall . UTF16ToString ( pe . ExeFile [ : ] ) return name , int ( pe . ParentProcessID ) , nil }
3170	func ( client * Client ) DeleteIntegrationGCP ( cir * IntegrationGCPDeleteRequest ) error { return client . doJsonRequest ( "DELETE" , "/v1/integration/gcp" , cir , nil ) }
6087	func AddWithData ( q Queue , tx * reform . TX , jobType , relatedType , relatedID , creator string , jobData interface { } ) error { return AddWithDataAndDelay ( q , tx , jobType , relatedType , relatedID , creator , jobData , time . Duration ( 0 ) ) }
4768	func ReflectSetStructFieldString ( structPtr interface { } , name , value string ) error { v := reflect . ValueOf ( structPtr ) if v . Kind ( ) != reflect . Ptr || v . Elem ( ) . Kind ( ) != reflect . Struct { return fmt . Errorf ( "structPtr must be pointer to a struct, but is %T" , structPtr ) } v = v . Elem ( ) if f := v . FieldByName ( name ) ; f . IsValid ( ) { if f . Kind ( ) == reflect . String { f . SetString ( value ) } else { _ , err := fmt . Sscan ( value , f . Addr ( ) . Interface ( ) ) if err != nil { return err } } } else { return fmt . Errorf ( "%T has no struct field '%s'" , v . Interface ( ) , name ) } return nil }
0	func ( q * query ) Close ( ) { for _ , s := range q . matrix { putPointSlice ( s . Points ) } }
4714	func indent ( str string ) int { var i int for _ , b := range str { if b != unicodeSpace { break } i ++ } return i / 2 }
7222	func ( logger * Logger ) Log ( level Level , a ... interface { } ) { logger . log ( level , "" , a ... ) }
719	func NewCoreDNSProvider ( domainFilter DomainFilter , dryRun bool ) ( Provider , error ) { client , err := newETCDClient ( ) if err != nil { return nil , err } return coreDNSProvider { client : client , dryRun : dryRun , domainFilter : domainFilter , } , nil }
1161	func ( refreshHandler * refreshCredentialsHandler ) ackMessage ( ack * ecsacs . IAMRoleCredentialsAckRequest ) { err := refreshHandler . acsClient . MakeRequest ( ack ) if err != nil { seelog . Warnf ( "Error 'ack'ing request with messageID: %s, error: %v" , aws . StringValue ( ack . MessageId ) , err ) } seelog . Debugf ( "Acking credentials message: %s" , ack . String ( ) ) }
4672	func FlushCache ( ) { cacheMutex . Lock ( ) cache = make ( map [ string ] template . Template ) cacheMutex . Unlock ( ) }
197	func ( g * Group ) GetEvaluationDuration ( ) time . Duration { g . mtx . Lock ( ) defer g . mtx . Unlock ( ) return g . evaluationDuration }
5474	func ( c * ConferenceService ) GetConferencesInRange ( start time . Time , end time . Time , data url . Values ) ConferencePageIterator { if start . After ( end ) { panic ( "start date is after end date" ) } d := url . Values { } if data != nil { for k , v := range data { d [ k ] = v } } d . Del ( "DateCreated" ) d . Del ( "Page" ) if start != Epoch { startFormat := start . UTC ( ) . Format ( APISearchLayout ) d . Set ( "DateCreated>" , startFormat ) } if end != HeatDeath { endFormat := end . UTC ( ) . Add ( 24 * time . Hour ) . Format ( APISearchLayout ) d . Set ( "DateCreated<" , endFormat ) } iter := NewPageIterator ( c . client , d , conferencePathPart ) return & conferenceDateIterator { start : start , end : end , p : iter , } }
7051	func HMAC ( password string ) func ( ctx * neptulon . ReqCtx ) error { pass := [ ] byte ( password ) return func ( ctx * neptulon . ReqCtx ) error { if _ , ok := ctx . Conn . Session . GetOk ( "userid" ) ; ok { return ctx . Next ( ) } var t token if err := ctx . Params ( & t ) ; err != nil { ctx . Conn . Close ( ) return err } jt , err := jwt . Parse ( t . Token , func ( token * jwt . Token ) ( interface { } , error ) { if _ , ok := token . Method . ( * jwt . SigningMethodHMAC ) ; ! ok { return nil , fmt . Errorf ( "mw: jwt: unexpected signing method: %v" , token . Header [ "alg" ] ) } return pass , nil } ) if err != nil || ! jt . Valid { ctx . Conn . Close ( ) return fmt . Errorf ( "mw: jwt: invalid JWT authentication attempt: %v: %v: %v" , err , ctx . Conn . RemoteAddr ( ) , t . Token ) } userID := jt . Claims [ "userid" ] . ( string ) ctx . Conn . Session . Set ( "userid" , userID ) log . Printf ( "mw: jwt: client authenticated, user: %v, conn: %v, ip: %v" , userID , ctx . Conn . ID , ctx . Conn . RemoteAddr ( ) ) return ctx . Next ( ) } }
690	func newDnsimpleChange ( action string , e * endpoint . Endpoint ) * dnsimpleChange { ttl := dnsimpleRecordTTL if e . RecordTTL . IsConfigured ( ) { ttl = int ( e . RecordTTL ) } change := & dnsimpleChange { Action : action , ResourceRecordSet : dnsimple . ZoneRecord { Name : e . DNSName , Type : e . RecordType , Content : e . Targets [ 0 ] , TTL : ttl , } , } return change }
2709	func ( c * Config ) LoadRestClient ( ctx context . Context , u * url . URL ) ( * tags . RestClient , bool , error ) { id , err := c . readRestSessionID ( ) if err != nil { return nil , false , err } client := tags . NewClientWithSessionID ( u , c . InsecureFlag , "" , id ) if id == "" { log . Println ( "[DEBUG] No cached REST session data found or persistence not enabled, new session necessary" ) return client , false , nil } if ! client . Valid ( ctx ) { log . Println ( "[DEBUG] Cached REST client session data not valid, new session necessary" ) return client , false , nil } log . Println ( "[DEBUG] Cached REST client session loaded successfully" ) return client , true , nil }
4045	func DrawRawText ( x , y int , text string ) { cx , cy , cw , ch := ClipRect ( ) if x >= cx + cw || y < cy || y >= cy + ch { return } length := xs . Len ( text ) if x + length < cx { return } if x < cx { text = xs . Slice ( text , cx - x , - 1 ) length = length - ( cx - x ) x = cx } text = CutText ( text , cw ) dx := 0 for _ , ch := range text { putCharUnsafe ( x + dx , y , ch ) dx ++ } }
2096	func NewLRUCache ( size int , ttl time . Duration ) Cache { lru := & lruCache { size : size , ttl : ttl , cache : make ( map [ string ] * entry ) , evictList : list . New ( ) , } return lru }
2793	func BaseFromReference ( client * govmomi . Client , ref types . ManagedObjectReference ) ( BaseComputeResource , error ) { switch ref . Type { case "ComputeResource" : return StandaloneFromID ( client , ref . Value ) case "ClusterComputeResource" : return StandaloneFromID ( client , ref . Value ) } return nil , fmt . Errorf ( "unknown object type %s" , ref . Type ) }
3283	func ( d * Downtime ) GetCanceled ( ) int { if d == nil || d . Canceled == nil { return 0 } return * d . Canceled }
4540	func ResourceNameFor ( mapper meta . RESTMapper , o runtime . Object ) string { gvk := o . GetObjectKind ( ) . GroupVersionKind ( ) mapping , err := mapper . RESTMapping ( gvk . GroupKind ( ) , gvk . Version ) if err != nil { log . Debugf ( "RESTMapper failed for %s: %s, falling back to kind" , gvk , err ) return strings . ToLower ( gvk . Kind ) } return mapping . Resource . Resource }
1703	func ( m * MockPlugins ) Scan ( ) ( [ ] string , error ) { ret := m . ctrl . Call ( m , "Scan" ) ret0 , _ := ret [ 0 ] . ( [ ] string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6094	func ( h * Handler ) GetAgentChannels ( tkn string , channelStatus , serviceStatus [ ] string , offset , limit uint ) ( * GetAgentChannelsResult , error ) { logger := h . logger . Add ( "method" , "GetAgentChannels" , "channelStatus" , channelStatus , "serviceStatus" , serviceStatus ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } channels , total , err := h . getChannels ( logger , channelStatus , serviceStatus , agentChannelsCondition , offset , limit ) if err != nil { return nil , err } return & GetAgentChannelsResult { channels , total } , err }
6127	func ( b * backendInstance ) SuggestGasPrice ( ctx context . Context ) ( * big . Int , error ) { ctx2 , cancel := b . addTimeout ( ctx ) defer cancel ( ) gasPrice , err := b . conn . ethClient ( ) . SuggestGasPrice ( ctx2 ) if err != nil { return nil , fmt . Errorf ( "failed to get" + " suggested gas price: %s" , err ) } return gasPrice , err }
6674	func ( v Vec ) Sub ( v2 Vec ) Vec { return Vec { v . X - v2 . X , v . Y - v2 . Y } }
6803	func ( s * Session ) History ( ) QAPairs { s . mu . Lock ( ) defer s . mu . Unlock ( ) var qa [ ] QAPair for i := 1 ; ; i ++ { if v , ok := s . Decoded [ fmt . Sprintf ( "interaction_%d_other" , i ) ] . ( string ) ; ok && v != "" { qa = append ( [ ] QAPair { { s . Decoded [ fmt . Sprintf ( "interaction_%d" , i ) ] . ( string ) , s . Decoded [ fmt . Sprintf ( "interaction_%d_other" , i ) ] . ( string ) } } , qa ... ) } else { return qa } } }
1891	func ( engine * DockerTaskEngine ) synchronizeState ( ) { engine . tasksLock . Lock ( ) defer engine . tasksLock . Unlock ( ) imageStates := engine . state . AllImageStates ( ) if len ( imageStates ) != 0 { engine . imageManager . AddAllImageStates ( imageStates ) } tasks := engine . state . AllTasks ( ) tasksToStart := engine . filterTasksToStartUnsafe ( tasks ) for _ , task := range tasks { task . InitializeResources ( engine . resourceFields ) } for _ , task := range tasksToStart { engine . startTask ( task ) } engine . saver . Save ( ) }
30	func ( h * Handler ) isReady ( ) bool { ready := atomic . LoadUint32 ( & h . ready ) return ready > 0 }
445	func ( s * Server ) NextProto ( key string , nph ServeHandler ) { if s . nextProtos == nil { s . nextProtos = make ( map [ string ] ServeHandler ) } s . configTLS ( ) s . tlsConfig . NextProtos = append ( s . tlsConfig . NextProtos , key ) s . nextProtos [ key ] = nph }
4280	func Capture ( userSkip int ) Stacktrace { var ( skip = userSkip + 1 frames [ ] Frame ) for i := skip ; ; i ++ { pc , file , line , ok := runtime . Caller ( i ) if ! ok { break } frames = append ( frames , NewFrame ( pc , file , line ) ) } return Stacktrace { Frames : frames , } }
3171	func ( client * Client ) GetDashboardList ( id int ) ( * DashboardList , error ) { var out DashboardList if err := client . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/dashboard/lists/manual/%d" , id ) , nil , & out ) ; err != nil { return nil , err } return & out , nil }
4213	func NewJWKClient ( options JWKClientOptions , extractor RequestTokenExtractor ) * JWKClient { return NewJWKClientWithCache ( options , extractor , nil ) }
2910	func findVirtualDeviceInListControllerSelectFunc ( ct string , cb int ) func ( types . BaseVirtualDevice ) bool { return func ( device types . BaseVirtualDevice ) bool { switch ct { case SubresourceControllerTypeIDE : if _ , ok := device . ( * types . VirtualIDEController ) ; ! ok { return false } case SubresourceControllerTypeSATA : if _ , ok := device . ( * types . VirtualAHCIController ) ; ! ok { return false } case SubresourceControllerTypeSCSI : if _ , ok := device . ( types . BaseVirtualSCSIController ) ; ! ok { return false } case SubresourceControllerTypePCI : if _ , ok := device . ( * types . VirtualPCIController ) ; ! ok { return false } } vc := device . ( types . BaseVirtualController ) . GetVirtualController ( ) if vc . BusNumber == int32 ( cb ) { return true } return false } }
2245	func ( v * FileChooser ) native ( ) * C . GtkFileChooser { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooser ( p ) }
3179	func ( client * Client ) CreateAlert ( alert * Alert ) ( * Alert , error ) { var out Alert if err := client . doJsonRequest ( "POST" , "/v1/alert" , alert , & out ) ; err != nil { return nil , err } return & out , nil }
890	func ( d * Driver ) SetConfigFromFlags ( flags drivers . DriverOptions ) error { d . Project = flags . String ( "google-project" ) if d . Project == "" { return errors . New ( "no Google Cloud Project name specified (--google-project)" ) } d . Zone = flags . String ( "google-zone" ) d . UseExisting = flags . Bool ( "google-use-existing" ) if ! d . UseExisting { d . MachineType = flags . String ( "google-machine-type" ) d . MachineImage = flags . String ( "google-machine-image" ) d . MachineImage = strings . TrimPrefix ( d . MachineImage , "https://www.googleapis.com/compute/v1/projects/" ) d . DiskSize = flags . Int ( "google-disk-size" ) d . DiskType = flags . String ( "google-disk-type" ) d . Address = flags . String ( "google-address" ) d . Network = flags . String ( "google-network" ) d . Subnetwork = flags . String ( "google-subnetwork" ) d . Preemptible = flags . Bool ( "google-preemptible" ) d . UseInternalIP = flags . Bool ( "google-use-internal-ip" ) || flags . Bool ( "google-use-internal-ip-only" ) d . UseInternalIPOnly = flags . Bool ( "google-use-internal-ip-only" ) d . ServiceAccount = flags . String ( "google-service-account" ) d . Scopes = flags . String ( "google-scopes" ) d . Tags = flags . String ( "google-tags" ) d . OpenPorts = flags . StringSlice ( "google-open-port" ) } d . SSHUser = flags . String ( "google-username" ) d . SSHPort = 22 d . SetSwarmConfigFromFlags ( flags ) return nil }
4048	func DrawFrame ( x , y , w , h int , border BorderStyle ) { var chars string if border == BorderThick { chars = SysObject ( ObjDoubleBorder ) } else if border == BorderThin { chars = SysObject ( ObjSingleBorder ) } else if border == BorderNone { chars = " " } else { chars = " " } parts := [ ] rune ( chars ) H , V , UL , UR , DL , DR := parts [ 0 ] , parts [ 1 ] , parts [ 2 ] , parts [ 3 ] , parts [ 4 ] , parts [ 5 ] if InClipRect ( x , y ) { putCharUnsafe ( x , y , UL ) } if InClipRect ( x + w - 1 , y + h - 1 ) { putCharUnsafe ( x + w - 1 , y + h - 1 , DR ) } if InClipRect ( x , y + h - 1 ) { putCharUnsafe ( x , y + h - 1 , DL ) } if InClipRect ( x + w - 1 , y ) { putCharUnsafe ( x + w - 1 , y , UR ) } var xx , yy , ww , hh int xx , yy , ww , _ = clip ( x + 1 , y , w - 2 , 1 ) if ww > 0 { DrawHorizontalLine ( xx , yy , ww , H ) } xx , yy , ww , _ = clip ( x + 1 , y + h - 1 , w - 2 , 1 ) if ww > 0 { DrawHorizontalLine ( xx , yy , ww , H ) } xx , yy , _ , hh = clip ( x , y + 1 , 1 , h - 2 ) if hh > 0 { DrawVerticalLine ( xx , yy , hh , V ) } xx , yy , _ , hh = clip ( x + w - 1 , y + 1 , 1 , h - 2 ) if hh > 0 { DrawVerticalLine ( xx , yy , hh , V ) } }
3115	func NewTemplateSet ( ) * TemplateSet { return & TemplateSet { sets : make ( map [ string ] * template . Template ) , dirs : make ( map [ string ] string ) , } }
5189	func ( c * Cluster ) RemoveHost ( address * URI ) { c . mutex . Lock ( ) defer c . mutex . Unlock ( ) for i , uri := range c . hosts { if uri . Equals ( address ) { c . okList [ i ] = false break } } }
767	func NewDesignateProvider ( domainFilter DomainFilter , dryRun bool ) ( Provider , error ) { client , err := newDesignateClient ( ) if err != nil { return nil , err } return & designateProvider { client : client , domainFilter : domainFilter , dryRun : dryRun , } , nil }
3840	func New ( w io . Writer ) * ScreenBuf { return & ScreenBuf { buf : & bytes . Buffer { } , w : w } }
5030	func ( s * Session ) Close ( ) { s . m . Lock ( ) if s . cluster_ != nil { debugf ( "Closing session %p" , s ) s . unsetSocket ( ) s . cluster_ . Release ( ) s . cluster_ = nil } s . m . Unlock ( ) }
4428	func ( u * UUID ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { * u = UUID ( data ) return nil } return errors . New ( "couldn't unmarshal bson raw value as UUID" ) }
4299	func Chcon ( fpath string , scon string , recurse bool ) error { if scon == "" { return nil } if err := badPrefix ( fpath ) ; err != nil { return err } callback := func ( p string , info os . FileInfo , err error ) error { return Setfilecon ( p , scon ) } if recurse { return filepath . Walk ( fpath , callback ) } return Setfilecon ( fpath , scon ) }
1008	func ( w * Watcher ) Remove ( d dep . Dependency ) bool { w . Lock ( ) defer w . Unlock ( ) log . Printf ( "[DEBUG] (watcher) removing %s" , d ) if view , ok := w . depViewMap [ d . String ( ) ] ; ok { log . Printf ( "[TRACE] (watcher) actually removing %s" , d ) view . stop ( ) delete ( w . depViewMap , d . String ( ) ) return true } log . Printf ( "[TRACE] (watcher) %s did not exist, skipping" , d ) return false }
812	func NewDriver ( hostName , storePath string ) drivers . Driver { return & Driver { EnginePort : engine . DefaultPort , BaseDriver : & drivers . BaseDriver { MachineName : hostName , StorePath : storePath , } , } }
2889	func EnterMaintenanceMode ( host * object . HostSystem , timeout int , evacuate bool ) error { if err := viapi . VimValidateVirtualCenter ( host . Client ( ) ) ; err != nil { evacuate = false } log . Printf ( "[DEBUG] Host %q is entering maintenance mode (evacuate: %t)" , host . Name ( ) , evacuate ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Second * time . Duration ( timeout ) ) defer cancel ( ) task , err := host . EnterMaintenanceMode ( ctx , int32 ( timeout ) , evacuate , nil ) if err != nil { return err } return task . Wait ( ctx ) }
7072	func ( r * ReserveReleaseArg ) UnmarshalBinary ( b [ ] byte ) error { if len ( b ) < reserveReleaseArgLen { return io . ErrUnexpectedEOF } r . Command = ReserveReleaseCommand ( b [ 0 ] ) r . NMACs = b [ 1 ] if len ( b [ 2 : ] ) != ( 6 * int ( r . NMACs ) ) { return io . ErrUnexpectedEOF } r . MACs = make ( [ ] net . HardwareAddr , r . NMACs ) for i := 0 ; i < int ( r . NMACs ) ; i ++ { m := make ( net . HardwareAddr , 6 ) copy ( m , b [ 2 + ( i * 6 ) : 2 + ( i * 6 ) + 6 ] ) r . MACs [ i ] = m } return nil }
4850	func GenOracle ( u * URL ) ( string , error ) { dsn := u . Host + u . Path var un string if u . User != nil { if un = u . User . Username ( ) ; len ( un ) > 0 { if up , ok := u . User . Password ( ) ; ok { un += "/" + up } } } return un + "@" + dsn , nil }
6949	func ( s RethinkStore ) FilterBefore ( id string , filter map [ string ] interface { } , count int , skip int , store string , opts ObjectStoreOptions ) ( rows ObjectRows , err error ) { rootTerm := r . DB ( s . Database ) . Table ( store ) . Between ( r . MinVal , id , r . BetweenOpts { RightBound : "closed" } ) . OrderBy ( r . OrderByOpts { Index : r . Desc ( "id" ) } ) . Filter ( s . transformFilter ( nil , filter ) ) . Limit ( count ) result , err := rootTerm . Run ( s . Session ) if err != nil { return } if result . Err ( ) != nil { return nil , result . Err ( ) } if result . IsNil ( ) { return nil , ErrNotFound } rows = RethinkRows { result } return }
2114	func ( v * StackSwitcher ) native ( ) * C . GtkStackSwitcher { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStackSwitcher ( p ) }
3636	func ( t * TraceServiceDefinition ) HasShowHits ( ) bool { if t != nil && t . ShowHits != nil { return true } return false }
161	func ( s * shards ) sendSamplesWithBackoff ( ctx context . Context , samples [ ] prompb . TimeSeries ) error { backoff := s . qm . cfg . MinBackoff req , highest , err := buildWriteRequest ( samples ) if err != nil { return err } for { select { case <- ctx . Done ( ) : return ctx . Err ( ) default : } begin := time . Now ( ) err := s . qm . client . Store ( ctx , req ) s . qm . sentBatchDuration . Observe ( time . Since ( begin ) . Seconds ( ) ) if err == nil { s . qm . succeededSamplesTotal . Add ( float64 ( len ( samples ) ) ) s . qm . highestSentTimestampMetric . Set ( float64 ( highest / 1000 ) ) return nil } if _ , ok := err . ( recoverableError ) ; ! ok { return err } s . qm . retriedSamplesTotal . Add ( float64 ( len ( samples ) ) ) level . Debug ( s . qm . logger ) . Log ( "msg" , "failed to send batch, retrying" , "err" , err ) time . Sleep ( time . Duration ( backoff ) ) backoff = backoff * 2 if backoff > s . qm . cfg . MaxBackoff { backoff = s . qm . cfg . MaxBackoff } } }
42	func appsToTargetGroups ( apps * appList ) map [ string ] * targetgroup . Group { tgroups := map [ string ] * targetgroup . Group { } for _ , a := range apps . Apps { group := createTargetGroup ( & a ) tgroups [ group . Source ] = group } return tgroups }
126	func ( p * parser ) errorf ( format string , args ... interface { } ) { p . error ( errors . Errorf ( format , args ... ) ) }
6640	func ( r Rectangle ) Size ( ) Vec3 { return Vec3 { r . Max [ 0 ] - r . Min [ 0 ] , r . Max [ 1 ] - r . Min [ 1 ] , r . Max [ 2 ] - r . Min [ 2 ] , } }
6052	func NewServer ( conf * Config ) ( * Server , error ) { rpcsrv := rpc . NewServer ( ) mux := http . NewServeMux ( ) mux . HandleFunc ( HTTPPath , rpcsrv . ServeHTTP ) mux . Handle ( WSPath , rpcsrv . WebsocketHandler ( conf . AllowedOrigins ) ) httpsrv := & http . Server { Addr : conf . Addr , Handler : mux , } return & Server { conf : conf , rpcsrv : rpcsrv , httpsrv : httpsrv , } , nil }
5964	func ( otp HOTP ) Counter ( ) uint64 { counter := binary . BigEndian . Uint64 ( otp . counter [ : ] ) return counter }
7084	func ( s * RunConfig ) AddArgs ( args ... string ) { s . Args = append ( s . Args , args ... ) }
6707	func ( c * Client ) FirewallPolicies ( ) ( [ ] FirewallPolicy , error ) { var policies [ ] FirewallPolicy _ , err := c . MakeApiRequest ( "GET" , "/1.0/firewall_policies" , nil , & policies ) if err != nil { return nil , err } return policies , err }
2660	func flattenClusterDasConfigInfo ( d * schema . ResourceData , obj types . ClusterDasConfigInfo , version viapi . VSphereVersion ) error { var dsIDs [ ] string for _ , v := range obj . HeartbeatDatastore { dsIDs = append ( dsIDs , v . Value ) } err := structure . SetBatch ( d , map [ string ] interface { } { "ha_enabled" : obj . Enabled , "ha_heartbeat_datastore_policy" : obj . HBDatastoreCandidatePolicy , "ha_host_monitoring" : obj . HostMonitoring , "ha_vm_monitoring" : obj . VmMonitoring , "ha_heartbeat_datastore_ids" : dsIDs , } ) if err != nil { return err } if err := flattenClusterDasVMSettings ( d , obj . DefaultVmSettings , version ) ; err != nil { return err } if err := flattenResourceVSphereComputeClusterDasAdvancedOptions ( d , obj . Option ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := d . Set ( "ha_vm_component_protection" , obj . VmComponentProtecting ) ; err != nil { return err } } if * obj . AdmissionControlEnabled == false { return d . Set ( "ha_admission_control_policy" , clusterAdmissionControlTypeDisabled ) } return flattenBaseClusterDasAdmissionControlPolicy ( d , obj . AdmissionControlPolicy , version ) }
2353	func ( i * Image ) PutVertex ( dest [ ] float32 , dx , dy , sx , sy float32 , bx0 , by0 , bx1 , by1 float32 , cr , cg , cb , ca float32 ) { if i . backend == nil { i . allocate ( true ) } ox , oy , _ , _ := i . region ( ) oxf , oyf := float32 ( ox ) , float32 ( oy ) i . backend . restorable . PutVertex ( dest , dx , dy , sx + oxf , sy + oyf , bx0 + oxf , by0 + oyf , bx1 + oxf , by1 + oyf , cr , cg , cb , ca ) }
2557	func expandHostVirtualSwitchBondBridge ( d * schema . ResourceData ) * types . HostVirtualSwitchBondBridge { obj := & types . HostVirtualSwitchBondBridge { NicDevice : structure . SliceInterfacesToStrings ( d . Get ( "network_adapters" ) . ( [ ] interface { } ) ) , } obj . Beacon = expandHostVirtualSwitchBeaconConfig ( d ) obj . LinkDiscoveryProtocolConfig = expandLinkDiscoveryProtocolConfig ( d ) return obj }
7068	func ataRead ( r * ATAArg , rs io . ReadSeeker ) ( * ATAArg , error ) { if r . CmdStatus != ATACmdStatusRead28Bit && r . CmdStatus != ATACmdStatusRead48Bit { return nil , errATAAbort } if r . FlagWrite { return nil , errATAAbort } offset := calculateLBA ( r . LBA , r . FlagLBA48Extended ) * sectorSize if _ , err := rs . Seek ( offset , os . SEEK_SET ) ; err != nil { return nil , err } b := make ( [ ] byte , int ( r . SectorCount ) * sectorSize ) n , err := rs . Read ( b ) if err != nil { return nil , err } if sectors := n / sectorSize ; sectors != int ( r . SectorCount ) { return nil , errATAAbort } return & ATAArg { CmdStatus : ATACmdStatusReadyStatus , Data : b , } , nil }
4518	func ( s * SortFilter ) flipLast ( ) * SortFilter { last := s . cmp [ len ( s . cmp ) - 1 ] s . cmp [ len ( s . cmp ) - 1 ] = func ( a , b string ) int { return last ( b , a ) } return s }
5521	func string__concat ( L * lua . State ) int { v1 , t1 := luaToGoValue ( L , 1 ) v2 , t2 := luaToGoValue ( L , 2 ) s1 := valueToString ( L , v1 ) s2 := valueToString ( L , v2 ) result := s1 + s2 if t1 == t2 || isPredeclaredType ( t2 ) { v := reflect . ValueOf ( result ) makeValueProxy ( L , v . Convert ( t1 ) , cStringMeta ) } else if isPredeclaredType ( t1 ) { v := reflect . ValueOf ( result ) makeValueProxy ( L , v . Convert ( t2 ) , cStringMeta ) } else { L . PushString ( result ) } return 1 }
4577	func getFiles ( goroutines [ ] * Goroutine ) [ ] string { files := map [ string ] struct { } { } for _ , g := range goroutines { for _ , c := range g . Stack . Calls { files [ c . SrcPath ] = struct { } { } } } out := make ( [ ] string , 0 , len ( files ) ) for f := range files { out = append ( out , f ) } sort . Strings ( out ) return out }
6965	func ( h holidaysUSNational ) fixWeekend ( in time . Time ) time . Time { switch in . Weekday ( ) { case time . Saturday : return in . Add ( - 1 * 24 * time . Hour ) case time . Sunday : return in . Add ( 1 * 24 * time . Hour ) default : return in } }
7076	func FromJSON ( db * sql . DB , jsonIn [ ] byte ) ( Fixture , error ) { var tables Tables err := json . Unmarshal ( jsonIn , & tables ) return New ( db , tables ) , err }
4304	func newGraph ( ) * graph { return & graph { idToNodes : make ( map [ ID ] Node ) , nodeToSources : make ( map [ ID ] map [ ID ] float64 ) , nodeToTargets : make ( map [ ID ] map [ ID ] float64 ) , } }
1604	func ( m * MockSecretsManagerAPI ) PutResourcePolicyRequest ( arg0 * secretsmanager . PutResourcePolicyInput ) ( * request . Request , * secretsmanager . PutResourcePolicyOutput ) { ret := m . ctrl . Call ( m , "PutResourcePolicyRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . PutResourcePolicyOutput ) return ret0 , ret1 }
880	func ( d * SerialDriver ) GetSSHKeyPath ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHKeyPath ( ) }
6876	func ( e * execStreamerBuilder ) StdoutPrefix ( prefix string ) ExecStreamerBuilder { e . d . StdoutPrefix = prefix return e }
685	func newCloudFlareChanges ( action string , endpoints [ ] * endpoint . Endpoint , proxiedByDefault bool ) [ ] * cloudFlareChange { changes := make ( [ ] * cloudFlareChange , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , newCloudFlareChange ( action , endpoint , proxiedByDefault ) ) } return changes }
7291	func ( db DB ) Begin ( writable bool ) ( Tx , error ) { tx , err := db . DB . Begin ( writable ) return Tx { tx } , errorsp . WithStacks ( err ) }
2619	func SliceInterfacesToManagedObjectReferences ( s [ ] interface { } , t string ) [ ] types . ManagedObjectReference { var d [ ] types . ManagedObjectReference for _ , v := range s { d = append ( d , types . ManagedObjectReference { Type : t , Value : v . ( string ) , } ) } return d }
1499	func ( c * Container ) ShouldCreateWithSSMSecret ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) if c . Secrets == nil { return false } for _ , secret := range c . Secrets { if secret . Provider == SecretProviderSSM { return true } } return false }
5230	func ( f * Field ) Rows ( ) * PQLRowsQuery { text := fmt . Sprintf ( "Rows(field='%s')" , f . name ) return NewPQLRowsQuery ( text , f . index , nil ) }
6159	func ( w * Worker ) checkInPeriod ( logger log . Logger , hash common . Hash , periodKey string , periodErr error ) error { updateBlockNumber , err := w . getOfferingBlockNumber ( logger , hash ) if err != nil { return err } lastBlock , err := w . ethBack . LatestBlockNumber ( context . Background ( ) ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } removePeriod , err := data . ReadUintSetting ( w . db . Querier , periodKey ) if err != nil { return periodErr } if uint64 ( updateBlockNumber ) + uint64 ( removePeriod ) > lastBlock . Uint64 ( ) { return periodErr } return nil }
2528	func isNasVolume ( t types . HostFileSystemVolumeFileSystemType ) bool { switch t { case types . HostFileSystemVolumeFileSystemTypeNFS , types . HostFileSystemVolumeFileSystemTypeNFS41 : return true } return false }
2602	func FromPath ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . DistributedVirtualPortgroup , error ) { finder := find . NewFinder ( client . Client , false ) if dc != nil { finder . SetDatacenter ( dc ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) net , err := finder . Network ( ctx , name ) if err != nil { return nil , err } if net . Reference ( ) . Type != "DistributedVirtualPortgroup" { return nil , fmt . Errorf ( "network at path %q is not a portgroup (type %s)" , name , net . Reference ( ) . Type ) } return FromMOID ( client , net . Reference ( ) . Value ) }
2658	func flattenClusterConfigSpecEx ( d * schema . ResourceData , obj * types . ClusterConfigInfoEx , version viapi . VSphereVersion ) error { if err := flattenClusterDasConfigInfo ( d , obj . DasConfig , version ) ; err != nil { return err } if err := flattenClusterDpmConfigInfo ( d , obj . DpmConfigInfo ) ; err != nil { return err } if err := flattenClusterDrsConfigInfo ( d , obj . DrsConfig ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { if err := flattenClusterInfraUpdateHaConfigInfo ( d , obj . InfraUpdateHaConfig ) ; err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { if err := flattenClusterOrchestrationInfo ( d , obj . Orchestration ) ; err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return flattenClusterProactiveDrsConfigInfo ( d , obj . ProactiveDrsConfig ) } return nil }
1516	func handleInactivityTimeout ( reader io . ReadCloser , timeout time . Duration , cancelRequest func ( ) , canceled * uint32 ) ( io . ReadCloser , chan <- struct { } ) { done := make ( chan struct { } ) proxyReader := & proxyReader { ReadCloser : reader } go func ( ) { var lastCallCount uint64 for { select { case <- time . After ( timeout ) : case <- done : return } curCallCount := proxyReader . callCount ( ) if curCallCount == lastCallCount { atomic . AddUint32 ( canceled , 1 ) cancelRequest ( ) return } lastCallCount = curCallCount } } ( ) return proxyReader , done }
730	func ( p * AWSSDProvider ) GetServiceDetail ( serviceID * string ) ( * sd . Service , error ) { output , err := p . client . GetService ( & sd . GetServiceInput { Id : serviceID , } ) if err != nil { return nil , err } return output . Service , nil }
3540	func ( s * SyntheticsRequest ) HasBody ( ) bool { if s != nil && s . Body != nil { return true } return false }
1014	func ( s * Set ) Len ( ) int { s . RLock ( ) defer s . RUnlock ( ) return len ( s . list ) }
32	func ( tv * TagValue ) UnmarshalJSON ( json [ ] byte ) error { escapeLevel := 0 var parsedByte byte result := bytes . NewBuffer ( make ( [ ] byte , 0 , len ( json ) - 2 ) ) for i , b := range json { if i == 0 { if b != '"' { return errors . Errorf ( "expected '\"', got %q" , \" ) } b } continue if i == len ( json ) - 1 { if b != '"' { return errors . Errorf ( "expected '\"', got %q" , \" ) } b } } break switch escapeLevel { case 0 : if b == '_' { escapeLevel = 1 continue } result . WriteByte ( b ) case 1 : switch { case b == '_' : result . WriteByte ( '_' ) escapeLevel = 0 case b == '.' : result . WriteByte ( ':' ) escapeLevel = 0 case b >= '0' && b <= '9' : parsedByte = ( b - 48 ) << 4 escapeLevel = 2 case b >= 'A' && b <= 'F' : parsedByte = ( b - 55 ) << 4 escapeLevel = 2 default : return errors . Errorf ( "illegal escape sequence at byte %d (%c)" , i , b , ) } case 2 : switch { case b >= '0' && b <= '9' : parsedByte += b - 48 case b >= 'A' && b <= 'F' : parsedByte += b - 55 default : return errors . Errorf ( "illegal escape sequence at byte %d (%c)" , i , b , ) } result . WriteByte ( parsedByte ) escapeLevel = 0 default : panic ( "unexpected escape level" ) } }
2614	func Create ( rp * object . ResourcePool , name string , resSpec * types . ResourceConfigSpec , vSpec * types . VAppConfigSpec , folder * object . Folder ) ( * object . VirtualApp , error ) { log . Printf ( "[DEBUG] Creating vApp container %s/%s" , rp . InventoryPath , name ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) nva , err := rp . CreateVApp ( ctx , name , * resSpec , * vSpec , folder ) if err != nil { return nil , err } return nva , nil }
5133	func ( ui * ColorUI ) Log ( message string ) { ct . ChangeColor ( ui . LogFGColor . Code , ui . LogFGColor . Bright , ui . LogBGColor . Code , ui . LogBGColor . Bright ) ui . UI . Log ( message ) ct . ResetColor ( ) }
3480	func ( r * reqGetEvent ) GetEventOk ( ) ( Event , bool ) { if r == nil || r . Event == nil { return Event { } , false } return * r . Event , true }
4726	func ParseLine ( n int , unsafeText [ ] byte ) ( * Line , error ) { linetype := LineTypePlain var comment [ ] byte text := make ( [ ] byte , len ( unsafeText ) ) copy ( text , unsafeText ) if bytes . Contains ( text , commentPrefix ) { segs := bytes . Split ( text , commentPrefix ) text = segs [ 0 ] comment = segs [ 1 ] } var rx * regexp . Regexp for _ , item := range matchTypes { if regexes [ item . R ] . Match ( text ) { linetype = item . Type rx = regexes [ item . R ] break } } var d * Detail if linetype == LineTypeDetail || linetype == LineTypeParam { var err error d , err = parseDetail ( text , rx ) if err != nil { return nil , & ErrLine { N : n , Err : err } } } return & Line { Number : n , Type : linetype , Bytes : text , Regexp : rx , Comment : comment , detail : d , } , nil }
1809	func ( m * MockDockerClient ) ListPlugins ( arg0 context . Context , arg1 time . Duration , arg2 filters . Args ) dockerapi . ListPluginsResponse { ret := m . ctrl . Call ( m , "ListPlugins" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( dockerapi . ListPluginsResponse ) return ret0 }
2795	func BasePropertiesFromReference ( client * govmomi . Client , ref types . ManagedObjectReference ) ( * mo . ComputeResource , error ) { obj , err := BaseFromReference ( client , ref ) if err != nil { return nil , err } return BaseProperties ( obj ) }
5357	func SetsysForUid ( id int , key , value string ) error { if ! _IS_ROOT { return ErrNoRoot } _settings , err := getSettingsForUid ( id ) if err != nil { return err } return _Set ( _settings . global , key , value ) }
7321	func PublishEventContext ( ctx context . Context , eventName string , eventBody interface { } ) { pub := PublisherContext ( ctx ) if pub == nil { return } pub . Publish ( eventName , eventBody ) }
6753	func incrNonce ( nonce * [ 24 ] byte ) { for i := 23 ; 0 <= i ; i -- { nonce [ i ] += 1 if nonce [ i ] != 0 { return } } }
2923	func ( r * Subresource ) ControllerForCreateUpdate ( l object . VirtualDeviceList , ct string , bus int ) ( types . BaseVirtualController , error ) { log . Printf ( "[DEBUG] ControllerForCreateUpdate: Looking for controller type %s" , ct ) var ctlr types . BaseVirtualController var err error switch ct { case SubresourceControllerTypeIDE : ctlr = l . PickController ( & types . VirtualIDEController { } ) case SubresourceControllerTypeSATA : ctlr = l . PickController ( & types . VirtualAHCIController { } ) case SubresourceControllerTypeSCSI : ctlr , err = pickSCSIController ( l , bus ) case SubresourceControllerTypePCI : ctlr = l . PickController ( & types . VirtualPCIController { } ) default : return nil , fmt . Errorf ( "invalid controller type %T" , ct ) } if err != nil { return nil , err } if ctlr == nil { return nil , fmt . Errorf ( "could not find an available %s controller" , ct ) } if ctlr . GetVirtualController ( ) . BusNumber != 0 && ct != SubresourceControllerTypeSCSI { return nil , fmt . Errorf ( "there are no available slots on the primary %s controller" , ct ) } log . Printf ( "[DEBUG] ControllerForCreateUpdate: Found controller: %s" , l . Name ( ctlr . ( types . BaseVirtualDevice ) ) ) return ctlr , nil }
5449	func ( c * CallService ) Redirect ( sid string , u * url . URL ) ( * Call , error ) { data := url . Values { } data . Set ( "Url" , u . String ( ) ) return c . Update ( context . Background ( ) , sid , data ) }
6628	func ( r * Router ) ServeHTTP ( w http . ResponseWriter , req * http . Request ) { if root , exist := r . roots [ req . Method ] ; exist { handler , params , _ := root . match ( req . URL . Path ) if handler != nil { handler . ServeHTTP ( w , req , params ) return } } r . handleMissing ( w , req ) }
1127	func ( item Item ) Expired ( ) bool { if item . Expiration == 0 { return false } return time . Now ( ) . UnixNano ( ) > item . Expiration }
6381	func Select ( subject Enumerable , transform Transform ) Enumerable { return selecter { original : subject , transform : transform , } }
2906	func ( r * Subresource ) SetRestart ( key string ) { log . Printf ( "[DEBUG] %s: Resource argument %q requires a VM restart" , r , key ) switch d := r . rdd . ( type ) { case * schema . ResourceData : d . Set ( "reboot_required" , true ) case * schema . ResourceDiff : d . SetNew ( "reboot_required" , true ) default : log . Printf ( "[WARN] %s: Could not flag reboot_required: invalid type %T" , r , r . rdd ) } }
1596	func ( m * MockSecretsManagerAPI ) ListSecretVersionIdsPages ( arg0 * secretsmanager . ListSecretVersionIdsInput , arg1 func ( * secretsmanager . ListSecretVersionIdsOutput , bool ) bool ) error { ret := m . ctrl . Call ( m , "ListSecretVersionIdsPages" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
6600	func ( q * Query ) WaitTimeout ( d time . Duration ) * Query { q . headers = append ( q . headers , fmt . Sprintf ( "WaitTimeout: %d" , d / time . Millisecond ) ) return q }
1493	func ( c * Container ) GetAppliedStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . AppliedStatus }
6216	func ( w * Worker ) ClientAfterCooperativeClose ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientAfterCooperativeClose" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientAfterCooperativeClose ) if err != nil { return err } logger = logger . Add ( "channel" , ch ) ch . ChannelStatus = data . ChannelClosedCoop if err := w . saveRecord ( logger , w . db . Querier , ch ) ; err != nil { return err } if ch . ServiceStatus != data . ServiceTerminated { _ , err = w . processor . TerminateChannel ( ch . ID , data . JobTask , false ) if err != nil { logger . Error ( err . Error ( ) ) return ErrTerminateChannel } } client , err := w . account ( logger , ch . Client ) if err != nil { return err } return w . addJob ( logger , nil , data . JobAccountUpdateBalances , data . JobAccount , client . ID ) }
842	func ( c * ComputeUtil ) staticAddress ( ) ( string , error ) { isName , err := regexp . MatchString ( "[a-z]([-a-z0-9]*[a-z0-9])?" , c . address ) if err != nil { return "" , err } if ! isName { return c . address , nil } externalAddress , err := c . service . Addresses . Get ( c . project , c . region ( ) , c . address ) . Do ( ) if err != nil { return "" , err } return externalAddress . Address , nil }
2175	func ( v * SearchBar ) native ( ) * C . GtkSearchBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSearchBar ( p ) }
1091	func keyFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { if len ( s ) == 0 { return "" , nil } d , err := dep . NewKVGetQuery ( s ) if err != nil { return "" , err } d . EnableBlocking ( ) used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { if value == nil { return "" , nil } return value . ( string ) , nil } missing . Add ( d ) return "" , nil } }
4920	func NewWriterSize ( w io . Writer , size int ) * Writer { return & Writer { wr : bufio . NewWriterSize ( w , size ) , b : make ( [ ] byte , writerBufferSize ) , tr : unicode . Utf8ToCesu8Transformer , } }
123	func ( p * parser ) typecheck ( node Node ) ( err error ) { defer p . recover ( & err ) p . checkType ( node ) return nil }
3943	func Substitute ( s string , sub map [ string ] string ) ( buf string ) { buf = s var keys [ ] string for k := range sub { keys = append ( keys , k ) } sort . Strings ( keys ) for _ , key := range keys { buf = strings . Replace ( buf , key , sub [ key ] , - 1 ) } return }
5452	func ( c * CallService ) GetCallsInRange ( start time . Time , end time . Time , data url . Values ) CallPageIterator { if start . After ( end ) { panic ( "start date is after end date" ) } d := url . Values { } if data != nil { for k , v := range data { d [ k ] = v } } d . Del ( "StartTime" ) d . Del ( "Page" ) if start != Epoch { startFormat := start . UTC ( ) . Format ( APISearchLayout ) d . Set ( "StartTime>" , startFormat ) } if end != HeatDeath { endFormat := end . UTC ( ) . Add ( 24 * time . Hour ) . Format ( APISearchLayout ) d . Set ( "StartTime<" , endFormat ) } iter := NewPageIterator ( c . client , d , callsPathPart ) return & callDateIterator { start : start , end : end , p : iter , } }
4085	func CreateAlertDialog ( title , message string , button string ) * ConfirmationDialog { return CreateConfirmationDialog ( title , message , [ ] string { button } , 0 ) }
4650	func ( index * ClusteringIndex ) KNearest ( point Point , k int , maxDistance Meters , accept func ( p Point ) bool ) [ ] Point { return index . streetLevel . KNearest ( point , k , maxDistance , accept ) }
3944	func SubstituteRune ( s string , sub map [ rune ] string ) string { var buf bytes . Buffer for _ , c := range s { if d , ok := sub [ c ] ; ok { buf . WriteString ( d ) } else { buf . WriteRune ( c ) } } return buf . String ( ) }
594	func ContentCharset ( charsets ... string ) func ( next http . Handler ) http . Handler { for i , c := range charsets { charsets [ i ] = strings . ToLower ( c ) } return func ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if ! contentEncoding ( r . Header . Get ( "Content-Type" ) , charsets ... ) { w . WriteHeader ( http . StatusUnsupportedMediaType ) return } next . ServeHTTP ( w , r ) } ) } }
2314	func ( v Atom ) native ( ) C . GdkAtom { return C . toGdkAtom ( unsafe . Pointer ( uintptr ( v ) ) ) }
2501	func ( q * commandQueue ) appendVertices ( vertices [ ] float32 ) { if len ( q . vertices ) < q . nvertices + len ( vertices ) { n := q . nvertices + len ( vertices ) - len ( q . vertices ) q . vertices = append ( q . vertices , make ( [ ] float32 , n ) ... ) } copy ( q . vertices [ q . nvertices : ] , vertices ) q . nvertices += len ( vertices ) }
4541	func FqName ( o metav1 . Object ) string { if o . GetNamespace ( ) == "" { return o . GetName ( ) } return fmt . Sprintf ( "%s.%s" , o . GetNamespace ( ) , o . GetName ( ) ) }
5188	func ( c * Cluster ) Host ( ) * URI { c . mutex . Lock ( ) var host * URI for i := range c . okList { idx := ( i + c . lastHostIdx ) % len ( c . okList ) ok := c . okList [ idx ] if ok { host = c . hosts [ idx ] break } } c . lastHostIdx ++ c . mutex . Unlock ( ) if host != nil { return host } c . reset ( ) return host }
3973	func ( bus * EventBus ) Unsubscribe ( topic string , handler interface { } ) error { bus . lock . Lock ( ) defer bus . lock . Unlock ( ) if _ , ok := bus . handlers [ topic ] ; ok && len ( bus . handlers [ topic ] ) > 0 { bus . removeHandler ( topic , bus . findHandlerIdx ( topic , reflect . ValueOf ( handler ) ) ) return nil } return fmt . Errorf ( "topic %s doesn't exist" , topic ) }
5811	func ( m * CirconusMetrics ) RecordValue ( metric string , val float64 ) { m . SetHistogramValue ( metric , val ) }
5936	func ( r * BasicReporter ) PostCountTime ( statKey , userKey string , count int , timestamp int64 ) error { x := newClassicStatCount ( statKey , userKey , count ) x . Timestamp = timestamp r . add ( x ) return nil }
2667	func expandClusterFailoverHostAdmissionControlPolicy ( d * schema . ResourceData , version viapi . VSphereVersion , ) * types . ClusterFailoverHostAdmissionControlPolicy { obj := & types . ClusterFailoverHostAdmissionControlPolicy { FailoverHosts : structure . SliceInterfacesToManagedObjectReferences ( d . Get ( "ha_admission_control_failover_host_system_ids" ) . ( * schema . Set ) . List ( ) , "HostSystem" , ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . FailoverLevel = int32 ( d . Get ( "ha_admission_control_host_failure_tolerance" ) . ( int ) ) } return obj }
7099	func ( g GRPCLoggerV2 ) Infof ( format string , args ... interface { } ) { g . l . Infof ( format , args ... ) }
4429	func ( u * UUID ) DeepCopy ( ) * UUID { if u == nil { return nil } out := new ( UUID ) u . DeepCopyInto ( out ) return out }
2935	func resourceVSphereDatastoreClusterApplyTags ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } if tagsClient == nil { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping" , resourceVSphereDatastoreClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying any pending tags" , resourceVSphereDatastoreClusterIDString ( d ) ) return processTagDiff ( tagsClient , d , pod ) }
13	func ( ev * evaluator ) evalSubquery ( subq * SubqueryExpr ) * MatrixSelector { val := ev . eval ( subq ) . ( Matrix ) ms := & MatrixSelector { Range : subq . Range , Offset : subq . Offset , series : make ( [ ] storage . Series , 0 , len ( val ) ) , } for _ , s := range val { ms . series = append ( ms . series , NewStorageSeries ( s ) ) } return ms }
3686	func ( w * Widget ) GetManageStatusTitleTextOk ( ) ( string , bool ) { if w == nil || w . ManageStatusTitleText == nil { return "" , false } return * w . ManageStatusTitleText , true }
2003	func newDockerContainerMetadataResolver ( taskEngine ecsengine . TaskEngine ) ( * DockerContainerMetadataResolver , error ) { dockerTaskEngine , ok := taskEngine . ( * ecsengine . DockerTaskEngine ) if ! ok { return nil , fmt . Errorf ( "Could not load docker task engine" ) } resolver := & DockerContainerMetadataResolver { dockerTaskEngine : dockerTaskEngine , } return resolver , nil }
4370	func ProxyRequestFromContext ( ctx context . Context ) ( events . APIGatewayProxyRequest , bool ) { event , ok := ctx . Value ( requestContextKey ) . ( events . APIGatewayProxyRequest ) return event , ok }
2958	func flattenStorageDrsOptionSpec ( d * schema . ResourceData , opts [ ] types . BaseOptionValue ) error { m := make ( map [ string ] interface { } ) for _ , opt := range opts { m [ opt . GetOptionValue ( ) . Key ] = opt . GetOptionValue ( ) . Value } return d . Set ( "sdrs_advanced_options" , m ) }
2482	func updateGroundImage ( ground * ebiten . Image ) { ground . Clear ( ) x16 , y16 := thePlayer . Position ( ) a := thePlayer . Angle ( ) gw , gh := ground . Size ( ) w , h := gophersImage . Size ( ) op := & ebiten . DrawImageOptions { } op . GeoM . Translate ( float64 ( - x16 ) / 16 , float64 ( - y16 ) / 16 ) op . GeoM . Translate ( float64 ( - w * 2 ) , float64 ( - h * 2 ) ) op . GeoM . Rotate ( float64 ( - a ) * 2 * math . Pi / maxAngle + math . Pi * 3.0 / 2.0 ) op . GeoM . Translate ( float64 ( gw ) / 2 , float64 ( gh ) - 32 ) ground . DrawImage ( repeatedGophersImage , op ) }
5438	func ( bot * Bot ) Run ( ) { bot . Debug ( "Starting bot goroutines" ) var hijack bool if bot . HijackSession { if bot . SSL { bot . Crit ( "Can't Hijack a SSL connection" ) return } hijack = bot . hijackSession ( ) bot . Debug ( "Hijack" , "Did we?" , hijack ) } if ! hijack { err := bot . connect ( bot . Host ) if err != nil { bot . Crit ( "bot.Connect error" , "err" , err . Error ( ) ) return } bot . Info ( "Connected successfully!" ) } go bot . handleIncomingMessages ( ) go bot . handleOutgoingMessages ( ) go bot . StartUnixListener ( ) if ! bot . reconnecting { if bot . SASL { bot . SASLAuthenticate ( bot . Nick , bot . Password ) } else { bot . StandardRegistration ( ) } } for m := range bot . Incoming { if m == nil { log . Info ( "Disconnected" ) return } } }
1589	func ( m * MockSecretsManagerAPI ) GetResourcePolicy ( arg0 * secretsmanager . GetResourcePolicyInput ) ( * secretsmanager . GetResourcePolicyOutput , error ) { ret := m . ctrl . Call ( m , "GetResourcePolicy" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
4071	func MainLoop ( ) { RefreshScreen ( ) eventQueue := make ( chan term . Event ) go func ( ) { for { eventQueue <- term . PollEvent ( ) } } ( ) for { RefreshScreen ( ) select { case ev := <- eventQueue : switch ev . Type { case term . EventError : panic ( ev . Err ) default : ProcessEvent ( termboxEventToLocal ( ev ) ) } case cmd := <- loop . channel : if cmd . Type == EventQuit { return } ProcessEvent ( cmd ) } } }
6399	func ( stack * Stack ) Enumerate ( cancel <- chan struct { } ) Enumerator { stack . key . RLock ( ) defer stack . key . RUnlock ( ) return stack . underlyer . Enumerate ( cancel ) }
1286	func ( cgroup * CgroupResource ) Cleanup ( ) error { err := cgroup . control . Remove ( cgroup . cgroupRoot ) if err != nil { if err == cgroups . ErrCgroupDeleted { seelog . Warnf ( "Cgroup at %s has already been removed: %v" , cgroup . cgroupRoot , err ) return nil } return errors . Wrapf ( err , "resource: cleanup cgroup: unable to remove cgroup at %s" , cgroup . cgroupRoot ) } return nil }
5488	func ( r * RecordingService ) Delete ( ctx context . Context , sid string ) error { return r . client . DeleteResource ( ctx , recordingsPathPart , sid ) }
5267	func OptQueryColumnAttrs ( enable bool ) QueryOption { return func ( options * QueryOptions ) error { options . ColumnAttrs = enable return nil } }
4890	func ( s * Sniffer ) Go ( ) { defer s . dbConn . Close ( ) defer s . conn . Close ( ) req := newInitRequest ( ) if err := s . streamFragment ( dir ( true ) , s . clRd , s . dbWr , req ) ; err != nil { return } rep := newInitReply ( ) if err := s . streamFragment ( dir ( false ) , s . dbRd , s . clWr , rep ) ; err != nil { return } for { if err := s . stream ( dir ( true ) , s . clRd , s . dbWr ) ; err != nil { return } if err := s . stream ( dir ( false ) , s . dbRd , s . clWr ) ; err != nil { return } } }
3580	func ( t * ThresholdCount ) GetUnknown ( ) json . Number { if t == nil || t . Unknown == nil { return "" } return * t . Unknown }
4354	func Null ( in [ ] byte , pos int ) ( int , error ) { switch in [ pos ] { case 'n' : return expect ( in , pos , n ... ) return pos + 4 , nil default : return 0 , errUnexpectedValue } }
6243	func HexToAddress ( addr HexString ) ( common . Address , error ) { addrBytes , err := HexToBytes ( addr ) if err != nil { err = fmt . Errorf ( "unable to parse ethereum addr: %s" , err ) } return common . BytesToAddress ( addrBytes ) , err }
1307	func sendTaskStatusToECS ( client api . ECSClient , event * sendableEvent ) error { return client . SubmitTaskStateChange ( event . taskChange ) }
102	func ( t * Target ) Health ( ) TargetHealth { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . health }
5254	func ( c * Client ) Status ( ) ( Status , error ) { span := c . tracer . StartSpan ( "Client.Status" ) defer span . Finish ( ) _ , data , err := c . httpRequest ( "GET" , "/status" , nil , nil , false ) if err != nil { return Status { } , errors . Wrap ( err , "requesting /status" ) } status := Status { } err = json . Unmarshal ( data , & status ) if err != nil { return Status { } , errors . Wrap ( err , "unmarshaling /status data" ) } return status , nil }
4954	func Parse ( token string ) ( result [ ] [ ] byte , e error ) { parts := strings . Split ( token , "." ) result = make ( [ ] [ ] byte , len ( parts ) ) for i , part := range parts { if result [ i ] , e = base64url . Decode ( part ) ; e != nil { return nil , e } } return result , nil }
5037	func ( s * Session ) Fsync ( async bool ) error { return s . Run ( bson . D { { "fsync" , 1 } , { "async" , async } } , nil ) }
3054	func virtualMachineIPsForTag ( ctx context . Context , client * vSphereClient , id string ) ( [ ] string , error ) { vms , err := virtualMachinesForTag ( ctx , client , id ) if err != nil { return nil , err } return ipAddrsForVirtualMachines ( ctx , client , vms ) }
2169	func ( v * VariantDict ) native ( ) * C . GVariantDict { if v == nil || v . GVariantDict == nil { return nil } p := unsafe . Pointer ( v . GVariantDict ) return C . toGVariantDict ( p ) }
4151	func ( p * prefixTrie ) String ( ) string { children := [ ] string { } padding := strings . Repeat ( "| " , p . level ( ) + 1 ) for bits , child := range p . children { if child == nil { continue } childStr := fmt . Sprintf ( "\n%s%d , \n , padding , bits ) child . String ( ) } children = append ( children , childStr ) }
5909	func ( alg Algorithm ) Encode ( signer Signer , obj interface { } ) ( [ ] byte , error ) { return Encode ( alg , signer , obj ) }
2891	func dvsFromUUID ( client * govmomi . Client , uuid string ) ( * object . VmwareDistributedVirtualSwitch , error ) { dvsm := types . ManagedObjectReference { Type : "DistributedVirtualSwitchManager" , Value : "DVSManager" } req := & types . QueryDvsByUuid { This : dvsm , Uuid : uuid , } resp , err := methods . QueryDvsByUuid ( context . TODO ( ) , client , req ) if err != nil { return nil , err } return dvsFromMOID ( client , resp . Returnval . Reference ( ) . Value ) }
6383	func SelectMany ( subject Enumerable , toMany Unfolder ) Enumerable { return selectManyer { original : subject , toMany : toMany , } }
565	func NewMux ( ) * Mux { mux := & Mux { tree : & node { } , pool : & sync . Pool { } } mux . pool . New = func ( ) interface { } { return NewRouteContext ( ) } return mux }
806	func addHostOnlyDHCPServer ( ifname string , d dhcpServer , vbox VBoxManager ) error { name := dhcpPrefix + ifname dhcps , err := listDHCPServers ( vbox ) if err != nil { return err } command := "add" if dhcp , ok := dhcps [ name ] ; ok { command = "modify" if ( dhcp . IPv4 . IP . Equal ( d . IPv4 . IP ) ) && ( dhcp . IPv4 . Mask . String ( ) == d . IPv4 . Mask . String ( ) ) && ( dhcp . LowerIP . Equal ( d . LowerIP ) ) && ( dhcp . UpperIP . Equal ( d . UpperIP ) ) && ( dhcp . Enabled == d . Enabled ) { return nil } } args := [ ] string { "dhcpserver" , command , "--netname" , name , "--ip" , d . IPv4 . IP . String ( ) , "--netmask" , net . IP ( d . IPv4 . Mask ) . String ( ) , "--lowerip" , d . LowerIP . String ( ) , "--upperip" , d . UpperIP . String ( ) , } if d . Enabled { args = append ( args , "--enable" ) } else { args = append ( args , "--disable" ) } if runtime . GOOS == "windows" { log . Warn ( "Windows might ask for the permission to configure a dhcp server. Sometimes, such confirmation window is minimized in the taskbar." ) } return vbox . vbm ( args ... ) }
280	func lexNumberOrDuration ( l * lexer ) stateFn { if l . scanNumber ( ) { l . emit ( ItemNumber ) return lexStatements } if l . accept ( "smhdwy" ) { if isAlphaNumeric ( l . next ( ) ) { return l . errorf ( "bad number or duration syntax: %q" , l . input [ l . start : l . pos ] ) } l . backup ( ) l . emit ( ItemDuration ) return lexStatements } return l . errorf ( "bad number or duration syntax: %q" , l . input [ l . start : l . pos ] ) }
626	func NewDomainFilter ( domainFilters [ ] string ) DomainFilter { filters := make ( [ ] string , len ( domainFilters ) ) for i , domain := range domainFilters { filters [ i ] = strings . TrimSuffix ( strings . TrimSpace ( domain ) , "." ) } return DomainFilter { filters } }
6486	func NoCache ( reqCtx * fasthttp . RequestCtx ) { reqCtx . Response . Header . Set ( cfg . NoCacheHeader , "true" ) }
4009	func NewClient ( httpClient * http . Client ) * Client { return & Client { client : graphql . NewClient ( "https://api.github.com/graphql" , httpClient ) , } }
1776	func validateAttachTaskNetworkInterfacesMessage ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) error { if message == nil { return errors . Errorf ( "attach eni handler validation: empty AttachTaskNetworkInterface message received from ECS" ) } messageId := aws . StringValue ( message . MessageId ) if messageId == "" { return errors . Errorf ( "attach eni handler validation: message id not set in AttachTaskNetworkInterface message received from ECS" ) } clusterArn := aws . StringValue ( message . ClusterArn ) if clusterArn == "" { return errors . Errorf ( "attach eni handler validation: clusterArn not set in AttachTaskNetworkInterface message received from ECS" ) } containerInstanceArn := aws . StringValue ( message . ContainerInstanceArn ) if containerInstanceArn == "" { return errors . Errorf ( "attach eni handler validation: containerInstanceArn not set in AttachTaskNetworkInterface message received from ECS" ) } enis := message . ElasticNetworkInterfaces if len ( enis ) != 1 { return errors . Errorf ( "attach eni handler validation: incorrect number of ENIs in AttachTaskNetworkInterface message received from ECS. Obtained %d" , len ( enis ) ) } eni := enis [ 0 ] if aws . StringValue ( eni . MacAddress ) == "" { return errors . Errorf ( "attach eni handler validation: MACAddress not listed in AttachTaskNetworkInterface message received from ECS" ) } taskArn := aws . StringValue ( message . TaskArn ) if taskArn == "" { return errors . Errorf ( "attach eni handler validation: taskArn not set in AttachTaskNetworkInterface message received from ECS" ) } timeout := aws . Int64Value ( message . WaitTimeoutMs ) if timeout <= 0 { return errors . Errorf ( "attach eni handler validation: invalid timeout listed in AttachTaskNetworkInterface message received from ECS" ) } return nil }
5654	func ( kb dbKeybase ) Sign ( name , passphrase string , msg [ ] byte ) ( sig crypto . Signature , pub crypto . PubKey , err error ) { info , err := kb . Get ( name ) if err != nil { return } var priv crypto . PrivKey switch info . ( type ) { case localInfo : linfo := info . ( localInfo ) if linfo . PrivKeyArmor == "" { err = fmt . Errorf ( "private key not available" ) return } priv , err = unarmorDecryptPrivKey ( linfo . PrivKeyArmor , passphrase ) if err != nil { return nil , nil , err } case ledgerInfo : linfo := info . ( ledgerInfo ) priv , err = crypto . NewPrivKeyLedgerSecp256k1 ( linfo . Path ) if err != nil { return } case offlineInfo : linfo := info . ( offlineInfo ) fmt . Printf ( "Bytes to sign:\n%s" , \n ) msg buf := bufio . NewReader ( os . Stdin ) fmt . Printf ( "\nEnter Amino-encoded signature:\n" ) \n \n signed , err := buf . ReadString ( '\n' ) } if err != nil { return nil , nil , err } cdc . MustUnmarshalBinary ( [ ] byte ( signed ) , sig ) return sig , linfo . GetPubKey ( ) , nil sig , err = priv . Sign ( msg ) }
5348	func getSettingsForUid ( id int ) ( settings , error ) { u , err := user . LookupUID ( id ) if err != nil { return settings { } , err } if u . Shell == "" { return settings { } , NoShellError ( u . Name ) } if u . Dir == "" { return settings { } , NoHomeError ( u . Name ) } shell := path . Base ( u . Shell ) _settings := settings { global : systemFile [ _SHELL_SH ] , user : path . Join ( u . Dir , userFile [ _SHELL_SH ] ) , kde : path . Join ( u . Dir , kdeFile ) , } info , err := os . Stat ( _settings . kde ) if err == nil && info . IsDir ( ) { _settings . useKDE = true } for _ , v := range shFamily { if v == shell { return _settings , nil } } return settings { } , fmt . Errorf ( "shell unsopported: %s" , shell ) }
2497	func ( u * UserInterface ) actualScreenScale ( ) float64 { if cm , ok := getCachedMonitor ( u . window . GetPos ( ) ) ; ok { return u . getScale ( ) * devicescale . GetAt ( cm . x , cm . y ) } return u . getScale ( ) * devicescale . GetAt ( u . currentMonitor ( ) . GetPos ( ) ) }
3484	func ( r * reqGetTags ) HasTags ( ) bool { if r != nil && r . Tags != nil { return true } return false }
3009	func ( b * EnvironmentBrowser ) DefaultDevices ( ctx context . Context , key string , host * object . HostSystem ) ( object . VirtualDeviceList , error ) { var eb mo . EnvironmentBrowser err := b . Properties ( ctx , b . Reference ( ) , nil , & eb ) if err != nil { return nil , err } req := types . QueryConfigOption { This : b . Reference ( ) , Key : key , } if host != nil { ref := host . Reference ( ) req . Host = & ref } res , err := methods . QueryConfigOption ( ctx , b . Client ( ) , & req ) if err != nil { return nil , err } if res . Returnval == nil { return nil , errors . New ( "no config options were found for the supplied criteria" ) } return object . VirtualDeviceList ( res . Returnval . DefaultDevice ) , nil }
1537	func ValueFromRequest ( r * http . Request , field string ) ( string , bool ) { values := r . URL . Query ( ) _ , exists := values [ field ] return values . Get ( field ) , exists }
5190	func ( c * Cluster ) Hosts ( ) [ ] URI { hosts := make ( [ ] URI , 0 , len ( c . hosts ) ) for i , host := range c . hosts { if c . okList [ i ] { hosts = append ( hosts , * host ) } } return hosts }
3028	func Index ( vs [ ] string , t string ) int { for i , v := range vs { if v == t { return i } } return - 1 }
4723	func New ( t T , URL string ) * Runner { r := & Runner { t : t , rootURL : URL , vars : make ( map [ string ] * parse . Value ) , DoRequest : http . DefaultTransport . RoundTrip , Log : func ( s string ) { fmt . Println ( s ) } , Verbose : func ( args ... interface { } ) { if ! testing . Verbose ( ) { return } fmt . Println ( args ... ) } , ParseBody : ParseJSONBody , NewRequest : http . NewRequest , } for _ , e := range os . Environ ( ) { pair := strings . Split ( e , "=" ) r . vars [ pair [ 0 ] ] = parse . ParseValue ( [ ] byte ( pair [ 1 ] ) ) } return r }
4000	func LintCertificate ( c * x509 . Certificate ) * ResultSet { if c == nil { return nil } res := new ( ResultSet ) res . execute ( c ) res . Version = Version res . Timestamp = time . Now ( ) . Unix ( ) return res }
662	func NewTargets ( target ... string ) Targets { t := make ( Targets , 0 , len ( target ) ) t = append ( t , target ... ) return t }
6516	func ( c Client ) Buy ( amount float64 , agreeBtcAmountVaries bool ) ( * transfer , error ) { params := map [ string ] interface { } { "qty" : amount , "agree_btc_amount_varies" : agreeBtcAmountVaries , } holder := transferHolder { } if err := c . Post ( "buys" , params , & holder ) ; err != nil { return nil , err } if err := checkApiErrors ( holder . response , "Buy" ) ; err != nil { return nil , err } return & holder . Transfer , nil }
7245	func ( l * logger ) Infoln ( vals ... interface { } ) { l . mut . Lock ( ) defer l . mut . Unlock ( ) s := fmt . Sprintln ( vals ... ) l . logger . Output ( 2 , "INFO: " + s ) l . callHandlers ( LevelInfo , s ) }
5931	func PostEZCount ( statName , ezkey string , count int ) error { return DefaultReporter . PostEZCount ( statName , ezkey , count ) }
2084	func ( mr * MockRoundTripperMockRecorder ) RoundTrip ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "RoundTrip" , reflect . TypeOf ( ( * MockRoundTripper ) ( nil ) . RoundTrip ) , arg0 ) }
5945	func NewBatchReporter ( reporter Reporter , interval time . Duration ) Reporter { br := & BatchReporter { r : reporter , batchInterval : interval , caches : make ( map [ string ] * statCache ) , shutdownBatchCh : make ( chan struct { } ) , } go br . batchLoop ( ) return br }
5556	func ( d * digest ) Sum ( in [ ] byte ) [ ] byte { s := d . Sum64 ( ) in = append ( in , byte ( s ) ) in = append ( in , byte ( s >> 8 ) ) in = append ( in , byte ( s >> 16 ) ) in = append ( in , byte ( s >> 24 ) ) in = append ( in , byte ( s >> 32 ) ) in = append ( in , byte ( s >> 40 ) ) in = append ( in , byte ( s >> 48 ) ) in = append ( in , byte ( s >> 56 ) ) return in }
4087	func ( c * CheckBox ) SetState ( val int ) { c . mtx . Lock ( ) defer c . mtx . Unlock ( ) if val == c . state { return } if val < 0 { val = 0 } if val > 1 && ! c . allow3state { val = 1 } if val > 2 { val = 2 } c . state = val if c . onChange != nil { go c . onChange ( val ) } }
166	func ( g * RuleGroups ) Validate ( ) ( errs [ ] error ) { set := map [ string ] struct { } { } for _ , g := range g . Groups { if g . Name == "" { errs = append ( errs , errors . Errorf ( "Groupname should not be empty" ) ) } if _ , ok := set [ g . Name ] ; ok { errs = append ( errs , errors . Errorf ( "groupname: \"%s\" is repeated in the same file" , \" ) , ) } \" g . Name } set [ g . Name ] = struct { } { } }
5352	func MSet ( keys , values [ ] string ) error { err := _MSet ( _SETTINGS . user , keys , values ) if err != nil { return err } if _SETTINGS . useKDE { return _MSet ( _SETTINGS . kde , keys , values ) } return nil }
4347	func DictionaryEntropy ( match match . Match , rank float64 ) float64 { baseEntropy := math . Log2 ( rank ) upperCaseEntropy := extraUpperCaseEntropy ( match ) return baseEntropy + upperCaseEntropy }
5940	func ( r * BasicReporter ) PostEZCountOne ( statName , ezkey string ) error { return r . PostEZCount ( statName , ezkey , 1 ) }
2445	func ( i * Image ) makeStaleIfDependingOn ( target * Image ) { if i . stale { return } if i . dependsOn ( target ) { i . makeStale ( ) } }
69	func ( ls Labels ) Map ( ) map [ string ] string { m := make ( map [ string ] string , len ( ls ) ) for _ , l := range ls { m [ l . Name ] = l . Value } return m }
6677	func ( v Vec ) ApproxFuncEqual ( v2 Vec , eq func ( float64 , float64 ) bool ) bool { if ! eq ( v . X , v2 . X ) { return false } if ! eq ( v . Y , v2 . Y ) { return false } return true }
1843	func ( f * factory ) getClient ( version dockerclient . DockerVersion ) ( sdkclient . Client , error ) { client , ok := f . clients [ version ] if ! ok { return nil , errors . New ( "docker client factory: client not found for docker version: " + string ( version ) ) } return client , nil }
6868	func ( e * execStreamer ) ExecAndWait ( ) error { cmd , err := e . StartExec ( ) if err != nil { return err } e . stdOutAndErrWaitGroup . Wait ( ) err = cmd . Wait ( ) if err != nil { return err } return nil }
6559	func ( c Command ) String ( ) string { s := fmt . Sprintf ( "COMMAND [%d] %s" , time . Now ( ) . Unix ( ) , c . name ) if len ( c . args ) > 0 { s += ";" + strings . Join ( c . args , ";" ) } s += "\n\n" \n }
2663	func expandClusterFailoverResourcesAdmissionControlPolicy ( d * schema . ResourceData , version viapi . VSphereVersion , ) * types . ClusterFailoverResourcesAdmissionControlPolicy { obj := & types . ClusterFailoverResourcesAdmissionControlPolicy { CpuFailoverResourcesPercent : int32 ( d . Get ( "ha_admission_control_resource_percentage_cpu" ) . ( int ) ) , MemoryFailoverResourcesPercent : int32 ( d . Get ( "ha_admission_control_resource_percentage_memory" ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . AutoComputePercentages = structure . GetBool ( d , "ha_admission_control_resource_percentage_auto_compute" ) obj . FailoverLevel = int32 ( d . Get ( "ha_admission_control_host_failure_tolerance" ) . ( int ) ) } return obj }
6238	func FromBase64ToHex ( s Base64String ) ( string , error ) { b , err := ToBytes ( s ) if err != nil { return "" , err } return hex . EncodeToString ( b ) , nil }
31	func New ( fs http . FileSystem , t time . Time ) http . FileSystem { return & timefs { fs : fs , t : t } }
4868	func IsPublicIP ( ip net . IP ) bool { if ! ip . IsGlobalUnicast ( ) { return false } for _ , mask := range privateMasks { if mask . Contains ( ip ) { return false } } return true }
3387	func ( m * MetricMetadata ) GetPerUnitOk ( ) ( string , bool ) { if m == nil || m . PerUnit == nil { return "" , false } return * m . PerUnit , true }
6287	func ( t * BTTracer ) SetTracerPath ( path string ) { t . m . Lock ( ) defer t . m . Unlock ( ) t . cmd = path }
4921	func ( w * Writer ) Flush ( ) error { if w . err != nil { return w . err } return w . wr . Flush ( ) }
5596	func ( m State ) Validate ( formats strfmt . Registry ) error { var res [ ] error if err := m . validateStateEnum ( "" , "body" , m ) ; err != nil { return err } if len ( res ) > 0 { return errors . CompositeValidationError ( res ... ) } return nil }
1608	func ( m * MockSecretsManagerAPI ) PutSecretValueWithContext ( arg0 aws . Context , arg1 * secretsmanager . PutSecretValueInput , arg2 ... request . Option ) ( * secretsmanager . PutSecretValueOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "PutSecretValueWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
4696	func ( e * htmlTag ) setAttributes ( ) error { parsedTokens := e . parseTokens ( ) var i int var token string var setTextValue bool for i , token = range parsedTokens { kv := strings . Split ( token , equal ) if len ( kv ) < 2 { setTextValue = true break } k := kv [ 0 ] v := strings . Join ( kv [ 1 : ] , equal ) if len ( v ) > 1 && strings . HasPrefix ( v , doubleQuote ) && strings . HasSuffix ( v , doubleQuote ) { v = v [ 1 : len ( v ) - 1 ] } switch k { case attributeNameID : if e . id != "" { return fmt . Errorf ( "multiple IDs are specified [file: %s][line: %d]" , e . ln . fileName ( ) , e . ln . no ) } e . id = v case e . opts . AttributeNameClass : e . classes = append ( e . classes , strings . Split ( v , space ) ... ) default : e . attributes = append ( e . attributes , htmlAttribute { k , v } ) } } if setTextValue { e . textValue = strings . Join ( parsedTokens [ i : ] , space ) } return nil }
4338	func Prefix ( p string ) Option { return Option ( func ( c * config ) { c . Client . Prefix += strings . TrimSuffix ( p , "." ) + "." } ) }
3458	func ( q * QueryConfig ) GetQueryString ( ) string { if q == nil || q . QueryString == nil { return "" } return * q . QueryString }
1423	func ( cs * ClientServerImpl ) IsReady ( ) bool { cs . writeLock . RLock ( ) defer cs . writeLock . RUnlock ( ) return cs . conn != nil }
4254	func ( l * LinuxFactory ) StartInitialization ( ) ( err error ) { pipefd , err := strconv . Atoi ( os . Getenv ( "_LIBCONTAINER_INITPIPE" ) ) if err != nil { return err } var ( pipe = os . NewFile ( uintptr ( pipefd ) , "pipe" ) it = initType ( os . Getenv ( "_LIBCONTAINER_INITTYPE" ) ) ) os . Clearenv ( ) defer func ( ) { if err != nil { ioutil . ReadAll ( pipe ) if err := json . NewEncoder ( pipe ) . Encode ( newSystemError ( err ) ) ; err != nil { panic ( err ) } } pipe . Close ( ) } ( ) i , err := newContainerInit ( it , pipe ) if err != nil { return err } return i . Init ( ) }
50	func ( d * Discovery ) shouldWatch ( name string , tags [ ] string ) bool { return d . shouldWatchFromName ( name ) && d . shouldWatchFromTags ( tags ) }
7034	func NewConn ( ) ( * Conn , error ) { id , err := shortid . UUID ( ) if err != nil { return nil , err } c := & Conn { ID : id , Session : cmap . New ( ) , resRoutes : cmap . New ( ) , deadline : time . Second * time . Duration ( 300 ) , disconnHandler : func ( c * Conn ) { } , } c . connected . Store ( false ) return c , nil }
4923	func ( w * Writer ) Write ( p [ ] byte ) { if w . err != nil { return } w . wr . Write ( p ) }
2969	func DiskImportOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) error { log . Printf ( "[DEBUG] DiskImportOperation: Performing pre-read import and validation of virtual disks" ) devices := SelectDisks ( l , d . Get ( "scsi_controller_count" ) . ( int ) ) devSort := virtualDeviceListSorter { Sort : devices , DeviceList : l , } log . Printf ( "[DEBUG] DiskImportOperation: Disk devices order before sort: %s" , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( "[DEBUG] DiskImportOperation: Disk devices order after sort: %s" , DeviceListString ( devices ) ) var curSet [ ] interface { } log . Printf ( "[DEBUG] DiskImportOperation: Validating disk type and saving " ) for i , device := range devices { vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return fmt . Errorf ( "could not find controller with key %d" , vd . Key ) } addr , err := computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return fmt . Errorf ( "error computing device address: %s" , err ) } ct , _ , _ , err := splitDevAddr ( addr ) if err != nil { return fmt . Errorf ( "disk.%d: error parsing device address %s: %s" , i , addr , err ) } if ct != SubresourceControllerTypeSCSI { return fmt . Errorf ( "disk.%d: unsupported controller type %s for disk %s. The VM resource supports SCSI disks only" , i , ct , addr ) } if _ , ok := device . ( * types . VirtualDisk ) . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) ; ! ok { return fmt . Errorf ( "disk.%d: unsupported disk type at %s (expected flat VMDK version 2, got %T)" , i , addr , device . ( * types . VirtualDisk ) . Backing , ) } m := make ( map [ string ] interface { } ) m [ "key" ] = ( i + 1 ) * - 1 m [ "device_address" ] = addr m [ "label" ] = fmt . Sprintf ( "disk%d" , i ) m [ "keep_on_remove" ] = true curSet = append ( curSet , m ) } log . Printf ( "[DEBUG] DiskImportOperation: Discovered disks from import: %s" , subresourceListString ( curSet ) ) if err := d . Set ( subresourceTypeDisk , curSet ) ; err != nil { return err } log . Printf ( "[DEBUG] DiskImportOperation: Pre-read import and validation complete" ) return nil }
4193	func ( u * Updater ) UpdateOrgs ( ) error { ocs , err := u . Cfg . GetOrgConfigs ( ) if err != nil { return err } for _ , oc := range ocs { org , err := u . OrgManager . FindOrg ( oc . Org ) if err != nil { return errors . Wrap ( err , "finding org for org configs in update orgs" ) } isolationSegmentMap , err := u . isolationSegmentMap ( ) if err != nil { return err } isolationSegmentGUID , err := u . getIsolationSegmentGUID ( oc . DefaultIsoSegment , isolationSegmentMap ) if err != nil { return err } if org . DefaultIsolationSegmentGuid != isolationSegmentGUID { if u . Peek { if isolationSegmentGUID != "" { lo . G . Infof ( "[dry-run]: set default isolation segment for org %s to %s" , oc . Org , oc . DefaultIsoSegment ) } else { lo . G . Infof ( "[dry-run]: reset default isolation segment for org %s" , oc . Org ) } continue } if isolationSegmentGUID != "" { lo . G . Infof ( "set default isolation segment for org %s to %s" , oc . Org , oc . DefaultIsoSegment ) err = u . Client . DefaultIsolationSegmentForOrg ( org . Guid , isolationSegmentGUID ) if err != nil { return err } } else { lo . G . Infof ( "reset default isolation segment for org %s" , oc . Org ) err = u . Client . ResetDefaultIsolationSegmentForOrg ( org . Guid ) if err != nil { return err } } } } return nil }
5196	func NewPQLBaseQuery ( pql string , index * Index , err error ) * PQLBaseQuery { return & PQLBaseQuery { index : index , pql : pql , err : err , hasKeys : index . options . keys , } }
2415	func Loop ( ch <- chan error ) error { atomic . StoreInt32 ( & started , 1 ) for { select { case f := <- funcs : f ( ) case err := <- ch : return err } } }
5136	func ( ui * ColorUI ) Info ( message string ) { ct . ChangeColor ( ui . InfoFGColor . Code , ui . InfoFGColor . Bright , ui . InfoBGColor . Code , ui . InfoBGColor . Bright ) ui . UI . Info ( message ) ct . ResetColor ( ) }
2240	func ( v * Entry ) native ( ) * C . GtkEntry { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEntry ( p ) }
3180	func ( client * Client ) UpdateAlert ( alert * Alert ) error { return client . doJsonRequest ( "PUT" , fmt . Sprintf ( "/v1/alert/%d" , alert . Id ) , alert , nil ) }
371	func ( a * Args ) AddBytesK ( key [ ] byte , value string ) { a . args = appendArg ( a . args , b2s ( key ) , value , argsHasValue ) }
1818	func ( m * MockCache ) Set ( arg0 string , arg1 async . Value ) { m . ctrl . Call ( m , "Set" , arg0 , arg1 ) }
253	func NewManager ( o * Options , logger log . Logger ) * Manager { ctx , cancel := context . WithCancel ( context . Background ( ) ) if o . Do == nil { o . Do = do } if logger == nil { logger = log . NewNopLogger ( ) } n := & Manager { queue : make ( [ ] * Alert , 0 , o . QueueCapacity ) , ctx : ctx , cancel : cancel , more : make ( chan struct { } , 1 ) , opts : o , logger : logger , } queueLenFunc := func ( ) float64 { return float64 ( n . queueLen ( ) ) } alertmanagersDiscoveredFunc := func ( ) float64 { return float64 ( len ( n . Alertmanagers ( ) ) ) } n . metrics = newAlertMetrics ( o . Registerer , o . QueueCapacity , queueLenFunc , alertmanagersDiscoveredFunc , ) return n }
1370	func ( handler * TaskHandler ) batchContainerEventUnsafe ( event api . ContainerStateChange ) { seelog . Infof ( "TaskHandler: batching container event: %s" , event . String ( ) ) handler . tasksToContainerStates [ event . TaskArn ] = append ( handler . tasksToContainerStates [ event . TaskArn ] , event ) }
5435	func ( bot * Bot ) StandardRegistration ( ) { if bot . Password != "" { bot . Send ( "PASS " + bot . Password ) } bot . Debug ( "Sending standard registration" ) bot . sendUserCommand ( bot . Nick , bot . Nick , "8" ) bot . SetNick ( bot . Nick ) }
405	func ( u * URI ) SetScheme ( scheme string ) { u . scheme = append ( u . scheme [ : 0 ] , scheme ... ) lowercaseBytes ( u . scheme ) }
431	func ( ctx * RequestCtx ) String ( ) string { return fmt . Sprintf ( "#%016X - %s<->%s - %s %s" , ctx . ID ( ) , ctx . LocalAddr ( ) , ctx . RemoteAddr ( ) , ctx . Request . Header . Method ( ) , ctx . URI ( ) . FullURI ( ) ) }
1120	func timestamp ( s ... string ) ( string , error ) { switch len ( s ) { case 0 : return now ( ) . Format ( time . RFC3339 ) , nil case 1 : if s [ 0 ] == "unix" { return strconv . FormatInt ( now ( ) . Unix ( ) , 10 ) , nil } return now ( ) . Format ( s [ 0 ] ) , nil default : return "" , fmt . Errorf ( "timestamp: wrong number of arguments, expected 0 or 1" + ", but got %d" , len ( s ) ) } }
6529	func NewSerialDispatcher ( handlers [ ] Handler ) Dispatcher { return & SerialDispatcher { handlers : handlers , mutex : sync . RWMutex { } , } }
265	func ( i ItemType ) isComparisonOperator ( ) bool { switch i { case ItemEQL , ItemNEQ , ItemLTE , ItemLSS , ItemGTE , ItemGTR : return true default : return false } }
4586	func ( a * Arg ) IsPtr ( ) bool { return a . Value > 16 * 1024 * 1024 && a . Value < math . MaxInt64 }
144	func ( c * Client ) Write ( samples model . Samples ) error { conn , err := net . DialTimeout ( c . transport , c . address , c . timeout ) if err != nil { return err } defer conn . Close ( ) var buf bytes . Buffer for _ , s := range samples { k := pathFromMetric ( s . Metric , c . prefix ) t := float64 ( s . Timestamp . UnixNano ( ) ) / 1e9 v := float64 ( s . Value ) if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { level . Debug ( c . logger ) . Log ( "msg" , "cannot send value to Graphite, skipping sample" , "value" , v , "sample" , s ) continue } fmt . Fprintf ( & buf , "%s %f %f\n" , \n , k , v ) } t _ , err = conn . Write ( buf . Bytes ( ) ) }
2948	func resourceVSphereDatastoreClusterFlattenSDRSData ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { log . Printf ( "[DEBUG] %s: Saving datastore cluster attributes" , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return err } version := viapi . ParseVersionFromClient ( client ) props , err := storagepod . Properties ( pod ) if err != nil { return err } return flattenStorageDrsPodConfigInfo ( d , props . PodStorageDrsEntry . StorageDrsConfig . PodConfig , version ) }
5459	func ( cmps * CountryMessagingPriceService ) Get ( ctx context . Context , isoCountry string ) ( * MessagePrice , error ) { messagePrice := new ( MessagePrice ) err := cmps . client . GetResource ( ctx , messagingPathPart + "/Countries" , isoCountry , messagePrice ) return messagePrice , err }
1686	func FinalSave ( saver statemanager . Saver , taskEngine engine . TaskEngine ) error { engineDisabled := make ( chan error ) disableTimer := time . AfterFunc ( engineDisableTimeout , func ( ) { engineDisabled <- errors . New ( "final save: timed out waiting for TaskEngine to settle" ) } ) go func ( ) { seelog . Debug ( "Shutting down task engine for final save" ) taskEngine . Disable ( ) disableTimer . Stop ( ) engineDisabled <- nil } ( ) disableErr := <- engineDisabled stateSaved := make ( chan error ) saveTimer := time . AfterFunc ( finalSaveTimeout , func ( ) { stateSaved <- errors . New ( "final save: timed out trying to save to disk" ) } ) go func ( ) { seelog . Debug ( "Saving state before shutting down" ) stateSaved <- saver . ForceSave ( ) saveTimer . Stop ( ) } ( ) saveErr := <- stateSaved if disableErr != nil || saveErr != nil { return apierrors . NewMultiError ( disableErr , saveErr ) } return nil }
1674	func ( auth * ASMAuthResource ) Create ( ) error { seelog . Infof ( "ASM Auth: Retrieving credentials for containers in task: [%s]" , auth . taskARN ) if auth . dockerAuthData == nil { auth . dockerAuthData = make ( map [ string ] types . AuthConfig ) } for _ , a := range auth . GetRequiredASMResources ( ) { err := auth . retrieveASMDockerAuthData ( a ) if err != nil { auth . setTerminalReason ( err . Error ( ) ) return err } } return nil }
4100	func ( c * Radio ) SetSelected ( val bool ) { c . selected = val if c . onChange != nil { go c . onChange ( val ) } }
6062	func NewMonitor ( conf * Config , c Client , db * reform . DB , l log . Logger , psc , ptc common . Address , role string , q Queue ) ( * Monitor , error ) { abiJSON := contract . PrivatixServiceContractABI pscABI , err := abi . JSON ( strings . NewReader ( abiJSON ) ) if err != nil { l . Error ( err . Error ( ) ) return nil , ErrFailedToParseABI } abiJSON2 := contract . PrivatixTokenContractABI ptcABI , err := abi . JSON ( strings . NewReader ( abiJSON2 ) ) if err != nil { l . Error ( err . Error ( ) ) return nil , ErrFailedToParseABI } ethCallTimeout := time . Duration ( conf . EthCallTimeout ) * time . Millisecond queryPause := time . Duration ( conf . QueryPause ) * time . Millisecond m := & Monitor { db : db , eth : c , logger : l . Add ( "type" , "monitor.Monitor" ) , queue : q , ethCallTimeout : ethCallTimeout , pscABI : pscABI , ptcABI : ptcABI , pscAddr : psc , queryPause : queryPause , } m . initLastProcessedBlock ( role , conf . InitialBlocks ) f := m . clientQueries m . jobsProducers = m . clientJobsProducers ( ) if role == data . RoleAgent { f = m . agentQueries m . jobsProducers = m . agentJobsProducers ( ) } m . getFilterLogQueries = func ( from , to uint64 ) ( [ ] ethereum . FilterQuery , error ) { return f ( from , to , psc , ptc ) } return m , nil }
1721	func convertAppMeshToCNIConfig ( appMesh * apiappmesh . AppMesh , cfg * ecscni . Config ) { cfg . AppMeshCNIEnabled = true cfg . IgnoredUID = appMesh . IgnoredUID cfg . IgnoredGID = appMesh . IgnoredGID cfg . ProxyIngressPort = appMesh . ProxyIngressPort cfg . ProxyEgressPort = appMesh . ProxyEgressPort cfg . AppPorts = appMesh . AppPorts cfg . EgressIgnoredIPs = appMesh . EgressIgnoredIPs cfg . EgressIgnoredPorts = appMesh . EgressIgnoredPorts }
679	func ns1ChangesByZone ( zones [ ] * dns . Zone , changeSets [ ] * ns1Change ) map [ string ] [ ] * ns1Change { changes := make ( map [ string ] [ ] * ns1Change ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( z . Zone , z . Zone ) changes [ z . Zone ] = [ ] * ns1Change { } } for _ , c := range changeSets { zone , _ := zoneNameIDMapper . FindZone ( c . Endpoint . DNSName ) if zone == "" { log . Debugf ( "Skipping record %s because no hosted zone matching record DNS Name was detected " , c . Endpoint . DNSName ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes }
460	func AppendInflateBytes ( dst , src [ ] byte ) ( [ ] byte , error ) { w := & byteSliceWriter { dst } _ , err := WriteInflate ( w , src ) return w . b , err }
1836	func ( mtask * managedTask ) startContainerTransitions ( transitionFunc containerTransitionFunc ) ( bool , map [ string ] apicontainer . DependsOn , map [ string ] apicontainerstatus . ContainerStatus , [ ] error ) { anyCanTransition := false var reasons [ ] error blocked := make ( map [ string ] apicontainer . DependsOn ) transitions := make ( map [ string ] apicontainerstatus . ContainerStatus ) for _ , cont := range mtask . Containers { transition := mtask . containerNextState ( cont ) if transition . reason != nil { reasons = append ( reasons , transition . reason ) if transition . blockedOn != nil { blocked [ cont . Name ] = * transition . blockedOn } continue } if transition . actionRequired && ! cont . SetAppliedStatus ( transition . nextState ) { anyCanTransition = true continue } anyCanTransition = true if ! transition . actionRequired { go func ( cont * apicontainer . Container , status apicontainerstatus . ContainerStatus ) { mtask . dockerMessages <- dockerContainerChange { container : cont , event : dockerapi . DockerContainerChangeEvent { Status : status , } , } } ( cont , transition . nextState ) continue } transitions [ cont . Name ] = transition . nextState go transitionFunc ( cont , transition . nextState ) } return anyCanTransition , blocked , transitions , reasons }
4948	func NewLob ( rd io . Reader , wr io . Writer ) * Lob { return & Lob { rd : rd , wr : wr } }
3793	func ( r * Request ) SetParams ( v interface { } ) error { b , err := json . Marshal ( v ) if err != nil { return err } r . Params = ( * json . RawMessage ) ( & b ) return nil }
72	func NewBuilder ( base Labels ) * Builder { return & Builder { base : base , del : make ( [ ] string , 0 , 5 ) , add : make ( [ ] Label , 0 , 5 ) , } }
6491	func serviceOAuth ( certFilePath string ) ( * serviceOAuthAuthentication , error ) { certs := x509 . NewCertPool ( ) pemData , err := ioutil . ReadFile ( certFilePath ) if err != nil { return nil , err } certs . AppendCertsFromPEM ( pemData ) mTLSConfig := & tls . Config { RootCAs : certs , } a := serviceOAuthAuthentication { BaseUrl : "https://coinbase.com/" , Client : http . Client { Transport : & http . Transport { Dial : dialTimeout , TLSClientConfig : mTLSConfig , } , } , } return & a , nil }
4255	func newConsole ( uid , gid int ) ( Console , error ) { master , err := os . OpenFile ( "/dev/ptmx" , syscall . O_RDWR | syscall . O_NOCTTY | syscall . O_CLOEXEC , 0 ) if err != nil { return nil , err } console , err := ptsname ( master ) if err != nil { return nil , err } if err := unlockpt ( master ) ; err != nil { return nil , err } if err := os . Chmod ( console , 0600 ) ; err != nil { return nil , err } if err := os . Chown ( console , uid , gid ) ; err != nil { return nil , err } return & linuxConsole { slavePath : console , master : master , } , nil }
4451	func ( h * HexColor ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { * h = HexColor ( data ) } }
7316	func ( b * Bus ) Publish ( eventName string , eventBody interface { } ) { e := NewEvent ( eventName , eventBody ) b . mu . RLock ( ) defer b . mu . RUnlock ( ) for _ , h := range b . handlers { h . Handle ( e ) } }
7098	func ( b * RefCountBox ) Free ( ) { b . Lock ( ) defer b . Unlock ( ) b . count -- if b . count == 0 { b . db . Close ( ) b . db = DB { } } }
5286	func stringFormat ( c * Config , widths [ ] int , columns int ) string { buf := bytes . NewBuffer ( make ( [ ] byte , 0 , ( 6 + len ( c . Glue ) ) * columns ) ) buf . WriteString ( c . Prefix ) for i := 0 ; i < columns && i < len ( widths ) ; i ++ { if i == columns - 1 { buf . WriteString ( "%s\n" ) } else \n } { fmt . Fprintf ( buf , "%%-%ds%s" , widths [ i ] , c . Glue ) } }
1600	func ( m * MockSecretsManagerAPI ) ListSecretsPages ( arg0 * secretsmanager . ListSecretsInput , arg1 func ( * secretsmanager . ListSecretsOutput , bool ) bool ) error { ret := m . ctrl . Call ( m , "ListSecretsPages" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
1333	func ( m * MockHttpClient ) GetUserData ( ) ( string , error ) { ret := m . ctrl . Call ( m , "GetUserData" ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6774	func ( r * PEXReactor ) SendAddrs ( p * Peer , addrs [ ] * NetAddress ) { p . Send ( PexChannel , struct { PexMessage } { & pexAddrsMessage { Addrs : addrs } } ) }
2249	func ( v * FileFilter ) native ( ) * C . GtkFileFilter { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileFilter ( p ) }
2657	func expandClusterConfigSpecEx ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . ClusterConfigSpecEx { obj := & types . ClusterConfigSpecEx { DasConfig : expandClusterDasConfigInfo ( d , version ) , DpmConfig : expandClusterDpmConfigInfo ( d ) , DrsConfig : expandClusterDrsConfigInfo ( d ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . InfraUpdateHaConfig = expandClusterInfraUpdateHaConfigInfo ( d ) obj . Orchestration = expandClusterOrchestrationInfo ( d ) obj . ProactiveDrsConfig = expandClusterProactiveDrsConfigInfo ( d ) } return obj }
6221	func ( w * Worker ) ClientPreChannelTopUp ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientPreChannelTopUp" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientPreChannelTopUp ) if err != nil { return err } offer , err := w . offering ( logger , ch . Offering ) if err != nil { return err } acc , err := w . account ( logger , ch . Client ) if err != nil { return err } logger = logger . Add ( "channel" , ch , "offering" , offer ) var jdata data . JobTopUpChannelData if err := w . unmarshalDataTo ( logger , job . Data , & jdata ) ; err != nil { return err } if err := w . checkDeposit ( logger , acc , offer , jdata . Deposit ) ; err != nil { return err } return w . clientPreChannelTopUpSaveTx ( logger , job , ch , acc , offer , jdata . GasPrice , uint64 ( jdata . Deposit ) ) }
943	func ( s State ) String ( ) string { if int ( s ) >= 0 && int ( s ) < len ( states ) { return states [ s ] } return "" }
4058	func ( l * ListBox ) SelectedItemText ( ) string { if l . currSelection == - 1 { return "" } return l . items [ l . currSelection ] }
4470	func ( t * DateTime ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { var err error * t , err = ParseDateTime ( data ) return err } return errors . New ( "couldn't unmarshal bson raw value as Duration" ) }
4534	func ( s * OpenAPISchema ) Validate ( obj * unstructured . Unstructured ) [ ] error { gvk := obj . GroupVersionKind ( ) log . Infof ( "validate object %q" , gvk ) return validation . ValidateModel ( obj . UnstructuredContent ( ) , s . schema , fmt . Sprintf ( "%s.%s" , gvk . Version , gvk . Kind ) ) }
2036	func IsValidNetworkDevice ( devicePath string ) bool { splitDevLink := strings . SplitN ( devicePath , "devices/" , 2 ) if len ( splitDevLink ) != 2 { seelog . Warnf ( "Cannot determine device validity: %s" , devicePath ) return false } if strings . HasPrefix ( splitDevLink [ 1 ] , pciDevicePrefix ) || strings . HasPrefix ( splitDevLink [ 1 ] , vifDevicePrefix ) { return true } if strings . HasPrefix ( splitDevLink [ 1 ] , virtualDevicePrefix ) { return false } seelog . Criticalf ( "Failed to validate device path: %s" , devicePath ) return false }
4442	func ( u ISBN13 ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
67	func ( ls Labels ) Has ( name string ) bool { for _ , l := range ls { if l . Name == name { return true } } return false }
5613	func ( m * VMResponse ) Validate ( formats strfmt . Registry ) error { var res [ ] error if err := m . validateVM ( formats ) ; err != nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . CompositeValidationError ( res ... ) } return nil }
1052	func ( c * Child ) Pid ( ) int { c . RLock ( ) defer c . RUnlock ( ) return c . pid ( ) }
5692	func ( st * state ) exprList ( stop byte ) AST { if len ( st . str ) > 0 && st . str [ 0 ] == stop { st . advance ( 1 ) return & ExprList { Exprs : nil } } var exprs [ ] AST for { e := st . expression ( ) exprs = append ( exprs , e ) if len ( st . str ) > 0 && st . str [ 0 ] == stop { st . advance ( 1 ) break } } return & ExprList { Exprs : exprs } }
3404	func ( n * NoteDefinition ) GetContent ( ) string { if n == nil || n . Content == nil { return "" } return * n . Content }
5770	func ( a * API ) UpdateCheckBundleMetrics ( cfg * CheckBundleMetrics ) ( * CheckBundleMetrics , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid check bundle metrics config [nil]" ) } metricsCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . CheckBundleMetricsCIDRegex , metricsCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid check bundle metrics CID [%s]" , metricsCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update check bundle metrics, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( metricsCID , jsonCfg ) if err != nil { return nil , err } metrics := & CheckBundleMetrics { } if err := json . Unmarshal ( result , metrics ) ; err != nil { return nil , err } return metrics , nil }
651	func NewInfobloxProvider ( infobloxConfig InfobloxConfig ) ( * InfobloxProvider , error ) { hostConfig := ibclient . HostConfig { Host : infobloxConfig . Host , Port : strconv . Itoa ( infobloxConfig . Port ) , Username : infobloxConfig . Username , Password : infobloxConfig . Password , Version : infobloxConfig . Version , } httpPoolConnections := lookupEnvAtoi ( "EXTERNAL_DNS_INFOBLOX_HTTP_POOL_CONNECTIONS" , 10 ) httpRequestTimeout := lookupEnvAtoi ( "EXTERNAL_DNS_INFOBLOX_HTTP_REQUEST_TIMEOUT" , 60 ) transportConfig := ibclient . NewTransportConfig ( strconv . FormatBool ( infobloxConfig . SSLVerify ) , httpRequestTimeout , httpPoolConnections , ) requestBuilder := & ibclient . WapiRequestBuilder { } requestor := & ibclient . WapiHttpRequestor { } client , err := ibclient . NewConnector ( hostConfig , transportConfig , requestBuilder , requestor ) if err != nil { return nil , err } provider := & InfobloxProvider { client : client , domainFilter : infobloxConfig . DomainFilter , zoneIDFilter : infobloxConfig . ZoneIDFilter , dryRun : infobloxConfig . DryRun , view : infobloxConfig . View , } return provider , nil }
6537	func ( l * listener ) Accept ( ) ( transport . Conn , error ) { if c , ok := <- l . incoming ; ok { return c . conn , c . err } return nil , fmt . Errorf ( "listener is closed" ) }
4721	func NewRelay ( ctx context . Context , h host . Host , upgrader * tptu . Upgrader , opts ... RelayOpt ) ( * Relay , error ) { r := & Relay { upgrader : upgrader , host : h , ctx : ctx , self : h . ID ( ) , incoming : make ( chan * Conn ) , relays : make ( map [ peer . ID ] struct { } ) , liveHops : make ( map [ peer . ID ] map [ peer . ID ] int ) , } for _ , opt := range opts { switch opt { case OptActive : r . active = true case OptHop : r . hop = true case OptDiscovery : r . discovery = true default : return nil , fmt . Errorf ( "unrecognized option: %d" , opt ) } } h . SetStreamHandler ( ProtoID , r . handleNewStream ) if r . discovery { h . Network ( ) . Notify ( r . notifiee ( ) ) } return r , nil }
909	func create ( ) { log . SetDebug ( true ) client := libmachine . NewClient ( "/tmp/automatic" , "/tmp/automatic/certs" ) defer client . Close ( ) hostName := "myfunhost" driver := virtualbox . NewDriver ( hostName , "/tmp/automatic" ) driver . CPU = 2 driver . Memory = 2048 data , err := json . Marshal ( driver ) if err != nil { log . Error ( err ) return } h , err := client . NewHost ( "virtualbox" , data ) if err != nil { log . Error ( err ) return } h . HostOptions . EngineOptions . StorageDriver = "overlay" if err := client . Create ( h ) ; err != nil { log . Error ( err ) return } out , err := h . RunSSHCommand ( "df -h" ) if err != nil { log . Error ( err ) return } fmt . Printf ( "Results of your disk space query:\n%s\n" , \n ) \n out }
619	func ( p * AWSProvider ) newChanges ( action string , endpoints [ ] * endpoint . Endpoint , recordsCache [ ] * endpoint . Endpoint , zones map [ string ] * route53 . HostedZone ) [ ] * route53 . Change { changes := make ( [ ] * route53 . Change , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , p . newChange ( action , endpoint , recordsCache , zones ) ) } return changes }
1775	func ( handler * attachENIHandler ) addENIAttachmentToState ( message * ecsacs . AttachTaskNetworkInterfacesMessage , receivedAt time . Time ) error { attachmentARN := aws . StringValue ( message . ElasticNetworkInterfaces [ 0 ] . AttachmentArn ) mac := aws . StringValue ( message . ElasticNetworkInterfaces [ 0 ] . MacAddress ) taskARN := aws . StringValue ( message . TaskArn ) eniAttachment := & apieni . ENIAttachment { TaskARN : taskARN , AttachmentARN : attachmentARN , AttachStatusSent : false , MACAddress : mac , ExpiresAt : receivedAt . Add ( time . Duration ( aws . Int64Value ( message . WaitTimeoutMs ) ) * time . Millisecond ) , } eniAckTimeoutHandler := ackTimeoutHandler { mac : mac , state : handler . state } if err := eniAttachment . StartTimer ( eniAckTimeoutHandler . handle ) ; err != nil { return err } seelog . Infof ( "Adding eni info for task '%s' to state, attachment=%s mac=%s" , taskARN , attachmentARN , mac ) handler . state . AddENIAttachment ( eniAttachment ) return nil }
908	func ( d * Driver ) Restart ( ) error { if err := d . checkLegacyDriver ( true ) ; err != nil { return err } c , err := d . newAzureClient ( ) if err != nil { return err } return c . RestartVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) ) }
5355	func Setsys ( key , value string ) error { if ! _IS_ROOT { return ErrNoRoot } return _Set ( _SETTINGS . global , key , value ) }
1880	func ( err * WSError ) Retry ( ) bool { for _ , unretriable := range err . Get ( ) { if reflect . TypeOf ( err . ErrObj ) == reflect . TypeOf ( unretriable ) { return false } } return true }
6174	func ( m * Monitor ) Run ( ) error { m . logger . Info ( "Billing monitor started" ) for { if err := m . processRound ( ) ; err != nil { return err } time . Sleep ( time . Duration ( m . interval ) * time . Millisecond ) } }
2546	func expandCustomizationSysprepText ( d * schema . ResourceData ) * types . CustomizationSysprepText { obj := & types . CustomizationSysprepText { Value : d . Get ( cKeyPrefix + "." + "windows_sysprep_text" ) . ( string ) , } return obj }
6072	func ClientOpen ( c , agentPub [ ] byte , clientPrv * ecdsa . PrivateKey ) ( [ ] byte , error ) { sealed , sig := UnpackSignature ( c ) hash := ethcrypto . Keccak256 ( sealed ) if ! VerifySignature ( agentPub , hash , sig ) { return nil , ErrWrongSignature } prv := ecies . ImportECDSA ( clientPrv ) opened , err := prv . Decrypt ( sealed , nil , nil ) if err != nil { return nil , err } return opened , nil }
1753	func ( task * Task ) GetPullStoppedAt ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . PullStoppedAtUnsafe }
5625	func ( pk PrivKeyLedgerSecp256k1 ) Sign ( msg [ ] byte ) ( Signature , error ) { dev , err := getLedger ( ) if err != nil { return nil , err } sig , err := signLedgerSecp256k1 ( dev , pk . Path , msg ) if err != nil { return nil , err } return sig , nil }
6048	func ( n * upnp ) AddMapping ( protocol string , extPort , intPort int , desc string , lifetime time . Duration ) error { ip , err := n . internalAddress ( ) if err != nil { return nil } protocol = strings . ToUpper ( protocol ) lifetimeS := uint32 ( lifetime / time . Second ) n . DeleteMapping ( protocol , extPort , intPort ) return n . client . AddPortMapping ( "" , uint16 ( extPort ) , protocol , uint16 ( intPort ) , ip . String ( ) , true , desc , lifetimeS ) }
136	func ( t * timestampTracker ) AddFast ( l labels . Labels , _ uint64 , ts int64 , v float64 ) error { _ , err := t . Add ( l , ts , v ) return err }
4456	func ( r * RGBColor ) DeepCopy ( ) * RGBColor { if r == nil { return nil } out := new ( RGBColor ) r . DeepCopyInto ( out ) return out }
1799	func ( mr * MockDockerClientMockRecorder ) ContainerEvents ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "ContainerEvents" , reflect . TypeOf ( ( * MockDockerClient ) ( nil ) . ContainerEvents ) , arg0 ) }
4007	func printJSON ( v interface { } ) { w := json . NewEncoder ( os . Stdout ) w . SetIndent ( "" , "\t" ) \t err := w . Encode ( v ) }
3086	func ( ctx * Context ) GetCookieInt ( name string ) int { return com . StrTo ( ctx . GetCookie ( name ) ) . MustInt ( ) }
4620	func getSourceLines ( file string ) [ ] [ ] byte { fileSources . Lock ( ) defer fileSources . Unlock ( ) if fileSources . lines == nil { fileSources . lines = map [ string ] [ ] [ ] byte { } } if lines , ok := fileSources . lines [ file ] ; ok { return lines } text , _ := ioutil . ReadFile ( file ) fileSources . lines [ file ] = bytes . Split ( text , [ ] byte { '\n' } ) return fileSources . lines [ file ] }
5464	func ( a * Alert ) Description ( ) string { return capitalize ( strings . TrimSpace ( strings . TrimSuffix ( a . description ( ) , "." ) ) ) }
2613	func IsVApp ( client * govmomi . Client , rp string ) bool { _ , err := FromID ( client , rp ) if err != nil { return false } return true }
5186	func NewClusterWithHost ( hosts ... * URI ) * Cluster { cluster := DefaultCluster ( ) for _ , host := range hosts { cluster . AddHost ( host ) } return cluster }
575	func ( mx * Mux ) Head ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mHEAD , pattern , handlerFn ) }
34	func mergeSamples ( a , b [ ] prompb . Sample ) [ ] prompb . Sample { result := make ( [ ] prompb . Sample , 0 , len ( a ) + len ( b ) ) i , j := 0 , 0 for i < len ( a ) && j < len ( b ) { if a [ i ] . Timestamp < b [ j ] . Timestamp { result = append ( result , a [ i ] ) i ++ } else if a [ i ] . Timestamp > b [ j ] . Timestamp { result = append ( result , b [ j ] ) j ++ } else { result = append ( result , a [ i ] ) i ++ j ++ } } result = append ( result , a [ i : ] ... ) result = append ( result , b [ j : ] ... ) return result }
241	func tagsFromMetric ( m model . Metric ) map [ string ] TagValue { tags := make ( map [ string ] TagValue , len ( m ) - 1 ) for l , v := range m { if l == model . MetricNameLabel { continue } tags [ string ( l ) ] = TagValue ( v ) } return tags }
2821	func expandDVSSecurityPolicy ( d * schema . ResourceData ) * types . DVSSecurityPolicy { obj := & types . DVSSecurityPolicy { AllowPromiscuous : structure . GetBoolPolicy ( d , "allow_promiscuous" ) , MacChanges : structure . GetBoolPolicy ( d , "allow_mac_changes" ) , ForgedTransmits : structure . GetBoolPolicy ( d , "allow_forged_transmits" ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
7266	func PeekNextPattern ( p [ ] string ) ( pat string , size int ) { if isNextSuffixPattern ( p ) { pat , size = ( p [ 0 ] + p [ 1 ] ) , 2 } else { pat , size = p [ 0 ] , 1 } return }
6781	func New ( h http . Handler , onPanic recovery . PanicHandler ) Service { l := logging . Wrap ( recovery . Wrap ( debug . Wrap ( metrics . Wrap ( h , ) , ) , onPanic , ) , os . Stdout , ) l . Start ( ) return Service { h : l } }
6789	func ( hub * hub ) Publish ( channels [ ] string , msg interface { } ) { for _ , name := range channels { var cn = hub . getChannel ( name ) cn . Publish ( msg ) } }
4516	func ( s * SortFilter ) NumDecreasing ( n int ) * SortFilter { return s . Num ( n ) . flipLast ( ) }
1498	func ( c * Container ) InjectV3MetadataEndpoint ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) if c . Environment == nil { c . Environment = make ( map [ string ] string ) } c . Environment [ MetadataURIEnvironmentVariableName ] = fmt . Sprintf ( MetadataURIFormat , c . V3EndpointID ) }
2282	func DragSetIconPixbuf ( context * gdk . DragContext , pixbuf * gdk . Pixbuf , hot_x int , hot_y int ) { ctx := unsafe . Pointer ( context . Native ( ) ) pix := unsafe . Pointer ( pixbuf . Native ( ) ) C . gtk_drag_set_icon_pixbuf ( ( * C . GdkDragContext ) ( ctx ) , ( * C . GdkPixbuf ) ( pix ) , C . gint ( hot_x ) , C . gint ( hot_y ) ) }
7106	func ToMorseCode ( theString string ) ( string , error ) { f := New ( theString ) if f . length < 1 { return "" , errors . New ( lengthError ) } f . makeLower ( ) var buffer bytes . Buffer for _ , i := range f . theString { key := string ( i ) if _ , ok := morse [ key ] ; ok { buffer . WriteString ( morse [ key ] ) } else if key == " " { buffer . WriteString ( " " ) } } return buffer . String ( ) , nil }
5673	func ( ps * printState ) printOneInner ( save * [ ] AST ) { if len ( ps . inner ) == 0 { panic ( "printOneInner called with no inner types" ) } ln := len ( ps . inner ) a := ps . inner [ ln - 1 ] ps . inner = ps . inner [ : ln - 1 ] if save != nil { if _ , ok := a . ( * MethodWithQualifiers ) ; ok { * save = append ( * save , a ) return } } if ip , ok := a . ( innerPrinter ) ; ok { ip . printInner ( ps ) } else { ps . print ( a ) } }
2850	func IsVmdkDatastorePath ( p string ) bool { dp , success := DatastorePathFromString ( p ) if ! success { log . Printf ( "[DEBUG] IsVmdkDatastorePath: %q is not a datastore path" , p ) return false } isVMDK := dp . IsVMDK ( ) log . Printf ( "[DEBUG] IsVmdkDatastorePath: %q %s a datastore path" , p , structure . LogCond ( isVMDK , "is" , "is not" ) ) return isVMDK }
1579	func ( m * MockSecretsManagerAPI ) DeleteResourcePolicyWithContext ( arg0 aws . Context , arg1 * secretsmanager . DeleteResourcePolicyInput , arg2 ... request . Option ) ( * secretsmanager . DeleteResourcePolicyOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "DeleteResourcePolicyWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DeleteResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2177	func ( v * Binding ) GetSource ( ) * Object { obj := C . g_binding_get_source ( v . native ( ) ) if obj == nil { return nil } return wrapObject ( unsafe . Pointer ( obj ) ) }
809	func NewDriverNotSupported ( driverName , hostName , storePath string ) Driver { return & DriverNotSupported { BaseDriver : & BaseDriver { MachineName : hostName , StorePath : storePath , } , Name : driverName , } }
4907	func ( r * Reader ) ReadB ( ) byte { if r . err != nil { return 0 } var b byte b , r . err = r . rd . ReadByte ( ) r . cnt ++ return b }
6306	func NewServiceContainer ( ) ServiceContainer { return & dependencyInjector { registry : make ( map [ reflect . Type ] interface { } ) , instances : make ( map [ reflect . Type ] reflect . Value ) , caching : true , } }
3525	func ( s * SyntheticsLocation ) HasRegion ( ) bool { if s != nil && s . Region != nil { return true } return false }
3090	func ( ctx * Context ) GetSecureCookie ( key string ) ( string , bool ) { return ctx . GetSuperSecureCookie ( defaultCookieSecret , key ) }
6211	func Caller ( ) string { _ , file , line , ok := runtime . Caller ( 2 ) if ! ok { return "?" } rel , err := filepath . Rel ( RootPath ( ) , file ) if err != nil { return "?" } return fmt . Sprintf ( "%s:%d" , rel , line ) }
5129	func bytesToHex ( b [ ] byte ) string { hex := make ( [ ] string , len ( b ) ) for i , ch := range b { hex [ i ] = fmt . Sprintf ( "%X" , ch ) } return strings . Join ( hex , "" ) }
5113	func ( file * GridFile ) SetId ( id interface { } ) { file . assertMode ( gfsWriting ) file . m . Lock ( ) file . doc . Id = id file . m . Unlock ( ) }
5110	func SetDebug ( debug bool ) { if raceDetector { globalMutex . Lock ( ) defer globalMutex . Unlock ( ) } globalDebug = debug }
3313	func ( g * GraphDefinition ) GetIncludeNoMetricHosts ( ) bool { if g == nil || g . IncludeNoMetricHosts == nil { return false } return * g . IncludeNoMetricHosts }
5595	func ( o * AddVMOK ) WithPayload ( payload string ) * AddVMOK { o . Payload = payload return o }
3777	func ( client * Client ) UpdateScreenboard ( board * Screenboard ) error { return client . doJsonRequest ( "PUT" , fmt . Sprintf ( "/v1/screen/%d" , * board . Id ) , board , nil ) }
2006	func ( engine * DockerStatsEngine ) ContainerDockerStats ( taskARN string , containerID string ) ( * types . StatsJSON , error ) { engine . lock . RLock ( ) defer engine . lock . RUnlock ( ) containerIDToStatsContainer , ok := engine . tasksToContainers [ taskARN ] if ! ok { return nil , errors . Errorf ( "stats engine: task '%s' for container '%s' not found" , taskARN , containerID ) } container , ok := containerIDToStatsContainer [ containerID ] if ! ok { return nil , errors . Errorf ( "stats engine: container not found: %s" , containerID ) } return container . statsQueue . GetLastStat ( ) , nil }
741	func ( s PerResource ) less ( x , y * endpoint . Endpoint ) bool { return x . Targets . IsLess ( y . Targets ) }
2332	func ( v * Context ) Rotate ( angle float64 ) { C . cairo_rotate ( v . native ( ) , C . double ( angle ) ) }
865	func checkResourceExistsFromError ( err error ) ( bool , error ) { if err == nil { return true , nil } v , ok := err . ( autorest . DetailedError ) if ok && v . StatusCode == http . StatusNotFound { return false , nil } return false , v }
2599	func ( r MOIDForUUIDResults ) UUIDs ( ) [ ] string { var uuids [ ] string for _ , result := range r { uuids = append ( uuids , result . UUID ) } return uuids }
1725	func ( task * Task ) DockerHostConfig ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer , apiVersion dockerclient . DockerVersion ) ( * dockercontainer . HostConfig , * apierrors . HostConfigError ) { return task . dockerHostConfig ( container , dockerContainerMap , apiVersion ) }
6521	func ( c Client ) GetTransactions ( page int ) ( * transactions , error ) { params := map [ string ] int { "page" : page , } holder := transactionsHolder { } if err := c . Get ( "transactions" , params , & holder ) ; err != nil { return nil , err } transactions := transactions { paginationStats : holder . paginationStats , } for _ , tx := range holder . Transactions { transactions . Transactions = append ( transactions . Transactions , tx . Transaction ) } return & transactions , nil }
3984	func ( l * arpaMalformedIP ) Execute ( c * x509 . Certificate ) * LintResult { for _ , name := range c . DNSNames { name = strings . ToLower ( name ) var err error if strings . HasSuffix ( name , rdnsIPv4Suffix ) { err = lintReversedIPAddressLabels ( name , false ) } else if strings . HasSuffix ( name , rdnsIPv6Suffix ) { err = lintReversedIPAddressLabels ( name , true ) } if err != nil { return & LintResult { Status : Warn , Details : err . Error ( ) , } } } return & LintResult { Status : Pass , } }
3495	func ( s * Series ) GetAggrOk ( ) ( string , bool ) { if s == nil || s . Aggr == nil { return "" , false } return * s . Aggr , true }
3772	func ( client * Client ) DeleteAPIKey ( key string ) error { return client . doJsonRequest ( "DELETE" , fmt . Sprintf ( "/v1/api_key/%s" , key ) , nil , nil ) }
5724	func ( c * Client ) Delete ( key string ) error { cn , err := c . sendCommand ( key , cmdDelete , nil , 0 , nil ) if err != nil { return err } _ , _ , _ , _ , err = c . parseResponse ( key , cn ) c . condRelease ( cn , & err ) return err }
3616	func ( t * TimeseriesRequestStyle ) GetLineWidth ( ) string { if t == nil || t . LineWidth == nil { return "" } return * t . LineWidth }
2884	func SystemOrDefault ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . HostSystem , error ) { finder := find . NewFinder ( client . Client , false ) finder . SetDatacenter ( dc ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) t := client . ServiceContent . About . ApiType switch t { case "HostAgent" : return finder . DefaultHostSystem ( ctx ) case "VirtualCenter" : if name != "" { return finder . HostSystem ( ctx , name ) } return finder . DefaultHostSystem ( ctx ) } return nil , fmt . Errorf ( "unsupported ApiType: %s" , t ) }
3177	func ( client * Client ) SearchHosts ( search string ) ( [ ] string , error ) { var out reqSearch if err := client . doJsonRequest ( "GET" , "/v1/search?q=hosts:" + search , nil , & out ) ; err != nil { return nil , err } return out . Results . Hosts , nil }
2016	func verifyResponseFieldNames ( expectedFields [ ] string , responseBody [ ] byte , responseName string ) error { var responseMap map [ string ] json . RawMessage if err := json . Unmarshal ( responseBody , & responseMap ) ; err != nil { fmt . Errorf ( "unable to unmarshal %s response to response map" , responseName ) } for _ , field := range expectedFields { if _ , ok := responseMap [ field ] ; ! ok { return fmt . Errorf ( "missing field '%s' in %s response" , field , responseName ) } } return nil }
424	func ServeTLSEmbed ( ln net . Listener , certData , keyData [ ] byte , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ServeTLSEmbed ( ln , certData , keyData ) }
7314	func ( b * Bus ) Subscribe ( h Handler ) bool { b . mu . Lock ( ) defer b . mu . Unlock ( ) for _ , v := range b . handlers { if v == h { return false } } b . handlers = append ( b . handlers , h ) return true }
798	func getAccessToken ( cfg config , environment azure . Environment ) ( * adal . ServicePrincipalToken , error ) { if cfg . UseManagedIdentityExtension { log . Info ( "Using managed identity extension to retrieve access token for Azure API." ) msiEndpoint , err := adal . GetMSIVMEndpoint ( ) if err != nil { return nil , fmt . Errorf ( "failed to get the managed service identity endpoint: %v" , err ) } token , err := adal . NewServicePrincipalTokenFromMSI ( msiEndpoint , environment . ServiceManagementEndpoint ) if err != nil { return nil , fmt . Errorf ( "failed to create the managed service identity token: %v" , err ) } return token , nil } if len ( cfg . ClientID ) > 0 && len ( cfg . ClientSecret ) > 0 { log . Info ( "Using client_id+client_secret to retrieve access token for Azure API." ) oauthConfig , err := adal . NewOAuthConfig ( environment . ActiveDirectoryEndpoint , cfg . TenantID ) if err != nil { return nil , fmt . Errorf ( "failed to retrieve OAuth config: %v" , err ) } token , err := adal . NewServicePrincipalToken ( * oauthConfig , cfg . ClientID , cfg . ClientSecret , environment . ResourceManagerEndpoint ) if err != nil { return nil , fmt . Errorf ( "failed to create service principal token: %v" , err ) } return token , nil } return nil , fmt . Errorf ( "no credentials provided for Azure API" ) }
5530	func NewLuaObject ( L * lua . State , idx int ) * LuaObject { L . PushValue ( idx ) ref := L . Ref ( lua . LUA_REGISTRYINDEX ) return & LuaObject { l : L , ref : ref } }
5059	func ( cluster * mongoCluster ) Release ( ) { cluster . Lock ( ) if cluster . references == 0 { panic ( "cluster.Release() with references == 0" ) } cluster . references -- debugf ( "Cluster %p released (refs=%d)" , cluster , cluster . references ) if cluster . references == 0 { for _ , server := range cluster . servers . Slice ( ) { server . Close ( ) } cluster . syncServers ( ) stats . cluster ( - 1 ) } cluster . Unlock ( ) }
4928	func ( w * Writer ) WriteUint32 ( i uint32 ) { if w . err != nil { return } binary . LittleEndian . PutUint32 ( w . b [ : 4 ] , i ) w . wr . Write ( w . b [ : 4 ] ) }
6948	func ( r * Reporter ) Metric ( name string , tags [ ] string , v float32 ) { r . metrics = append ( r . metrics , Metric { Name : name , Points : [ ] [ 2 ] interface { } { [ 2 ] interface { } { r . timestamp , v } } , Tags : tags , Host : r . Hostname , } ) }
1978	func ( m * MockClient ) ImageImport ( arg0 context . Context , arg1 types . ImageImportSource , arg2 string , arg3 types . ImageImportOptions ) ( io . ReadCloser , error ) { ret := m . ctrl . Call ( m , "ImageImport" , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( io . ReadCloser ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2938	func resourceVSphereDatastoreClusterReadCustomAttributes ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { client := meta . ( * VSphereClient ) . vimClient if customattribute . IsSupported ( client ) { log . Printf ( "[DEBUG] %s: Reading custom attributes" , resourceVSphereDatastoreClusterIDString ( d ) ) props , err := storagepod . Properties ( pod ) if err != nil { return err } customattribute . ReadFromResource ( client , props . Entity ( ) , d ) } else { log . Printf ( "[DEBUG] %s: Custom attributes unsupported on this connection, skipping" , resourceVSphereDatastoreClusterIDString ( d ) ) } return nil }
4754	func HTTPCompressHandlerFunc ( handlerFunc http . HandlerFunc ) http . HandlerFunc { return func ( response http . ResponseWriter , request * http . Request ) { NewHTTPCompressHandlerFromFunc ( handlerFunc ) . ServeHTTP ( response , request ) } }
857	func ( a AzureClient ) CreateResourceGroup ( name , location string ) error { if ok , err := a . resourceGroupExists ( name ) ; err != nil { return err } else if ok { log . Infof ( "Resource group %q already exists." , name ) return nil } log . Info ( "Creating resource group." , logutil . Fields { "name" : name , "location" : location } ) _ , err := a . resourceGroupsClient ( ) . CreateOrUpdate ( name , resources . ResourceGroup { Location : to . StringPtr ( location ) , } ) return err }
2505	func ( c * drawTrianglesCommand ) Exec ( indexOffset int ) error { if c . nindices == 0 { return nil } c . dst . image . SetAsDestination ( ) c . src . image . SetAsSource ( ) if err := theGraphicsDriver . Draw ( c . nindices , indexOffset , c . mode , c . color , c . filter , c . address ) ; err != nil { return err } return nil }
3402	func ( n * NoteDefinition ) GetBackgroundColorOk ( ) ( string , bool ) { if n == nil || n . BackgroundColor == nil { return "" , false } return * n . BackgroundColor , true }
5947	func ( s Scan ) GetHost ( hostTarget string ) ( target Host , exists bool ) { target , ok := s . Hosts [ hostTarget ] if ok { return target , true } for _ , host := range s . Hosts { for _ , hostname := range host . Hostnames { if hostname . Name == hostTarget { return host , true } } } return Host { } , false }
5327	func NextSystemUID ( ) ( int , error ) { db , uid , err := nextUID ( true ) db . close ( ) return uid , err }
1376	func ( handler * TaskHandler ) getTasksToEventsLen ( ) int { handler . lock . RLock ( ) defer handler . lock . RUnlock ( ) return len ( handler . tasksToEvents ) }
6108	func ( h * Handler ) TransferTokens ( tkn , account , destination string , amount , gasPrice uint64 ) error { logger := h . logger . Add ( "method" , "TransferTokens" , "destination" , destination , "amount" , amount , "gasPrice" , gasPrice ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } if amount == 0 { logger . Error ( ErrTokenAmountTooSmall . Error ( ) ) return ErrTokenAmountTooSmall } if destination != data . ContractPSC && destination != data . ContractPTC { logger . Error ( ErrBadDestination . Error ( ) ) return ErrBadDestination } err := h . findByPrimaryKey ( logger , ErrAccountNotFound , & data . Account { } , account ) if err != nil { return err } jobType := data . JobPreAccountAddBalanceApprove if destination == data . ContractPTC { jobType = data . JobPreAccountReturnBalance } jobData := & data . JobBalanceData { Amount : amount , GasPrice : gasPrice , } err = job . AddWithData ( h . queue , nil , jobType , data . JobAccount , account , data . JobUser , jobData ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil }
2817	func expandVMwareUplinkPortOrderPolicy ( d * schema . ResourceData ) * types . VMwareUplinkPortOrderPolicy { obj := & types . VMwareUplinkPortOrderPolicy { ActiveUplinkPort : structure . SliceInterfacesToStrings ( d . Get ( "active_uplinks" ) . ( [ ] interface { } ) ) , StandbyUplinkPort : structure . SliceInterfacesToStrings ( d . Get ( "standby_uplinks" ) . ( [ ] interface { } ) ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
6227	func ( w * Worker ) ClientAfterOfferingDelete ( job * data . Job ) error { return w . updateRelatedOffering ( job , data . JobClientAfterOfferingDelete , data . OfferRemoved ) }
6602	func ( q * Query ) ReadTimeout ( timeout time . Duration ) * Query { q . readTimeout = timeout return q }
6652	func ( v Vec3 ) Dist2D ( v1 Vec3 ) float32 { dx := v1 [ 0 ] - v [ 0 ] dz := v1 [ 2 ] - v [ 2 ] return math32 . Sqrt ( dx * dx + dz * dz ) }
2519	func expandHostNetworkSecurityPolicy ( d * schema . ResourceData ) * types . HostNetworkSecurityPolicy { obj := & types . HostNetworkSecurityPolicy { } if v , ok := d . GetOkExists ( "allow_promiscuous" ) ; ok { obj . AllowPromiscuous = structure . BoolPtr ( v . ( bool ) ) } if v , ok := d . GetOkExists ( "allow_forged_transmits" ) ; ok { obj . ForgedTransmits = structure . BoolPtr ( v . ( bool ) ) } if v , ok := d . GetOkExists ( "allow_mac_changes" ) ; ok { obj . MacChanges = structure . BoolPtr ( v . ( bool ) ) } return obj }
932	func machineCommand ( actionName string , host * host . Host , errorChan chan <- error ) { commands := map [ string ] ( func ( ) error ) { "configureAuth" : host . ConfigureAuth , "configureAllAuth" : host . ConfigureAllAuth , "start" : host . Start , "stop" : host . Stop , "restart" : host . Restart , "kill" : host . Kill , "upgrade" : host . Upgrade , "ip" : printIP ( host ) , "provision" : host . Provision , } log . Debugf ( "command=%s machine=%s" , actionName , host . Name ) errorChan <- commands [ actionName ] ( ) }
6044	func ( w * Worker ) AccountUpdateBalances ( job * data . Job ) error { return w . updateAccountBalancesJob ( job , data . JobAccountUpdateBalances ) }
4164	func ( c * Client ) Connect ( ) error { if c . IrcAddress == "" && c . TLS { c . IrcAddress = ircTwitchTLS } else if c . IrcAddress == "" && ! c . TLS { c . IrcAddress = ircTwitch } dialer := & net . Dialer { KeepAlive : time . Second * 10 , } var conf * tls . Config if strings . HasPrefix ( c . IrcAddress , "127.0.0.1:" ) { conf = & tls . Config { InsecureSkipVerify : true , } } else { conf = & tls . Config { } } for { err := c . makeConnection ( dialer , conf ) switch err { case errReconnect : continue default : return err } } }
1116	func replaceAll ( f , t , s string ) ( string , error ) { return strings . Replace ( s , f , t , - 1 ) , nil }
7237	func ( e * Entry ) addPatterns ( patterns [ ] string ) * Entry { var currentNode * Entry = e for len ( patterns ) > 0 { var entry * Entry pat , size := PeekNextPattern ( patterns ) if size == 2 { matcher , name := parseMatcher ( patterns [ 0 ] ) suffixMatcher := & SuffixMatcher { patterns [ 1 ] , matcher } entry = newSuffixMatchEntry ( pat , name , suffixMatcher ) } else if isMatchPattern ( pat ) { entry = newMatchEntry ( pat ) } else { entry = newStaticEntry ( pat ) } currentNode . AddEntry ( entry ) currentNode = entry patterns = patterns [ size : ] } return currentNode }
1900	func ( engine * DockerTaskEngine ) handleDockerEvent ( event dockerapi . DockerContainerChangeEvent ) { seelog . Debugf ( "Task engine: handling a docker event: %s" , event . String ( ) ) task , ok := engine . state . TaskByID ( event . DockerID ) if ! ok { seelog . Debugf ( "Task engine: event for container [%s] not managed, unable to map container id to task" , event . DockerID ) return } cont , ok := engine . state . ContainerByID ( event . DockerID ) if ! ok { seelog . Debugf ( "Task engine: event for container [%s] not managed, unable to map container id to container" , event . DockerID ) return } if event . Type == apicontainer . ContainerHealthEvent { if cont . Container . HealthStatusShouldBeReported ( ) { seelog . Debugf ( "Task engine: updating container [%s(%s)] health status: %v" , cont . Container . Name , cont . DockerID , event . DockerContainerMetadata . Health ) cont . Container . SetHealthStatus ( event . DockerContainerMetadata . Health ) } return } engine . tasksLock . RLock ( ) managedTask , ok := engine . managedTasks [ task . Arn ] defer engine . tasksLock . RUnlock ( ) if ! ok { seelog . Criticalf ( "Task engine: could not find managed task [%s] corresponding to a docker event: %s" , task . Arn , event . String ( ) ) return } seelog . Debugf ( "Task engine [%s]: writing docker event to the task: %s" , task . Arn , event . String ( ) ) managedTask . emitDockerContainerChange ( dockerContainerChange { container : cont . Container , event : event } ) seelog . Debugf ( "Task engine [%s]: wrote docker event to the task: %s" , task . Arn , event . String ( ) ) }
6261	func ( h * Handler ) GetClientOfferingsFilterParams ( tkn string ) ( * GetClientOfferingsFilterParamsResult , error ) { logger := h . logger . Add ( "method" , "GetClientOfferingsFilterParams" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } countries , err := h . offeringCountries ( logger ) if err != nil { return nil , err } min , max , err := h . offeringsMinMaxPrice ( logger ) if err != nil { return nil , err } return & GetClientOfferingsFilterParamsResult { countries , min , max } , nil }
5262	func OptClientPoolSizePerRoute ( size int ) ClientOption { return func ( options * ClientOptions ) error { options . PoolSizePerRoute = size return nil } }
1433	func ( state * DockerTaskEngineState ) AddENIAttachment ( eniAttachment * apieni . ENIAttachment ) { if eniAttachment == nil { log . Debug ( "Cannot add empty eni attachment information" ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) if _ , ok := state . eniAttachments [ eniAttachment . MACAddress ] ; ! ok { state . eniAttachments [ eniAttachment . MACAddress ] = eniAttachment } else { seelog . Debugf ( "Duplicate eni attachment information: %v" , eniAttachment ) } }
3074	func ( ctx * Context ) Query ( name string ) string { ctx . parseForm ( ) return ctx . Req . Form . Get ( name ) }
6812	func ( c * Client ) Value ( ) interface { } { if c . value == nil { var v interface { } c = c . Child ( "" , nil , v ) } if c == nil { return nil } return c . value }
5385	func NewInfo ( name string ) ( * info , error ) { i , err := os . Stat ( name ) if err != nil { return nil , err } return & info { i } , nil }
1639	func ( mr * MockLicenseProviderMockRecorder ) GetText ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "GetText" , reflect . TypeOf ( ( * MockLicenseProvider ) ( nil ) . GetText ) ) }
5563	func FindPerformanceSpacePrice ( productPackage datatypes . Product_Package , size int ) ( datatypes . Product_Item_Price , error ) { for _ , item := range productPackage . Items { if int ( * item . Capacity ) != size { continue } for _ , price := range item . Prices { if price . LocationGroupId != nil { continue } if ! hasCategory ( price . Categories , "performance_storage_space" ) { continue } return price , nil } } return datatypes . Product_Item_Price { } , bosherr . Errorf ( "Unable to find disk space price with size of %d for the given volume" , size ) }
3597	func ( t * TileDefRequest ) HasQueryType ( ) bool { if t != nil && t . QueryType != nil { return true } return false }
4653	func ( queue * queue ) Peek ( ) interface { } { if queue . size == 0 { return nil } return queue . elements [ queue . start % int64 ( queue . cap ) ] }
3076	func ( ctx * Context ) QueryStrings ( name string ) [ ] string { ctx . parseForm ( ) vals , ok := ctx . Req . Form [ name ] if ! ok { return [ ] string { } } return vals }
5361	func ( * GShadow ) lookUp ( line string , f field , value interface { } ) interface { } { _field := f . ( gshadowField ) _value := value . ( string ) allField := strings . Split ( line , ":" ) arrayField := make ( map [ int ] [ ] string ) arrayField [ 2 ] = strings . Split ( allField [ 2 ] , "," ) arrayField [ 3 ] = strings . Split ( allField [ 3 ] , "," ) var isField bool if GS_NAME & _field != 0 && allField [ 0 ] == _value { isField = true } else if GS_PASSWD & _field != 0 && allField [ 1 ] == _value { isField = true } else if GS_ADMIN & _field != 0 && checkGroup ( arrayField [ 2 ] , _value ) { isField = true } else if GS_MEMBER & _field != 0 && checkGroup ( arrayField [ 3 ] , _value ) { isField = true } else if GS_ALL & _field != 0 { isField = true } if isField { return & GShadow { allField [ 0 ] , allField [ 1 ] , arrayField [ 2 ] , arrayField [ 3 ] , } } return nil }
6927	func ( c * Client ) Post ( metrics [ ] Metric ) error { series := struct { Series [ ] Metric `json:"series,omitempty"` } { Series : metrics } buf := fetchBuffer ( ) defer bufferPool . Put ( buf ) var dst io . Writer = buf if ! c . DisableCompression { zlw := fetcZlibWriter ( buf ) defer zlibWriterPool . Put ( zlw ) defer zlw . Close ( ) dst = zlw } if err := json . NewEncoder ( dst ) . Encode ( & series ) ; err != nil { return err } if c , ok := dst . ( io . Closer ) ; ok { if err := c . Close ( ) ; err != nil { return err } } return c . post ( buf . Bytes ( ) , 0 ) }
4542	func ( n ImageName ) String ( ) string { buf := bytes . Buffer { } if n . Registry != "" { buf . WriteString ( n . Registry ) buf . WriteString ( "/" ) } if n . Repository != "" { buf . WriteString ( n . Repository ) buf . WriteString ( "/" ) } buf . WriteString ( n . Name ) if n . Digest != "" { buf . WriteString ( "@" ) buf . WriteString ( n . Digest ) } else { buf . WriteString ( ":" ) buf . WriteString ( n . Tag ) } return buf . String ( ) }
1942	func ( m * MockTaskEngineState ) RemoveImageState ( arg0 * image . ImageState ) { m . ctrl . Call ( m , "RemoveImageState" , arg0 ) }
1634	func ( n * NvidiaGPUManager ) SetDriverVersion ( version string ) { n . lock . Lock ( ) defer n . lock . Unlock ( ) n . DriverVersion = version }
5415	func ( w * World ) AddEntity ( e Identifier ) { if w . sysIn == nil { w . sysIn = make ( map [ reflect . Type ] reflect . Type ) } if w . sysEx == nil { w . sysEx = make ( map [ reflect . Type ] reflect . Type ) } for _ , system := range w . systems { sys , ok := system . ( SystemAddByInterfacer ) if ! ok { continue } if ex , not := w . sysEx [ reflect . TypeOf ( sys ) ] ; not { if reflect . TypeOf ( e ) . Implements ( ex ) { continue } } if in , ok := w . sysIn [ reflect . TypeOf ( sys ) ] ; ok { if reflect . TypeOf ( e ) . Implements ( in ) { sys . AddByInterface ( e ) } } } }
3329	func ( g * GroupData ) GetLastNoDataTsOk ( ) ( int , bool ) { if g == nil || g . LastNoDataTs == nil { return 0 , false } return * g . LastNoDataTs , true }
3216	func ( client * Client ) MuteHost ( host string , action * HostActionMute ) ( * HostActionResp , error ) { var out HostActionResp uri := "/v1/host/" + host + "/mute" if err := client . doJsonRequest ( "POST" , uri , action , & out ) ; err != nil { return nil , err } return & out , nil }
533	func ( c * Cookie ) SetPathBytes ( path [ ] byte ) { c . buf = append ( c . buf [ : 0 ] , path ... ) c . path = normalizePath ( c . path , c . buf ) }
380	func ( a * Args ) Peek ( key string ) [ ] byte { return peekArgStr ( a . args , key ) }
2953	func expandStorageDrsIoLoadBalanceConfig ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . StorageDrsIoLoadBalanceConfig { obj := & types . StorageDrsIoLoadBalanceConfig { IoLatencyThreshold : int32 ( d . Get ( "sdrs_io_latency_threshold" ) . ( int ) ) , IoLoadImbalanceThreshold : int32 ( d . Get ( "sdrs_io_load_imbalance_threshold" ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . ReservableIopsThreshold = int32 ( d . Get ( "sdrs_io_reservable_iops_threshold" ) . ( int ) ) obj . ReservablePercentThreshold = int32 ( d . Get ( "sdrs_io_reservable_percent_threshold" ) . ( int ) ) obj . ReservableThresholdMode = d . Get ( "sdrs_io_reservable_threshold_mode" ) . ( string ) } return obj }
2644	func resourceVSphereComputeClusterApplyTags ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } if tagsClient == nil { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping" , resourceVSphereComputeClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying any pending tags" , resourceVSphereComputeClusterIDString ( d ) ) return processTagDiff ( tagsClient , d , cluster ) }
2836	func resourceVSphereDatastoreApplyFolderOrStorageClusterPath ( d * schema . ResourceData , meta interface { } ) ( string , error ) { var path string fvalue , fok := d . GetOk ( "folder" ) cvalue , cok := d . GetOk ( "datastore_cluster_id" ) switch { case fok : path = fvalue . ( string ) case cok : return resourceVSphereDatastoreStorageClusterPathNormalized ( meta , cvalue . ( string ) ) } return path , nil }
451	func ( s * Server ) ServeTLSEmbed ( ln net . Listener , certData , keyData [ ] byte ) error { err := s . AppendCertEmbed ( certData , keyData ) if err != nil && err != errNoCertOrKeyProvided { return err } if s . tlsConfig == nil { return errNoCertOrKeyProvided } s . tlsConfig . BuildNameToCertificate ( ) return s . Serve ( tls . NewListener ( ln , s . tlsConfig ) , ) }
2875	func resourceVSphereResourcePoolReadTags ( d * schema . ResourceData , meta interface { } , rp * object . ResourcePool ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( "[DEBUG] %s: Reading tags" , resourceVSphereResourcePoolIDString ( d ) ) if err := readTagsForResource ( tagsClient , rp , d ) ; err != nil { return err } } else { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping tag read" , resourceVSphereResourcePoolIDString ( d ) ) } return nil }
1752	func ( task * Task ) SetPullStoppedAt ( timestamp time . Time ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . PullStoppedAtUnsafe = timestamp }
2965	func diskApplyOperationDelete ( index int , oldData map [ string ] interface { } , newDataSet [ ] interface { } , c * govmomi . Client , d * schema . ResourceData , l * object . VirtualDeviceList , spec * [ ] types . BaseVirtualDeviceConfigSpec , ) error { didx := - 1 for ni , ne := range newDataSet { newData := ne . ( map [ string ] interface { } ) var name string var err error if name , err = diskLabelOrName ( newData ) ; err != nil { return err } if ( name == diskDeletedName || name == diskDetachedName ) && oldData [ "uuid" ] == newData [ "uuid" ] { didx = ni break } } if didx < 0 { return nil } r := NewDiskSubresource ( c , d , oldData , nil , index ) dspec , err := r . Delete ( * l ) if err != nil { return fmt . Errorf ( "%s: %s" , r . Addr ( ) , err ) } * l = applyDeviceChange ( * l , dspec ) * spec = append ( * spec , dspec ... ) return nil }
2933	func resourceVSphereComputeClusterVMDependencyRuleFetchObjects ( meta interface { } , clusterID string , key int32 , ) ( * object . ClusterComputeResource , int32 , error ) { client , err := resourceVSphereComputeClusterVMDependencyRuleClient ( meta ) if err != nil { return nil , 0 , err } cluster , err := clustercomputeresource . FromID ( client , clusterID ) if err != nil { return nil , 0 , fmt . Errorf ( "cannot locate cluster: %s" , err ) } return cluster , key , nil }
2888	func NameOrID ( client * govmomi . Client , id string ) string { name , err := hostSystemNameFromID ( client , id ) if err != nil { return id } return name }
3421	func ( o * Options ) HasIncludeTags ( ) bool { if o != nil && o . IncludeTags != nil { return true } return false }
5138	func ( ui * ColorUI ) Warn ( message string ) { ct . ChangeColor ( ui . WarnFGColor . Code , ui . WarnFGColor . Bright , ui . WarnBGColor . Code , ui . WarnBGColor . Bright ) ui . UI . Warn ( message ) ct . ResetColor ( ) }
6305	func NewDependencyInjector ( ) DependencyInjector { return & dependencyInjector { registry : make ( map [ reflect . Type ] interface { } ) , instances : make ( map [ reflect . Type ] reflect . Value ) , } }
7128	func ( s * Docker ) HasBin ( ) bool { _ , err := exec . LookPath ( s . binCmd ) return err == nil }
2391	func Str ( str string ) * uint8 { if ! strings . HasSuffix ( str , "\x00" ) \x00 { panic ( "str argument missing null terminator: " + str ) } header := ( * reflect . StringHeader ) ( unsafe . Pointer ( & str ) ) }
2102	func ( eni * ENIAttachment ) SetSentStatus ( ) { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) eni . AttachStatusSent = true }
2594	func MOIDsForUUIDs ( client * govmomi . Client , uuids [ ] string ) ( MOIDForUUIDResults , error ) { var results MOIDForUUIDResults for _ , uuid := range uuids { result , err := MOIDForUUID ( client , uuid ) if err != nil { return nil , err } results = append ( results , result ) } return results , nil }
1780	func ( m * MockClientServer ) AddRequestHandler ( arg0 wsclient . RequestHandler ) { m . ctrl . Call ( m , "AddRequestHandler" , arg0 ) }
1959	func ( f * factory ) GetClient ( version dockerclient . DockerVersion ) ( sdkclient . Client , error ) { return f . getClient ( version ) }
6055	func Recover ( db * reform . DB ) error { if err := recoverServiceStatuses ( db ) ; err != nil { return err } return nil }
5465	func ( a * Alert ) StatusCode ( ) int { vals , err := url . ParseQuery ( a . AlertText ) if err != nil { return 0 } if code := vals . Get ( "httpResponse" ) ; code != "" { i , err := strconv . ParseInt ( code , 10 , 64 ) if err == nil && i > 99 && i < 600 { return int ( i ) } } return 0 }
6405	func NewLinkedList ( entries ... interface { } ) * LinkedList { list := & LinkedList { } for _ , entry := range entries { list . AddBack ( entry ) } return list }
4711	func ( l * line ) fileName ( ) string { return l . file . path + dot + l . opts . Extension }
4502	func Contents ( filters ... Filter ) ( [ ] string , error ) { var result [ ] string err := ForEach ( Sequence ( filters ... ) , func ( s string ) { result = append ( result , s ) } ) if err != nil { result = nil } return result , err }
2755	func expandDVSCreateSpec ( d * schema . ResourceData ) types . DVSCreateSpec { obj := types . DVSCreateSpec { ProductInfo : & types . DistributedVirtualSwitchProductSpec { Version : d . Get ( "version" ) . ( string ) , } , ConfigSpec : expandVMwareDVSConfigSpec ( d ) , } return obj }
2300	func ( v * TreeModel ) native ( ) * C . GtkTreeModel { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeModel ( p ) }
7265	func isNextSuffixPattern ( p [ ] string ) bool { if len ( p ) >= 2 && isMatchPattern ( p [ 0 ] ) && ! isMatchPattern ( p [ 1 ] ) { matcher , _ := parseMatcher ( p [ 0 ] ) if _ , ok := matcher . ( * FixedLengthMatcher ) ; ok { return false } r , _ := utf8 . DecodeRuneInString ( p [ 1 ] ) return matcher . MatchRune ( r ) } return false }
2992	func diskCapacityInGiB ( disk * types . VirtualDisk ) int { if disk . CapacityInBytes > 0 { return int ( structure . ByteToGiB ( disk . CapacityInBytes ) . ( int64 ) ) } log . Printf ( "[DEBUG] diskCapacityInGiB: capacityInBytes missing for for %s, falling back to capacityInKB" , object . VirtualDeviceList { } . Name ( disk ) , ) return int ( structure . ByteToGiB ( disk . CapacityInKB * 1024 ) . ( int64 ) ) }
636	func ( f ZoneTagFilter ) Match ( tagsMap map [ string ] string ) bool { for _ , tagFilter := range f . zoneTags { filterParts := strings . SplitN ( tagFilter , "=" , 2 ) switch len ( filterParts ) { case 1 : if _ , hasTag := tagsMap [ filterParts [ 0 ] ] ; ! hasTag { return false } case 2 : if value , hasTag := tagsMap [ filterParts [ 0 ] ] ; ! hasTag || value != filterParts [ 1 ] { return false } } } return true }
3508	func ( s * SyntheticsAssertion ) GetOperator ( ) string { if s == nil || s . Operator == nil { return "" } return * s . Operator }
2538	func matchGateway ( a string , m int , g string ) bool { ip := net . ParseIP ( a ) gw := net . ParseIP ( g ) var mask net . IPMask if ip . To4 ( ) != nil { mask = net . CIDRMask ( m , 32 ) } else { mask = net . CIDRMask ( m , 128 ) } if ip . Mask ( mask ) . Equal ( gw . Mask ( mask ) ) { return true } return false }
3911	func yaml_emitter_set_output_writer ( emitter * yaml_emitter_t , w io . Writer ) { if emitter . write_handler != nil { panic ( "must set the output target only once" ) } emitter . write_handler = yaml_writer_write_handler emitter . output_writer = w }
3939	func ( p * Pinger ) AddIPAddr ( ip * net . IPAddr ) { p . mu . Lock ( ) p . addrs [ ip . String ( ) ] = ip if isIPv4 ( ip . IP ) { p . hasIPv4 = true } else if isIPv6 ( ip . IP ) { p . hasIPv6 = true } p . mu . Unlock ( ) }
5775	func ( a * API ) FetchMetricCluster ( cid CIDType , extras string ) ( * MetricCluster , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid metric cluster CID [none]" ) } clusterCID := string ( * cid ) matched , err := regexp . MatchString ( config . MetricClusterCIDRegex , clusterCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid metric cluster CID [%s]" , clusterCID ) } reqURL := url . URL { Path : clusterCID , } extra := "" switch extras { case "metrics" : extra = "_matching_metrics" case "uuids" : extra = "_matching_uuid_metrics" } if extra != "" { q := url . Values { } q . Set ( "extra" , extra ) reqURL . RawQuery = q . Encode ( ) } result , err := a . Get ( reqURL . String ( ) ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch metric cluster, received JSON: %s" , string ( result ) ) } cluster := & MetricCluster { } if err := json . Unmarshal ( result , cluster ) ; err != nil { return nil , err } return cluster , nil }
4568	func ( h HelperContext ) BlockWith ( hc hctx . Context ) ( string , error ) { ctx , ok := hc . ( * Context ) if ! ok { return "" , fmt . Errorf ( "expected *Context, got %T" , hc ) } octx := h . compiler . ctx defer func ( ) { h . compiler . ctx = octx } ( ) h . compiler . ctx = ctx if h . block == nil { return "" , errors . New ( "no block defined" ) } i , err := h . compiler . evalBlockStatement ( h . block ) if err != nil { return "" , err } bb := & bytes . Buffer { } h . compiler . write ( bb , i ) return bb . String ( ) , nil }
7187	func JsonWrite ( w http . ResponseWriter , status int , content interface { } ) { HttpHeader_ContentType_Json ( ) . SetWriter ( w . Header ( ) ) w . WriteHeader ( status ) if content != nil { json . NewEncoder ( w ) . Encode ( content ) } }
5962	func uint16ListToStringList ( source [ ] uint16 ) ( o [ ] string ) { for _ , s := range source { o = append ( o , strconv . FormatUint ( uint64 ( s ) , 10 ) ) } return }
4062	func SetThemePath ( path string ) { if path == themeManager . themePath { return } themeManager . themePath = path ThemeReset ( ) }
3197	func GetPrecision ( v * PrecisionT ) ( PrecisionT , bool ) { if v != nil { return * v , true } return PrecisionT ( "" ) , false }
5466	func ( d Direction ) Friendly ( ) string { switch d { case DirectionOutboundReply : return "Reply" case DirectionOutboundCall : return "Outgoing (from call)" case DirectionOutboundAPI : return "Outgoing (from API)" case DirectionInbound : return "Incoming" case DirectionOutboundDial : return "Outgoing (via Dial)" case DirectionTrunkingTerminating : return "Trunking (terminating)" case DirectionTrunkingOriginating : return "Trunking (originating)" default : return string ( d ) } }
2099	func ( lru * lruCache ) Delete ( key string ) { lru . Lock ( ) defer lru . Unlock ( ) lru . removeFromEvictList ( key ) delete ( lru . cache , key ) }
7146	func ( s * Random ) readByte ( ) byte { before := time . Now ( ) rndDuration := time . Duration ( getUInt16FromBytes ( s . val ) ) time . Sleep ( DEFAULT_SLEEP_TIME + rndDuration ) diff := time . Now ( ) . Sub ( before ) n := byte ( diff . Nanoseconds ( ) ) s . val [ s . index ] = n s . index ^= 1 return n }
3344	func ( h * HostActionMute ) GetEndTimeOk ( ) ( string , bool ) { if h == nil || h . EndTime == nil { return "" , false } return * h . EndTime , true }
1199	func ( m * MockTime ) Sleep ( arg0 time . Duration ) { m . ctrl . Call ( m , "Sleep" , arg0 ) }
2786	func expandHostPortGroupSpec ( d * schema . ResourceData ) * types . HostPortGroupSpec { obj := & types . HostPortGroupSpec { Name : d . Get ( "name" ) . ( string ) , VlanId : int32 ( d . Get ( "vlan_id" ) . ( int ) ) , VswitchName : d . Get ( "virtual_switch_name" ) . ( string ) , Policy : * expandHostNetworkPolicy ( d ) , } return obj }
3315	func ( g * GraphDefinition ) HasIncludeNoMetricHosts ( ) bool { if g != nil && g . IncludeNoMetricHosts != nil { return true } return false }
2880	func VirtualMachineCloneSchema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { "template_uuid" : { Type : schema . TypeString , Required : true , Description : "The UUID of the source virtual machine or template." , } , "linked_clone" : { Type : schema . TypeBool , Optional : true , Description : "Whether or not to create a linked clone when cloning. When this option is used, the source VM must have a single snapshot associated with it." , } , "timeout" : { Type : schema . TypeInt , Optional : true , Default : 30 , Description : "The timeout, in minutes, to wait for the virtual machine clone to complete." , ValidateFunc : validation . IntAtLeast ( 10 ) , } , "customize" : { Type : schema . TypeList , Optional : true , MaxItems : 1 , Description : "The customization spec for this clone. This allows the user to configure the virtual machine post-clone." , Elem : & schema . Resource { Schema : VirtualMachineCustomizeSchema ( ) } , } , } }
4845	func GenFromURL ( urlstr string ) func ( * URL ) ( string , error ) { z , err := url . Parse ( urlstr ) if err != nil { panic ( err ) } return func ( u * URL ) ( string , error ) { opaque := z . Opaque if u . Opaque != "" { opaque = u . Opaque } user := z . User if u . User != nil { user = u . User } host , port := hostname ( z . Host ) , hostport ( z . Host ) if h := hostname ( u . Host ) ; h != "" { host = h } if p := hostport ( u . Host ) ; p != "" { port = p } if port != "" { host += ":" + port } path := z . Path if u . Path != "" { path = u . Path } rawPath := z . RawPath if u . RawPath != "" { rawPath = u . RawPath } q := z . Query ( ) for k , v := range u . Query ( ) { q . Set ( k , strings . Join ( v , " " ) ) } fragment := z . Fragment if u . Fragment != "" { fragment = u . Fragment } y := & url . URL { Scheme : z . Scheme , Opaque : opaque , User : user , Host : host , Path : path , RawPath : rawPath , RawQuery : q . Encode ( ) , Fragment : fragment , } return y . String ( ) , nil } }
3108	func ( r * Router ) InternalServerError ( handlers ... Handler ) { handlers = validateAndWrapHandlers ( handlers ) r . internalServerError = func ( c * Context , err error ) { c . index = 0 c . handlers = handlers c . Map ( err ) c . run ( ) } }
4080	func FindFirstActiveControl ( parent Control ) Control { for _ , curr := range getLinearControlList ( parent , nil ) { if curr . Active ( ) { return curr } } return nil }
6571	func ChangeCustomHostVar ( host_name string , varname string , varvalue string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_CUSTOM_HOST_VAR" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "varname" , "string" , varname ) , stringifyArg ( "varvalue" , "string" , varvalue ) , ) }
5217	func OptFieldTypeTime ( quantum TimeQuantum , opts ... bool ) FieldOption { return func ( options * FieldOptions ) { options . fieldType = FieldTypeTime options . timeQuantum = quantum if len ( opts ) > 0 && opts [ 0 ] { options . noStandardView = true } } }
3565	func ( t * TemplateVariable ) GetPrefix ( ) string { if t == nil || t . Prefix == nil { return "" } return * t . Prefix }
4241	func ( b Box ) Center ( ) ( lat , lng float64 ) { lat = ( b . MinLat + b . MaxLat ) / 2.0 lng = ( b . MinLng + b . MaxLng ) / 2.0 return }
6718	func ( c * Client ) CloudIPs ( ) ( [ ] CloudIP , error ) { var cloudips [ ] CloudIP _ , err := c . MakeApiRequest ( "GET" , "/1.0/cloud_ips" , nil , & cloudips ) if err != nil { return nil , err } return cloudips , err }
7272	func NewTournament ( tdata Info ) ( * Tournament , error ) { if err := validateTournamentInfo ( tdata ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not create tournament" ) } t := new ( Tournament ) t . UUID , _ = uuid . V4 ( ) if err := mergo . MergeWithOverwrite ( & t . Info , tdata ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not set initial tournament data" ) } fixupTournamentInfo ( & t . Info , tdata ) if err := storage . Store ( t ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not write tournament to storage" ) } return t , nil }
6822	func ServeMetrics ( ctx context . Context , l net . Listener ) error { return http . Serve ( l , promhttp . Handler ( ) ) }
7122	func ( i * cacheItem ) Postpone ( ) { i . expireAt = time . Now ( ) . Add ( i . lifetime ) }
1524	func ( cfg * Config ) trimWhitespace ( ) { cfgElem := reflect . ValueOf ( cfg ) . Elem ( ) cfgStructField := reflect . Indirect ( reflect . ValueOf ( cfg ) ) . Type ( ) for i := 0 ; i < cfgElem . NumField ( ) ; i ++ { cfgField := cfgElem . Field ( i ) if ! cfgField . CanInterface ( ) { continue } trimTag := cfgStructField . Field ( i ) . Tag . Get ( "trim" ) if len ( trimTag ) == 0 { continue } if cfgField . Kind ( ) != reflect . String { seelog . Warnf ( "Cannot trim non-string field type %v index %v" , cfgField . Kind ( ) . String ( ) , i ) continue } str := cfgField . Interface ( ) . ( string ) cfgField . SetString ( strings . TrimSpace ( str ) ) } }
5201	func OptIndexTrackExistence ( trackExistence bool ) IndexOption { return func ( options * IndexOptions ) { options . trackExistence = trackExistence options . trackExistenceSet = true } }
239	func ( m * Manager ) TargetsDropped ( ) map [ string ] [ ] * Target { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) targets := make ( map [ string ] [ ] * Target , len ( m . scrapePools ) ) for tset , sp := range m . scrapePools { targets [ tset ] = sp . DroppedTargets ( ) } return targets }
6341	func LogRequest ( r * Request , v ... string ) { serializedHeaders := bytes . Buffer { } r . Header . Write ( & serializedHeaders ) printf := log . Printf if Logger != nil { printf = Logger . Printf } printf ( LogRequestTemplate , strings . Join ( v , " " ) , r . URL . String ( ) , r . Method , time . Now ( ) , serializedHeaders . String ( ) , string ( r . BodyData ( ) ) , debug . Stack ( ) , ) }
4096	func ( l * TableView ) OnKeyPress ( fn func ( term . Key ) bool ) { l . onKeyPress = fn }
5575	func NewHTTPClient ( formats strfmt . Registry ) * SoftLayerVMPool { if formats == nil { formats = strfmt . Default } transport := httptransport . New ( "vps.swagger.io" , "/v2" , [ ] string { "http" } ) return New ( transport , formats ) }
5270	func OptQueryExcludeColumns ( enable bool ) QueryOption { return func ( options * QueryOptions ) error { options . ExcludeColumns = enable return nil } }
2572	func baseVirtualEthernetCardToBaseVirtualDevice ( v types . BaseVirtualEthernetCard ) types . BaseVirtualDevice { switch t := v . ( type ) { case * types . VirtualE1000 : return types . BaseVirtualDevice ( t ) case * types . VirtualE1000e : return types . BaseVirtualDevice ( t ) case * types . VirtualPCNet32 : return types . BaseVirtualDevice ( t ) case * types . VirtualSriovEthernetCard : return types . BaseVirtualDevice ( t ) case * types . VirtualVmxnet2 : return types . BaseVirtualDevice ( t ) case * types . VirtualVmxnet3 : return types . BaseVirtualDevice ( t ) } panic ( fmt . Errorf ( "unknown ethernet card type %T" , v ) ) }
828	func ( d * Driver ) IsVTXDisabled ( ) bool { if cpuid . HasFeature ( cpuid . VMX ) || cpuid . HasFeature ( cpuid . SVM ) { return false } return true }
411	func ( u * URI ) AppendBytes ( dst [ ] byte ) [ ] byte { dst = u . appendSchemeHost ( dst ) return append ( dst , u . RequestURI ( ) ... ) }
4473	func ParseDuration ( cand string ) ( time . Duration , error ) { if dur , err := time . ParseDuration ( cand ) ; err == nil { return dur , nil } var dur time . Duration ok := false for _ , match := range durationMatcher . FindAllStringSubmatch ( cand , - 1 ) { factor , err := strconv . Atoi ( match [ 2 ] ) if err != nil { return 0 , err } unit := strings . ToLower ( strings . TrimSpace ( match [ 3 ] ) ) for _ , variants := range timeUnits { last := len ( variants ) - 1 multiplier := timeMultiplier [ variants [ 0 ] ] for i , variant := range variants { if ( last == i && strings . HasPrefix ( unit , variant ) ) || strings . EqualFold ( variant , unit ) { ok = true dur += ( time . Duration ( factor ) * multiplier ) } } } } if ok { return dur , nil } return 0 , fmt . Errorf ( "unable to parse %s as duration" , cand ) }
3005	func flattenClusterVMHostRuleInfo ( d * schema . ResourceData , obj * types . ClusterVmHostRuleInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { "enabled" : obj . Enabled , "mandatory" : obj . Mandatory , "name" : obj . Name , "affinity_host_group_name" : obj . AffineHostGroupName , "anti_affinity_host_group_name" : obj . AntiAffineHostGroupName , "vm_group_name" : obj . VmGroupName , } ) }
6004	func JsonFileArray ( path string ) ( [ ] Typed , error ) { data , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } return JsonArray ( data ) }
7204	func ( self * Salter ) Token ( size int ) string { return base64 . URLEncoding . EncodeToString ( self . BToken ( size ) ) }
771	func ( p designateProvider ) getHostZoneID ( hostname string , managedZones map [ string ] string ) ( string , error ) { longestZoneLength := 0 resultID := "" for zoneID , zoneName := range managedZones { if ! strings . HasSuffix ( hostname , zoneName ) { continue } ln := len ( zoneName ) if ln > longestZoneLength { resultID = zoneID longestZoneLength = ln } } return resultID , nil }
3700	func ( w * Widget ) GetMustShowHits ( ) bool { if w == nil || w . MustShowHits == nil { return false } return * w . MustShowHits }
2462	func ScaleColor ( r , g , b , a float64 ) ColorM { c := ColorM { } c . Scale ( r , g , b , a ) return c }
5283	func ( c * Iterator ) NextRecord ( ) ( pilosa . Record , error ) { if ok := c . scanner . Scan ( ) ; ok { c . line ++ text := strings . TrimSpace ( c . scanner . Text ( ) ) if text != "" { rc , err := c . unmarshaller ( text ) if err != nil { return nil , fmt . Errorf ( "%s at line: %d" , err . Error ( ) , c . line ) } return rc , nil } } err := c . scanner . Err ( ) if err != nil { return nil , err } return nil , io . EOF }
577	func ( mx * Mux ) Patch ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mPATCH , pattern , handlerFn ) }
1418	func ( mr * MockSaveableOptionMockRecorder ) AddSaveable ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "AddSaveable" , reflect . TypeOf ( ( * MockSaveableOption ) ( nil ) . AddSaveable ) , arg0 , arg1 ) }
5779	func ( a * API ) DeleteMetricCluster ( cfg * MetricCluster ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid metric cluster config [nil]" ) } return a . DeleteMetricClusterByCID ( CIDType ( & cfg . CID ) ) }
6330	func NewCookieSigner ( key [ ] byte ) CookieSigner { return CookieSigner { signer : hmac . New ( sha256 . New , key ) } }
4283	func addArgsFromEnv ( evar string , args * [ ] string ) { if e := os . Getenv ( evar ) ; e != "" { for _ , f := range strings . Fields ( e ) { * args = append ( * args , f ) } } fmt . Printf ( ">>> criu %v\n" , \n ) }
1189	func ( task * Task ) adjustForPlatform ( cfg * config . Config ) { task . downcaseAllVolumePaths ( ) platformFields := PlatformFields { CpuUnbounded : cfg . PlatformVariables . CPUUnbounded , } task . PlatformFields = platformFields }
5855	func ( m * CirconusMetrics ) Flush ( ) { m . flushmu . Lock ( ) if m . flushing { m . flushmu . Unlock ( ) return } m . flushing = true m . flushmu . Unlock ( ) newMetrics , output := m . packageMetrics ( ) if len ( output ) > 0 { m . submit ( output , newMetrics ) } else { if m . Debug { m . Log . Println ( "[DEBUG] No metrics to send, skipping" ) } } m . flushmu . Lock ( ) m . flushing = false m . flushmu . Unlock ( ) }
6020	func ( t Typed ) ObjectMust ( key string ) Typed { t , exists := t . ObjectIf ( key ) if exists == false { panic ( "expected map for " + key ) } return t }
6878	func ( e * execStreamerBuilder ) StderrPrefix ( prefix string ) ExecStreamerBuilder { e . d . StderrPrefix = prefix return e }
3651	func ( t * TriggeringValue ) HasFromTs ( ) bool { if t != nil && t . FromTs != nil { return true } return false }
1746	func ( task * Task ) SetAppMesh ( appMesh * apiappmesh . AppMesh ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . AppMesh = appMesh }
388	func ( a * Args ) SetUintBytes ( key [ ] byte , value int ) { a . SetUint ( b2s ( key ) , value ) }
4702	func extractClasses ( s string ) [ ] string { var classes [ ] string for i , token := range strings . Split ( s , dot ) { if i == 0 { continue } class := strings . Split ( token , sharp ) [ 0 ] if class == "" { continue } classes = append ( classes , class ) } return classes }
4847	func GenPostgres ( u * URL ) ( string , error ) { host , port , dbname := hostname ( u . Host ) , hostport ( u . Host ) , strings . TrimPrefix ( u . Path , "/" ) if host == "." { return "" , ErrRelativePathNotSupported } if u . Proto == "unix" { if host == "" { dbname = "/" + dbname } host , port , dbname = resolveDir ( stdpath . Join ( host , dbname ) ) } q := u . Query ( ) q . Set ( "host" , host ) q . Set ( "port" , port ) q . Set ( "dbname" , dbname ) if u . User != nil { q . Set ( "user" , u . User . Username ( ) ) pass , _ := u . User . Password ( ) q . Set ( "password" , pass ) } if u . hostPortDB == nil { u . hostPortDB = [ ] string { host , port , dbname } } return genOptions ( q , "" , "=" , " " , "," , true ) , nil }
963	func ( v * View ) Data ( ) interface { } { v . dataLock . RLock ( ) defer v . dataLock . RUnlock ( ) return v . data }
2696	func HasDiskCreationOperations ( dc [ ] types . BaseVirtualDeviceConfigSpec ) bool { for _ , deviceConfigSpec := range dc { if _ , ok := virtualDiskFromDeviceConfigSpecForPlacement ( deviceConfigSpec ) ; ok { return true } } return false }
676	func ns1BuildRecord ( zoneName string , change * ns1Change ) * dns . Record { record := dns . NewRecord ( zoneName , change . Endpoint . DNSName , change . Endpoint . RecordType ) for _ , v := range change . Endpoint . Targets { record . AddAnswer ( dns . NewAnswer ( strings . Split ( v , " " ) ) ) } var ttl = ns1DefaultTTL if change . Endpoint . RecordTTL . IsConfigured ( ) { ttl = int ( change . Endpoint . RecordTTL ) } record . TTL = ttl return record }
1200	func ( mr * MockTimeMockRecorder ) Sleep ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Sleep" , reflect . TypeOf ( ( * MockTime ) ( nil ) . Sleep ) , arg0 ) }
3633	func ( t * TraceServiceDefinition ) HasShowErrors ( ) bool { if t != nil && t . ShowErrors != nil { return true } return false }
141	func lintHelp ( mf dto . MetricFamily ) [ ] Problem { var problems problems if mf . Help == nil { problems . Add ( mf , "no help text" ) } return problems }
895	func ( d * Driver ) Start ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } instance , err := c . instance ( ) if err != nil { if ! isNotFound ( err ) { return err } } if instance == nil { if err = c . createInstance ( d ) ; err != nil { return err } } else { if err := c . startInstance ( ) ; err != nil { return err } } d . IPAddress , err = d . GetIP ( ) return err }
5550	func ( s StringData ) ToTable ( ) TabularData { var tabData TabularData lines := strings . Split ( string ( s ) , "\n" ) \n for _ , line := range lines { row := strings . Split ( line , "|" ) row = row [ 1 : len ( row ) - 1 ] for i , c := range row { row [ i ] = strings . TrimSpace ( c ) } tabData = append ( tabData , row ) } }
7216	func ( logger * Logger ) SetBufferLength ( length int ) { logger . lock . Lock ( ) if length == 0 { logger . buffer = nil } else if length != logger . buffer . Len ( ) { logger . buffer = ring . New ( length ) } logger . lock . Unlock ( ) }
4842	func Unregister ( name string ) * Scheme { scheme , ok := schemeMap [ name ] if ok { for _ , alias := range scheme . Aliases { delete ( schemeMap , alias ) } delete ( schemeMap , name ) return scheme } return nil }
5127	func ( h * windowsAnsiEventHandler ) scroll ( param int , sr scrollRegion , info * CONSOLE_SCREEN_BUFFER_INFO ) error { h . logf ( "scroll: scrollTop: %d, scrollBottom: %d" , sr . top , sr . bottom ) h . logf ( "scroll: windowTop: %d, windowBottom: %d" , info . Window . Top , info . Window . Bottom ) scrollRect := SMALL_RECT { Top : sr . top , Bottom : sr . bottom , Left : 0 , Right : info . Size . X - 1 , } destOrigin := COORD { X : 0 , Y : sr . top - int16 ( param ) , } char := CHAR_INFO { UnicodeChar : ' ' , Attributes : h . attributes , } if err := ScrollConsoleScreenBuffer ( h . fd , scrollRect , scrollRect , destOrigin , char ) ; err != nil { return err } return nil }
6492	func ( a serviceOAuthAuthentication ) authenticate ( req * http . Request , endpoint string , params [ ] byte ) error { return nil }
420	func ( cc * LBClient ) DoTimeout ( req * Request , resp * Response , timeout time . Duration ) error { deadline := time . Now ( ) . Add ( timeout ) return cc . get ( ) . DoDeadline ( req , resp , deadline ) }
3189	func ( self * Client ) GetMonitorsByName ( name string ) ( [ ] Monitor , error ) { var out reqMonitors query , err := url . ParseQuery ( fmt . Sprintf ( "name=%v" , name ) ) if err != nil { return nil , err } err = self . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/monitor?%v" , query . Encode ( ) ) , nil , & out . Monitors ) if err != nil { return nil , err } return out . Monitors , nil }
4336	func ( c * Client ) Close ( ) { if c . muted { return } c . conn . mu . Lock ( ) c . conn . flush ( 0 ) c . conn . handleError ( c . conn . w . Close ( ) ) c . conn . closed = true c . conn . mu . Unlock ( ) }
6170	func HandlersMap ( worker * worker . Worker ) job . HandlerMap { return job . HandlerMap { data . JobAgentAfterChannelCreate : worker . AgentAfterChannelCreate , data . JobAgentAfterChannelTopUp : worker . AgentAfterChannelTopUp , data . JobAgentAfterUncooperativeCloseRequest : worker . AgentAfterUncooperativeCloseRequest , data . JobAgentAfterUncooperativeClose : worker . AgentAfterUncooperativeClose , data . JobAgentAfterCooperativeClose : worker . AgentAfterCooperativeClose , data . JobAgentPreServiceSuspend : worker . AgentPreServiceSuspend , data . JobAgentPreServiceUnsuspend : worker . AgentPreServiceUnsuspend , data . JobAgentPreServiceTerminate : worker . AgentPreServiceTerminate , data . JobAgentPreEndpointMsgCreate : worker . AgentPreEndpointMsgCreate , data . JobAgentPreOfferingMsgBCPublish : worker . AgentPreOfferingMsgBCPublish , data . JobAgentAfterOfferingMsgBCPublish : worker . AgentAfterOfferingMsgBCPublish , data . JobAgentPreOfferingPopUp : worker . AgentPreOfferingPopUp , data . JobAgentAfterOfferingPopUp : worker . AgentAfterOfferingPopUp , data . JobAgentPreOfferingDelete : worker . AgentPreOfferingDelete , data . JobAgentAfterOfferingDelete : worker . AgentAfterOfferingDelete , data . JobClientAfterOfferingDelete : worker . ClientAfterOfferingDelete , data . JobClientAfterOfferingPopUp : worker . ClientAfterOfferingPopUp , data . JobClientPreChannelCreate : worker . ClientPreChannelCreate , data . JobClientAfterChannelCreate : worker . ClientAfterChannelCreate , data . JobClientEndpointRestore : worker . ClientEndpointCreate , data . JobClientAfterUncooperativeClose : worker . ClientAfterUncooperativeClose , data . JobClientAfterCooperativeClose : worker . ClientAfterCooperativeClose , data . JobClientPreUncooperativeClose : worker . ClientPreUncooperativeClose , data . JobClientPreChannelTopUp : worker . ClientPreChannelTopUp , data . JobClientAfterChannelTopUp : worker . ClientAfterChannelTopUp , data . JobClientPreUncooperativeCloseRequest : worker . ClientPreUncooperativeCloseRequest , data . JobClientAfterUncooperativeCloseRequest : worker . ClientAfterUncooperativeCloseRequest , data . JobClientPreServiceTerminate : worker . ClientPreServiceTerminate , data . JobClientPreServiceSuspend : worker . ClientPreServiceSuspend , data . JobClientPreServiceUnsuspend : worker . ClientPreServiceUnsuspend , data . JobClientAfterOfferingMsgBCPublish : worker . ClientAfterOfferingMsgBCPublish , data . JobClientCompleteServiceTransition : worker . ClientCompleteServiceTransition , data . JobPreAccountAddBalanceApprove : worker . PreAccountAddBalanceApprove , data . JobPreAccountAddBalance : worker . PreAccountAddBalance , data . JobAfterAccountAddBalance : worker . AfterAccountAddBalance , data . JobPreAccountReturnBalance : worker . PreAccountReturnBalance , data . JobAfterAccountReturnBalance : worker . AfterAccountReturnBalance , data . JobAccountUpdateBalances : worker . AccountUpdateBalances , data . JobDecrementCurrentSupply : worker . DecrementCurrentSupply , data . JobIncrementCurrentSupply : worker . IncrementCurrentSupply , } }
2996	func hostPortGroupFromName ( client * govmomi . Client , ns * object . HostNetworkSystem , name string ) ( * types . HostPortGroup , error ) { var mns mo . HostNetworkSystem pc := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) if err := pc . RetrieveOne ( ctx , ns . Reference ( ) , [ ] string { "networkInfo.portgroup" } , & mns ) ; err != nil { return nil , fmt . Errorf ( "error fetching host network properties: %s" , err ) } for _ , pg := range mns . NetworkInfo . Portgroup { if pg . Spec . Name == name { return & pg , nil } } return nil , fmt . Errorf ( "could not find port group %s" , name ) }
2189	func goMarshal ( closure * C . GClosure , retValue * C . GValue , nParams C . guint , params * C . GValue , invocationHint C . gpointer , marshalData * C . GValue ) { closures . RLock ( ) cc := closures . m [ closure ] closures . RUnlock ( ) nGLibParams := int ( nParams ) nTotalParams := nGLibParams if cc . userData . IsValid ( ) { nTotalParams ++ } nCbParams := cc . rf . Type ( ) . NumIn ( ) if nCbParams > nTotalParams { fmt . Fprintf ( os . Stderr , "too many closure args: have %d, max allowed %d\n" , \n , nCbParams ) nTotalParams } return gValues := gValueSlice ( params , nCbParams ) args := make ( [ ] reflect . Value , 0 , nCbParams ) for i := 0 ; i < nCbParams && i < nGLibParams ; i ++ { v := & Value { & gValues [ i ] } val , err := v . GoValue ( ) if err != nil { fmt . Fprintf ( os . Stderr , "no suitable Go value for arg %d: %v\n" , \n , i ) err } return switch objVal := val . ( type ) { case * Object : innerVal , err := objVal . goValue ( ) if err != nil { fmt . Fprintf ( os . Stderr , "warning: no suitable Go value from object for arg %d: %v\n" , \n , i ) } else err } { val = innerVal } } rv := reflect . ValueOf ( val ) args = append ( args , rv . Convert ( cc . rf . Type ( ) . In ( i ) ) ) }
2063	func NewPublishHealthMetricsRequest ( metadata * HealthMetadata , healthMetrics [ ] * TaskHealth ) * PublishHealthRequest { return & PublishHealthRequest { Metadata : metadata , Tasks : healthMetrics , Timestamp : aws . Time ( time . Now ( ) ) , } }
104	func FromTime ( t time . Time ) int64 { return t . Unix ( ) * 1000 + int64 ( t . Nanosecond ( ) ) / int64 ( time . Millisecond ) }
6699	func ( c * Client ) ServerGroup ( identifier string ) ( * ServerGroup , error ) { group := new ( ServerGroup ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/server_groups/" + identifier , nil , group ) if err != nil { return nil , err } return group , err }
3174	func ( client * Client ) UpdateDashboardList ( list * DashboardList ) error { req := reqUpdateDashboardList { list . GetName ( ) } return client . doJsonRequest ( "PUT" , fmt . Sprintf ( "/v1/dashboard/lists/manual/%d" , * list . Id ) , req , nil ) }
4363	func Index ( index int ) OpFunc { return func ( in [ ] byte ) ( [ ] byte , error ) { return scanner . FindIndex ( in , 0 , index ) } }
7057	func ( r * Router ) Options ( pattern string , handlers ... interface { } ) * Router { c := r . pattern ( pattern ) c . Method = "OPTIONS" clone := r . clone ( c ) clone . handle ( handlers ) return clone }
4802	func ( g GenericHook ) Handle ( w http . ResponseWriter , r * http . Request , repo * Repo ) ( int , error ) { if r . Method != "POST" { return http . StatusMethodNotAllowed , errors . New ( "the request had an invalid method" ) } body , err := ioutil . ReadAll ( r . Body ) if err != nil { return http . StatusRequestTimeout , errors . New ( "could not read body from request" ) } err = g . handlePush ( body , repo ) if err != nil { return http . StatusBadRequest , err } return http . StatusOK , nil }
4172	func ( c * SpaceNamedQuotaConfigurationCommand ) Execute ( args [ ] string ) error { c . initConfig ( ) spaceQuota , err := c . ConfigManager . GetSpaceQuota ( c . Name , c . Org ) if err != nil { return err } if spaceQuota == nil { spaceQuota = & config . SpaceQuota { Name : c . Name , Org : c . Org , TotalReservedRoutePorts : "unlimited" , TotalServiceKeys : "unlimited" , AppInstanceLimit : "unlimited" , AppTaskLimit : "unlimited" , InstanceMemoryLimit : "unlimited" , TotalRoutes : "unlimited" , TotalServices : "unlimited" , PaidServicePlansAllowed : true , } } errorString := "" updateSpaceNamedQuotaConfig ( spaceQuota , c . Quota , & errorString ) if errorString != "" { return errors . New ( errorString ) } return c . ConfigManager . SaveSpaceQuota ( spaceQuota ) }
4883	func StringSize ( s string ) int { n := 0 for _ , r := range s { n += RuneLen ( r ) } return n }
3453	func ( q * QueryConfig ) GetLogSetOk ( ) ( LogSet , bool ) { if q == nil || q . LogSet == nil { return LogSet { } , false } return * q . LogSet , true }
5777	func ( a * API ) UpdateMetricCluster ( cfg * MetricCluster ) ( * MetricCluster , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid metric cluster config [nil]" ) } clusterCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . MetricClusterCIDRegex , clusterCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid metric cluster CID [%s]" , clusterCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update metric cluster, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( clusterCID , jsonCfg ) if err != nil { return nil , err } cluster := & MetricCluster { } if err := json . Unmarshal ( result , cluster ) ; err != nil { return nil , err } return cluster , nil }
1700	func ENIFromACS ( acsenis [ ] * ecsacs . ElasticNetworkInterface ) ( * ENI , error ) { err := ValidateTaskENI ( acsenis ) if err != nil { return nil , err } var ipv4 [ ] * ENIIPV4Address var ipv6 [ ] * ENIIPV6Address for _ , ec2Ipv4 := range acsenis [ 0 ] . Ipv4Addresses { ipv4 = append ( ipv4 , & ENIIPV4Address { Primary : aws . BoolValue ( ec2Ipv4 . Primary ) , Address : aws . StringValue ( ec2Ipv4 . PrivateAddress ) , } ) } for _ , ec2Ipv6 := range acsenis [ 0 ] . Ipv6Addresses { ipv6 = append ( ipv6 , & ENIIPV6Address { Address : aws . StringValue ( ec2Ipv6 . Address ) , } ) } eni := & ENI { ID : aws . StringValue ( acsenis [ 0 ] . Ec2Id ) , IPV4Addresses : ipv4 , IPV6Addresses : ipv6 , MacAddress : aws . StringValue ( acsenis [ 0 ] . MacAddress ) , PrivateDNSName : aws . StringValue ( acsenis [ 0 ] . PrivateDnsName ) , SubnetGatewayIPV4Address : aws . StringValue ( acsenis [ 0 ] . SubnetGatewayIpv4Address ) , } for _ , nameserverIP := range acsenis [ 0 ] . DomainNameServers { eni . DomainNameServers = append ( eni . DomainNameServers , aws . StringValue ( nameserverIP ) ) } for _ , nameserverDomain := range acsenis [ 0 ] . DomainName { eni . DomainNameSearchList = append ( eni . DomainNameSearchList , aws . StringValue ( nameserverDomain ) ) } return eni , nil }
1602	func ( m * MockSecretsManagerAPI ) ListSecretsWithContext ( arg0 aws . Context , arg1 * secretsmanager . ListSecretsInput , arg2 ... request . Option ) ( * secretsmanager . ListSecretsOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "ListSecretsWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . ListSecretsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3389	func ( m * MetricMetadata ) GetShortName ( ) string { if m == nil || m . ShortName == nil { return "" } return * m . ShortName }
2822	func flattenDVSSecurityPolicy ( d * schema . ResourceData , obj * types . DVSSecurityPolicy ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , "allow_promiscuous" , obj . AllowPromiscuous ) structure . SetBoolPolicy ( d , "allow_mac_changes" , obj . MacChanges ) structure . SetBoolPolicy ( d , "allow_forged_transmits" , obj . ForgedTransmits ) return nil }
5232	func ( qr * QueryResponse ) Result ( ) QueryResult { if len ( qr . ResultList ) == 0 { return nil } return qr . ResultList [ 0 ] }
1936	func ( mr * MockTaskEngineStateMockRecorder ) AllImageStates ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "AllImageStates" , reflect . TypeOf ( ( * MockTaskEngineState ) ( nil ) . AllImageStates ) ) }
1133	func ( c * cache ) DeleteExpired ( ) { var evictedItems [ ] keyAndValue now := time . Now ( ) . UnixNano ( ) c . mu . Lock ( ) for k , v := range c . items { if v . Expiration > 0 && now > v . Expiration { ov , evicted := c . delete ( k ) if evicted { evictedItems = append ( evictedItems , keyAndValue { k , ov } ) } } } c . mu . Unlock ( ) for _ , v := range evictedItems { c . onEvicted ( v . key , v . value ) } }
3954	func ( z * Reader ) Reset ( r io . Reader ) { z . Header = Header { } z . pos = 0 z . src = r z . zdata = z . zdata [ : 0 ] z . data = z . data [ : 0 ] z . idx = 0 z . checksum . Reset ( ) }
4227	func New ( cs [ ] string , d time . Duration , options ... Option ) * Spinner { s := & Spinner { Delay : d , chars : cs , color : color . New ( color . FgWhite ) . SprintFunc ( ) , lock : & sync . RWMutex { } , Writer : color . Output , active : false , stopChan : make ( chan struct { } , 1 ) , } for _ , option := range options { option ( s ) } return s }
1772	func ( attachENIHandler * attachENIHandler ) handlerFunc ( ) func ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) { return func ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) { attachENIHandler . messageBuffer <- message } }
4634	func ( points * PointsIndex ) Get ( id string ) Point { if point , ok := points . currentPosition [ id ] ; ok { if result , resultOk := points . index . GetEntryAt ( point ) . ( set ) . Get ( id ) ; resultOk { return result . ( Point ) } } return nil }
3993	func delegatedGTLDs ( entries [ ] util . GTLDPeriod ) [ ] util . GTLDPeriod { var results [ ] util . GTLDPeriod for _ , gTLD := range entries { if gTLD . DelegationDate == "" { continue } results = append ( results , gTLD ) } return results }
185	func ( r * AlertingRule ) SetEvaluationDuration ( dur time . Duration ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . evaluationDuration = dur }
5001	func ( d * Dataset ) Snapshot ( name string , recursive bool ) ( * Dataset , error ) { args := make ( [ ] string , 1 , 4 ) args [ 0 ] = "snapshot" if recursive { args = append ( args , "-r" ) } snapName := fmt . Sprintf ( "%s@%s" , d . Name , name ) args = append ( args , snapName ) _ , err := zfs ( args ... ) if err != nil { return nil , err } return GetDataset ( snapName ) }
3846	func ( l * List ) Prev ( ) { if l . cursor > 0 { l . cursor -- } if l . start > l . cursor { l . start = l . cursor } }
3359	func ( i * IntegrationGCPCreateRequest ) HasAuthProviderX509CertURL ( ) bool { if i != nil && i . AuthProviderX509CertURL != nil { return true } return false }
6375	func AsEnumerable ( entries ... interface { } ) Enumerable { if len ( entries ) != 1 { return enumerableSlice ( entries ) } val := reflect . ValueOf ( entries [ 0 ] ) if kind := val . Kind ( ) ; kind == reflect . Slice || kind == reflect . Array { return enumerableValue { Value : val , } } return enumerableSlice ( entries ) }
3544	func ( s * SyntheticsRequest ) GetTimeout ( ) int { if s == nil || s . Timeout == nil { return 0 } return * s . Timeout }
900	func ( d * Driver ) PreCreateCheck ( ) ( err error ) { if d . CustomDataFile != "" { if _ , err := os . Stat ( d . CustomDataFile ) ; os . IsNotExist ( err ) { return fmt . Errorf ( "custom-data file %s could not be found" , d . CustomDataFile ) } } c , err := d . newAzureClient ( ) if err != nil { return err } if err := c . RegisterResourceProviders ( "Microsoft.Compute" , "Microsoft.Network" , "Microsoft.Storage" ) ; err != nil { return err } d . ctx . FirewallRules , err = d . getSecurityRules ( d . OpenPorts ) if err != nil { return err } log . Debug ( "Checking if Virtual Machine already exists." ) if exists , err := c . VirtualMachineExists ( d . ResourceGroup , d . naming ( ) . VM ( ) ) ; err != nil { return err } else if exists { return fmt . Errorf ( "Virtual Machine with name %s already exists in resource group %q" , d . naming ( ) . VM ( ) , d . ResourceGroup ) } log . Info ( "Completed machine pre-create checks." ) return nil }
942	func parseSecurityRuleProtocol ( proto string ) ( network . SecurityRuleProtocol , error ) { switch strings . ToLower ( proto ) { case "tcp" : return network . TCP , nil case "udp" : return network . UDP , nil case "*" : return network . Asterisk , nil default : return "" , fmt . Errorf ( "invalid protocol %s" , proto ) } }
470	func ( resp * Response ) AppendBodyString ( s string ) { resp . closeBodyStream ( ) resp . bodyBuffer ( ) . WriteString ( s ) }
3050	func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { if args [ "provider" ] != "vsphere" { return nil , discoverErr ( "invalid provider %s" , args [ "provider" ] ) } setLog ( l ) tagName := args [ "tag_name" ] categoryName := args [ "category_name" ] host := valueOrEnv ( args , "host" , "VSPHERE_SERVER" ) user := valueOrEnv ( args , "user" , "VSPHERE_USER" ) password := valueOrEnv ( args , "password" , "VSPHERE_PASSWORD" ) insecure , err := strconv . ParseBool ( valueOrEnv ( args , "insecure_ssl" , "VSPHERE_ALLOW_UNVERIFIED_SSL" ) ) if err != nil { logger . Println ( "[DEBUG] Non-truthy/falsey value for insecure_ssl, assuming false" ) } timeout , err := time . ParseDuration ( args [ "timeout" ] ) if err != nil { logger . Println ( "[DEBUG] Non-time value given for timeout, assuming 10m" ) timeout = time . Minute * 10 } ctx , cancel := context . WithTimeout ( context . Background ( ) , timeout ) defer cancel ( ) client , err := newVSphereClient ( ctx , host , user , password , insecure ) if err != nil { return nil , discoverErr ( err . Error ( ) ) } if tagName == "" || categoryName == "" { return nil , discoverErr ( "both tag_name and category_name must be specified" ) } logger . Printf ( "[INFO] Locating all virtual machine IP addresses with tag %q in category %q" , tagName , categoryName ) tagID , err := tagIDFromName ( ctx , client . TagsClient , tagName , categoryName ) if err != nil { return nil , discoverErr ( err . Error ( ) ) } addrs , err := virtualMachineIPsForTag ( ctx , client , tagID ) if err != nil { return nil , discoverErr ( err . Error ( ) ) } logger . Printf ( "[INFO] Final IP address list: %s" , strings . Join ( addrs , "," ) ) return addrs , nil }
4673	func newPlainTextInner ( ln * line , rslt * result , src * source , parent element , insertBr bool , opts * Options ) * plainTextInner { return & plainTextInner { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , insertBr : insertBr , } }
4316	func ( c * Client ) AddSSHUser ( account , repo string , buildNum int ) ( * Build , error ) { build := & Build { } err := c . request ( "POST" , fmt . Sprintf ( "project/%s/%s/%d/ssh-users" , account , repo , buildNum ) , build , nil , nil ) if err != nil { return nil , err } return build , nil }
2044	func ( m * MockEngine ) GetTaskHealthMetrics ( ) ( * ecstcs . HealthMetadata , [ ] * ecstcs . TaskHealth , error ) { ret := m . ctrl . Call ( m , "GetTaskHealthMetrics" ) ret0 , _ := ret [ 0 ] . ( * ecstcs . HealthMetadata ) ret1 , _ := ret [ 1 ] . ( [ ] * ecstcs . TaskHealth ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 }
6460	func ( l * Log ) getBuffer ( ) * buffer { l . freeListMu . Lock ( ) b := l . freeList if b != nil { l . freeList = b . next } l . freeListMu . Unlock ( ) if b == nil { b = new ( buffer ) } else { b . next = nil b . Reset ( ) } return b }
1534	func anyMessageHandler ( timer ttime . Timer , client wsclient . ClientServer ) func ( interface { } ) { return func ( interface { } ) { seelog . Debug ( "ACS activity occurred" ) if err := client . SetReadDeadline ( time . Now ( ) . Add ( wsRWTimeout ) ) ; err != nil { seelog . Warnf ( "Unable to extend read deadline for ACS connection: %v" , err ) } timer . Reset ( retry . AddJitter ( heartbeatTimeout , heartbeatJitter ) ) } }
5998	func ( ds * DNSServer ) DeleteSRV ( service , protocol string ) { ds . srvMutex . Lock ( ) delete ( ds . srvRecords , ds . qualifySrv ( service , protocol ) ) ds . srvMutex . Unlock ( ) }
5480	func capitalize ( s string ) string { r , l := utf8 . DecodeRuneInString ( s ) b := make ( [ ] byte , l ) utf8 . EncodeRune ( b , unicode . ToTitle ( r ) ) return strings . Join ( [ ] string { string ( b ) , s [ l : ] } , "" ) }
5888	func PeekAlgorithm ( buf [ ] byte ) ( Algorithm , error ) { alg := NONE algVal , err := PeekHeaderField ( buf , "alg" ) if err != nil { return NONE , err } err = ( & alg ) . UnmarshalText ( [ ] byte ( algVal ) ) if err != nil { return NONE , err } return alg , nil }
2	func contextDone ( ctx context . Context , env string ) error { if err := ctx . Err ( ) ; err != nil { return contextErr ( err , env ) } return nil }
643	func ( p * SingletonClientGenerator ) KubeClient ( ) ( kubernetes . Interface , error ) { var err error p . kubeOnce . Do ( func ( ) { p . kubeClient , err = NewKubeClient ( p . KubeConfig , p . KubeMaster , p . RequestTimeout ) } ) return p . kubeClient , err }
6223	func ( w * Worker ) ClientPreUncooperativeCloseRequest ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientPreUncooperativeCloseRequest" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientPreUncooperativeCloseRequest ) if err != nil { return err } jdata , err := w . publishData ( logger , job ) if err != nil { return err } offer , err := w . offering ( logger , ch . Offering ) if err != nil { return err } acc , err := w . account ( logger , ch . Client ) if err != nil { return err } if err := w . clientValidateChannelForClose ( ch ) ; err != nil { return err } return w . doClientPreUncooperativeCloseRequestAndSaveTx ( logger , job , ch , acc , offer , jdata . GasPrice ) }
5576	func New ( transport runtime . ClientTransport , formats strfmt . Registry ) * SoftLayerVMPool { cli := new ( SoftLayerVMPool ) cli . Transport = transport cli . VM = vm . New ( transport , formats ) return cli }
7075	func FromYAML ( db * sql . DB , yamlIn [ ] byte ) ( Fixture , error ) { var tables Tables err := yaml . Unmarshal ( yamlIn , & tables ) return New ( db , tables ) , err }
4491	func ( d * Date ) DeepCopy ( ) * Date { if d == nil { return nil } out := new ( Date ) d . DeepCopyInto ( out ) return out }
1465	func ( c * Container ) SetRegistryAuthCredentials ( credential credentials . IAMRoleCredentials ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . RegistryAuthentication . ECRAuthData . SetPullCredentials ( credential ) }
1073	func ( r * Runner ) storePid ( ) error { path := config . StringVal ( r . config . PidFile ) if path == "" { return nil } log . Printf ( "[INFO] creating pid file at %q" , path ) f , err := os . OpenFile ( path , os . O_CREATE | os . O_WRONLY | os . O_TRUNC , 0666 ) if err != nil { return fmt . Errorf ( "runner: could not open pid file: %s" , err ) } defer f . Close ( ) pid := os . Getpid ( ) _ , err = f . WriteString ( fmt . Sprintf ( "%d" , pid ) ) if err != nil { return fmt . Errorf ( "runner: could not write to pid file: %s" , err ) } return nil }
6130	func ( b * backendInstance ) GetTransactionByHash ( ctx context . Context , hash common . Hash ) ( * types . Transaction , bool , error ) { ctx2 , cancel := b . addTimeout ( ctx ) defer cancel ( ) tx , pending , err := b . conn . ethClient ( ) . TransactionByHash ( ctx2 , hash ) if err != nil { err = fmt . Errorf ( "failed to get transaction by hash: %s" , err ) } return tx , pending , err }
1252	func ( cs * clientServer ) publishHealthMetricsOnce ( ) error { requests , err := cs . createPublishHealthRequests ( ) if err != nil { return err } for _ , request := range requests { err = cs . MakeRequest ( request ) if err != nil { return err } } return nil }
2429	func TranslateGeo ( tx , ty float64 ) GeoM { g := GeoM { } g . Translate ( tx , ty ) return g }
786	func ( im * NoopRegistry ) ApplyChanges ( changes * plan . Changes ) error { return im . provider . ApplyChanges ( changes ) }
6379	func ( iter Enumerator ) ParallelSelect ( operation Transform ) Enumerator { if cpus := runtime . NumCPU ( ) ; cpus != 1 { intermediate := iter . splitN ( operation , uint ( cpus ) ) return intermediate [ 0 ] . Merge ( intermediate [ 1 : ] ... ) } return iter }
1570	func ( m * MockSecretsManagerAPI ) CancelRotateSecret ( arg0 * secretsmanager . CancelRotateSecretInput ) ( * secretsmanager . CancelRotateSecretOutput , error ) { ret := m . ctrl . Call ( m , "CancelRotateSecret" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CancelRotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3336	func ( g * GroupData ) HasLastResolvedTs ( ) bool { if g != nil && g . LastResolvedTs != nil { return true } return false }
7157	func ( s * Container ) WaitStartup ( timeout time . Duration ) error { nodes , err := s . NetworkNodes ( ) if err != nil { return fmt . Errorf ( "Error getting network nodes: %v" , err ) } if ! s . HasExposedPorts ( ) { return fmt . Errorf ( "Current container has no exposed ports" ) } ok := raiqub . WaitPeerListening ( nodes [ 0 ] . Protocol , nodes [ 0 ] . FormatDialAddress ( ) , timeout ) if ! ok { err = fmt . Errorf ( "%s unreachable for %v" , nodes [ 0 ] . FormatDialAddress ( ) , timeout ) } return err }
105	func Time ( ts int64 ) time . Time { return time . Unix ( ts / 1000 , ( ts % 1000 ) * int64 ( time . Millisecond ) ) }
2834	func schemaDatastoreSummary ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { "accessible" : { Type : schema . TypeBool , Description : "The connectivity status of the datastore. If this is false, some other computed attributes may be out of date." , Computed : true , } , "capacity" : { Type : schema . TypeInt , Description : "Maximum capacity of the datastore, in MB." , Computed : true , } , "free_space" : { Type : schema . TypeInt , Description : "Available space of this datastore, in MB." , Computed : true , } , "maintenance_mode" : { Type : schema . TypeString , Description : "The current maintenance mode state of the datastore." , Computed : true , } , "multiple_host_access" : { Type : schema . TypeBool , Description : "If true, more than one host in the datacenter has been configured with access to the datastore." , Computed : true , } , "uncommitted_space" : { Type : schema . TypeInt , Description : "Total additional storage space, in MB, potentially used by all virtual machines on this datastore." , Computed : true , } , "url" : { Type : schema . TypeString , Description : "The unique locator for the datastore." , Computed : true , } , } }
1726	func ( task * Task ) ApplyExecutionRoleLogsAuth ( hostConfig * dockercontainer . HostConfig , credentialsManager credentials . Manager ) * apierrors . HostConfigError { id := task . GetExecutionCredentialsID ( ) if id == "" { return & apierrors . HostConfigError { Msg : "No execution credentials set for the task" } } executionRoleCredentials , ok := credentialsManager . GetTaskCredentials ( id ) if ! ok { return & apierrors . HostConfigError { Msg : "Unable to get execution role credentials for task" } } credentialsEndpointRelativeURI := executionRoleCredentials . IAMRoleCredentials . GenerateCredentialsEndpointRelativeURI ( ) hostConfig . LogConfig . Config [ awslogsCredsEndpointOpt ] = credentialsEndpointRelativeURI return nil }
373	func ( a * Args ) AddNoValue ( key string ) { a . args = appendArg ( a . args , key , "" , argsNoValue ) }
5315	func StartLogger ( ) { var err error if BOOT { if logFile , err = os . OpenFile ( _LOG_FILE , os . O_WRONLY | os . O_TRUNC , 0 ) ; err != nil { log . Print ( err ) } else { Log = log . New ( logFile , "" , log . Lshortfile ) } } else { if Log , err = syslog . NewLogger ( syslog . LOG_NOTICE , log . Lshortfile ) ; err != nil { log . Fatal ( err ) } } }
5616	func loadBank ( bank string ) ( [ ] string , error ) { filename := "keys/words/wordlist/" + bank + ".txt" words , err := wordlist . Asset ( filename ) if err != nil { return nil , err } wordsAll := strings . Split ( strings . TrimSpace ( string ( words ) ) , "\n" ) \n }
7009	func ( s * PgDump ) Import ( lfile io . Reader ) ( err error ) { lo . G . Debug ( "pgdump Import being called" ) if err = s . RemoteOps . UploadFile ( lfile ) ; err == nil { err = s . restore ( ) } return }
5743	func ( c * CustomerIO ) DeleteDevice ( customerID string , deviceID string ) error { status , responseBody , err := c . request ( "DELETE" , c . deleteDeviceURL ( customerID , deviceID ) , [ ] byte { } ) if err != nil { return err } else if status != 200 { return & CustomerIOError { status , c . deleteDeviceURL ( customerID , deviceID ) , responseBody } } return nil }
4309	func ( c * Client ) ListProjects ( ) ( [ ] * Project , error ) { projects := [ ] * Project { } err := c . request ( "GET" , "projects" , & projects , nil , nil ) if err != nil { return nil , err } for _ , project := range projects { if err := cleanupProject ( project ) ; err != nil { return nil , err } } return projects , nil }
3127	func ( app * App ) ReloadConfig ( ) error { app . Lock ( ) defer app . Unlock ( ) var err error if err = app . configure ( ) ; err != nil { return err } runtime . GOMAXPROCS ( app . Config . Common . MaxCPU ) app . Cache . SetMaxSize ( app . Config . Cache . MaxSize ) app . Cache . SetWriteStrategy ( app . Config . Cache . WriteStrategy ) app . Cache . SetTagsEnabled ( app . Config . Tags . Enabled ) if app . Persister != nil { app . Persister . Stop ( ) app . Persister = nil } if app . Tags != nil { app . Tags . Stop ( ) app . Tags = nil } app . startPersister ( ) if app . Collector != nil { app . Collector . Stop ( ) app . Collector = nil } app . Collector = NewCollector ( app ) return nil }
5	func ( ng * Engine ) NewRangeQuery ( q storage . Queryable , qs string , start , end time . Time , interval time . Duration ) ( Query , error ) { expr , err := ParseExpr ( qs ) if err != nil { return nil , err } if expr . Type ( ) != ValueTypeVector && expr . Type ( ) != ValueTypeScalar { return nil , errors . Errorf ( "invalid expression type %q for range query, must be Scalar or instant Vector" , documentedType ( expr . Type ( ) ) ) } qry := ng . newQuery ( q , expr , start , end , interval ) qry . q = qs return qry , nil }
1411	func ( m * MockECSClient ) GetResourceTags ( arg0 string ) ( [ ] * ecs . Tag , error ) { ret := m . ctrl . Call ( m , "GetResourceTags" , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] * ecs . Tag ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5321	func NewFromHash ( hashedKey string ) Crypter { var f func ( ) Crypter if strings . HasPrefix ( hashedKey , cryptPrefixes [ SHA512 ] ) { f = crypts [ SHA512 ] } else if strings . HasPrefix ( hashedKey , cryptPrefixes [ SHA256 ] ) { f = crypts [ SHA256 ] } else if strings . HasPrefix ( hashedKey , cryptPrefixes [ MD5 ] ) { f = crypts [ MD5 ] } else if strings . HasPrefix ( hashedKey , cryptPrefixes [ APR1 ] ) { f = crypts [ APR1 ] } else { toks := strings . SplitN ( hashedKey , "$" , 3 ) prefix := "$" + toks [ 1 ] + "$" panic ( "crypt: unknown cryp function from prefix: " + prefix ) } if f != nil { return f ( ) } panic ( "crypt: requested cryp function is unavailable" ) }
3878	func align ( x , a int64 ) int64 { y := x + a - 1 return y - y % a }
6496	func ( o OAuth ) NewTokens ( code string ) ( * oauthTokens , error ) { return o . GetTokens ( code , "authorization_code" ) }
862	func ( a AzureClient ) GetPrivateIPAddress ( resourceGroup , name string ) ( string , error ) { f := logutil . Fields { "name" : name } log . Debug ( "Querying network interface." , f ) nic , err := a . networkInterfacesClient ( ) . Get ( resourceGroup , name , "" ) if err != nil { return "" , err } if nic . Properties == nil || nic . Properties . IPConfigurations == nil || len ( * nic . Properties . IPConfigurations ) == 0 { log . Debug ( "No IPConfigurations found on NIC" , f ) return "" , nil } return to . String ( ( * nic . Properties . IPConfigurations ) [ 0 ] . Properties . PrivateIPAddress ) , nil }
1848	func ( eventStream * EventStream ) Subscribe ( name string , handler eventHandler ) error { eventStream . handlersLock . Lock ( ) defer eventStream . handlersLock . Unlock ( ) if _ , ok := eventStream . handlers [ name ] ; ok { return fmt . Errorf ( "handler %s already exists" , name ) } eventStream . handlers [ name ] = handler return nil }
5226	func ( f * Field ) NotNull ( ) * PQLRowQuery { text := fmt . Sprintf ( "Range(%s != null)" , f . name ) q := NewPQLRowQuery ( text , f . index , nil ) q . hasKeys = f . options . keys || f . index . options . keys return q }
5841	func ( m * CirconusMetrics ) RemoveTextFunc ( metric string ) { m . tfm . Lock ( ) defer m . tfm . Unlock ( ) delete ( m . textFuncs , metric ) }
7136	func NewJsonXmlContentNegotiator ( defaultEncoder Encoder , responseWriter http . ResponseWriter , prettyPrint bool ) * ContentNegotiator { result := NewContentNegotiator ( defaultEncoder , responseWriter ) result . AddEncoder ( MimeJSON , JsonEncoder { prettyPrint } ) result . AddEncoder ( MimeXML , XmlEncoder { prettyPrint } ) return result }
5852	func ( m * CirconusMetrics ) RemoveCounter ( metric string ) { m . cm . Lock ( ) defer m . cm . Unlock ( ) delete ( m . counters , metric ) }
4288	func NetworkGetRoutes ( ) ( [ ] Route , error ) { s , err := getNetlinkSocket ( ) if err != nil { return nil , err } defer s . Close ( ) wb := newNetlinkRequest ( syscall . RTM_GETROUTE , syscall . NLM_F_DUMP ) msg := newIfInfomsg ( syscall . AF_UNSPEC ) wb . AddData ( msg ) if err := s . Send ( wb ) ; err != nil { return nil , err } pid , err := s . GetPid ( ) if err != nil { return nil , err } res := make ( [ ] Route , 0 ) outer : for { msgs , err := s . Receive ( ) if err != nil { return nil , err } for _ , m := range msgs { if err := s . CheckMessage ( m , wb . Seq , pid ) ; err != nil { if err == io . EOF { break outer } return nil , err } if m . Header . Type != syscall . RTM_NEWROUTE { continue } var r Route msg := ( * RtMsg ) ( unsafe . Pointer ( & m . Data [ 0 : syscall . SizeofRtMsg ] [ 0 ] ) ) if msg . Flags & syscall . RTM_F_CLONED != 0 { continue } if msg . Table != syscall . RT_TABLE_MAIN { continue } if msg . Family != syscall . AF_INET { continue } if msg . Dst_len == 0 { r . Default = true } attrs , err := syscall . ParseNetlinkRouteAttr ( & m ) if err != nil { return nil , err } for _ , attr := range attrs { switch attr . Attr . Type { case syscall . RTA_DST : ip := attr . Value r . IPNet = & net . IPNet { IP : ip , Mask : net . CIDRMask ( int ( msg . Dst_len ) , 8 * len ( ip ) ) , } case syscall . RTA_OIF : index := int ( native . Uint32 ( attr . Value [ 0 : 4 ] ) ) r . Iface , _ = net . InterfaceByIndex ( index ) } } if r . Default || r . IPNet != nil { res = append ( res , r ) } } } return res , nil }
5344	func ReplaceN ( filename string , r [ ] Replacer , n int ) error { e , err := NewEdit ( filename ) if err != nil { return err } err = e . genReplace ( r , n ) err2 := e . Close ( ) if err != nil { return err } return err2 }
3582	func ( t * ThresholdCount ) HasUnknown ( ) bool { if t != nil && t . Unknown != nil { return true } return false }
2650	func resourceVSphereComputeClusterSaveDatacenter ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { log . Printf ( "[DEBUG] %s: Saving datacenter" , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return err } p , err := folder . RootPathParticleHost . SplitDatacenter ( cluster . InventoryPath ) if err != nil { return fmt . Errorf ( "error parsing datacenter path from cluster: %s" , err ) } dc , err := getDatacenter ( client , p ) if err != nil { return fmt . Errorf ( "error fetching datacenter for cluster: %s" , err ) } return d . Set ( "datacenter_id" , dc . Reference ( ) . Value ) }
6110	func ( h * Handler ) UpdateAccount ( tkn , account , name string , isDefault , inUse bool ) error { logger := h . logger . Add ( "method" , "UpdateAccount" , "account" , account ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } acc := data . Account { } err := h . findByPrimaryKey ( logger , ErrAccountNotFound , & acc , account ) if err != nil { return err } if name != "" { acc . Name = name } acc . IsDefault = isDefault acc . InUse = inUse return update ( logger , h . db . Querier , & acc ) }
7025	func StoreParam ( ctx context . Context , name string , value string ) context . Context { n := paramName ( name ) return context . WithValue ( ctx , n , Param ( value ) ) }
379	func ( a * Args ) SetBytesKNoValue ( key [ ] byte ) { a . args = setArg ( a . args , b2s ( key ) , "" , argsNoValue ) }
6630	func ( n * routeNode ) findChild ( nn * routeNode ) * routeNode { for _ , c := range n . children { if c . path == nn . path { return c } } return nil }
2551	func ValidateCustomizationSpec ( d * schema . ResourceDiff , family string ) error { linuxExists := len ( d . Get ( cKeyPrefix + "." + "linux_options" ) . ( [ ] interface { } ) ) > 0 windowsExists := len ( d . Get ( cKeyPrefix + "." + "windows_options" ) . ( [ ] interface { } ) ) > 0 sysprepExists := d . Get ( cKeyPrefix + "." + "windows_sysprep_text" ) . ( string ) != "" switch { case family == string ( types . VirtualMachineGuestOsFamilyLinuxGuest ) && ! linuxExists : return errors . New ( "linux_options must exist in VM customization options for Linux operating systems" ) case family == string ( types . VirtualMachineGuestOsFamilyWindowsGuest ) && ! windowsExists && ! sysprepExists : return errors . New ( "one of windows_options or windows_sysprep_text must exist in VM customization options for Windows operating systems" ) } return nil }
4645	func ( geoIndex * geoIndex ) GetEntryAt ( point Point ) interface { } { square := cellOf ( point , geoIndex . resolution ) entries , ok := geoIndex . index [ square ] if ! ok { return geoIndex . newEntry ( ) } return entries }
3735	func ( w * WidgetApmOrLogQuery ) HasCompute ( ) bool { if w != nil && w . Compute != nil { return true } return false }
135	func ( t * timestampTracker ) Add ( _ labels . Labels , ts int64 , v float64 ) ( uint64 , error ) { t . samples ++ if ts > t . highestTimestamp { t . highestTimestamp = ts } return 0 , nil }
2857	func isNotFoundError ( err error ) bool { if f , ok := vimSoapFault ( err ) ; ok { if _ , ok := f . ( types . NotFound ) ; ok { return true } } return false }
5360	func parseGShadow ( row string ) ( * GShadow , error ) { fields := strings . Split ( row , ":" ) if len ( fields ) != 4 { return nil , rowError { _GSHADOW_FILE , row } } return & GShadow { fields [ 0 ] , fields [ 1 ] , strings . Split ( fields [ 2 ] , "," ) , strings . Split ( fields [ 3 ] , "," ) , } , nil }
397	func AppendQuotedArg ( dst , src [ ] byte ) [ ] byte { for _ , c := range src { if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '*' || c == '-' || c == '.' || c == '_' { dst = append ( dst , c ) } else { dst = append ( dst , '%' , hexCharUpper ( c >> 4 ) , hexCharUpper ( c & 15 ) ) } } return dst }
4946	func ( f * FieldValues ) Row ( idx int , dest [ ] driver . Value ) { copy ( dest , f . values [ idx * f . cols : ( idx + 1 ) * f . cols ] ) }
3191	func ( client * Client ) GetMonitors ( ) ( [ ] Monitor , error ) { var out reqMonitors if err := client . doJsonRequest ( "GET" , "/v1/monitor" , nil , & out . Monitors ) ; err != nil { return nil , err } return out . Monitors , nil }
3105	func ( r * Router ) Handle ( method string , pattern string , handlers [ ] Handler ) * Route { if len ( r . groups ) > 0 { groupPattern := "" h := make ( [ ] Handler , 0 ) for _ , g := range r . groups { groupPattern += g . pattern h = append ( h , g . handlers ... ) } pattern = groupPattern + pattern h = append ( h , handlers ... ) handlers = h } handlers = validateAndWrapHandlers ( handlers , r . handlerWrapper ) return r . handle ( method , pattern , func ( resp http . ResponseWriter , req * http . Request , params Params ) { c := r . m . createContext ( resp , req ) c . params = params c . handlers = make ( [ ] Handler , 0 , len ( r . m . handlers ) + len ( handlers ) ) c . handlers = append ( c . handlers , r . m . handlers ... ) c . handlers = append ( c . handlers , handlers ... ) c . run ( ) } ) }
5116	func ( file * GridFile ) Size ( ) ( bytes int64 ) { file . m . Lock ( ) bytes = file . doc . Length file . m . Unlock ( ) return }
1538	func GetMuxValueFromRequest ( r * http . Request , gorillaMuxName string ) ( string , bool ) { vars := mux . Vars ( r ) val , ok := vars [ gorillaMuxName ] return val , ok }
4992	func zfs ( arg ... string ) ( [ ] [ ] string , error ) { c := command { Command : "zfs" } return c . Run ( arg ... ) }
6	func ( ng * Engine ) exec ( ctx context . Context , q * query ) ( Value , storage . Warnings , error ) { ng . metrics . currentQueries . Inc ( ) defer ng . metrics . currentQueries . Dec ( ) ctx , cancel := context . WithTimeout ( ctx , ng . timeout ) q . cancel = cancel execSpanTimer , ctx := q . stats . GetSpanTimer ( ctx , stats . ExecTotalTime ) defer execSpanTimer . Finish ( ) queueSpanTimer , _ := q . stats . GetSpanTimer ( ctx , stats . ExecQueueTime , ng . metrics . queryQueueTime ) if err := ng . gate . Start ( ctx ) ; err != nil { return nil , nil , contextErr ( err , "query queue" ) } defer ng . gate . Done ( ) queueSpanTimer . Finish ( ) defer q . cancel ( ) const env = "query execution" evalSpanTimer , ctx := q . stats . GetSpanTimer ( ctx , stats . EvalTotalTime ) defer evalSpanTimer . Finish ( ) if err := contextDone ( ctx , env ) ; err != nil { return nil , nil , err } switch s := q . Statement ( ) . ( type ) { case * EvalStmt : return ng . execEvalStmt ( ctx , q , s ) case testStmt : return nil , nil , s ( ctx ) } panic ( errors . Errorf ( "promql.Engine.exec: unhandled statement of type %T" , q . Statement ( ) ) ) }
2762	func expandToolsConfigInfo ( d * schema . ResourceData ) * types . ToolsConfigInfo { obj := & types . ToolsConfigInfo { SyncTimeWithHost : structure . GetBool ( d , "sync_time_with_host" ) , AfterPowerOn : getBoolWithRestart ( d , "run_tools_scripts_after_power_on" ) , AfterResume : getBoolWithRestart ( d , "run_tools_scripts_after_resume" ) , BeforeGuestStandby : getBoolWithRestart ( d , "run_tools_scripts_before_guest_standby" ) , BeforeGuestShutdown : getBoolWithRestart ( d , "run_tools_scripts_before_guest_shutdown" ) , BeforeGuestReboot : getBoolWithRestart ( d , "run_tools_scripts_before_guest_reboot" ) , } return obj }
1655	func ( m * MockTaskResource ) NextKnownState ( ) status0 . ResourceStatus { ret := m . ctrl . Call ( m , "NextKnownState" ) ret0 , _ := ret [ 0 ] . ( status0 . ResourceStatus ) return ret0 }
2327	func ( v * ColorChooser ) native ( ) * C . GtkColorChooser { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkColorChooser ( p ) }
4716	func ( opts * Options ) AddNoCloseTagName ( name string ) { opts . NoCloseTagNames = append ( opts . NoCloseTagNames , name ) }
2157	func ( v * MainContext ) native ( ) * C . GMainContext { if v == nil { return nil } return ( * C . GMainContext ) ( v ) }
478	func ( req * Request ) Body ( ) [ ] byte { if req . bodyStream != nil { bodyBuf := req . bodyBuffer ( ) bodyBuf . Reset ( ) _ , err := copyZeroAlloc ( bodyBuf , req . bodyStream ) req . closeBodyStream ( ) if err != nil { bodyBuf . SetString ( err . Error ( ) ) } } else if req . onlyMultipartForm ( ) { body , err := marshalMultipartForm ( req . multipartForm , req . multipartFormBoundary ) if err != nil { return [ ] byte ( err . Error ( ) ) } return body } return req . bodyBytes ( ) }
1082	func StringToSignalFunc ( ) mapstructure . DecodeHookFunc { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) != reflect . String { return data , nil } if t . String ( ) != "os.Signal" { return data , nil } if data == nil || data . ( string ) == "" { return SIGNIL , nil } return Parse ( data . ( string ) ) } }
2781	func expandClusterDasVMConfigInfo ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , ) ( * types . ClusterDasVmConfigInfo , error ) { client , err := resourceVSphereHAVMOverrideClient ( meta ) if err != nil { return nil , err } version := viapi . ParseVersionFromClient ( client ) obj := & types . ClusterDasVmConfigInfo { DasSettings : expandClusterDasVMSettings ( d , version ) , Key : vm . Reference ( ) , } obj . DasSettings . VmToolsMonitoringSettings . ClusterSettings = structure . GetBool ( d , "ha_vm_monitoring_use_cluster_defaults" ) return obj , nil }
3449	func ( p * Period ) GetSeconds ( ) json . Number { if p == nil || p . Seconds == nil { return "" } return * p . Seconds }
4922	func ( w * Writer ) WriteZeroes ( cnt int ) { if w . err != nil { return } l := cnt if l > len ( w . b ) { l = len ( w . b ) } for i := 0 ; i < l ; i ++ { w . b [ i ] = 0 } for i := 0 ; i < cnt ; { j := cnt - i if j > len ( w . b ) { j = len ( w . b ) } n , _ := w . wr . Write ( w . b [ : j ] ) if n != j { return } i += n } }
1969	func ( mr * MockResultMockRecorder ) Print ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Print" , reflect . TypeOf ( ( * MockResult ) ( nil ) . Print ) ) }
2634	func ( s MoRefSorter ) Swap ( i , j int ) { s [ i ] , s [ j ] = s [ j ] , s [ i ] }
1081	func DefaultConsulConfig ( ) * ConsulConfig { return & ConsulConfig { Auth : DefaultAuthConfig ( ) , Retry : DefaultRetryConfig ( ) , SSL : DefaultSSLConfig ( ) , Transport : DefaultTransportConfig ( ) , } }
1158	func ( c * ec2MetadataClientImpl ) SubnetID ( mac string ) ( string , error ) { return c . client . GetMetadata ( fmt . Sprintf ( SubnetIDResourceFormat , mac ) ) }
5368	func ( * User ) lookUp ( line string , f field , value interface { } ) interface { } { _field := f . ( userField ) allField := strings . Split ( line , ":" ) intField := make ( map [ int ] int ) var err error if intField [ 2 ] , err = strconv . Atoi ( allField [ 2 ] ) ; err != nil { panic ( atoiError { _USER_FILE , line , "UID" } ) } if intField [ 3 ] , err = strconv . Atoi ( allField [ 3 ] ) ; err != nil { panic ( atoiError { _USER_FILE , line , "GID" } ) } var isField bool if U_NAME & _field != 0 && allField [ 0 ] == value . ( string ) { isField = true } else if U_PASSWD & _field != 0 && allField [ 1 ] == value . ( string ) { isField = true } else if U_UID & _field != 0 && intField [ 2 ] == value . ( int ) { isField = true } else if U_GID & _field != 0 && intField [ 3 ] == value . ( int ) { isField = true } else if U_GECOS & _field != 0 && allField [ 4 ] == value . ( string ) { isField = true } else if U_DIR & _field != 0 && allField [ 5 ] == value . ( string ) { isField = true } else if U_SHELL & _field != 0 && allField [ 6 ] == value . ( string ) { isField = true } else if U_ALL & _field != 0 { isField = true } if isField { return & User { Name : allField [ 0 ] , password : allField [ 1 ] , UID : intField [ 2 ] , GID : intField [ 3 ] , Gecos : allField [ 4 ] , Dir : allField [ 5 ] , Shell : allField [ 6 ] , } } return nil }
4115	func ( b * BarChart ) SetLegendWidth ( width int32 ) { atomic . StoreInt32 ( & b . legendWidth , width ) }
1030	func NewCLI ( out , err io . Writer ) * CLI { return & CLI { outStream : out , errStream : err , signalCh : make ( chan os . Signal , 1 ) , stopCh : make ( chan struct { } ) , } }
6508	func ( c Client ) SendMoney ( params * TransactionParams ) ( * transactionConfirmation , error ) { return c . transactionRequest ( "POST" , "send_money" , params ) }
6543	func get ( values map [ string ] interface { } , key string ) interface { } { if len ( key ) == 0 || values == nil { return nil } key = strings . ToLower ( key ) val , ok := values [ key ] if ok { switch val . ( type ) { case [ ] interface { } : return nil default : return val } } return nil }
1791	func ( cs * ContainerStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == "null" { * cs = ContainerStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * cs = ContainerStatusNone return errors . New ( "container status unmarshal: status must be a string or null; Got " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) if strStatus == "UNKNOWN" { * cs = ContainerStatusNone return nil } if strStatus == "DEAD" { * cs = ContainerStopped return nil } stat , ok := containerStatusMap [ strStatus ] if ! ok { * cs = ContainerStatusNone return errors . New ( "container status unmarshal: unrecognized status" ) } * cs = stat return nil }
6894	func initKeyHandler ( ) { for { switch ev := termbox . PollEvent ( ) ; ev . Type { case termbox . EventKey : e := ev Queue ( func ( ) { var ( widget Widgeter window Windower ) if focus != nil { var used bool used , window , widget = focus . keyHandler ( e ) if used { flush ( ) return } } keyC <- Key { Mod : e . Mod , Key : e . Key , Ch : e . Ch , Window : window , Widget : widget , } } ) case termbox . EventResize : Queue ( func ( ) { resizeAndRender ( focus ) } ) case termbox . EventMouse : case termbox . EventError : return } } }
6080	func ( h * Handler ) SetPassword ( password string ) error { logger := h . logger . Add ( "method" , "SetPassword" ) logger . Debug ( "trying to set password" ) if password == "" { logger . Warn ( "received empty password" ) return ErrEmptyPassword } if err := h . validatePasswordNotSet ( logger ) ; err != nil { return err } salt := util . NewUUID ( ) hashed , err := hashedPassword ( logger , password , salt ) if err != nil { return err } tx , err := beginTX ( logger , h . db ) if err != nil { return err } defer tx . Rollback ( ) if err := insert ( logger , tx . Querier , saltSetting ( salt ) , passwordHashSetting ( hashed ) ) ; err != nil { return err } return commitTX ( logger , tx ) }
96	func ( t * Target ) DiscoveredLabels ( ) labels . Labels { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) lset := make ( labels . Labels , len ( t . discoveredLabels ) ) copy ( lset , t . discoveredLabels ) return lset }
6168	func ( m * Monitor ) getOpenBlockNumber ( el * data . JobEthLog ) ( block uint32 , ok bool , err error ) { var event string switch el . Topics [ 0 ] { case eth . ServiceChannelToppedUp : event = logChannelToppedUp case eth . ServiceChannelCloseRequested : event = logChannelCloseRequested case eth . ServiceCooperativeChannelClose : event = logCooperativeChannelClose case eth . ServiceUnCooperativeChannelClose : event = logUnCooperativeChannelClose default : return } if event != "" { block , err = m . blockNumber ( el . Data , logChannelToppedUp ) ok = true } return }
639	func ( sc * ingressSource ) filterByAnnotations ( ingresses [ ] * v1beta1 . Ingress ) ( [ ] * v1beta1 . Ingress , error ) { labelSelector , err := metav1 . ParseToLabelSelector ( sc . annotationFilter ) if err != nil { return nil , err } selector , err := metav1 . LabelSelectorAsSelector ( labelSelector ) if err != nil { return nil , err } if selector . Empty ( ) { return ingresses , nil } filteredList := [ ] * v1beta1 . Ingress { } for _ , ingress := range ingresses { annotations := labels . Set ( ingress . Annotations ) if selector . Matches ( annotations ) { filteredList = append ( filteredList , ingress ) } } return filteredList , nil }
6592	func ( q * Query ) Columns ( names ... string ) * Query { q . headers = append ( q . headers , "Columns: " + strings . Join ( names , " " ) ) q . columns = names return q }
1722	func ( task * Task ) HostVolumeByName ( name string ) ( taskresourcevolume . Volume , bool ) { for _ , v := range task . Volumes { if v . Name == name { return v . Volume , true } } return nil , false }
3420	func ( o * Options ) GetIncludeTagsOk ( ) ( bool , bool ) { if o == nil || o . IncludeTags == nil { return false , false } return * o . IncludeTags , true }
4639	func ( points * PointsIndex ) KNearest ( point Point , k int , maxDistance Meters , accept func ( p Point ) bool ) [ ] Point { nearbyPoints := make ( [ ] Point , 0 ) pointEntry := points . index . GetEntryAt ( point ) . ( set ) nearbyPoints = append ( nearbyPoints , getPoints ( [ ] interface { } { pointEntry } , accept ) ... ) totalCount := 0 idx := cellOf ( point , points . index . resolution ) coarseMaxDistance := math . Max ( float64 ( maxDistance ) * 2.0 , float64 ( points . index . resolution ) * 2.0 + 0.01 ) for d := 1 ; float64 ( d ) * float64 ( points . index . resolution ) <= coarseMaxDistance ; d ++ { oldCount := len ( nearbyPoints ) nearbyPoints = getPointsAppend ( nearbyPoints , points . index . get ( idx . x - d , idx . x + d , idx . y + d , idx . y + d ) , accept ) nearbyPoints = getPointsAppend ( nearbyPoints , points . index . get ( idx . x - d , idx . x + d , idx . y - d , idx . y - d ) , accept ) nearbyPoints = getPointsAppend ( nearbyPoints , points . index . get ( idx . x - d , idx . x - d , idx . y - d + 1 , idx . y + d - 1 ) , accept ) nearbyPoints = getPointsAppend ( nearbyPoints , points . index . get ( idx . x + d , idx . x + d , idx . y - d + 1 , idx . y + d - 1 ) , accept ) totalCount += len ( nearbyPoints ) - oldCount if totalCount > k { break } } sortedPoints := & sortedPoints { nearbyPoints , point } sort . Sort ( sortedPoints ) k = min ( k , len ( sortedPoints . points ) ) for i , nearbyPoint := range sortedPoints . points { if Distance ( point , nearbyPoint ) > maxDistance || i == k { k = i break } } return sortedPoints . points [ 0 : k ] }
4375	func HostnameValue ( v * strfmt . Hostname ) strfmt . Hostname { if v == nil { return strfmt . Hostname ( "" ) } return * v }
5747	func ( a * API ) FetchChecks ( ) ( * [ ] Check , error ) { result , err := a . Get ( config . CheckPrefix ) if err != nil { return nil , err } var checks [ ] Check if err := json . Unmarshal ( result , & checks ) ; err != nil { return nil , err } return & checks , nil }
2741	func expandDVSContactInfo ( d * schema . ResourceData ) * types . DVSContactInfo { obj := & types . DVSContactInfo { Name : d . Get ( "contact_name" ) . ( string ) , Contact : d . Get ( "contact_detail" ) . ( string ) , } return obj }
4168	func ( c * CleanupOrgUsersCommand ) Execute ( [ ] string ) error { if cfMgmt , err := InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { return cfMgmt . UserManager . CleanupOrgUsers ( ) } return nil }
20	func calcTrendValue ( i int , sf , tf , s0 , s1 , b float64 ) float64 { if i == 0 { return b } x := tf * ( s1 - s0 ) y := ( 1 - tf ) * b return x + y }
5457	func ( nvps * NumberVoicePriceService ) Get ( ctx context . Context , number string ) ( * VoiceNumberPrice , error ) { voiceNumPrice := new ( VoiceNumberPrice ) err := nvps . client . GetResource ( ctx , voicePathPart + "/Numbers" , number , voiceNumPrice ) return voiceNumPrice , err }
313	func FromQueryResult ( res * prompb . QueryResult ) storage . SeriesSet { series := make ( [ ] storage . Series , 0 , len ( res . Timeseries ) ) for _ , ts := range res . Timeseries { labels := labelProtosToLabels ( ts . Labels ) if err := validateLabelsAndMetricName ( labels ) ; err != nil { return errSeriesSet { err : err } } series = append ( series , & concreteSeries { labels : labels , samples : ts . Samples , } ) } sort . Sort ( byLabel ( series ) ) return & concreteSeriesSet { series : series , } }
2567	func resourceVSphereStorageDrsVMOverrideFindEntry ( pod * object . StoragePod , vm * object . VirtualMachine , ) ( * types . StorageDrsVmConfigInfo , error ) { props , err := storagepod . Properties ( pod ) if err != nil { return nil , fmt . Errorf ( "error fetching datastore cluster properties: %s" , err ) } for _ , info := range props . PodStorageDrsEntry . StorageDrsConfig . VmConfig { if * info . Vm == vm . Reference ( ) { log . Printf ( "[DEBUG] Found storage DRS config info for VM %q in datastore cluster %q" , vm . Name ( ) , pod . Name ( ) ) return & info , nil } } log . Printf ( "[DEBUG] No storage DRS config info found for VM %q in datastore cluster %q" , vm . Name ( ) , pod . Name ( ) ) return nil , nil }
1859	func ( mr * MockClientMockRecorder ) Get ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Get" , reflect . TypeOf ( ( * MockClient ) ( nil ) . Get ) , arg0 ) }
1647	func NewMockTaskResource ( ctrl * gomock . Controller ) * MockTaskResource { mock := & MockTaskResource { ctrl : ctrl } mock . recorder = & MockTaskResourceMockRecorder { mock } return mock }
1228	func ( client * cniClient ) SetupNS ( ctx context . Context , cfg * Config , timeout time . Duration ) ( * current . Result , error ) { derivedCtx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) type output struct { result * current . Result err error } response := make ( chan output ) go func ( response chan output ) { result , err := client . setupNS ( cfg ) response <- output { result : result , err : err , } } ( response ) select { case <- derivedCtx . Done ( ) : return nil , errors . Wrap ( derivedCtx . Err ( ) , "cni setup: container namespace setup failed" ) case result := <- response : return result . result , result . err } }
3066	func ( m * Macaron ) Use ( handler Handler ) { handler = validateAndWrapHandler ( handler ) m . handlers = append ( m . handlers , handler ) }
4484	func ( d * Date ) UnmarshalText ( text [ ] byte ) error { if len ( text ) == 0 { return nil } dd , err := time . Parse ( RFC3339FullDate , string ( text ) ) if err != nil { return err } * d = Date ( dd ) return nil }
3112	func Logger ( ) Handler { return func ( ctx * Context , log * log . Logger ) { start := time . Now ( ) log . Printf ( "%s: Started %s %s for %s" , time . Now ( ) . Format ( LogTimeFormat ) , ctx . Req . Method , ctx . Req . RequestURI , ctx . RemoteAddr ( ) ) rw := ctx . Resp . ( ResponseWriter ) ctx . Next ( ) content := fmt . Sprintf ( "%s: Completed %s %s %v %s in %v" , time . Now ( ) . Format ( LogTimeFormat ) , ctx . Req . Method , ctx . Req . RequestURI , rw . Status ( ) , http . StatusText ( rw . Status ( ) ) , time . Since ( start ) ) if ColorLog { switch rw . Status ( ) { case 200 , 201 , 202 : content = fmt . Sprintf ( "\033[1;32m%s\033[0m" , \033 ) \033 content case 301 , 302 : content = fmt . Sprintf ( "\033[1;37m%s\033[0m" , \033 ) \033 content } } case 304 : content = fmt . Sprintf ( "\033[1;33m%s\033[0m" , \033 ) } }
5177	func TraceGeneric ( ctx context . Context , name string ) * Trace { return trace ( ctx , name , func ( tx Tx ) error { return tx . StartGeneric ( name ) } ) }
1006	func ( w * Watcher ) Watching ( d dep . Dependency ) bool { w . Lock ( ) defer w . Unlock ( ) _ , ok := w . depViewMap [ d . String ( ) ] return ok }
2547	func expandCustomizationIPSettingsIPV6AddressSpec ( d * schema . ResourceData , n int , gwAdd bool ) ( * types . CustomizationIPSettingsIpV6AddressSpec , bool ) { v , ok := d . GetOk ( netifKey ( "ipv6_address" , n ) ) var gwFound bool if ! ok { return nil , gwFound } addr := v . ( string ) mask := d . Get ( netifKey ( "ipv6_netmask" , n ) ) . ( int ) gw , gwOk := d . Get ( cKeyPrefix + "." + "ipv6_gateway" ) . ( string ) obj := & types . CustomizationIPSettingsIpV6AddressSpec { Ip : [ ] types . BaseCustomizationIpV6Generator { & types . CustomizationFixedIpV6 { IpAddress : addr , SubnetMask : int32 ( mask ) , } , } , } if gwAdd && gwOk && matchGateway ( addr , mask , gw ) { obj . Gateway = [ ] string { gw } gwFound = true } return obj , gwFound }
6717	func ( c * Client ) Account ( identifier string ) ( * Account , error ) { account := new ( Account ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/accounts/" + identifier , nil , account ) if err != nil { return nil , err } return account , err }
5871	func ( cm * CheckManager ) addNewMetrics ( newMetrics map [ string ] * api . CheckBundleMetric ) bool { updatedCheckBundle := false if cm . checkBundle == nil || len ( newMetrics ) == 0 { return updatedCheckBundle } cm . cbmu . Lock ( ) defer cm . cbmu . Unlock ( ) numCurrMetrics := len ( cm . checkBundle . Metrics ) numNewMetrics := len ( newMetrics ) if numCurrMetrics + numNewMetrics >= cap ( cm . checkBundle . Metrics ) { nm := make ( [ ] api . CheckBundleMetric , numCurrMetrics + numNewMetrics ) copy ( nm , cm . checkBundle . Metrics ) cm . checkBundle . Metrics = nm } cm . checkBundle . Metrics = cm . checkBundle . Metrics [ 0 : numCurrMetrics + numNewMetrics ] i := 0 for _ , metric := range newMetrics { cm . checkBundle . Metrics [ numCurrMetrics + i ] = * metric i ++ updatedCheckBundle = true } if updatedCheckBundle { cm . forceCheckUpdate = true } return updatedCheckBundle }
3812	func ( s * Server ) Ping ( node * net . UDPAddr , callback func ( krpc . Msg , error ) ) error { s . mu . Lock ( ) defer s . mu . Unlock ( ) return s . ping ( node , callback ) }
2215	func PropertyActionNew ( name string , object * Object , propertyName string ) * PropertyAction { c := C . g_property_action_new ( ( * C . gchar ) ( C . CString ( name ) ) , C . gpointer ( unsafe . Pointer ( object . native ( ) ) ) , ( * C . gchar ) ( C . CString ( propertyName ) ) ) if c == nil { return nil } return wrapPropertyAction ( wrapObject ( unsafe . Pointer ( c ) ) ) }
6669	func ( s * VecStack ) Peek ( ) ( value * Vec , exists bool ) { exists = false if s . size > 0 { value = s . top . value exists = true } return }
3991	func getData ( url string ) ( [ ] byte , error ) { resp , err := httpClient . Get ( url ) if err != nil { return nil , fmt . Errorf ( "unable to fetch data from %q : %s" , url , err ) } defer resp . Body . Close ( ) if resp . StatusCode != http . StatusOK { return nil , fmt . Errorf ( "unexpected status code fetching data " + "from %q : expected status %d got %d" , url , http . StatusOK , resp . StatusCode ) } respBody , err := ioutil . ReadAll ( resp . Body ) if err != nil { return nil , fmt . Errorf ( "unexpected error reading response " + "body from %q : %s" , url , err ) } return respBody , nil }
7295	func ( tx Tx ) Delete ( k [ ] [ ] byte ) error { if len ( k ) == 1 { return errorsp . WithStacks ( tx . Tx . DeleteBucket ( k [ 0 ] ) ) } return tx . Bucket ( k [ : len ( k ) - 1 ] , func ( b Bucket ) error { return errorsp . WithStacks ( b . Bucket . Delete ( k [ len ( k ) - 1 ] ) ) } ) }
1965	func NewMockResult ( ctrl * gomock . Controller ) * MockResult { mock := & MockResult { ctrl : ctrl } mock . recorder = & MockResultMockRecorder { mock } return mock }
2348	func hideConsoleWindowOnWindows ( ) { pid , err := getCurrentProcessId ( ) if err != nil { return } w , err := getConsoleWindow ( ) if err != nil { return } cpid , err := getWindowThreadProcessId ( w ) if err != nil { return } if pid == cpid { showWindowAsync ( w , windows . SW_HIDE ) } }
1803	func ( m * MockDockerClient ) InspectContainer ( arg0 context . Context , arg1 string , arg2 time . Duration ) ( * types . ContainerJSON , error ) { ret := m . ctrl . Call ( m , "InspectContainer" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( * types . ContainerJSON ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2454	func ( i * Image ) Pixels ( ) [ ] byte { c := & pixelsCommand { result : nil , img : i , } theCommandQueue . Enqueue ( c ) theCommandQueue . Flush ( ) return c . result }
1234	func ( client * cniClient ) createBridgeNetworkConfigWithoutIPAM ( cfg * Config ) ( string , * libcni . NetworkConfig , error ) { networkConfig , err := client . constructNetworkConfig ( client . createBridgeConfig ( cfg ) , ECSBridgePluginName ) if err != nil { return "" , nil , errors . Wrap ( err , "createBridgeNetworkConfigWithoutIPAM: construct bridge network configuration failed" ) } return defaultVethName , networkConfig , nil }
6126	func ( b * backendInstance ) PendingNonceAt ( ctx context . Context , account common . Address ) ( uint64 , error ) { ctx , cancel := b . addTimeout ( ctx ) defer cancel ( ) return b . conn . ethClient ( ) . PendingNonceAt ( ctx , account ) }
4871	func ( f * ParameterField ) Out ( ) bool { return f . mode == pmInout || f . mode == pmOut }
471	func ( resp * Response ) SetBodyString ( body string ) { resp . closeBodyStream ( ) bodyBuf := resp . bodyBuffer ( ) bodyBuf . Reset ( ) bodyBuf . WriteString ( body ) }
7114	func ( c * Config ) Comments ( section string ) [ ] string { if section == "" { return c . comments } for _ , sect := range c . sections { if sect . name == section { return sect . comments } } return nil }
2960	func resourceVSphereFolderMigrateStateV1 ( s * terraform . InstanceState , meta interface { } ) error { dcp := folder . NormalizePath ( s . Attributes [ "datacenter" ] ) p := folder . NormalizePath ( s . Attributes [ "path" ] ) client := meta . ( * VSphereClient ) . vimClient dc , err := getDatacenter ( client , dcp ) if err != nil { return err } fp := folder . RootPathParticleVM . PathFromDatacenter ( dc , p ) folder , err := folder . FromAbsolutePath ( client , fp ) if err != nil { return err } s . Attributes = make ( map [ string ] string ) s . ID = folder . Reference ( ) . Value return nil }
6729	func ToWriter ( src string , w io . Writer , options Options ) error { u , err := url . Parse ( src ) if err != nil { return errors . Wrap ( err , "invalid src URL" ) } return FromURL ( u , w , options ) }
541	func ( c * Cookie ) Reset ( ) { c . key = c . key [ : 0 ] c . value = c . value [ : 0 ] c . expire = zeroTime c . maxAge = 0 c . domain = c . domain [ : 0 ] c . path = c . path [ : 0 ] c . httpOnly = false c . secure = false c . sameSite = CookieSameSiteDisabled }
1673	func NewASMAuthResource ( taskARN string , asmRequirements [ ] * apicontainer . ASMAuthData , executionCredentialsID string , credentialsManager credentials . Manager , asmClientCreator factory . ClientCreator ) * ASMAuthResource { c := & ASMAuthResource { taskARN : taskARN , requiredASMResources : asmRequirements , credentialsManager : credentialsManager , executionCredentialsID : executionCredentialsID , asmClientCreator : asmClientCreator , } c . initStatusToTransition ( ) return c }
4870	func ( f * ParameterField ) In ( ) bool { return f . mode == pmInout || f . mode == pmIn }
1344	func ValidDependencies ( task * apitask . Task ) bool { unresolved := make ( [ ] * apicontainer . Container , len ( task . Containers ) ) resolved := make ( [ ] * apicontainer . Container , 0 , len ( task . Containers ) ) copy ( unresolved , task . Containers ) OuterLoop : for len ( unresolved ) > 0 { for i , tryResolve := range unresolved { if dependenciesCanBeResolved ( tryResolve , resolved ) { resolved = append ( resolved , tryResolve ) unresolved = append ( unresolved [ : i ] , unresolved [ i + 1 : ] ... ) continue OuterLoop } } log . Warnf ( "Could not resolve some containers: [%v] for task %v" , unresolved , task ) return false } return true }
2708	func ( c * Config ) LoadVimClient ( ) ( * govmomi . Client , error ) { client := new ( vim25 . Client ) ok , err := c . restoreVimClient ( client ) if err != nil { return nil , err } if ! ok || ! client . Valid ( ) { log . Println ( "[DEBUG] Cached SOAP client session data not valid or persistence not enabled, new session necessary" ) return nil , nil } m := session . NewManager ( client ) u , err := m . UserSession ( context . TODO ( ) ) if err != nil { if soap . IsSoapFault ( err ) { fault := soap . ToSoapFault ( err ) . VimFault ( ) if _ , ok := fault . ( types . ManagedObjectNotFound ) ; ok { log . Println ( "[DEBUG] Cached SOAP client session missing property collector, new session necessary" ) return nil , nil } } return nil , err } if u == nil { log . Println ( "[DEBUG] Unauthenticated session, new session necessary" ) return nil , nil } log . Println ( "[DEBUG] Cached SOAP client session loaded successfully" ) return & govmomi . Client { Client : client , SessionManager : m , } , nil }
4267	func ( s * CpusetGroup ) ensureParent ( current , root string ) error { parent := filepath . Dir ( current ) if filepath . Clean ( parent ) == root { return nil } if err := s . ensureParent ( parent , root ) ; err != nil { return err } if err := os . MkdirAll ( current , 0755 ) ; err != nil && ! os . IsExist ( err ) { return err } return s . copyIfNeeded ( current , parent ) }
7129	func ( s * Docker ) Run ( cmd string , args ... string ) ( string , error ) { cmdArgs := make ( [ ] string , 0 , len ( args ) + 1 ) cmdArgs = append ( cmdArgs , cmd ) cmdArgs = append ( cmdArgs , args ... ) exe := exec . Command ( s . binCmd , cmdArgs ... ) var stdout , stderr bytes . Buffer exe . Stdout , exe . Stderr = & stdout , & stderr if err := exe . Run ( ) ; err != nil { return stdout . String ( ) , ExternalCmdError { err , stderr . String ( ) , stdout . String ( ) } } return stdout . String ( ) , nil }
5773	func ( cm * CheckManager ) selectBroker ( ) ( * api . Broker , error ) { var brokerList * [ ] api . Broker var err error enterpriseType := "enterprise" if len ( cm . brokerSelectTag ) > 0 { filter := api . SearchFilterType { "f__tags_has" : cm . brokerSelectTag , } brokerList , err = cm . apih . SearchBrokers ( nil , & filter ) if err != nil { return nil , err } } else { brokerList , err = cm . apih . FetchBrokers ( ) if err != nil { return nil , err } } if len ( * brokerList ) == 0 { return nil , fmt . Errorf ( "zero brokers found" ) } validBrokers := make ( map [ string ] api . Broker ) haveEnterprise := false for _ , broker := range * brokerList { broker := broker if cm . isValidBroker ( & broker ) { validBrokers [ broker . CID ] = broker if broker . Type == enterpriseType { haveEnterprise = true } } } if haveEnterprise { for k , v := range validBrokers { if v . Type != enterpriseType { delete ( validBrokers , k ) } } } if len ( validBrokers ) == 0 { return nil , fmt . Errorf ( "found %d broker(s), zero are valid" , len ( * brokerList ) ) } validBrokerKeys := reflect . ValueOf ( validBrokers ) . MapKeys ( ) selectedBroker := validBrokers [ validBrokerKeys [ rand . Intn ( len ( validBrokerKeys ) ) ] . String ( ) ] if cm . Debug { cm . Log . Printf ( "[DEBUG] Selected broker '%s'\n" , \n ) } selectedBroker . Name }
1530	func ( acsSession * session ) waitForDuration ( delay time . Duration ) bool { reconnectTimer := time . NewTimer ( delay ) select { case <- reconnectTimer . C : return true case <- acsSession . ctx . Done ( ) : reconnectTimer . Stop ( ) return false } }
3017	func datacenterPathFromHostSystemID ( client * govmomi . Client , hsID string ) ( string , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return "" , err } return RootPathParticleHost . SplitDatacenter ( hs . InventoryPath ) }
1079	func newWatcher ( c * config . Config , clients * dep . ClientSet , once bool ) ( * watch . Watcher , error ) { log . Printf ( "[INFO] (runner) creating watcher" ) w , err := watch . NewWatcher ( & watch . NewWatcherInput { Clients : clients , MaxStale : config . TimeDurationVal ( c . MaxStale ) , Once : once , RenewVault : clients . Vault ( ) . Token ( ) != "" && config . BoolVal ( c . Vault . RenewToken ) , VaultAgentTokenFile : config . StringVal ( c . Vault . VaultAgentTokenFile ) , RetryFuncConsul : watch . RetryFunc ( c . Consul . Retry . RetryFunc ( ) ) , RetryFuncDefault : nil , RetryFuncVault : watch . RetryFunc ( c . Vault . Retry . RetryFunc ( ) ) , VaultGrace : config . TimeDurationVal ( c . Vault . Grace ) , VaultToken : clients . Vault ( ) . Token ( ) , } ) if err != nil { return nil , errors . Wrap ( err , "runner" ) } return w , nil }
5446	func ( c * Call ) EndedUnsuccessfully ( ) bool { switch c . Status { case StatusCanceled , StatusFailed , StatusBusy , StatusNoAnswer : return true default : return false } }
4576	func hasPathPrefix ( p string , s map [ string ] string ) bool { for prefix := range s { if strings . HasPrefix ( p , prefix + "/" ) { return true } } return false }
1526	func NewTaskStatsResponse ( taskARN string , state dockerstate . TaskEngineState , statsEngine stats . Engine ) ( map [ string ] * types . StatsJSON , error ) { containerMap , ok := state . ContainerMapByArn ( taskARN ) if ! ok { return nil , errors . Errorf ( "v2 task stats response: unable to lookup containers for task %s" , taskARN ) } resp := make ( map [ string ] * types . StatsJSON ) for _ , dockerContainer := range containerMap { containerID := dockerContainer . DockerID dockerStats , err := statsEngine . ContainerDockerStats ( taskARN , containerID ) if err != nil { seelog . Warnf ( "V2 task stats response: Unable to get stats for container '%s' for task '%s': %v" , containerID , taskARN , err ) resp [ containerID ] = nil continue } resp [ containerID ] = dockerStats } return resp , nil }
2728	func searchForDirectory ( client * govmomi . Client , datacenter string , datastore string , directoryPath string ) error { log . Printf ( "[DEBUG] Searching for Directory" ) finder := find . NewFinder ( client . Client , true ) dc , err := getDatacenter ( client , datacenter ) if err != nil { return fmt . Errorf ( "Error finding Datacenter: %s: %s" , datacenter , err ) } finder = finder . SetDatacenter ( dc ) ds , err := finder . Datastore ( context . TODO ( ) , datastore ) if err != nil { return fmt . Errorf ( "Error finding Datastore: %s: %s" , datastore , err ) } ctx := context . TODO ( ) b , err := ds . Browser ( ctx ) if err != nil { return err } spec := types . HostDatastoreBrowserSearchSpec { Query : [ ] types . BaseFileQuery { & types . FolderFileQuery { } } , Details : & types . FileQueryFlags { FileSize : true , FileType : true , Modification : true , FileOwner : types . NewBool ( true ) , } , MatchPattern : [ ] string { path . Base ( directoryPath ) } , } dsPath := ds . Path ( path . Dir ( directoryPath ) ) task , err := b . SearchDatastore ( context . TODO ( ) , dsPath , & spec ) if err != nil { log . Printf ( "[DEBUG] searchForDirectory - could not search datastore for: %v" , directoryPath ) return err } info , err := task . WaitForResult ( context . TODO ( ) , nil ) if err != nil { if info == nil || info . Error != nil { _ , ok := info . Error . Fault . ( * types . FileNotFound ) if ok { log . Printf ( "[DEBUG] searchForDirectory - could not find: %v" , directoryPath ) return nil } } log . Printf ( "[DEBUG] searchForDirectory - could not search datastore for: %v" , directoryPath ) return err } res := info . Result . ( types . HostDatastoreBrowserSearchResults ) log . Printf ( "[DEBUG] num results: %d" , len ( res . File ) ) if len ( res . File ) == 0 { log . Printf ( "[DEBUG] searchForDirectory - could not find: %v" , directoryPath ) return nil } if len ( res . File ) != 1 { return errors . New ( "Datastore search did not return exactly one result" ) } fileInfo := res . File [ 0 ] log . Printf ( "[DEBUG] searchForDirectory - fileinfo: %#v" , fileInfo ) return nil }
5444	func ( irc * Bot ) hijackSession ( ) bool { unaddr , err := net . ResolveUnixAddr ( "unix" , irc . unixastr ) if err != nil { panic ( err ) } con , err := net . DialUnix ( "unix" , nil , unaddr ) if err != nil { irc . Info ( "Couldnt restablish connection, no prior bot." , "err" , err ) return false } ncon , err := sendfd . RecvFD ( con ) if err != nil { panic ( err ) } netcon , err := net . FileConn ( ncon ) if err != nil { panic ( err ) } irc . reconnecting = true irc . con = netcon return true }
4345	func BuildMacKeypad ( ) Graph { data , err := data . Asset ( "data/MacKeypad.json" ) if err != nil { panic ( "Can't find asset" ) } return getAdjancencyGraphFromFile ( data , "mac_keypad" ) }
3823	func ( a * Announce ) Close ( ) { a . mu . Lock ( ) defer a . mu . Unlock ( ) a . close ( ) }
6386	func Singlep ( iter Enumerable , pred Predicate ) ( retval interface { } , err error ) { iter = Where ( iter , pred ) return Single ( iter ) }
4937	func NewBasicAuthConnector ( host , username , password string ) * Connector { c := newConnector ( ) c . host = host c . username = username c . password = password return c }
3828	func ( uuid UUID ) NodeID ( ) [ ] byte { var node [ 6 ] byte copy ( node [ : ] , uuid [ 10 : ] ) return node [ : ] }
1308	func setContainerChangeSent ( event * sendableEvent ) { containerChangeStatus := event . containerChange . Status container := event . containerChange . Container if container != nil && container . GetSentStatus ( ) < containerChangeStatus { container . SetSentStatus ( containerChangeStatus ) } }
2083	func ( m * MockRoundTripper ) RoundTrip ( arg0 * http . Request ) ( * http . Response , error ) { ret := m . ctrl . Call ( m , "RoundTrip" , arg0 ) ret0 , _ := ret [ 0 ] . ( * http . Response ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5248	func ( c * Client ) DeleteIndex ( index * Index ) error { span := c . tracer . StartSpan ( "Client.DeleteIndex" ) defer span . Finish ( ) path := fmt . Sprintf ( "/index/%s" , index . name ) _ , _ , err := c . httpRequest ( "DELETE" , path , nil , nil , false ) return err }
6833	func ( c * Client ) Devices ( ) ( [ ] * Device , error ) { req := c . buildRequest ( "/devices" , nil ) resp , err := c . Client . Do ( req ) if err != nil { return nil , err } defer resp . Body . Close ( ) if resp . StatusCode != http . StatusOK { var errjson errorResponse dec := json . NewDecoder ( resp . Body ) err = dec . Decode ( & errjson ) if err == nil { return nil , & errjson . ErrResponse } return nil , errors . New ( resp . Status ) } var devResp deviceResponse dec := json . NewDecoder ( resp . Body ) err = dec . Decode ( & devResp ) if err != nil { return nil , err } for i := range devResp . Devices { devResp . Devices [ i ] . Client = c } devices := append ( devResp . Devices , devResp . SharedDevices ... ) return devices , nil }
3919	func ( d * Descriptions ) IsStub ( fn * ssa . Function ) bool { if len ( fn . Blocks ) == 0 { return true } if len ( fn . Blocks ) > 1 { return false } instrs := lintdsl . FilterDebug ( fn . Blocks [ 0 ] . Instrs ) if len ( instrs ) != 1 { return false } switch instrs [ 0 ] . ( type ) { case * ssa . Return : return true case * ssa . Panic : return true default : return false } }
1470	func ( c * Container ) SetMetadataFileUpdated ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . MetadataFileUpdated = true }
5345	func ReplaceAtLine ( filename string , r [ ] ReplacerAtLine ) error { e , err := NewEdit ( filename ) if err != nil { return err } err = e . genReplaceAtLine ( r , - 1 ) err2 := e . Close ( ) if err != nil { return err } return err2 }
7200	func ( r * Route ) Delete ( pat string , f ... HandlerFunc ) { r . HandleMethod ( pat , "DELETE" , f ... ) }
3794	func ( r * Request ) SetMeta ( v interface { } ) error { b , err := json . Marshal ( v ) if err != nil { return err } r . Meta = ( * json . RawMessage ) ( & b ) return nil }
4176	func ( c * OrgNamedQuotaConfigurationCommand ) Execute ( args [ ] string ) error { c . initConfig ( ) orgQuota , err := c . ConfigManager . GetOrgQuota ( c . Name ) if err != nil { return err } if orgQuota == nil { orgQuota = & config . OrgQuota { Name : c . Name , TotalPrivateDomains : "unlimited" , TotalReservedRoutePorts : "unlimited" , TotalServiceKeys : "unlimited" , AppInstanceLimit : "unlimited" , AppTaskLimit : "unlimited" , InstanceMemoryLimit : "unlimited" , TotalRoutes : "unlimited" , TotalServices : "unlimited" , PaidServicePlansAllowed : true , } } errorString := "" updateOrgNamedQuotaConfig ( orgQuota , c . Quota , & errorString ) if errorString != "" { return errors . New ( errorString ) } return c . ConfigManager . SaveOrgQuota ( orgQuota ) }
6681	func Callback ( cbReq * CallbackRequest , opts * CallbackOptions ) error { client := opts . Client if client == nil { client = http . DefaultClient } buf := bytes . NewBuffer ( nil ) err := json . NewEncoder ( buf ) . Encode ( cbReq ) if err != nil { return err } signature , err := opts . Signer . Sign ( buf . Bytes ( ) ) if err != nil { return err } req , err := http . NewRequest ( "POST" , cbReq . StatusCallbackUrl , buf ) if err != nil { return err } req . Header . Set ( "X-OpenGDPR-Processor-Domain" , opts . ProcessorDomain ) req . Header . Set ( "X-OpenGDPR-Signature" , signature ) for i := 0 ; i < opts . MaxAttempts ; i ++ { resp , err := client . Do ( req ) if err != nil || resp . StatusCode != 200 { time . Sleep ( opts . Backoff ) continue } return nil } return fmt . Errorf ( "callback timed out for %s" , cbReq . StatusCallbackUrl ) }
6140	func ( b * backendInstance ) PSCRemoveServiceOffering ( opts * bind . TransactOpts , offeringHash [ 32 ] byte ) ( * types . Transaction , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 tx , err := b . psc . RemoveServiceOffering ( opts , offeringHash ) if err != nil { err = fmt . Errorf ( "failed to remove" + " service offering: %v" , err ) } return tx , err }
3459	func ( q * QueryConfig ) GetQueryStringOk ( ) ( string , bool ) { if q == nil || q . QueryString == nil { return "" , false } return * q . QueryString , true }
2673	func expandClusterVMToolsMonitoringSettings ( d * schema . ResourceData ) * types . ClusterVmToolsMonitoringSettings { obj := & types . ClusterVmToolsMonitoringSettings { FailureInterval : int32 ( d . Get ( "ha_vm_failure_interval" ) . ( int ) ) , MaxFailures : int32 ( d . Get ( "ha_vm_maximum_resets" ) . ( int ) ) , MaxFailureWindow : int32 ( d . Get ( "ha_vm_maximum_failure_window" ) . ( int ) ) , MinUpTime : int32 ( d . Get ( "ha_vm_minimum_uptime" ) . ( int ) ) , VmMonitoring : d . Get ( "ha_vm_monitoring" ) . ( string ) , } return obj }
5536	func ( lo * LuaObject ) Push ( ) { lo . l . RawGeti ( lua . LUA_REGISTRYINDEX , lo . ref ) }
6998	func NotFound ( ctx context . Context , w http . ResponseWriter , r * http . Request ) { http . NotFound ( w , r ) }
1285	func ( cgroup * CgroupResource ) Create ( ) error { err := cgroup . setupTaskCgroup ( ) if err != nil { seelog . Criticalf ( "Cgroup resource [%s]: unable to setup cgroup root: %v" , cgroup . taskARN , err ) return err } return nil }
4225	func Diff ( old , new io . Reader , patch io . Writer ) error { obuf , err := ioutil . ReadAll ( old ) if err != nil { return err } nbuf , err := ioutil . ReadAll ( new ) if err != nil { return err } pbuf , err := diffBytes ( obuf , nbuf ) if err != nil { return err } _ , err = patch . Write ( pbuf ) return err }
6230	func ( h * Handler ) GetGUISettings ( tkn string ) ( map [ string ] interface { } , error ) { logger := h . logger . Add ( "method" , "GetGUISettings" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } retStr , err := data . ReadSetting ( h . db . Querier , data . SettingGUI ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrInternal } ret := make ( map [ string ] interface { } ) err = json . Unmarshal ( [ ] byte ( retStr ) , & ret ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrInternal } return ret , nil }
893	func ( d * Driver ) GetIP ( ) ( string , error ) { c , err := newComputeUtil ( d ) if err != nil { return "" , err } ip , err := c . ip ( ) if err != nil { return "" , err } if ip == "" { return "" , drivers . ErrHostIsNotRunning } return ip , nil }
7104	func ToURL ( theString , subdomain string , secure bool ) ( string , error ) { f := New ( theString ) if f . length < 4 { return "" , errors . New ( lengthError ) } f . makeLower ( ) if secure { if len ( subdomain ) > 0 { return fmt . Sprintf ( "https://%s.%s" , subdomain , f . theString ) , nil } return fmt . Sprintf ( "https://%s" , f . theString ) , nil } if len ( subdomain ) > 0 { return fmt . Sprintf ( "http://%s.%s" , subdomain , f . theString ) , nil } return fmt . Sprintf ( "http://%s" , f . theString ) , nil }
3215	func ( client * Client ) Validate ( ) ( bool , error ) { var out valid var resp * http . Response uri , err := client . uriForAPI ( "/v1/validate" ) if err != nil { return false , err } req , err := http . NewRequest ( "GET" , uri , nil ) if err != nil { return false , err } resp , err = client . doRequestWithRetries ( req , client . RetryTimeout ) if err != nil { return false , err } defer resp . Body . Close ( ) body , err := ioutil . ReadAll ( resp . Body ) if err != nil { return false , err } if err = json . Unmarshal ( body , & out ) ; err != nil { return false , err } return out . IsValid , nil }
3578	func ( t * ThresholdCount ) GetTimeAggregatorOk ( ) ( string , bool ) { if t == nil || t . TimeAggregator == nil { return "" , false } return * t . TimeAggregator , true }
5420	func ( is IdentifierSlice ) Less ( i , j int ) bool { return is [ i ] . ID ( ) < is [ j ] . ID ( ) }
5143	func ( ui * PrefixUI ) Log ( message string ) { if ui . LogPrefix == " " { message = ui . LogPrefix + message } else if ui . LogPrefix != "" { message = ui . LogPrefix + " " + message } ui . UI . Log ( message ) }
2736	func readTagsForResource ( client * tags . RestClient , obj object . Reference , d * schema . ResourceData ) error { log . Printf ( "[DEBUG] Reading tags for object %q" , obj . Reference ( ) . Value ) objID := obj . Reference ( ) . Value objType , err := tagTypeForObject ( obj ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) ids , err := client . ListAttachedTags ( ctx , objID , objType ) log . Printf ( "[DEBUG] Tags for object %q: %s" , objID , strings . Join ( ids , "," ) ) if err != nil { return err } if err := d . Set ( vSphereTagAttributeKey , ids ) ; err != nil { return fmt . Errorf ( "error saving tag IDs to resource data: %s" , err ) } return nil }
5865	func ( a * API ) CreateContactGroup ( cfg * ContactGroup ) ( * ContactGroup , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid contact group config [nil]" ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] create contact group, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Post ( config . ContactGroupPrefix , jsonCfg ) if err != nil { return nil , err } group := & ContactGroup { } if err := json . Unmarshal ( result , group ) ; err != nil { return nil , err } return group , nil }
2877	func flattenClusterAffinityRuleSpec ( d * schema . ResourceData , meta interface { } , obj * types . ClusterAffinityRuleSpec ) error { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return err } results , err := virtualmachine . UUIDsForManagedObjectReferences ( client , obj . Vm , ) if err != nil { return err } return structure . SetBatch ( d , map [ string ] interface { } { "enabled" : obj . Enabled , "mandatory" : obj . Mandatory , "name" : obj . Name , "virtual_machine_ids" : results . UUIDs ( ) , } ) }
2333	func ( v * Context ) Transform ( matrix * Matrix ) { C . cairo_transform ( v . native ( ) , matrix . native ( ) ) }
5781	func ( cm * CheckManager ) loadCACert ( ) error { if cm . certPool != nil { return nil } cm . certPool = x509 . NewCertPool ( ) var cert [ ] byte var err error if cm . enabled { cert , err = cm . fetchCert ( ) if err != nil { return err } } if cert == nil { cert = circonusCA } cm . certPool . AppendCertsFromPEM ( cert ) return nil }
1461	func ( c * Container ) GetSentStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . SentStatusUnsafe }
1695	func ( change * TaskStateChange ) SetTaskTimestamps ( ) { if change . Task == nil { return } if timestamp := change . Task . GetPullStartedAt ( ) ; ! timestamp . IsZero ( ) { change . PullStartedAt = aws . Time ( timestamp . UTC ( ) ) } if timestamp := change . Task . GetPullStoppedAt ( ) ; ! timestamp . IsZero ( ) { change . PullStoppedAt = aws . Time ( timestamp . UTC ( ) ) } if timestamp := change . Task . GetExecutionStoppedAt ( ) ; ! timestamp . IsZero ( ) { change . ExecutionStoppedAt = aws . Time ( timestamp . UTC ( ) ) } }
455	func WriteGzip ( w io . Writer , p [ ] byte ) ( int , error ) { return WriteGzipLevel ( w , p , CompressDefaultCompression ) }
6218	func ( w * Worker ) ClientPreServiceSuspend ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientPreServiceSuspend" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientPreServiceSuspend ) if err != nil { return err } logger = logger . Add ( "channel" , ch ) ch . ServiceStatus = data . ServiceSuspending changedTime := time . Now ( ) ch . ServiceChangedTime = & changedTime err = w . saveRecord ( logger , w . db . Querier , ch ) if err != nil { return err } return nil }
4444	func ( u CreditCard ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
4476	func ( d Duration ) MarshalJSON ( ) ( [ ] byte , error ) { var w jwriter . Writer d . MarshalEasyJSON ( & w ) return w . BuildBytes ( ) }
4183	func ( m * yamlManager ) GetSpaceDefaults ( ) ( * SpaceConfig , error ) { fp := filepath . Join ( m . ConfigDir , "spaceDefaults.yml" ) if ! FileOrDirectoryExists ( fp ) { return nil , nil } result := SpaceConfig { } err := LoadFile ( fp , & result ) return & result , err }
3884	func NewIssue ( linter string , formatTmpl * template . Template ) ( * Issue , error ) { issue := & Issue { Line : 1 , Severity : Warning , Linter : linter , formatTmpl : formatTmpl , } err := formatTmpl . Execute ( ioutil . Discard , issue ) return issue , err }
5742	func ( c * CustomerIO ) AddDevice ( customerID string , deviceID string , platform string , data map [ string ] interface { } ) error { if customerID == "" { return errors . New ( "customerID is a required field" ) } if deviceID == "" { return errors . New ( "deviceID is a required field" ) } if platform == "" { return errors . New ( "platform is a required field" ) } body := map [ string ] map [ string ] interface { } { "device" : { "id" : deviceID , "platform" : platform } } for k , v := range data { body [ "device" ] [ k ] = v } j , err := json . Marshal ( body ) if err != nil { return err } status , responseBody , err := c . request ( "PUT" , c . deviceURL ( customerID ) , j ) if err != nil { return err } else if status != 200 { return & CustomerIOError { status , c . deviceURL ( customerID ) , responseBody } } return nil }
7088	func ( s * CORSMiddleware ) Handle ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { origin := HttpHeader_Origin ( ) . GetReader ( r . Header ) if r . Method != DEFAULT_CORS_PREFLIGHT_METHOD && origin . Value != "" { if ! s . PredicateOrigin ( origin . Value ) { return } HttpHeader_AccessControlAllowOrigin ( ) . SetValue ( origin . Value ) . SetWriter ( w . Header ( ) ) HttpHeader_AccessControlAllowCredentials ( ) . SetValue ( strconv . FormatBool ( s . UseCredentials ) ) . SetWriter ( w . Header ( ) ) if len ( s . Headers ) > 0 { HttpHeader_AccessControlAllowHeaders ( ) . SetValue ( strings . Join ( s . Headers , ", " ) ) . SetWriter ( w . Header ( ) ) } else { HttpHeader_AccessControlAllowHeaders ( ) . SetWriter ( w . Header ( ) ) } } next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) }
4715	func InitializeOptions ( opts * Options ) * Options { if opts == nil { opts = & Options { } } if opts . Extension == "" { opts . Extension = defaultExtension } if opts . DelimLeft == "" { opts . DelimLeft = defaultDelimLeft } if opts . DelimRight == "" { opts . DelimRight = defaultDelimRight } if opts . AttributeNameClass == "" { opts . AttributeNameClass = defaultAttributeNameClass } if opts . NoCloseTagNames == nil { opts . NoCloseTagNames = make ( [ ] string , len ( defaultNoCloseTagNames ) ) copy ( opts . NoCloseTagNames , defaultNoCloseTagNames ) } if opts . Indent != "" { opts . formatter = newFormatter ( opts . Indent ) } return opts }
2166	func ( v * AboutDialog ) native ( ) * C . GtkAboutDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAboutDialog ( p ) }
5160	func errNo ( i C . int ) ( int , error ) { errno := int ( i ) if errno < 0 { errMsg := "unknown" if e , ok := errNoMap [ errno ] ; ok { errMsg = e } return errno , errors . New ( fmt . Sprintf ( "newrelic[%s]: %s" , caller ( ) , errMsg ) ) } return errno , nil }
4124	func loadEnv ( ) { gil . Lock ( ) defer gil . Unlock ( ) if os . Getenv ( "GO_ENV" ) == "" { if v := flag . Lookup ( "test.v" ) ; v != nil { env [ "GO_ENV" ] = "test" } } if os . Getenv ( "GOPATH" ) == "" { out , err := exec . Command ( "go" , "env" , "GOPATH" ) . Output ( ) if err == nil { gp := strings . TrimSpace ( string ( out ) ) os . Setenv ( "GOPATH" , gp ) } } for _ , e := range os . Environ ( ) { pair := strings . Split ( e , "=" ) env [ pair [ 0 ] ] = os . Getenv ( pair [ 0 ] ) } }
6612	func ( b * AddressBlock ) Contains ( address HardwareAddr ) bool { return ( bytes . Equal ( address . Mask ( CIDRMask ( b . Mask , len ( b . Oui ) * 8 ) ) , b . Oui ) ) }
6637	func RouteHandlerFunc ( next http . HandlerFunc ) r2router . HandlerFunc { return func ( w http . ResponseWriter , r * http . Request , _ r2router . Params ) { next ( w , r ) } }
4663	func approximateSquareDistance ( p1 , p2 Point ) Meters { avgLat := ( p1 . Lat ( ) + p2 . Lat ( ) ) / 2.0 latLen := math . Abs ( p1 . Lat ( ) - p2 . Lat ( ) ) * float64 ( latDegreeLength ) lonLen := math . Abs ( p1 . Lon ( ) - p2 . Lon ( ) ) * float64 ( lonLength . get ( avgLat ) ) return Meters ( latLen * latLen + lonLen * lonLen ) }
4335	func ( c * Client ) Flush ( ) { if c . muted { return } c . conn . mu . Lock ( ) c . conn . flush ( 0 ) c . conn . mu . Unlock ( ) }
3999	func EncodeLintDescriptionsToJSON ( w io . Writer ) { enc := json . NewEncoder ( w ) enc . SetEscapeHTML ( false ) for _ , lint := range lints . Lints { enc . Encode ( lint ) } }
4700	func extractTagName ( s string ) string { tagName := strings . Split ( strings . Split ( s , sharp ) [ 0 ] , dot ) [ 0 ] if tagName == "" { tagName = tagNameDiv } return tagName }
2845	func ( r * CdromSubresource ) Delete ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Beginning delete" , r ) d , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( "cannot find disk device: %s" , err ) } device , ok := d . ( * types . VirtualCdrom ) if ! ok { return nil , fmt . Errorf ( "device at %q is not a virtual CDROM device" , l . Name ( d ) ) } deleteSpec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } log . Printf ( "[DEBUG] %s: Device config operations from update: %s" , r , DeviceChangeString ( deleteSpec ) ) log . Printf ( "[DEBUG] %s: Delete completed" , r ) return deleteSpec , nil }
5977	func NewWriterPool ( maxRate int , maxBurst time . Duration ) * WriterPool { return & WriterPool { maxRate : maxRate , maxBurst : maxBurst , givenOut : make ( map [ ThrottlerWriter ] struct { } ) , } }
1004	func DefaultConfig ( ) * Config { return & Config { Consul : DefaultConsulConfig ( ) , Dedup : DefaultDedupConfig ( ) , Exec : DefaultExecConfig ( ) , Syslog : DefaultSyslogConfig ( ) , Templates : DefaultTemplateConfigs ( ) , Vault : DefaultVaultConfig ( ) , Wait : DefaultWaitConfig ( ) , } }
4180	func ( m * yamlManager ) Orgs ( ) ( * Orgs , error ) { configFile := filepath . Join ( m . ConfigDir , "orgs.yml" ) lo . G . Debug ( "Processing org file" , configFile ) input := & Orgs { } if err := LoadFile ( configFile , & input ) ; err != nil { return nil , err } return input , nil }
1706	func ( task * Task ) initializeDockerVolumes ( sharedVolumeMatchFullConfig bool , dockerClient dockerapi . DockerClient , ctx context . Context ) error { for i , vol := range task . Volumes { if vol . Type != DockerVolumeType { continue } dockerVolume , ok := vol . Volume . ( * taskresourcevolume . DockerVolumeConfig ) if ! ok { return errors . New ( "task volume: volume configuration does not match the type 'docker'" ) } if dockerVolume . Scope == taskresourcevolume . TaskScope { err := task . addTaskScopedVolumes ( ctx , dockerClient , & task . Volumes [ i ] ) if err != nil { return err } } else { err := task . addSharedVolumes ( sharedVolumeMatchFullConfig , ctx , dockerClient , & task . Volumes [ i ] ) if err != nil { return err } } } return nil }
3371	func ( i * IntegrationGCPCreateRequest ) GetPrivateKeyOk ( ) ( string , bool ) { if i == nil || i . PrivateKey == nil { return "" , false } return * i . PrivateKey , true }
2603	func Properties ( pg * object . DistributedVirtualPortgroup ) ( * mo . DistributedVirtualPortgroup , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . DistributedVirtualPortgroup if err := pg . Properties ( ctx , pg . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
1950	func ( containerType * ContainerType ) MarshalJSON ( ) ( [ ] byte , error ) { if containerType == nil { return [ ] byte ( "null" ) , nil } return [ ] byte ( `"` + containerType . String ( ) + `"` ) , nil }
4149	func ( p * prefixTrie ) Remove ( network net . IPNet ) ( RangerEntry , error ) { return p . remove ( rnet . NewNetwork ( network ) ) }
4642	func newAverageAccumulatingCounter ( point Point ) accumulatingCounter { return & averageAccumulatingCounter { newSingleValueAccumulatingCounter ( point ) . ( * singleValueAccumulatingCounter ) , point . ( * CountPoint ) . Count . ( float64 ) , } }
1457	func ( c * Container ) GetKnownStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . KnownStatusUnsafe }
6986	func ( s * S3Bucket ) NewReader ( path string ) ( io . ReadCloser , error ) { r , _ , err := s . bucket . GetReader ( path , nil ) return r , err }
88	func AlertTemplateData ( labels map [ string ] string , externalLabels map [ string ] string , value float64 ) interface { } { return struct { Labels map [ string ] string ExternalLabels map [ string ] string Value float64 } { Labels : labels , ExternalLabels : externalLabels , Value : value , } }
1893	func updateContainerMetadata ( metadata * dockerapi . DockerContainerMetadata , container * apicontainer . Container , task * apitask . Task ) { container . SetCreatedAt ( metadata . CreatedAt ) container . SetStartedAt ( metadata . StartedAt ) container . SetFinishedAt ( metadata . FinishedAt ) if len ( metadata . Labels ) != 0 && len ( container . GetLabels ( ) ) == 0 { container . SetLabels ( metadata . Labels ) } if metadata . Volumes != nil { if container . IsInternal ( ) { task . UpdateMountPoints ( container , metadata . Volumes ) } else { container . SetVolumes ( metadata . Volumes ) } } if metadata . ExitCode != nil { container . SetKnownExitCode ( metadata . ExitCode ) } if len ( metadata . PortBindings ) != 0 && len ( container . GetKnownPortBindings ( ) ) == 0 { container . SetKnownPortBindings ( metadata . PortBindings ) } if container . HealthStatusShouldBeReported ( ) { container . SetHealthStatus ( metadata . Health ) } container . SetNetworkMode ( metadata . NetworkMode ) container . SetNetworkSettings ( metadata . NetworkSettings ) }
1428	func ( cs * ClientServerImpl ) handleMessage ( data [ ] byte ) { typedMessage , typeStr , err := DecodeData ( data , cs . TypeDecoder ) if err != nil { seelog . Warnf ( "Unable to handle message from backend: %v" , err ) return } seelog . Debugf ( "Received message of type: %s" , typeStr ) if cs . AnyRequestHandler != nil { reflect . ValueOf ( cs . AnyRequestHandler ) . Call ( [ ] reflect . Value { reflect . ValueOf ( typedMessage ) } ) } if handler , ok := cs . RequestHandlers [ typeStr ] ; ok { reflect . ValueOf ( handler ) . Call ( [ ] reflect . Value { reflect . ValueOf ( typedMessage ) } ) } else { seelog . Infof ( "No handler for message type: %s" , typeStr ) } }
7190	func NewUser ( player uuid . UUID , userdata * User ) ( * User , error ) { p , err := storage . Load ( player ) if err != nil { return nil , err } p . User = * userdata err = storage . Store ( p ) if err != nil { return nil , errors . New ( err . Error ( ) + " - Could not write user to storage" ) } return & p . User , nil }
3436	func ( o * Options ) HasRenotifyInterval ( ) bool { if o != nil && o . RenotifyInterval != nil { return true } return false }
2963	func NewDiskSubresource ( client * govmomi . Client , rdd resourceDataDiff , d , old map [ string ] interface { } , idx int ) * DiskSubresource { sr := & DiskSubresource { Subresource : & Subresource { schema : DiskSubresourceSchema ( ) , client : client , srtype : subresourceTypeDisk , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr }
1113	func parseJSON ( s string ) ( interface { } , error ) { if s == "" { return map [ string ] interface { } { } , nil } var data interface { } if err := json . Unmarshal ( [ ] byte ( s ) , & data ) ; err != nil { return nil , err } return data , nil }
5516	func ( m * Messenger ) Handler ( rw http . ResponseWriter , req * http . Request ) { if req . Method == "GET" { query := req . URL . Query ( ) if query . Get ( "hub.verify_token" ) != m . VerifyToken { rw . WriteHeader ( http . StatusUnauthorized ) return } rw . WriteHeader ( http . StatusOK ) rw . Write ( [ ] byte ( query . Get ( "hub.challenge" ) ) ) } else if req . Method == "POST" { m . handlePOST ( rw , req ) } else { rw . WriteHeader ( http . StatusMethodNotAllowed ) } }
5843	func ( a * API ) FetchAlerts ( ) ( * [ ] Alert , error ) { result , err := a . Get ( config . AlertPrefix ) if err != nil { return nil , err } var alerts [ ] Alert if err := json . Unmarshal ( result , & alerts ) ; err != nil { return nil , err } return & alerts , nil }
7147	func RecoverHandlerJson ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { defer func ( ) { if err := recover ( ) ; err != nil { jerr := NewJsonErrorFromError ( http . StatusInternalServerError , fmt . Errorf ( "panic: %+v" , err ) ) JsonWrite ( w , jerr . Status , jerr ) } } ( ) next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) }
1233	func ( client * cniClient ) createBridgeNetworkConfigWithIPAM ( cfg * Config ) ( string , * libcni . NetworkConfig , error ) { bridgeConfig := client . createBridgeConfig ( cfg ) ipamConfig , err := client . createIPAMConfig ( cfg ) if err != nil { return "" , nil , errors . Wrap ( err , "createBridgeNetworkConfigWithIPAM: create ipam configuration failed" ) } bridgeConfig . IPAM = ipamConfig networkConfig , err := client . constructNetworkConfig ( bridgeConfig , ECSBridgePluginName ) if err != nil { return "" , nil , errors . Wrap ( err , "createBridgeNetworkConfigWithIPAM: construct bridge and ipam network configuration failed" ) } return defaultVethName , networkConfig , nil }
3809	func ( s * Server ) SetIPBlockList ( list iplist . Ranger ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) s . ipBlockList = list }
3996	func IsNameAttribute ( oid asn1 . ObjectIdentifier ) bool { if len ( oid ) != 4 { return false } if ! nameAttributePrefix . Equal ( oid [ 0 : 3 ] ) { return false } _ , ok := nameAttributeLeaves [ oid [ 3 ] ] return ok }
1973	func ( m * MockClient ) ContainerRemove ( arg0 context . Context , arg1 string , arg2 types . ContainerRemoveOptions ) error { ret := m . ctrl . Call ( m , "ContainerRemove" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
7059	func ( r * Router ) NotFound ( i interface { } ) { handler := r . buildHandler ( i ) r . dispatcher . NotFoundHandler ( r . route , handler ) }
3847	func ( l * List ) Search ( term string ) { term = strings . Trim ( term , " " ) l . cursor = 0 l . start = 0 l . search ( term ) }
1486	func ( c * Container ) SetNetworkMode ( networkMode string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . NetworkModeUnsafe = networkMode }
476	func ( resp * Response ) SwapBody ( body [ ] byte ) [ ] byte { bb := resp . bodyBuffer ( ) if resp . bodyStream != nil { bb . Reset ( ) _ , err := copyZeroAlloc ( bb , resp . bodyStream ) resp . closeBodyStream ( ) if err != nil { bb . Reset ( ) bb . SetString ( err . Error ( ) ) } } resp . bodyRaw = nil oldBody := bb . B bb . B = body return oldBody }
7045	func NewReadWriteCloser ( readErr , writeErr , closeErr error ) * MockReadWriteCloser { return & MockReadWriteCloser { ReadErr : readErr , WriteErr : writeErr , CloseErr : closeErr , } }
3261	func ( c * ConditionalFormat ) HasImageURL ( ) bool { if c != nil && c . ImageURL != nil { return true } return false }
7093	func ( f RuneMatcherFunc ) Match ( str string ) ( offset int , matchStr string ) { offset = - 1 length := len ( str ) if length == 0 { return } for i , r := range str { if f ( r ) { continue } if i != 0 { offset = i matchStr = str [ : i ] return } return } offset = length matchStr = str return }
5302	func NewMultiple ( buf [ ] byte , options Options , h hash . Hash , compareOnMatch bool ) * Cmp { c := & Cmp { Opt : options , hashType : h , hashMatchCompare : compareOnMatch , hashTable : map [ string ] hashSum { } , buf : buf , } if c . buf == nil || len ( c . buf ) == 0 { c . buf = make ( [ ] byte , defaultBufSize ) } c . debugf ( "New: bufSize=%d\n" , \n ) len ( c . buf ) }
1509	func ( secret * ASMSecretResource ) clearASMSecretValue ( ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for key := range secret . secretData { delete ( secret . secretData , key ) } }
1834	func ( mtask * managedTask ) progressTask ( ) { seelog . Debugf ( "Managed task [%s]: progressing containers and resources in task" , mtask . Arn ) resources := mtask . GetResources ( ) transitionChange := make ( chan struct { } , len ( mtask . Containers ) + len ( resources ) ) transitionChangeEntity := make ( chan string , len ( mtask . Containers ) + len ( resources ) ) anyResourceTransition , resTransitions := mtask . startResourceTransitions ( func ( resource taskresource . TaskResource , nextStatus resourcestatus . ResourceStatus ) { mtask . transitionResource ( resource , nextStatus ) transitionChange <- struct { } { } transitionChangeEntity <- resource . GetName ( ) } ) anyContainerTransition , blockedDependencies , contTransitions , reasons := mtask . startContainerTransitions ( func ( container * apicontainer . Container , nextStatus apicontainerstatus . ContainerStatus ) { mtask . engine . transitionContainer ( mtask . Task , container , nextStatus ) transitionChange <- struct { } { } transitionChangeEntity <- container . Name } ) atLeastOneTransitionStarted := anyResourceTransition || anyContainerTransition blockedByOrderingDependencies := len ( blockedDependencies ) > 0 if ! atLeastOneTransitionStarted && ! blockedByOrderingDependencies { if ! mtask . isWaitingForACSExecutionCredentials ( reasons ) { mtask . handleContainersUnableToTransitionState ( ) } return } if ! atLeastOneTransitionStarted && blockedByOrderingDependencies { go mtask . engine . checkTaskState ( mtask . Task ) ctx , cancel := context . WithTimeout ( context . Background ( ) , transitionPollTime ) defer cancel ( ) for timeout := mtask . waitEvent ( ctx . Done ( ) ) ; ! timeout ; { timeout = mtask . waitEvent ( ctx . Done ( ) ) } return } transitions := make ( map [ string ] string ) for k , v := range resTransitions { transitions [ k ] = v } for k , v := range contTransitions { transitions [ k ] = v . String ( ) } mtask . waitForTransition ( transitions , transitionChange , transitionChangeEntity ) changed := mtask . UpdateStatus ( ) if changed { seelog . Debugf ( "Managed task [%s]: container or resource change also resulted in task change" , mtask . Arn ) var taskStateChangeReason string if mtask . GetKnownStatus ( ) . Terminal ( ) { taskStateChangeReason = mtask . Task . GetTerminalReason ( ) } mtask . emitTaskEvent ( mtask . Task , taskStateChangeReason ) } }
474	func ( resp * Response ) ReleaseBody ( size int ) { resp . bodyRaw = nil if cap ( resp . body . B ) > size { resp . closeBodyStream ( ) resp . body = nil } }
5183	func ( c * LRU ) Keys ( ) [ ] string { keys := make ( [ ] string , len ( c . items ) ) i := 0 for ent := c . evictList . Back ( ) ; ent != nil ; ent = ent . Prev ( ) { keys [ i ] = ent . Value . ( * entry ) . key i ++ } return keys }
1685	func StartDefaultTerminationHandler ( saver statemanager . Saver , taskEngine engine . TaskEngine ) { signalChannel := make ( chan os . Signal , 2 ) signal . Notify ( signalChannel , os . Interrupt , syscall . SIGTERM ) sig := <- signalChannel seelog . Debugf ( "Termination handler received termination signal: %s" , sig . String ( ) ) err := FinalSave ( saver , taskEngine ) if err != nil { seelog . Criticalf ( "Error saving state before final shutdown: %v" , err ) os . Exit ( exitcodes . ExitTerminal ) } os . Exit ( exitcodes . ExitSuccess ) }
6067	func ( c * Client ) Offering ( hash data . HexString ) ( data . Base64String , error ) { return c . requestWithPayload ( "api_offering" , string ( hash ) ) }
1226	func ( ts * TaskStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if ts == nil { return nil , nil } return [ ] byte ( `"` + ts . String ( ) + `"` ) , nil }
3415	func ( o * Options ) HasEscalationMessage ( ) bool { if o != nil && o . EscalationMessage != nil { return true } return false }
4567	func ( h HelperContext ) Render ( s string ) ( string , error ) { return Render ( s , h . Context ) }
2430	func RotateGeo ( theta float64 ) GeoM { g := GeoM { } g . Rotate ( theta ) return g }
4248	func NeighborIntWithPrecision ( hash uint64 , bits uint , direction Direction ) uint64 { return NeighborsIntWithPrecision ( hash , bits ) [ direction ] }
516	func ( h * ResponseHeader ) Peek ( key string ) [ ] byte { k := getHeaderKeyBytes ( & h . bufKV , key , h . disableNormalizing ) return h . peek ( k ) }
1536	func WriteJSONToResponse ( w http . ResponseWriter , httpStatusCode int , responseJSON [ ] byte , requestType string ) { w . Header ( ) . Set ( "Content-Type" , "application/json" ) w . WriteHeader ( httpStatusCode ) _ , err := w . Write ( responseJSON ) if err != nil { seelog . Errorf ( "Unable to write %s json response message to ResponseWriter" , requestType ) } }
6235	func New ( db * reform . DB , logger log . Logger , payAddr string , timeout uint ) ( * Service , error ) { return & Service { db : db , msgChan : make ( chan * req ) , payAddr : payAddr , timeout : time . Duration ( timeout ) * time . Millisecond , logger : logger . Add ( "type" , "messages/ept.Service" ) , } , nil }
2199	func Local ( input string ) string { cstr := C . CString ( input ) defer C . free ( unsafe . Pointer ( cstr ) ) return C . GoString ( C . localize ( cstr ) ) }
6656	func NewRay ( o , v Vec ) Ray { return Ray { o : o , v : v , invv : Vec { 1.0 / v . X , 1.0 / v . Y } , } }
4872	func ( f * ParameterField ) SetLobReader ( rd io . Reader ) error { f . chunkReader = newLobChunkReader ( f . TypeCode ( ) . isCharBased ( ) , rd ) return nil }
2144	func NewMatrix ( xx , yx , xy , yy , x0 , y0 float64 ) * Matrix { return & Matrix { Xx : xx , Yx : yx , Xy : xy , Yy : yy , X0 : x0 , Y0 : y0 , } }
3821	func ( s * Server ) Announce ( infoHash [ 20 ] byte , port int , impliedPort bool ) ( * Announce , error ) { startAddrs , err := s . traversalStartingNodes ( ) if err != nil { return nil , err } a := & Announce { Peers : make ( chan PeersValues , 100 ) , values : make ( chan PeersValues ) , triedAddrs : newBloomFilterForTraversal ( ) , server : s , infoHash : int160FromByteArray ( infoHash ) , announcePort : port , announcePortImplied : impliedPort , contactRateLimiter : make ( chan struct { } , 10 ) , } a . ctx , a . cancel = context . WithCancel ( context . Background ( ) ) a . stop = a . ctx . Done ( ) a . nodesPendingContact . target = int160FromByteArray ( infoHash ) a . nodeContactorCond . L = & a . mu go a . rateUnlimiter ( ) go func ( ) { defer close ( a . Peers ) for { select { case psv := <- a . values : select { case a . Peers <- psv : case <- a . stop : return } case <- a . stop : return } } } ( ) for _ , n := range startAddrs { a . pendContact ( n ) } a . maybeClose ( ) go a . nodeContactor ( ) return a , nil }
6497	func ( o OAuth ) NewTokensFromRequest ( req * http . Request ) ( * oauthTokens , error ) { query := req . URL . Query ( ) code := query . Get ( "code" ) return o . GetTokens ( code , "authorization_code" ) }
1401	func ( lh LoggingHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { seelog . Debug ( "Handling http request" , "method" , r . Method , "from" , r . RemoteAddr ) lh . h . ServeHTTP ( w , r ) }
4331	func ( c * Client ) Gauge ( bucket string , value interface { } ) { if c . skip ( ) { return } c . conn . gauge ( c . prefix , bucket , value , c . tags ) }
5476	func NewPhoneNumber ( pn string ) ( PhoneNumber , error ) { if len ( pn ) == 0 { return "" , ErrEmptyNumber } num , err := libphonenumber . Parse ( pn , "US" ) switch { case err == libphonenumber . ErrNotANumber : return "" , fmt . Errorf ( "twilio: Invalid phone number: %s" , pn ) case err == libphonenumber . ErrInvalidCountryCode : return "" , fmt . Errorf ( "twilio: Invalid country code for number: %s" , pn ) case err != nil : return "" , err } return PhoneNumber ( libphonenumber . Format ( num , libphonenumber . E164 ) ) , nil }
1984	func ( m * MockClient ) Ping ( arg0 context . Context ) ( types . Ping , error ) { ret := m . ctrl . Call ( m , "Ping" , arg0 ) ret0 , _ := ret [ 0 ] . ( types . Ping ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1629	func ( manager * metadataManager ) parseMetadata ( dockerContainer * types . ContainerJSON , task * apitask . Task , containerName string ) Metadata { dockerMD := parseDockerContainerMetadata ( task . Arn , containerName , dockerContainer ) return Metadata { cluster : manager . cluster , taskMetadata : TaskMetadata { containerName : containerName , taskARN : task . Arn , taskDefinitionFamily : task . Family , taskDefinitionRevision : task . Version , } , dockerContainerMetadata : dockerMD , containerInstanceARN : manager . containerInstanceARN , metadataStatus : MetadataReady , availabilityZone : manager . availabilityZone , hostPublicIPv4Address : manager . hostPublicIPv4Address , } }
4325	func ( c * Client ) CreateCheckoutKey ( account , repo , keyType string ) ( * CheckoutKey , error ) { checkoutKey := & CheckoutKey { } body := struct { KeyType string `json:"type"` } { KeyType : keyType } err := c . request ( "POST" , fmt . Sprintf ( "project/%s/%s/checkout-key" , account , repo ) , checkoutKey , nil , body ) if err != nil { return nil , err } return checkoutKey , nil }
3488	func ( s * ScatterplotDefinition ) GetXaxis ( ) WidgetAxis { if s == nil || s . Xaxis == nil { return WidgetAxis { } } return * s . Xaxis }
2863	func parseVersion ( name , version , build string ) ( VSphereVersion , error ) { v := VSphereVersion { Product : name , } s := strings . Split ( version , "." ) if len ( s ) > 3 { return v , fmt . Errorf ( "version string %q has more than 3 components" , version ) } var err error v . Major , err = strconv . Atoi ( s [ 0 ] ) if err != nil { return v , fmt . Errorf ( "could not parse major version %q from version string %q" , s [ 0 ] , version ) } v . Minor , err = strconv . Atoi ( s [ 1 ] ) if err != nil { return v , fmt . Errorf ( "could not parse minor version %q from version string %q" , s [ 1 ] , version ) } v . Patch , err = strconv . Atoi ( s [ 2 ] ) if err != nil { return v , fmt . Errorf ( "could not parse patch version %q from version string %q" , s [ 2 ] , version ) } v . Build , err = strconv . Atoi ( build ) if err != nil { return v , fmt . Errorf ( "could not parse build version string %q" , build ) } return v , nil }
3822	func ( a * Announce ) maybeAnnouncePeer ( to Addr , token * string , peerId * krpc . ID ) { if token == nil { return } if ! a . server . config . NoSecurity && ( peerId == nil || ! NodeIdSecure ( * peerId , to . IP ( ) ) ) { return } a . server . mu . Lock ( ) defer a . server . mu . Unlock ( ) a . server . announcePeer ( to , a . infoHash , a . announcePort , * token , a . announcePortImplied , nil ) }
2756	func getWithRestart ( d * schema . ResourceData , key string ) interface { } { if d . HasChange ( key ) { log . Printf ( "[DEBUG] %s: Resource argument %q requires a VM restart" , resourceVSphereVirtualMachineIDString ( d ) , key ) d . Set ( "reboot_required" , true ) } return d . Get ( key ) }
7138	func ( cn * ContentNegotiator ) AddEncoder ( mimeType string , enc Encoder ) { if cn . encoderMap == nil { cn . encoderMap = make ( map [ string ] Encoder ) } cn . encoderMap [ mimeType ] = enc }
2270	func ( v * RadioMenuItem ) native ( ) * C . GtkRadioMenuItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRadioMenuItem ( p ) }
3572	func ( t * ThresholdCount ) GetCriticalRecoveryOk ( ) ( json . Number , bool ) { if t == nil || t . CriticalRecovery == nil { return "" , false } return * t . CriticalRecovery , true }
4224	func Patch ( old io . Reader , new io . Writer , patch io . Reader ) error { var hdr header err := binary . Read ( patch , signMagLittleEndian { } , & hdr ) if err != nil { return err } if hdr . Magic != magic { return ErrCorrupt } if hdr . CtrlLen < 0 || hdr . DiffLen < 0 || hdr . NewSize < 0 { return ErrCorrupt } ctrlbuf := make ( [ ] byte , hdr . CtrlLen ) _ , err = io . ReadFull ( patch , ctrlbuf ) if err != nil { return err } cpfbz2 := bzip2 . NewReader ( bytes . NewReader ( ctrlbuf ) ) diffbuf := make ( [ ] byte , hdr . DiffLen ) _ , err = io . ReadFull ( patch , diffbuf ) if err != nil { return err } dpfbz2 := bzip2 . NewReader ( bytes . NewReader ( diffbuf ) ) epfbz2 := bzip2 . NewReader ( patch ) obuf , err := ioutil . ReadAll ( old ) if err != nil { return err } nbuf := make ( [ ] byte , hdr . NewSize ) var oldpos , newpos int64 for newpos < hdr . NewSize { var ctrl struct { Add , Copy , Seek int64 } err = binary . Read ( cpfbz2 , signMagLittleEndian { } , & ctrl ) if err != nil { return err } if newpos + ctrl . Add > hdr . NewSize { return ErrCorrupt } _ , err = io . ReadFull ( dpfbz2 , nbuf [ newpos : newpos + ctrl . Add ] ) if err != nil { return ErrCorrupt } for i := int64 ( 0 ) ; i < ctrl . Add ; i ++ { if oldpos + i >= 0 && oldpos + i < int64 ( len ( obuf ) ) { nbuf [ newpos + i ] += obuf [ oldpos + i ] } } newpos += ctrl . Add oldpos += ctrl . Add if newpos + ctrl . Copy > hdr . NewSize { return ErrCorrupt } _ , err = io . ReadFull ( epfbz2 , nbuf [ newpos : newpos + ctrl . Copy ] ) if err != nil { return ErrCorrupt } newpos += ctrl . Copy oldpos += ctrl . Seek } for len ( nbuf ) > 0 { n , err := new . Write ( nbuf ) if err != nil { return err } nbuf = nbuf [ n : ] } return nil }
4566	func ( t * Template ) Clone ( ) * Template { t2 := & Template { Input : t . Input , program : t . program , } return t2 }
2058	func NewContainerResponse ( dockerContainer * apicontainer . DockerContainer , eni * apieni . ENI ) ContainerResponse { container := dockerContainer . Container resp := ContainerResponse { Name : container . Name , DockerID : dockerContainer . DockerID , DockerName : dockerContainer . DockerName , } resp . Ports = NewPortBindingsResponse ( dockerContainer , eni ) resp . Volumes = NewVolumesResponse ( dockerContainer ) if eni != nil { resp . Networks = [ ] containermetadata . Network { { NetworkMode : utils . NetworkModeAWSVPC , IPv4Addresses : eni . GetIPV4Addresses ( ) , IPv6Addresses : eni . GetIPV6Addresses ( ) , } , } } return resp }
6728	func ToFile ( src , dest string , options FileOptions ) error { u , err := url . Parse ( src ) if err != nil { return errors . Wrap ( err , "invalid src URL" ) } targetDir := filepath . Dir ( dest ) if err = createDir ( targetDir , options . Mkdirs == nil || * options . Mkdirs ) ; err != nil { return err } targetName := filepath . Base ( dest ) f , err := ioutil . TempFile ( targetDir , ".tmp-" + targetName ) if err != nil { return errors . Wrap ( err , "failed to create temp file" ) } err = downloadFile ( u , f , options . Options ) if err != nil { _ = f . Close ( ) _ = os . Remove ( f . Name ( ) ) return errors . Wrap ( err , "failed to download" ) } err = f . Close ( ) if err != nil { _ = os . Remove ( f . Name ( ) ) return errors . Wrap ( err , "failed to close temp file" ) } if err = renameFile ( f . Name ( ) , dest ) ; err != nil { return err } return nil }
311	func FromQuery ( req * prompb . Query ) ( int64 , int64 , [ ] * labels . Matcher , * storage . SelectParams , error ) { matchers , err := fromLabelMatchers ( req . Matchers ) if err != nil { return 0 , 0 , nil , nil , err } var selectParams * storage . SelectParams if req . Hints != nil { selectParams = & storage . SelectParams { Start : req . Hints . StartMs , End : req . Hints . EndMs , Step : req . Hints . StepMs , Func : req . Hints . Func , } } return req . StartTimestampMs , req . EndTimestampMs , matchers , selectParams , nil }
3087	func ( ctx * Context ) GetCookieInt64 ( name string ) int64 { return com . StrTo ( ctx . GetCookie ( name ) ) . MustInt64 ( ) }
4322	func ( c * Client ) AddSSHKey ( account , repo , hostname , privateKey string ) error { key := & struct { Hostname string `json:"hostname"` PrivateKey string `json:"private_key"` } { hostname , privateKey } return c . request ( "POST" , fmt . Sprintf ( "project/%s/%s/ssh-key" , account , repo ) , nil , nil , key ) }
7080	func NewMulti ( vals ... interface { } ) LogBackend { if len ( vals ) % 2 != 0 { Fail ( e . New ( "parameters must be in pair of LogBackend and Formatter" ) ) return nil } l := len ( vals ) / 2 mp := make ( [ ] LogBackend , 0 , l ) for i := 0 ; i < len ( vals ) ; i += 2 { bak , ok := vals [ i ] . ( LogBackend ) if ! ok { Fail ( e . New ( "not a LogBackend" ) ) return nil } f , ok := vals [ i + 1 ] . ( Formatter ) if ! ok { Fail ( e . New ( "not a Formatter" ) ) return nil } bak . F ( f ) mp = append ( mp , bak ) } return & MultiLog { mp : mp , } }
1327	func ( m * MockEC2MetadataClient ) DefaultCredentials ( ) ( * ec2 . RoleCredentials , error ) { ret := m . ctrl . Call ( m , "DefaultCredentials" ) ret0 , _ := ret [ 0 ] . ( * ec2 . RoleCredentials ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1500	func ( c * Container ) ShouldCreateWithASMSecret ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) if c . Secrets == nil { return false } for _ , secret := range c . Secrets { if secret . Provider == SecretProviderASM { return true } } return false }
103	func targetsFromGroup ( tg * targetgroup . Group , cfg * config . ScrapeConfig ) ( [ ] * Target , error ) { targets := make ( [ ] * Target , 0 , len ( tg . Targets ) ) for i , tlset := range tg . Targets { lbls := make ( [ ] labels . Label , 0 , len ( tlset ) + len ( tg . Labels ) ) for ln , lv := range tlset { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } for ln , lv := range tg . Labels { if _ , ok := tlset [ ln ] ; ! ok { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } } lset := labels . New ( lbls ... ) lbls , origLabels , err := populateLabels ( lset , cfg ) if err != nil { return nil , errors . Wrapf ( err , "instance %d in group %s" , i , tg ) } if lbls != nil || origLabels != nil { targets = append ( targets , NewTarget ( lbls , origLabels , cfg . Params ) ) } } return targets , nil }
820	func ( d * Driver ) Stop ( ) error { cs := d . client ( ) _ , err := cs . RequestWithContext ( context . TODO ( ) , & egoscale . StopVirtualMachine { ID : d . ID , } ) return err }
5863	func ( a * API ) FetchContactGroups ( ) ( * [ ] ContactGroup , error ) { result , err := a . Get ( config . ContactGroupPrefix ) if err != nil { return nil , err } var groups [ ] ContactGroup if err := json . Unmarshal ( result , & groups ) ; err != nil { return nil , err } return & groups , nil }
889	func NewDriver ( machineName string , storePath string ) * Driver { return & Driver { Zone : defaultZone , DiskType : defaultDiskType , DiskSize : defaultDiskSize , MachineType : defaultMachineType , MachineImage : defaultImageName , Network : defaultNetwork , Subnetwork : defaultSubnetwork , ServiceAccount : defaultServiceAccount , Scopes : defaultScopes , BaseDriver : & drivers . BaseDriver { SSHUser : defaultUser , MachineName : machineName , StorePath : storePath , } , } }
1293	func NewECRFactory ( acceptInsecureCert bool ) ECRFactory { return & ecrFactory { httpClient : httpclient . New ( roundtripTimeout , acceptInsecureCert ) , } }
434	func ( ctx * RequestCtx ) FormFile ( key string ) ( * multipart . FileHeader , error ) { mf , err := ctx . MultipartForm ( ) if err != nil { return nil , err } if mf . File == nil { return nil , err } fhh := mf . File [ key ] if fhh == nil { return nil , ErrMissingFile } return fhh [ 0 ] , nil }
4622	func NewWithAlphabet ( abc string ) string { enc := base57 { newAlphabet ( abc ) } return enc . Encode ( uuid . New ( ) ) }
6551	func NewDataReader ( r io . Reader ) ( * Data , error ) { d := newData ( ) d . r = r d . cbs . read = C . gpgme_data_read_cb_t ( C . gogpgme_readfunc ) cbc := callbackAdd ( d ) d . cbc = cbc return d , handleError ( C . gogpgme_data_new_from_cbs ( & d . dh , & d . cbs , C . uintptr_t ( cbc ) ) ) }
1275	func ( m * MockManager ) GetTaskCredentials ( arg0 string ) ( credentials . TaskIAMRoleCredentials , bool ) { ret := m . ctrl . Call ( m , "GetTaskCredentials" , arg0 ) ret0 , _ := ret [ 0 ] . ( credentials . TaskIAMRoleCredentials ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 }
2802	func Reconfigure ( cluster * object . ClusterComputeResource , spec * types . ClusterConfigSpecEx ) error { return computeresource . Reconfigure ( cluster , spec ) }
3724	func ( w * Widget ) GetTileDef ( ) TileDef { if w == nil || w . TileDef == nil { return TileDef { } } return * w . TileDef }
2425	func ( g * GeoM ) Concat ( other GeoM ) { a := ( other . a_1 + 1 ) * ( g . a_1 + 1 ) + other . b * g . c b := ( other . a_1 + 1 ) * g . b + other . b * ( g . d_1 + 1 ) tx := ( other . a_1 + 1 ) * g . tx + other . b * g . ty + other . tx c := other . c * ( g . a_1 + 1 ) + ( other . d_1 + 1 ) * g . c d := other . c * g . b + ( other . d_1 + 1 ) * ( g . d_1 + 1 ) ty := other . c * g . tx + ( other . d_1 + 1 ) * g . ty + other . ty g . a_1 = a - 1 g . b = b g . c = c g . d_1 = d - 1 g . tx = tx g . ty = ty }
1515	func validateCgroupSpec ( cgroupSpec * Spec ) error { if cgroupSpec == nil { return errors . New ( "cgroup spec validator: empty cgroup spec" ) } if cgroupSpec . Root == "" { return errors . New ( "cgroup spec validator: invalid cgroup root" ) } if cgroupSpec . Specs == nil { return errors . New ( "cgroup spec validator: empty linux resource spec" ) } return nil }
5458	func ( cvps * CountryVoicePriceService ) GetPage ( ctx context . Context , data url . Values ) ( * CountriesPricePage , error ) { return cvps . GetPageIterator ( data ) . Next ( ctx ) }
3383	func ( l * LogSet ) GetID ( ) json . Number { if l == nil || l . ID == nil { return "" } return * l . ID }
6208	func IsUUID ( s string ) bool { _ , err := uuid . FromString ( s ) return err == nil }
2411	func JustPressedTouchIDs ( ) [ ] int { var ids [ ] int theInputState . m . RLock ( ) for id , s := range theInputState . touchDurations { if s == 1 { ids = append ( ids , id ) } } theInputState . m . RUnlock ( ) sort . Ints ( ids ) return ids }
6824	func NewEventLog ( family , title string ) xtr . EventLog { e := & EventLog { family : family , title : title , el : xtr . NewEventLog ( family , title ) , } return e }
6077	func ( h * Handler ) GetObject ( tkn , objectType , id string ) ( json . RawMessage , error ) { logger := h . logger . Add ( "method" , "GetObject" , "type" , objectType , "id" , id ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } table , ok := objectTypes [ objectType ] if ! ok { logger . Warn ( ErrBadObjectType . Error ( ) ) return nil , ErrBadObjectType } obj , err := h . db . FindByPrimaryKeyFrom ( table , id ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrObjectNotFound } raw , err := json . Marshal ( obj ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrInternal } return raw , nil }
84	func extractTimeRange ( min , max * time . Time ) ( mint , maxt time . Time , err error ) { if min == nil { mint = minTime } else { mint = * min } if max == nil { maxt = maxTime } else { maxt = * max } if mint . After ( maxt ) { return mint , maxt , errors . Errorf ( "min time must be before or equal to max time" ) } return mint , maxt , nil }
4631	func ( t TextStyle ) TextStyle ( val string ) string { if t == emptyTextStyle { return val } return fmt . Sprintf ( "%s%s%s" , t . start , val , t . stop ) }
3667	func ( w * Widget ) GetHTML ( ) string { if w == nil || w . HTML == nil { return "" } return * w . HTML }
5421	func ( is IdentifierSlice ) Swap ( i , j int ) { is [ i ] , is [ j ] = is [ j ] , is [ i ] }
5697	func options ( ) [ ] demangle . Option { var options [ ] demangle . Option if * noParams { options = append ( options , demangle . NoParams ) } if ! * noVerbose { options = append ( options , demangle . Verbose ) } return options }
6916	func ( s * Session ) NextEvent ( channel NotificationsChannel , lastEventID string ) * Error { currentURL := s . URL + "/events" if lastEventID != "" { currentURL += "?uuid=" + lastEventID } request , err := http . NewRequest ( "GET" , currentURL , nil ) if err != nil { return NewBambouError ( "HTTP transaction error" , err . Error ( ) ) } response , berr := s . send ( request , nil ) if berr != nil { return berr } defer response . Body . Close ( ) notification := NewNotification ( ) if err := json . NewDecoder ( response . Body ) . Decode ( notification ) ; err != nil { return NewBambouError ( "JSON error" , err . Error ( ) ) } if len ( notification . Events ) > 0 { channel <- notification } return nil }
6380	func ( iter Enumerator ) Reverse ( ) Enumerator { cache := NewStack ( ) for entry := range iter { cache . Push ( entry ) } retval := make ( chan interface { } ) go func ( ) { for ! cache . IsEmpty ( ) { val , _ := cache . Pop ( ) retval <- val } close ( retval ) } ( ) return retval }
254	func ( n * Manager ) ApplyConfig ( conf * config . Config ) error { n . mtx . Lock ( ) defer n . mtx . Unlock ( ) n . opts . ExternalLabels = conf . GlobalConfig . ExternalLabels n . opts . RelabelConfigs = conf . AlertingConfig . AlertRelabelConfigs amSets := make ( map [ string ] * alertmanagerSet ) for _ , cfg := range conf . AlertingConfig . AlertmanagerConfigs { ams , err := newAlertmanagerSet ( cfg , n . logger ) if err != nil { return err } ams . metrics = n . metrics b , err := json . Marshal ( cfg ) if err != nil { return err } amSets [ fmt . Sprintf ( "%x" , md5 . Sum ( b ) ) ] = ams } n . alertmanagers = amSets return nil }
3929	func Dereference ( T types . Type ) types . Type { if p , ok := T . Underlying ( ) . ( * types . Pointer ) ; ok { return p . Elem ( ) } return T }
3485	func ( r * Rule ) GetThreshold ( ) json . Number { if r == nil || r . Threshold == nil { return "" } return * r . Threshold }
2253	func ( v * Image ) native ( ) * C . GtkImage { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkImage ( p ) }
3781	func ( client * Client ) GetHostTags ( host , source string ) ( [ ] string , error ) { var out reqGetHostTags uri := "/v1/tags/hosts/" + host if source != "" { uri += "?source=" + source } if err := client . doJsonRequest ( "GET" , uri , nil , & out ) ; err != nil { return nil , err } return out . Tags , nil }
2533	func expandClusterHostGroup ( d * schema . ResourceData , name string ) ( * types . ClusterHostGroup , error ) { obj := & types . ClusterHostGroup { ClusterGroupInfo : types . ClusterGroupInfo { Name : name , UserCreated : structure . BoolPtr ( true ) , } , Host : structure . SliceInterfacesToManagedObjectReferences ( d . Get ( "host_system_ids" ) . ( * schema . Set ) . List ( ) , "HostSystem" ) , } return obj , nil }
2244	func ( v * Expander ) native ( ) * C . GtkExpander { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkExpander ( p ) }
179	func NewAlertingRule ( name string , vec promql . Expr , hold time . Duration , labels , annotations , externalLabels labels . Labels , restored bool , logger log . Logger , ) * AlertingRule { el := make ( map [ string ] string , len ( externalLabels ) ) for _ , lbl := range externalLabels { el [ lbl . Name ] = lbl . Value } return & AlertingRule { name : name , vector : vec , holdDuration : hold , labels : labels , annotations : annotations , externalLabels : el , health : HealthUnknown , active : map [ uint64 ] * Alert { } , logger : logger , restored : restored , } }
2896	func resourceVSphereDatastoreClusterVMAntiAffinityRuleFlattenID ( pod * object . StoragePod , key int32 ) ( string , error ) { podID := pod . Reference ( ) . Value return strings . Join ( [ ] string { podID , strconv . Itoa ( int ( key ) ) } , ":" ) , nil }
6095	func ( h * Handler ) GetChannelsUsage ( tkn string , ids [ ] string ) ( map [ string ] Usage , error ) { logger := h . logger . Add ( "method" , "GetChannelsUsage" , "objectType" , "channel" , "objectIDs" , ids ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } return h . getChannelsUsages ( logger , ids ) }
423	func ServeTLS ( ln net . Listener , certFile , keyFile string , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ServeTLS ( ln , certFile , keyFile ) }
502	func ( h * RequestHeader ) SetMethod ( method string ) { h . method = append ( h . method [ : 0 ] , method ... ) }
5560	func ( lo * largeObject ) abort ( ) { objects , err := lo . c . ObjectNamesAll ( lo . container , nil ) if err != nil { lo . logger . Error ( swiftLargeObjectLogTag , fmt . Sprintf ( "Return all multipart objects: %v\n" , \n ) ) err } return for _ , object := range objects { if strings . HasPrefix ( object , lo . objectName + "/" + lo . timestamp + "/" ) { err = lo . c . ObjectDelete ( lo . container , object ) if err != nil { lo . logger . Error ( swiftLargeObjectLogTag , fmt . Sprintf ( "Delete the multipart objects: %v\n" , \n ) ) } } } }
1567	func ( auth * ASMAuthData ) GetDockerAuthConfig ( ) types . AuthConfig { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . dockerAuthConfig }
3227	func ( a * APIKey ) HasKey ( ) bool { if a != nil && a . Key != nil { return true } return false }
3299	func ( e * Event ) GetAlertTypeOk ( ) ( string , bool ) { if e == nil || e . AlertType == nil { return "" , false } return * e . AlertType , true }
223	func ( m * Manager ) ApplyConfig ( cfg map [ string ] sd_config . ServiceDiscoveryConfig ) error { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) for pk := range m . targets { if _ , ok := cfg [ pk . setName ] ; ! ok { discoveredTargets . DeleteLabelValues ( m . name , pk . setName ) } } m . cancelDiscoverers ( ) for name , scfg := range cfg { m . registerProviders ( scfg , name ) discoveredTargets . WithLabelValues ( m . name , name ) . Set ( 0 ) } for _ , prov := range m . providers { m . startProvider ( m . ctx , prov ) } return nil }
338	func fileSource ( filename string , i int ) string { return fmt . Sprintf ( "%s:%d" , filename , i ) }
6003	func JsonArray ( data [ ] byte ) ( [ ] Typed , error ) { var m [ ] interface { } err := json . Unmarshal ( data , & m ) if err != nil { return nil , err } l := len ( m ) if l == 0 { return nil , nil } typed := make ( [ ] Typed , l ) for i := 0 ; i < l ; i ++ { value := m [ i ] if t , ok := value . ( map [ string ] interface { } ) ; ok { typed [ i ] = t } else { typed [ i ] = map [ string ] interface { } { "0" : value } } } return typed , nil }
5442	func ( t Trigger ) Handle ( b * Bot , m * Message ) bool { return t . Condition ( b , m ) && t . Action ( b , m ) }
3830	func MustParse ( s string ) UUID { uuid , err := Parse ( s ) if err != nil { panic ( `uuid: Parse(` + s + `): ` + err . Error ( ) ) } return uuid }
3649	func ( t * TriggeringValue ) GetFromTs ( ) int { if t == nil || t . FromTs == nil { return 0 } return * t . FromTs }
2703	func ( c * Config ) restSessionFile ( ) ( string , error ) { p , err := c . sessionFile ( ) if err != nil { return "" , err } return filepath . Join ( c . RestSessionPath , p ) , nil }
7003	func NewRemoteExecutor ( sshCfg SshConfig ) ( executor Executer , err error ) { clientconfig := & ssh . ClientConfig { User : sshCfg . Username , Auth : sshCfg . GetAuthMethod ( ) , HostKeyCallback : ssh . InsecureIgnoreHostKey ( ) , } remoteExecutor := & DefaultRemoteExecutor { } remoteExecutor . LazyClientDial = func ( ) { client , err := ssh . Dial ( "tcp" , fmt . Sprintf ( "%s:%d" , sshCfg . Host , sshCfg . Port ) , clientconfig ) if err != nil { lo . G . Error ( "ssh connection issue:" , err ) return } remoteExecutor . Client = NewClientWrapper ( client ) } executor = remoteExecutor return }
6124	func NewBackend ( cfg * Config , logger log . Logger ) Backend { conn , ptc , psc , err := newInstance ( cfg , logger ) if err != nil { logger . Fatal ( err . Error ( ) ) } b := & backendInstance { cfg : cfg , ptc : ptc , psc : psc , conn : conn , logger : logger , } go b . connectionControl ( ) return b }
845	func ( c * ComputeUtil ) configureInstance ( d * Driver ) error { log . Infof ( "Configuring instance" ) instance , err := c . instance ( ) if err != nil { return err } if err := c . addFirewallTag ( instance ) ; err != nil { return err } return c . uploadSSHKey ( instance , d . GetSSHKeyPath ( ) ) }
6646	func Approx ( x , y float64 ) bool { eps := epsilon64 * 100 return math . Abs ( x - y ) < eps * ( 1.0 + math . Max ( math . Abs ( x ) , math . Abs ( y ) ) ) }
6352	func DiscoverWalk ( app App , insecure discovery . InsecureOption , discoverFn DiscoverWalkFunc ) ( err error ) { var ( eps * Endpoints ) parts := strings . Split ( string ( app . Name ) , "/" ) for i := range parts { end := len ( parts ) - i pre := strings . Join ( parts [ : end ] , "/" ) eps , err = doDiscover ( pre , app , insecure ) if derr := discoverFn ( pre , eps , err ) ; derr != nil { return derr } } return }
6139	func ( b * backendInstance ) PSCSettle ( opts * bind . TransactOpts , agent common . Address , blockNumber uint32 , hash [ common . HashLength ] byte ) ( * types . Transaction , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 tx , err := b . psc . Settle ( opts , agent , blockNumber , hash ) if err != nil { err = fmt . Errorf ( "failed to settle" + " PSC channel: %s" , err ) } return tx , err }
1811	func ( m * MockDockerClient ) PullImage ( arg0 context . Context , arg1 string , arg2 * container . RegistryAuthenticationData , arg3 time . Duration ) dockerapi . DockerContainerMetadata { ret := m . ctrl . Call ( m , "PullImage" , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerContainerMetadata ) return ret0 }
2865	func ParseVersionFromClient ( client * govmomi . Client ) VSphereVersion { return parseVersionFromAboutInfo ( client . Client . ServiceContent . About ) }
1517	func NewImageManager ( cfg * config . Config , client dockerapi . DockerClient , state dockerstate . TaskEngineState ) ImageManager { return & dockerImageManager { client : client , state : state , minimumAgeBeforeDeletion : cfg . MinimumImageDeletionAge , numImagesToDelete : cfg . NumImagesToDeletePerCycle , imageCleanupTimeInterval : cfg . ImageCleanupInterval , imagePullBehavior : cfg . ImagePullBehavior , imageCleanupExclusionList : cfg . ImageCleanupExclusionList , deleteNonECSImagesEnabled : cfg . DeleteNonECSImagesEnabled , nonECSContainerCleanupWaitDuration : cfg . TaskCleanupWaitDuration , numNonECSContainersToDelete : cfg . NumNonECSContainersToDeletePerCycle , } }
5405	func AddGroup ( name string , members ... string ) ( gid int , err error ) { s := NewGShadow ( name , members ... ) if err = s . Add ( nil ) ; err != nil { return } return NewGroup ( name , members ... ) . Add ( ) }
1676	func ( auth * ASMAuthResource ) GetExecutionCredentialsID ( ) string { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . executionCredentialsID }
6267	func GetURL ( conf * Config , path string ) string { var proto = "http" if conf . TLS != nil { proto += "s" } return proto + "://" + conf . Addr + path }
275	func lexValueSequence ( l * lexer ) stateFn { switch r := l . next ( ) ; { case r == eof : return lexStatements case isSpace ( r ) : l . emit ( ItemSpace ) lexSpace ( l ) case r == '+' : l . emit ( ItemADD ) case r == '-' : l . emit ( ItemSUB ) case r == 'x' : l . emit ( ItemTimes ) case r == '_' : l . emit ( ItemBlank ) case isDigit ( r ) || ( r == '.' && isDigit ( l . peek ( ) ) ) : l . backup ( ) lexNumber ( l ) case isAlpha ( r ) : l . backup ( ) return lexKeywordOrIdentifier default : return l . errorf ( "unexpected character in series sequence: %q" , r ) } return lexValueSequence }
5917	func ( it * Iterator ) Init ( list * Skiplist ) { it . list = list it . arena = list . arena it . nd = nil it . value = 0 }
4269	func ( p Process ) Signal ( sig os . Signal ) error { if p . ops == nil { return newGenericError ( fmt . Errorf ( "invalid process" ) , ProcessNotExecuted ) } return p . ops . signal ( sig ) }
3196	func GetJsonNumberOk ( v * json . Number ) ( json . Number , bool ) { if v != nil { return * v , true } return "" , false }
1832	func ( mtask * managedTask ) handleEventError ( containerChange dockerContainerChange , currentKnownStatus apicontainerstatus . ContainerStatus ) bool { container := containerChange . container event := containerChange . event if container . ApplyingError == nil { container . ApplyingError = apierrors . NewNamedError ( event . Error ) } switch event . Status { case apicontainerstatus . ContainerPulled : if mtask . cfg . ImagePullBehavior == config . ImagePullAlwaysBehavior || mtask . cfg . ImagePullBehavior == config . ImagePullOnceBehavior { seelog . Errorf ( "Managed task [%s]: error while pulling image %s for container %s , moving task to STOPPED: %v" , mtask . Arn , container . Image , container . Name , event . Error ) mtask . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false } seelog . Errorf ( "Managed task [%s]: error while pulling container %s and image %s, will try to run anyway: %v" , mtask . Arn , container . Name , container . Image , event . Error ) return true case apicontainerstatus . ContainerStopped : return mtask . handleContainerStoppedTransitionError ( event , container , currentKnownStatus ) case apicontainerstatus . ContainerStatusNone : fallthrough case apicontainerstatus . ContainerCreated : seelog . Warnf ( "Managed task [%s]: error creating container [%s]; marking its desired status as STOPPED: %v" , mtask . Arn , container . Name , event . Error ) container . SetKnownStatus ( currentKnownStatus ) container . SetDesiredStatus ( apicontainerstatus . ContainerStopped ) return false default : seelog . Warnf ( "Managed task [%s]: error starting/provisioning container[%s]; marking its desired status as STOPPED: %v" , mtask . Arn , container . Name , event . Error ) container . SetKnownStatus ( currentKnownStatus ) container . SetDesiredStatus ( apicontainerstatus . ContainerStopped ) errorName := event . Error . ErrorName ( ) if errorName == dockerapi . DockerTimeoutErrorName || errorName == dockerapi . CannotInspectContainerErrorName { seelog . Warnf ( "Managed task [%s]: forcing container [%s] to stop" , mtask . Arn , container . Name ) go mtask . engine . transitionContainer ( mtask . Task , container , apicontainerstatus . ContainerStopped ) } return false } }
5451	func ( c * CallService ) MakeCall ( from string , to string , u * url . URL ) ( * Call , error ) { data := url . Values { } data . Set ( "From" , from ) data . Set ( "To" , to ) data . Set ( "Url" , u . String ( ) ) return c . Create ( context . Background ( ) , data ) }
7211	func GetLogger ( name string ) ( * Logger , error ) { if name == "default" { return getDefaultLogger ( ) , nil } lock . RLock ( ) logger , ok := loggers [ name ] lock . RUnlock ( ) if ! ok { return nil , fmt . Errorf ( "unknown logger %s" , name ) } return logger , nil }
896	func ( d * Driver ) Stop ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } if err := c . stopInstance ( ) ; err != nil { return err } d . IPAddress = "" return nil }
6951	func ( e * EnvVar ) SetStr ( keyVal string ) { s := strings . SplitN ( keyVal , "=" , 2 ) if len ( s ) == 2 { e . Set ( s [ 0 ] , s [ 1 ] ) } }
978	func ( d * CatalogNodesQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , Near : d . near , } ) log . Printf ( "[TRACE] %s: GET %s" , d , & url . URL { Path : "/v1/catalog/nodes" , RawQuery : opts . String ( ) , } ) n , qm , err := clients . Consul ( ) . Catalog ( ) . Nodes ( opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( "[TRACE] %s: returned %d results" , d , len ( n ) ) nodes := make ( [ ] * Node , 0 , len ( n ) ) for _ , node := range n { nodes = append ( nodes , & Node { ID : node . ID , Node : node . Node , Address : node . Address , Datacenter : node . Datacenter , TaggedAddresses : node . TaggedAddresses , Meta : node . Meta , } ) } if d . near == "" { sort . Stable ( ByNode ( nodes ) ) } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return nodes , rm , nil }
4017	func ( c * BaseControl ) Destroy ( ) { c . parent . removeChild ( c ) c . parent . SetConstraints ( 0 , 0 ) }
6787	func SendEvents ( w http . ResponseWriter , r * http . Request , channels [ ] string ) { flusher , ok := w . ( http . Flusher ) if ! ok { log . Error ( "current response %T does not implement http.Flusher, plase check your middlewares that wraps response" , w ) http . Error ( w , "streaming unsupported" , http . StatusInternalServerError ) return } closeNotifier , ok := w . ( http . CloseNotifier ) if ! ok { log . Error ( "current response %T does not implement http.CloseNotifier, plase check your middlewares that wraps response" , w ) http . Error ( w , "streaming unsupported" , http . StatusInternalServerError ) return } sub , err := pubsub . Subscribe ( channels ) if err != nil { log . Error ( "subscribe failed: %v" , err ) http . Error ( w , err . Error ( ) , http . StatusInternalServerError ) return } w . Header ( ) . Set ( "Content-Type" , "text/event-stream" ) w . Header ( ) . Set ( "Cache-Control" , "no-cache" ) w . Header ( ) . Set ( "Connection" , "keep-alive" ) var send = make ( chan [ ] byte ) var closeConn = closeNotifier . CloseNotify ( ) var heartbeatTicker = time . NewTicker ( 10 * time . Second ) var heatbeat = [ ] byte { } var stop = func ( ) { log . Info ( "SSE streaming stopped" ) heartbeatTicker . Stop ( ) sub . Close ( ) close ( send ) } go func ( ) { defer func ( ) { if err := recover ( ) ; err != nil { log . Error ( "recovered from panic: %+v" , err ) debug . PrintStack ( ) } } ( ) log . Info ( "SSE streaming started" ) for { select { case msg := <- sub . Read ( ) : var err error var data , ok = msg . ( [ ] byte ) if ! ok { data , err = json . Marshal ( msg ) if err != nil { log . Error ( "json.Marshal failed with: %+v" , err ) continue } } if len ( data ) == 0 { log . Warning ( "empty message is not allowed" ) continue } send <- data case <- sub . CloseNotify ( ) : log . Info ( "subscription closed" ) stop ( ) return case <- closeConn : stop ( ) return case <- heartbeatTicker . C : send <- heatbeat } } } ( ) for { var data , ok = <- send if ! ok { log . Info ( "connection closed, stop streaming of %v" , channels ) return } if len ( data ) == 0 { fmt . Fprint ( w , ":heartbeat signal\n\n" ) } else \n \n } }
2051	func ( m * MockIOUtil ) WriteFile ( arg0 string , arg1 [ ] byte , arg2 os . FileMode ) error { ret := m . ctrl . Call ( m , "WriteFile" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
2737	func ( p * tagDiffProcessor ) diff ( a , b [ ] string ) [ ] string { var found bool c := make ( [ ] string , 0 ) for _ , v1 := range a { for _ , v2 := range b { if v1 == v2 { found = true } } if ! found { c = append ( c , v1 ) } found = false } return c }
1926	func ( agent * ecsAgent ) initializeTaskENIDependencies ( state dockerstate . TaskEngineState , taskEngine engine . TaskEngine ) ( error , bool ) { if agent . os . Getpid ( ) == initPID { return errors . New ( "agent is not started with an init system" ) , true } if err , ok := agent . setVPCSubnet ( ) ; err != nil { return err , ok } if err := agent . verifyCNIPluginsCapabilities ( ) ; err != nil { return err , true } if _ , err := agent . pauseLoader . LoadImage ( agent . ctx , agent . cfg , agent . dockerClient ) ; err != nil { if pause . IsNoSuchFileError ( err ) || pause . UnsupportedPlatform ( err ) { return err , true } return err , false } if err := agent . startUdevWatcher ( state , taskEngine . StateChangeEvents ( ) ) ; err != nil { return err , false } return nil , false }
6580	func DisableSvcEventHandler ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "DISABLE_SVC_EVENT_HANDLER" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
5149	func ( ui * PrefixUI ) Running ( message string ) { if ui . RunningPrefix == " " { message = ui . RunningPrefix + message } else if ui . RunningPrefix != "" { message = ui . RunningPrefix + " " + message } ui . UI . Running ( message ) }
6631	func ( n * routeNode ) insertChild ( nn * routeNode ) * routeNode { if child := n . findChild ( nn ) ; child != nil { return child } if n . paramChild != nil && nn . paramNode { if n . paramChild . paramName != nn . paramName { panic ( "Param name must be same for" ) } return n . paramChild } if nn . paramNode { n . paramChild = nn } else { n . children = append ( n . children , nn ) } return nn }
589	func methodNotAllowedHandler ( w http . ResponseWriter , r * http . Request ) { w . WriteHeader ( 405 ) w . Write ( nil ) }
6222	func ( w * Worker ) ClientAfterChannelTopUp ( job * data . Job ) error { return w . afterChannelTopUp ( job , data . JobClientAfterChannelTopUp ) }
2945	func resourceVSphereDatastoreClusterApplyFolderChange ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod , ) ( * object . StoragePod , error ) { log . Printf ( "[DEBUG] %s: Applying any folder changes (old path = %q)" , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) var changed bool var err error if d . HasChange ( "folder" ) { f := d . Get ( "folder" ) . ( string ) client := meta . ( * VSphereClient ) . vimClient if err = storagepod . MoveToFolder ( client , pod , f ) ; err != nil { return nil , fmt . Errorf ( "could not move datastore cluster to folder %q: %s" , f , err ) } changed = true } if changed { pod , err = resourceVSphereDatastoreClusterGetPod ( d , meta ) if err != nil { return nil , fmt . Errorf ( "error refreshing pod after folder change: %s" , err ) } log . Printf ( "[DEBUG] %s: Folder changed, new path = %q" , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) } return pod , nil }
7163	func Compile ( sources [ ] * Source , filePath string , pkgName string , varName string , opts * Opts ) error { fs , err := Retrieve ( sources ) if err != nil { return err } if opts == nil { opts = & Opts { } } if opts . VariableComment == "" { opts . VariableComment = fmt . Sprintf ( "%s implements a http.FileSystem." , varName ) } err = vfsgen . Generate ( fs , vfsgen . Options { Filename : filePath , PackageName : pkgName , BuildTags : opts . BuildTags , VariableName : varName , VariableComment : opts . VariableComment , } ) if err != nil { return err } return nil }
3950	func ChecksumZero ( input [ ] byte ) uint32 { n := len ( input ) h32 := uint32 ( n ) if n < 16 { h32 += prime32_5 } else { v1 := prime32_1plus2 v2 := prime32_2 v3 := uint32 ( 0 ) v4 := prime32_minus1 p := 0 for n := n - 16 ; p <= n ; p += 16 { sub := input [ p : ] [ : 16 ] v1 = rol13 ( v1 + binary . LittleEndian . Uint32 ( sub [ : ] ) * prime32_2 ) * prime32_1 v2 = rol13 ( v2 + binary . LittleEndian . Uint32 ( sub [ 4 : ] ) * prime32_2 ) * prime32_1 v3 = rol13 ( v3 + binary . LittleEndian . Uint32 ( sub [ 8 : ] ) * prime32_2 ) * prime32_1 v4 = rol13 ( v4 + binary . LittleEndian . Uint32 ( sub [ 12 : ] ) * prime32_2 ) * prime32_1 } input = input [ p : ] n -= p h32 += rol1 ( v1 ) + rol7 ( v2 ) + rol12 ( v3 ) + rol18 ( v4 ) } p := 0 for n := n - 4 ; p <= n ; p += 4 { h32 += binary . LittleEndian . Uint32 ( input [ p : p + 4 ] ) * prime32_3 h32 = rol17 ( h32 ) * prime32_4 } for p < n { h32 += uint32 ( input [ p ] ) * prime32_5 h32 = rol11 ( h32 ) * prime32_1 p ++ } h32 ^= h32 >> 15 h32 *= prime32_2 h32 ^= h32 >> 13 h32 *= prime32_3 h32 ^= h32 >> 16 return h32 }
4108	func ( b * ProgressBar ) Step ( ) int { b . mtx . Lock ( ) defer b . mtx . Unlock ( ) b . value ++ if b . value > b . max { b . value = b . max } return b . value }
5974	func ( otp * HOTP ) Check ( code string ) bool { codeBytes := [ ] byte ( code ) genCode := [ ] byte ( otp . OTP ( ) ) if subtle . ConstantTimeCompare ( codeBytes , genCode ) != 1 { otp . setCounter ( otp . Counter ( ) - 1 ) return false } return true }
6980	func ( s * Server ) SendRequest ( connID string , method string , params interface { } , resHandler func ( ctx * ResCtx ) error ) ( reqID string , err error ) { if ! s . running . Load ( ) . ( bool ) { return "" , errors . New ( "use of closed server" ) } if conn , ok := s . conns . GetOk ( connID ) ; ok { reqID , err = conn . ( * Conn ) . SendRequest ( method , params , resHandler ) log . Printf ( "server: send-request: connID: %v, reqID: %v, method: %v, params: %#v, err (if any): %v" , connID , reqID , method , params , err ) return } return "" , fmt . Errorf ( "connection with requested ID: %v does not exist" , connID ) }
3064	func NewWithLogger ( out io . Writer ) * Macaron { m := & Macaron { Injector : inject . New ( ) , action : func ( ) { } , Router : NewRouter ( ) , logger : log . New ( out , "[Macaron] " , 0 ) , } m . Router . m = m m . Map ( m . logger ) m . Map ( defaultReturnHandler ( ) ) m . NotFound ( http . NotFound ) m . InternalServerError ( func ( rw http . ResponseWriter , err error ) { http . Error ( rw , err . Error ( ) , 500 ) } ) return m }
4854	func GenOLEODBC ( u * URL ) ( string , error ) { props , err := GenODBC ( u ) if err != nil { return "" , nil } return `Provider=MSDASQL.1;Extended Properties="` + props + `"` , nil }
2295	func ( v * Toolbar ) native ( ) * C . GtkToolbar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToolbar ( p ) }
1102	func base64URLDecode ( s string ) ( string , error ) { v , err := base64 . URLEncoding . DecodeString ( s ) if err != nil { return "" , errors . Wrap ( err , "base64URLDecode" ) } return string ( v ) , nil }
7055	func ( r * Router ) Platform ( pattern string , platform Platform ) { c := r . pattern ( pattern ) platform . Routes ( r . clone ( c ) ) }
4132	func ( pn * notificationRequest ) validate ( ) error { if 0 == len ( pn . Interests ) || len ( pn . Interests ) > 10 { return errors . New ( "Interests must contain between 1 and 10 interests" ) } if pn . APNS == nil && pn . GCM == nil && pn . FCM == nil { return errors . New ( "PushNotification must contain a GCM, FCM or APNS payload" ) } return nil }
1125	func add ( b , a interface { } ) ( interface { } , error ) { av := reflect . ValueOf ( a ) bv := reflect . ValueOf ( b ) switch av . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return av . Int ( ) + bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Int ( ) + int64 ( bv . Uint ( ) ) , nil case reflect . Float32 , reflect . Float64 : return float64 ( av . Int ( ) ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( "add: unknown type for %q (%T)" , bv , b ) } case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return int64 ( av . Uint ( ) ) + bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Uint ( ) + bv . Uint ( ) , nil case reflect . Float32 , reflect . Float64 : return float64 ( av . Uint ( ) ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( "add: unknown type for %q (%T)" , bv , b ) } case reflect . Float32 , reflect . Float64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return av . Float ( ) + float64 ( bv . Int ( ) ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Float ( ) + float64 ( bv . Uint ( ) ) , nil case reflect . Float32 , reflect . Float64 : return av . Float ( ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( "add: unknown type for %q (%T)" , bv , b ) } default : return nil , fmt . Errorf ( "add: unknown type for %q (%T)" , av , a ) } }
3357	func ( i * IntegrationGCPCreateRequest ) GetAuthProviderX509CertURL ( ) string { if i == nil || i . AuthProviderX509CertURL == nil { return "" } return * i . AuthProviderX509CertURL }
3903	func ( d * decoder ) prepare ( n * node , out reflect . Value ) ( newout reflect . Value , unmarshaled , good bool ) { if n . tag == yaml_NULL_TAG || n . kind == scalarNode && n . tag == "" && ( n . value == "null" || n . value == "~" || n . value == "" && n . implicit ) { return out , false , false } again := true for again { again = false if out . Kind ( ) == reflect . Ptr { if out . IsNil ( ) { out . Set ( reflect . New ( out . Type ( ) . Elem ( ) ) ) } out = out . Elem ( ) again = true } if out . CanAddr ( ) { if u , ok := out . Addr ( ) . Interface ( ) . ( Unmarshaler ) ; ok { good = d . callUnmarshaler ( n , u ) return out , true , good } } } return out , false , false }
2072	func NewMockECRClient ( ctrl * gomock . Controller ) * MockECRClient { mock := & MockECRClient { ctrl : ctrl } mock . recorder = & MockECRClientMockRecorder { mock } return mock }
1243	func ( udevWatcher * UdevWatcher ) sendENIStateChange ( mac string ) error { if mac == "" { return errors . New ( "udev watcher send ENI state change: empty mac address" ) } eni , ok := udevWatcher . agentState . ENIByMac ( mac ) if ! ok { return & unmanagedENIError { mac } } if eni . IsSent ( ) { return errors . Errorf ( "udev watcher send ENI state change: eni status already sent: %s" , eni . String ( ) ) } if eni . HasExpired ( ) { udevWatcher . agentState . RemoveENIAttachment ( eni . MACAddress ) return errors . Errorf ( "udev watcher send ENI state change: eni status expired, no longer tracking it: %s" , eni . String ( ) ) } go func ( eni * apieni . ENIAttachment ) { eni . Status = apieni . ENIAttached log . Infof ( "Emitting ENI change event for: %s" , eni . String ( ) ) udevWatcher . eniChangeEvent <- api . TaskStateChange { TaskARN : eni . TaskARN , Attachment : eni , } } ( eni ) return nil }
732	func ( p * AWSSDProvider ) CreateService ( namespaceID * string , srvName * string , ep * endpoint . Endpoint ) ( * sd . Service , error ) { log . Infof ( "Creating a new service \"%s\" in \"%s\" namespace" , \" , \" ) \" \" * srvName * namespaceID srvType := p . serviceTypeFromEndpoint ( ep ) routingPolicy := p . routingPolicyFromEndpoint ( ep ) }
6353	func DiscoverEndpoints ( app App , insecure discovery . InsecureOption ) ( out * Endpoints , attempts [ ] FailedAttempt , err error ) { out = & Endpoints { } testFn := func ( pre string , eps * Endpoints , err error ) error { if len ( out . ACIEndpoints ) != 0 || len ( out . Keys ) != 0 || len ( out . ACIPushEndpoints ) != 0 { return errEnough } return nil } err = DiscoverWalk ( app , insecure , walker ( out , & attempts , testFn ) ) if err != nil && err != errEnough { return nil , attempts , err } return out , attempts , nil }
811	func MustBeRunning ( d Driver ) error { s , err := d . GetState ( ) if err != nil { return err } if s != state . Running { return ErrHostIsNotRunning } return nil }
4654	func ( queue * queue ) PeekBack ( ) interface { } { if queue . size == 0 { return nil } return queue . elements [ ( queue . end - 1 ) % int64 ( queue . cap ) ] }
4889	func ( h * segmentHeader ) read ( rd * bufio . Reader ) error { h . segmentLength = rd . ReadInt32 ( ) h . segmentOfs = rd . ReadInt32 ( ) h . noOfParts = rd . ReadInt16 ( ) h . segmentNo = rd . ReadInt16 ( ) h . segmentKind = segmentKind ( rd . ReadInt8 ( ) ) switch h . segmentKind { default : rd . Skip ( 11 ) case skRequest : h . messageType = messageType ( rd . ReadInt8 ( ) ) h . commit = rd . ReadBool ( ) h . commandOptions = commandOptions ( rd . ReadInt8 ( ) ) rd . Skip ( 8 ) case skReply : rd . Skip ( 1 ) h . functionCode = functionCode ( rd . ReadInt16 ( ) ) rd . Skip ( 8 ) } if trace { outLogger . Printf ( "read segment header: %s" , h ) } return rd . GetError ( ) }
1261	func ( vol * VolumeResource ) setMountPoint ( mountPoint string ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . VolumeConfig . Mountpoint = mountPoint }
2947	func resourceVSphereDatastoreClusterApplyDelete ( d * schema . ResourceData , pod * object . StoragePod ) error { log . Printf ( "[DEBUG] %s: Proceeding with datastore cluster deletion" , resourceVSphereDatastoreClusterIDString ( d ) ) if err := storagepod . Delete ( pod ) ; err != nil { return err } d . SetId ( "" ) return nil }
4012	func ( c * Client ) Mutate ( ctx context . Context , m interface { } , input Input , variables map [ string ] interface { } ) error { if variables == nil { variables = map [ string ] interface { } { "input" : input } } else { variables [ "input" ] = input } return c . client . Mutate ( ctx , m , variables ) }
7087	func ( s * CORSPreflight ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { origin := HttpHeader_Origin ( ) . GetReader ( r . Header ) status := http . StatusBadRequest msg := "" defer func ( ) { w . WriteHeader ( status ) w . Write ( [ ] byte ( msg ) ) } ( ) if origin . Value != "" { if ! s . PredicateOrigin ( origin . Value ) { status = http . StatusForbidden return } method := HttpHeader_AccessControlRequestMethod ( ) . GetReader ( r . Header ) . Value header := strings . Split ( HttpHeader_AccessControlRequestHeaders ( ) . GetReader ( r . Header ) . Value , ", " ) if len ( header ) == 1 && header [ 0 ] == "" { header = [ ] string { } } if ! raiqub . StringSlice ( s . Methods ) . Exists ( method ) { msg = "Method not allowed" return } if len ( s . Headers ) == 0 { HttpHeader_AccessControlAllowHeaders ( ) . SetWriter ( w . Header ( ) ) } else { if len ( header ) > 0 && ! raiqub . StringSlice ( s . Headers ) . ExistsAllIgnoreCase ( header ) { msg = "Header not allowed" return } HttpHeader_AccessControlAllowHeaders ( ) . SetValue ( strings . Join ( s . Headers , ", " ) ) . SetWriter ( w . Header ( ) ) } HttpHeader_AccessControlAllowMethods ( ) . SetValue ( strings . Join ( s . Methods , ", " ) ) . SetWriter ( w . Header ( ) ) HttpHeader_AccessControlAllowOrigin ( ) . SetValue ( origin . Value ) . SetWriter ( w . Header ( ) ) HttpHeader_AccessControlAllowCredentials ( ) . SetValue ( strconv . FormatBool ( s . UseCredentials ) ) . SetWriter ( w . Header ( ) ) HttpHeader_AccessControlMaxAge ( ) . SetValue ( strconv . Itoa ( int ( DEFAULT_CORS_MAX_AGE ) ) ) . SetWriter ( w . Header ( ) ) status = http . StatusOK } else { status = http . StatusNotFound } }
1813	func ( m * MockDockerClient ) StopContainer ( arg0 context . Context , arg1 string , arg2 time . Duration ) dockerapi . DockerContainerMetadata { ret := m . ctrl . Call ( m , "StopContainer" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerContainerMetadata ) return ret0 }
2137	func ( v * List ) dataRaw ( ) unsafe . Pointer { return unsafe . Pointer ( v . native ( ) . data ) }
4098	func ( l * TableView ) SetSelectedRow ( row int ) { oldSelection := l . selectedRow if row >= l . rowCount { l . selectedRow = l . rowCount - 1 } else if row < - 1 { l . selectedRow = - 1 } if l . selectedRow != oldSelection { l . EnsureRowVisible ( ) l . emitSelectionChange ( ) } }
7054	func ( r * Router ) Group ( pattern string , group func ( * Router ) ) { c := r . pattern ( pattern ) group ( r . clone ( c ) ) }
2585	func WaitForGuestIP ( client * govmomi . Client , vm * object . VirtualMachine , timeout int , ignoredGuestIPs [ ] interface { } ) error { if timeout < 1 { log . Printf ( "[DEBUG] Skipping IP waiter for VM %q" , vm . InventoryPath ) return nil } log . Printf ( "[DEBUG] Waiting for an available IP address on VM %q (timeout = %dm)" , vm . InventoryPath , timeout , ) p := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) err := property . Wait ( ctx , p , vm . Reference ( ) , [ ] string { "guest.ipAddress" } , func ( pc [ ] types . PropertyChange ) bool { for _ , c := range pc { if c . Op != types . PropertyChangeOpAssign { continue } if c . Val == nil { continue } ip := net . ParseIP ( c . Val . ( string ) ) if skipIPAddrForWaiter ( ip , ignoredGuestIPs ) { continue } return true } return false } ) if err != nil { if ctx . Err ( ) == context . DeadlineExceeded { return errors . New ( "timeout waiting for an available IP address" ) } return err } log . Printf ( "[DEBUG] IP address is now available for VM %q" , vm . InventoryPath ) return nil }
4093	func ( l * TableView ) EnsureRowVisible ( ) { length := l . rowCount hgt := l . height - 3 if length <= hgt || l . selectedRow == - 1 { return } diff := l . selectedRow - l . topRow if diff >= 0 && diff < hgt { return } if diff < 0 { l . topRow = l . selectedRow } else { top := l . selectedRow - hgt + 1 if length - top > hgt { l . topRow = top } else { l . topRow = length - hgt } } }
1109	func join ( sep string , a [ ] string ) ( string , error ) { return strings . Join ( a , sep ) , nil }
5929	func PostValue ( statKey , userKey string , value float64 ) error { return DefaultReporter . PostValue ( statKey , userKey , value ) }
5667	func ( twq * TypeWithQualifiers ) printInner ( ps * printState ) { ps . writeByte ( ' ' ) ps . writeString ( strings . Join ( twq . Qualifiers , " " ) ) }
3160	func ( client * Client ) GetIntegrationPD ( ) ( * integrationPD , error ) { var out integrationPD if err := client . doJsonRequest ( "GET" , "/v1/integration/pagerduty" , nil , & out ) ; err != nil { return nil , err } return & out , nil }
6634	func main ( ) { router := r2router . NewSeeforRouter ( ) router . Before ( httpauth . SimpleBasicAuth ( "testuser" , "testpw" ) ) router . Get ( "/hello/:name" , func ( w http . ResponseWriter , r * http . Request , p r2router . Params ) { w . Write ( [ ] byte ( p . Get ( "name" ) ) ) } ) http . ListenAndServe ( "127.0.0.1:8080" , router ) }
7047	func ( r * MockReadWriteCloser ) Write ( p [ ] byte ) ( n int , err error ) { if err = r . WriteErr ; err != nil { r . BytesWritten = p n = len ( p ) } return }
1906	func ( engine * DockerTaskEngine ) updateTaskUnsafe ( task * apitask . Task , update * apitask . Task ) { managedTask , ok := engine . managedTasks [ task . Arn ] if ! ok { seelog . Criticalf ( "Task engine [%s]: ACS message for a task we thought we managed, but don't! Aborting." , task . Arn ) return } updateDesiredStatus := update . GetDesiredStatus ( ) seelog . Debugf ( "Task engine [%s]: putting update on the acs channel: [%s] with seqnum [%d]" , task . Arn , updateDesiredStatus . String ( ) , update . StopSequenceNumber ) managedTask . emitACSTransition ( acsTransition { desiredStatus : updateDesiredStatus , seqnum : update . StopSequenceNumber , } ) seelog . Debugf ( "Task engine [%s]: update taken off the acs channel: [%s] with seqnum [%d]" , task . Arn , updateDesiredStatus . String ( ) , update . StopSequenceNumber ) }
2275	func ( v * Scrollbar ) native ( ) * C . GtkScrollbar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScrollbar ( p ) }
4130	func CurrentModule ( ) ( string , error ) { if ! Mods ( ) { return CurrentPackage ( ) , nil } moddata , err := ioutil . ReadFile ( "go.mod" ) if err != nil { return "" , errors . New ( "go.mod cannot be read or does not exist while go module is enabled" ) } packagePath := modfile . ModulePath ( moddata ) if packagePath == "" { return "" , errors . New ( "go.mod is malformed" ) } return packagePath , nil }
2224	func ( v * CellRendererToggle ) native ( ) * C . GtkCellRendererToggle { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRendererToggle ( p ) }
6705	func ( c * Client ) RemoveListenersFromLoadBalancer ( loadBalancerID string , listeners [ ] LoadBalancerListener ) ( * LoadBalancer , error ) { lb := new ( LoadBalancer ) _ , err := c . MakeApiRequest ( "POST" , "/1.0/load_balancers/" + loadBalancerID + "/remove_listeners" , listeners , & lb ) if err != nil { return nil , err } return lb , nil }
3129	func ( o * Offset ) MarshalText ( ) ( [ ] byte , error ) { switch * o { case OffsetNewest : return [ ] byte ( "newest" ) , nil case OffsetOldest : return [ ] byte ( "oldest" ) , nil } return [ ] byte ( fmt . Sprintf ( "%v" , * o ) ) , nil }
584	func ( mx * Mux ) NotFoundHandler ( ) http . HandlerFunc { if mx . notFoundHandler != nil { return mx . notFoundHandler } return http . NotFound }
1119	func split ( sep , s string ) ( [ ] string , error ) { s = strings . TrimSpace ( s ) if s == "" { return [ ] string { } , nil } return strings . Split ( s , sep ) , nil }
6958	func ( s * Set ) Contains ( value interface { } ) bool { s . RLock ( ) defer s . RUnlock ( ) _ , ok := s . m [ value ] return ok }
2068	func NewMetricsClient ( api APIType , registry * prometheus . Registry ) MetricsClient { switch api { case DockerAPI : return NewGenericMetricsClient ( DockerSubsystem , registry ) case TaskEngine : return NewGenericMetricsClient ( TaskEngineSubsystem , registry ) case StateManager : return NewGenericMetricsClient ( StateManagerSubsystem , registry ) case ECSClient : return NewGenericMetricsClient ( ECSClientSubsystem , registry ) default : seelog . Error ( "Unmanaged MetricsClient cannot be created." ) return nil } }
3647	func ( t * TraceServiceDefinition ) GetSpanNameOk ( ) ( string , bool ) { if t == nil || t . SpanName == nil { return "" , false } return * t . SpanName , true }
2136	func ( v * AccelMap ) native ( ) * C . GtkAccelMap { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAccelMap ( p ) }
5274	func OptImportClear ( clear bool ) ImportOption { return func ( options * ImportOptions ) error { options . clear = clear return nil } }
1643	func ( status * MetadataStatus ) UnmarshalText ( text [ ] byte ) error { t := string ( text ) switch t { case MetadataInitialText : * status = MetadataInitial case MetadataReadyText : * status = MetadataReady default : return fmt . Errorf ( "failed unmarshalling MetadataStatus %s" , text ) } return nil }
3893	func ( b * builder ) typeSwitchStmt ( fn * Function , s * ast . TypeSwitchStmt , label * lblock ) { if s . Init != nil { b . stmt ( fn , s . Init ) } var x Value switch ass := s . Assign . ( type ) { case * ast . ExprStmt : x = b . expr ( fn , unparen ( ass . X ) . ( * ast . TypeAssertExpr ) . X ) case * ast . AssignStmt : x = b . expr ( fn , unparen ( ass . Rhs [ 0 ] ) . ( * ast . TypeAssertExpr ) . X ) } done := fn . newBasicBlock ( "typeswitch.done" ) if label != nil { label . _break = done } var default_ * ast . CaseClause for _ , clause := range s . Body . List { cc := clause . ( * ast . CaseClause ) if cc . List == nil { default_ = cc continue } body := fn . newBasicBlock ( "typeswitch.body" ) var next * BasicBlock var casetype types . Type var ti Value for _ , cond := range cc . List { next = fn . newBasicBlock ( "typeswitch.next" ) casetype = fn . Pkg . typeOf ( cond ) var condv Value if casetype == tUntypedNil { condv = emitCompare ( fn , token . EQL , x , nilConst ( x . Type ( ) ) , token . NoPos ) ti = x } else { yok := emitTypeTest ( fn , x , casetype , cc . Case ) ti = emitExtract ( fn , yok , 0 ) condv = emitExtract ( fn , yok , 1 ) } emitIf ( fn , condv , body , next ) fn . currentBlock = next } if len ( cc . List ) != 1 { ti = x } fn . currentBlock = body b . typeCaseBody ( fn , cc , ti , done ) fn . currentBlock = next } if default_ != nil { b . typeCaseBody ( fn , default_ , x , done ) } else { emitJump ( fn , done ) } fn . currentBlock = done }
4743	func StringFind ( s , token string ) ( remainder string , found bool ) { i := strings . Index ( s , token ) if i == - 1 { return s , false } return s [ i + len ( token ) : ] , true }
6735	func ( p * Peer ) PubKey ( ) crypto . PubKeyEd25519 { if p . config . AuthEnc { return p . conn . ( * SecretConnection ) . RemotePubKey ( ) } if p . NodeInfo == nil { panic ( "Attempt to get peer's PubKey before calling Handshake" ) } return p . PubKey ( ) }
3058	func virtualMachineProperties ( ctx context . Context , vm * object . VirtualMachine , keys [ ] string ) ( * mo . VirtualMachine , error ) { logger . Printf ( "[DEBUG] Fetching properties for VM %q" , vm . Name ( ) ) var props mo . VirtualMachine if err := vm . Properties ( ctx , vm . Reference ( ) , keys , & props ) ; err != nil { return nil , err } return & props , nil }
2647	func resourceVSphereComputeClusterReadCustomAttributes ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { client := meta . ( * VSphereClient ) . vimClient if customattribute . IsSupported ( client ) { log . Printf ( "[DEBUG] %s: Reading custom attributes" , resourceVSphereComputeClusterIDString ( d ) ) props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return err } customattribute . ReadFromResource ( client , props . Entity ( ) , d ) } else { log . Printf ( "[DEBUG] %s: Custom attributes unsupported on this connection, skipping" , resourceVSphereComputeClusterIDString ( d ) ) } return nil }
302	func ( sp * scrapePool ) stop ( ) { sp . cancel ( ) var wg sync . WaitGroup sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) for fp , l := range sp . loops { wg . Add ( 1 ) go func ( l loop ) { l . stop ( ) wg . Done ( ) } ( l ) delete ( sp . loops , fp ) delete ( sp . activeTargets , fp ) } wg . Wait ( ) sp . client . CloseIdleConnections ( ) }
2321	func ( v * Event ) native ( ) * C . GdkEvent { if v == nil { return nil } return v . GdkEvent }
5585	func NewAgentSettings ( agentID string , vmCID string , networksSettings NetworksSettings , env EnvSettings , agentOptions AgentOptions ) AgentSettings { agentSettings := AgentSettings { AgentID : agentID , Disks : DisksSettings { Ephemeral : "" , Persistent : map [ string ] PersistentSettings { } , } , Blobstore : BlobstoreSettings { Provider : agentOptions . Blobstore . Provider , Options : agentOptions . Blobstore . Options , } , Env : EnvSettings ( env ) , Mbus : agentOptions . Mbus , Networks : networksSettings , Ntp : agentOptions . Ntp , VM : VMSettings { Name : vmCID , } , } return agentSettings }
5485	func ( c * Client ) MakeRequest ( ctx context . Context , method string , pathPart string , data url . Values , v interface { } ) error { if ! strings . HasPrefix ( pathPart , "/" + c . APIVersion ) { pathPart = c . FullPath ( pathPart ) } rb := new ( strings . Reader ) if data != nil && ( method == "POST" || method == "PUT" ) { rb = strings . NewReader ( data . Encode ( ) ) } if method == "GET" && data != nil { pathPart = pathPart + "?" + data . Encode ( ) } req , err := c . NewRequest ( method , pathPart , rb ) if err != nil { return err } req = withContext ( req , ctx ) if ua := req . Header . Get ( "User-Agent" ) ; ua == "" { req . Header . Set ( "User-Agent" , userAgent ) } else { req . Header . Set ( "User-Agent" , userAgent + " " + ua ) } return c . Do ( req , & v ) }
3089	func ( ctx * Context ) SetSecureCookie ( name , value string , others ... interface { } ) { ctx . SetSuperSecureCookie ( defaultCookieSecret , name , value , others ... ) }
596	func split ( str , sep string ) ( string , string ) { var a , b string var parts = strings . SplitN ( str , sep , 2 ) a = strings . TrimSpace ( parts [ 0 ] ) if len ( parts ) == 2 { b = strings . TrimSpace ( parts [ 1 ] ) } return a , b }
6246	func Uint64ToBytes ( x uint64 ) [ 8 ] byte { var xBytes [ 8 ] byte binary . BigEndian . PutUint64 ( xBytes [ : ] , x ) return xBytes }
5765	func ( m * CirconusMetrics ) AddGauge ( metric string , val interface { } ) { m . gm . Lock ( ) defer m . gm . Unlock ( ) v , ok := m . gauges [ metric ] if ! ok { m . gauges [ metric ] = val return } switch val . ( type ) { default : case int : m . gauges [ metric ] = v . ( int ) + val . ( int ) case int8 : m . gauges [ metric ] = v . ( int8 ) + val . ( int8 ) case int16 : m . gauges [ metric ] = v . ( int16 ) + val . ( int16 ) case int32 : m . gauges [ metric ] = v . ( int32 ) + val . ( int32 ) case int64 : m . gauges [ metric ] = v . ( int64 ) + val . ( int64 ) case uint : m . gauges [ metric ] = v . ( uint ) + val . ( uint ) case uint8 : m . gauges [ metric ] = v . ( uint8 ) + val . ( uint8 ) case uint16 : m . gauges [ metric ] = v . ( uint16 ) + val . ( uint16 ) case uint32 : m . gauges [ metric ] = v . ( uint32 ) + val . ( uint32 ) case uint64 : m . gauges [ metric ] = v . ( uint64 ) + val . ( uint64 ) case float32 : m . gauges [ metric ] = v . ( float32 ) + val . ( float32 ) case float64 : m . gauges [ metric ] = v . ( float64 ) + val . ( float64 ) } }
588	func ( mx * Mux ) updateSubRoutes ( fn func ( subMux * Mux ) ) { for _ , r := range mx . tree . routes ( ) { subMux , ok := r . SubRoutes . ( * Mux ) if ! ok { continue } fn ( subMux ) } }
1453	func ( state * DockerTaskEngineState ) TaskARNByV3EndpointID ( v3EndpointID string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) taskArn , ok := state . v3EndpointIDToTask [ v3EndpointID ] return taskArn , ok }
568	func ( mx * Mux ) Handle ( pattern string , handler http . Handler ) { mx . handle ( mALL , pattern , handler ) }
3514	func ( s * SyntheticsConfig ) GetRequest ( ) SyntheticsRequest { if s == nil || s . Request == nil { return SyntheticsRequest { } } return * s . Request }
4104	func ( l * TextView ) LoadFile ( filename string ) bool { l . lines = make ( [ ] string , 0 ) file , err := os . Open ( filename ) if err != nil { return false } defer file . Close ( ) scanner := bufio . NewScanner ( file ) for scanner . Scan ( ) { line := scanner . Text ( ) line = strings . TrimSpace ( line ) l . lines = append ( l . lines , line ) } l . applyLimit ( ) l . calculateVirtualSize ( ) if l . autoscroll { l . end ( ) } return true }
1045	func NewVaultReadQuery ( s string ) ( * VaultReadQuery , error ) { s = strings . TrimSpace ( s ) s = strings . Trim ( s , "/" ) if s == "" { return nil , fmt . Errorf ( "vault.read: invalid format: %q" , s ) } secretURL , err := url . Parse ( s ) if err != nil { return nil , err } return & VaultReadQuery { stopCh : make ( chan struct { } , 1 ) , rawPath : secretURL . Path , queryValues : secretURL . Query ( ) , } , nil }
39	func ( app app ) isContainerNet ( ) bool { return len ( app . Networks ) > 0 && app . Networks [ 0 ] . Mode == "container" }
5066	func ( r * Render ) Instance ( name string , data interface { } ) render . Render { var tpl * template . Template if r . Debug { tpl = r . loadTemplate ( name ) } else { tpl = r . Templates [ name ] } return render . HTML { Template : tpl , Data : data , } }
5211	func ( idx * Index ) Options ( row * PQLRowQuery , opts ... OptionsOption ) * PQLBaseQuery { oo := & OptionsOptions { } for _ , opt := range opts { opt ( oo ) } text := fmt . Sprintf ( "Options(%s,%s)" , row . serialize ( ) , oo . marshal ( ) ) return NewPQLBaseQuery ( text , idx , nil ) }
2648	func resourceVSphereComputeClusterGetCluster ( d structure . ResourceIDStringer , meta interface { } , ) ( * object . ClusterComputeResource , error ) { log . Printf ( "[DEBUG] %s: Fetching ComputeClusterResource object from resource ID" , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return nil , err } return clustercomputeresource . FromID ( client , d . Id ( ) ) }
6220	func ( w * Worker ) ClientPreUncooperativeClose ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientPreUncooperativeClose" , "job" , job ) err := w . db . SelectOneTo ( & data . Job { } , "WHERE related_id=$1 AND related_type=$2 AND type=$3" , job . RelatedID , job . RelatedType , data . JobClientAfterCooperativeClose ) if err == nil { job . Status = data . JobCanceled w . db . Save ( job ) return nil } ch , err := w . relatedChannel ( logger , job , data . JobClientPreUncooperativeClose ) if err != nil { return err } if ch . ChannelStatus == data . ChannelClosedCoop { logger . Warn ( "channel closed cooperatively" ) return nil } logger = logger . Add ( "channel" , ch ) agent , err := data . HexToAddress ( ch . Agent ) if err != nil { logger . Error ( err . Error ( ) ) return ErrParseEthAddr } client , err := data . HexToAddress ( ch . Client ) if err != nil { logger . Error ( err . Error ( ) ) return ErrParseEthAddr } acc , err := w . account ( logger , ch . Client ) if err != nil { return err } offer , err := w . offering ( logger , ch . Offering ) if err != nil { return err } offerHash , err := data . HexToHash ( offer . Hash ) if err != nil { logger . Error ( err . Error ( ) ) return ErrParseOfferingHash } ctx , cancel := context . WithCancel ( context . Background ( ) ) defer cancel ( ) blocks , err := w . blocksTillChallangeEnd ( ctx , logger , client , agent , ch . Block , offerHash ) if err != nil { return err } if blocks > 0 { logger . Add ( "blocksTillChallangeEnd" , blocks ) . Warn ( "in challange period" ) return ErrChallengePeriodIsNotOver } tx , err := w . settle ( ctx , logger , acc , agent , ch . Block , offerHash ) if err != nil { return err } if err := w . saveEthTX ( logger , job , tx , "Settle" , data . JobChannel , ch . ID , acc . EthAddr , data . HexFromBytes ( w . pscAddr . Bytes ( ) ) ) ; err != nil { return err } ch . ChannelStatus = data . ChannelWaitUncoop return w . saveRecord ( logger , w . db . Querier , ch ) }
905	func ( d * Driver ) GetState ( ) ( state . State , error ) { if err := d . checkLegacyDriver ( true ) ; err != nil { return state . None , err } c , err := d . newAzureClient ( ) if err != nil { return state . None , err } powerState , err := c . GetVirtualMachinePowerState ( d . ResourceGroup , d . naming ( ) . VM ( ) ) if err != nil { return state . None , err } machineState := machineStateForVMPowerState ( powerState ) log . Debugf ( "Determined Azure PowerState=%q, docker-machine state=%q" , powerState , machineState ) return machineState , nil }
5425	func ( g * Group ) Add ( memberChannel chan interface { } ) * Member { g . memberLock . Lock ( ) g . clockLock . Lock ( ) member := & Member { group : g , Read : memberChannel , clock : g . clock , messageQueue : PriorityQueue { } , send : make ( chan Message ) , close : make ( chan bool ) , } go member . listen ( ) g . members = append ( g . members , member ) g . clockLock . Unlock ( ) g . memberLock . Unlock ( ) return member }
1434	func ( state * DockerTaskEngineState ) RemoveENIAttachment ( mac string ) { if mac == "" { log . Debug ( "Cannot remove empty eni attachment information" ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) if _ , ok := state . eniAttachments [ mac ] ; ok { delete ( state . eniAttachments , mac ) } else { seelog . Debugf ( "Delete non-existed eni attachment: %v" , mac ) } }
2490	func ( i * Image ) Bounds ( ) image . Rectangle { if ! i . isSubImage ( ) { w , h := i . mipmap . original ( ) . Size ( ) return image . Rect ( 0 , 0 , w , h ) } return i . bounds }
3588	func ( t * ThresholdCount ) HasWarningRecovery ( ) bool { if t != nil && t . WarningRecovery != nil { return true } return false }
1035	func FileModeGoString ( o * os . FileMode ) string { if o == nil { return "(*os.FileMode)(nil)" } return fmt . Sprintf ( "%q" , * o ) }
2666	func flattenClusterFailoverLevelAdmissionControlPolicy ( d * schema . ResourceData , obj * types . ClusterFailoverLevelAdmissionControlPolicy , ) error { if err := d . Set ( "ha_admission_control_host_failure_tolerance" , obj . FailoverLevel ) ; err != nil { return err } if obj . SlotPolicy != nil { return structure . SetBatch ( d , map [ string ] interface { } { "ha_admission_control_resource_percentage_cpu" : obj . SlotPolicy . ( * types . ClusterFixedSizeSlotPolicy ) . Cpu , "ha_admission_control_resource_percentage_memory" : obj . SlotPolicy . ( * types . ClusterFixedSizeSlotPolicy ) . Memory , } ) } return nil }
441	func ( ctx * RequestCtx ) NotFound ( ) { ctx . Response . Reset ( ) ctx . SetStatusCode ( StatusNotFound ) ctx . SetBodyString ( "404 Page not found" ) }
3290	func ( d * Downtime ) GetParentIdOk ( ) ( int , bool ) { if d == nil || d . ParentId == nil { return 0 , false } return * d . ParentId , true }
6575	func ChangeSvcModattr ( host_name string , service_description string , value string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_SVC_MODATTR" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , stringifyArg ( "value" , "string" , value ) , ) }
769	func canonicalizeDomainName ( d string ) string { if ! strings . HasSuffix ( d , "." ) { d += "." } return strings . ToLower ( d ) }
923	func ( d * BaseDriver ) SetSwarmConfigFromFlags ( flags DriverOptions ) { d . SwarmMaster = flags . Bool ( "swarm-master" ) d . SwarmHost = flags . String ( "swarm-host" ) d . SwarmDiscovery = flags . String ( "swarm-discovery" ) }
2668	func flattenClusterFailoverHostAdmissionControlPolicy ( d * schema . ResourceData , obj * types . ClusterFailoverHostAdmissionControlPolicy , version viapi . VSphereVersion , ) error { var hsIDs [ ] string for _ , v := range obj . FailoverHosts { hsIDs = append ( hsIDs , v . Value ) } if err := d . Set ( "ha_admission_control_failover_host_system_ids" , hsIDs ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return d . Set ( "ha_admission_control_host_failure_tolerance" , obj . FailoverLevel ) } return nil }
4090	func ( c * CheckBox ) SetSize ( width , height int ) { if width != KeepValue && ( width > 1000 || width < c . minW ) { return } if height != KeepValue && ( height > 200 || height < c . minH ) { return } if width != KeepValue { c . width = width } c . height = 1 }
4351	func ExtraLeetEntropy ( match match . Match , password string ) float64 { var subsitutions float64 var unsub float64 subPassword := password [ match . I : match . J ] for index , char := range subPassword { if string ( char ) != string ( match . Token [ index ] ) { subsitutions ++ } else { unsub ++ } } var possibilities float64 for i := float64 ( 0 ) ; i <= math . Min ( subsitutions , unsub ) + 1 ; i ++ { possibilities += zxcvbnmath . NChoseK ( subsitutions + unsub , i ) } if possibilities <= 1 { return float64 ( 1 ) } return math . Log2 ( possibilities ) }
5866	func ( a * API ) DeleteContactGroup ( cfg * ContactGroup ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid contact group config [nil]" ) } return a . DeleteContactGroupByCID ( CIDType ( & cfg . CID ) ) }
3167	func ( client * Client ) ListIntegrationGCP ( ) ( [ ] * IntegrationGCP , error ) { var list [ ] * IntegrationGCP if err := client . doJsonRequest ( "GET" , "/v1/integration/gcp" , nil , & list ) ; err != nil { return nil , err } return list , nil }
6905	func ( e * Edit ) Focus ( ) { if e . cx == - 1 || e . cy == - 1 { e . cx = e . trueX e . cy = e . trueY e . at = 0 } setCursor ( e . cx , e . cy ) }
5816	func ( h * Histogram ) RecordValue ( v float64 ) { h . rw . Lock ( ) h . hist . RecordValue ( v ) h . rw . Unlock ( ) }
3103	func ( r * Route ) Name ( name string ) { if len ( name ) == 0 { panic ( "route name cannot be empty" ) } else if r . router . namedRoutes [ name ] != nil { panic ( "route with given name already exists: " + name ) } r . router . namedRoutes [ name ] = r . leaf }
825	func ( xcg * X509CertGenerator ) GenerateCert ( opts * Options ) error { template , err := xcg . newCertificate ( opts . Org ) if err != nil { return err } if len ( opts . Hosts ) == 1 && opts . Hosts [ 0 ] == "" { template . ExtKeyUsage = [ ] x509 . ExtKeyUsage { x509 . ExtKeyUsageClientAuth } template . KeyUsage = x509 . KeyUsageDigitalSignature } else { template . ExtKeyUsage = [ ] x509 . ExtKeyUsage { x509 . ExtKeyUsageServerAuth } if opts . SwarmMaster { template . ExtKeyUsage = append ( template . ExtKeyUsage , x509 . ExtKeyUsageClientAuth ) } for _ , h := range opts . Hosts { if ip := net . ParseIP ( h ) ; ip != nil { template . IPAddresses = append ( template . IPAddresses , ip ) } else { template . DNSNames = append ( template . DNSNames , h ) } } } tlsCert , err := tls . LoadX509KeyPair ( opts . CAFile , opts . CAKeyFile ) if err != nil { return err } priv , err := rsa . GenerateKey ( rand . Reader , opts . Bits ) if err != nil { return err } x509Cert , err := x509 . ParseCertificate ( tlsCert . Certificate [ 0 ] ) if err != nil { return err } derBytes , err := x509 . CreateCertificate ( rand . Reader , template , x509Cert , & priv . PublicKey , tlsCert . PrivateKey ) if err != nil { return err } certOut , err := os . Create ( opts . CertFile ) if err != nil { return err } pem . Encode ( certOut , & pem . Block { Type : "CERTIFICATE" , Bytes : derBytes } ) certOut . Close ( ) keyOut , err := os . OpenFile ( opts . KeyFile , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0600 ) if err != nil { return err } pem . Encode ( keyOut , & pem . Block { Type : "RSA PRIVATE KEY" , Bytes : x509 . MarshalPKCS1PrivateKey ( priv ) } ) keyOut . Close ( ) return nil }
6253	func ( h * Handler ) AcceptOffering ( tkn string , account data . HexString , offering string , deposit , gasPrice uint64 ) ( * string , error ) { logger := h . logger . Add ( "method" , "AcceptOffering" , "account" , account , "offering" , offering , "deposit" , deposit , "gasPrice" , gasPrice ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } var acc data . Account if err := h . findByColumn ( logger , ErrAccountNotFound , & acc , "eth_addr" , account ) ; err != nil { return nil , err } offer , err := h . findActiveOfferingByID ( logger , offering ) if err != nil { return nil , err } minDeposit := data . MinDeposit ( offer ) if deposit == 0 { deposit = minDeposit } else if deposit < minDeposit { logger . Error ( ErrDepositTooSmall . Error ( ) ) return nil , ErrDepositTooSmall } if err := h . pingOffering ( logger , offer ) ; err != nil { return nil , err } rid := util . NewUUID ( ) jobData := & worker . ClientPreChannelCreateData { Account : acc . ID , Offering : offering , GasPrice : gasPrice , Deposit : deposit } if err := job . AddWithData ( h . queue , nil , data . JobClientPreChannelCreate , data . JobChannel , rid , data . JobUser , jobData ) ; err != nil { logger . Error ( err . Error ( ) ) return nil , ErrInternal } return & rid , nil }
1449	func ( state * DockerTaskEngineState ) GetTaskByIPAddress ( addr string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) taskARN , ok := state . ipToTask [ addr ] return taskARN , ok }
5783	func ( a * API ) FetchAccounts ( ) ( * [ ] Account , error ) { result , err := a . Get ( config . AccountPrefix ) if err != nil { return nil , err } var accounts [ ] Account if err := json . Unmarshal ( result , & accounts ) ; err != nil { return nil , err } return & accounts , nil }
3023	func NormalizePath ( v interface { } ) string { p := v . ( string ) if PathIsEmpty ( p ) { return "" } return strings . TrimPrefix ( path . Clean ( p ) , "/" ) }
320	func ( b * BufferedSeriesIterator ) PeekBack ( n int ) ( t int64 , v float64 , ok bool ) { return b . buf . nthLast ( n ) }
5672	func ( ps * printState ) printInner ( prefixOnly bool ) [ ] AST { var save [ ] AST var psave * [ ] AST if prefixOnly { psave = & save } for len ( ps . inner ) > 0 { ps . printOneInner ( psave ) } return save }
3628	func ( t * TraceServiceDefinition ) GetShowDistribution ( ) bool { if t == nil || t . ShowDistribution == nil { return false } return * t . ShowDistribution }
6416	func ( list * LinkedList ) Sorta ( ) error { list . key . Lock ( ) defer list . key . Unlock ( ) var err error list . first , err = mergeSort ( list . first , func ( a , b interface { } ) ( int , error ) { castA , ok := a . ( string ) if ! ok { return 0 , ErrUnexpectedType } castB , ok := b . ( string ) if ! ok { return 0 , ErrUnexpectedType } return strings . Compare ( castA , castB ) , nil } ) list . last = findLast ( list . first ) return err }
4919	func NewWriter ( w io . Writer ) * Writer { return & Writer { wr : bufio . NewWriter ( w ) , b : make ( [ ] byte , writerBufferSize ) , tr : unicode . Utf8ToCesu8Transformer , } }
3945	func Parse ( ) error { args := os . Args if len ( args ) == 1 { return nil } fset := flag . CommandLine fset . Usage = Usage out := fsetOutput ( fset ) if err := fset . Parse ( args [ 1 : ] ) ; err != nil { return err } if f := fset . Lookup ( VersionBoolFlag ) ; f != nil { if v , ok := f . Value . ( flag . Getter ) ; ok { if b , ok := v . Get ( ) . ( bool ) ; ok && b { program := programName ( args [ 0 ] ) fmt . Fprintf ( out , "%s version %s %s/%s\n" , \n , program , buildinfo ( ) , runtime . GOOS ) runtime . GOARCH } } } return nil if fset . NArg ( ) == 0 { return nil } idx := len ( args ) - fset . NArg ( ) s := args [ idx ] args = args [ idx + 1 : ] for _ , sub := range subs { if sub . name != s { continue } fs , handler := sub . init ( out ) if err := fs . Parse ( args ) ; err != nil { return err } return handler ( args [ len ( args ) - fs . NArg ( ) : ] ... ) } }
7288	func ( s SyslogFacility ) OK ( ) ( ok bool ) { _ , ok = syslogPriorities [ strings . ToLower ( s . String ( ) ) ] return }
2037	func ( r * eventLogReceiver ) ReceiveMessage ( message string , level seelog . LogLevel , context seelog . LogContextInterface ) error { switch level { case seelog . DebugLvl , seelog . InfoLvl : return eventLog . Info ( eventLogID , message ) case seelog . WarnLvl : return eventLog . Warning ( eventLogID , message ) case seelog . ErrorLvl , seelog . CriticalLvl : return eventLog . Error ( eventLogID , message ) } return nil }
3107	func ( r * Router ) NotFound ( handlers ... Handler ) { handlers = validateAndWrapHandlers ( handlers ) r . notFound = func ( rw http . ResponseWriter , req * http . Request ) { c := r . m . createContext ( rw , req ) c . handlers = make ( [ ] Handler , 0 , len ( r . m . handlers ) + len ( handlers ) ) c . handlers = append ( c . handlers , r . m . handlers ... ) c . handlers = append ( c . handlers , handlers ... ) c . run ( ) } }
2971	func ( r * DiskSubresource ) Create ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Creating disk" , r ) var spec [ ] types . BaseVirtualDeviceConfigSpec disk , err := r . createDisk ( l ) if err != nil { return nil , fmt . Errorf ( "error creating disk: %s" , err ) } ctlr , err := r . assignDisk ( l , disk ) if err != nil { return nil , fmt . Errorf ( "cannot assign disk: %s" , err ) } if err := r . expandDiskSettings ( disk ) ; err != nil { return nil , err } if err := r . SaveDevIDs ( disk , ctlr ) ; err != nil { return nil , err } dspec , err := object . VirtualDeviceList { disk } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } if len ( dspec ) != 1 { return nil , fmt . Errorf ( "incorrect number of config spec items returned - expected 1, got %d" , len ( dspec ) ) } if r . Get ( "attach" ) . ( bool ) { dspec [ 0 ] . GetVirtualDeviceConfigSpec ( ) . FileOperation = "" } spec = append ( spec , dspec ... ) log . Printf ( "[DEBUG] %s: Device config operations from create: %s" , r , DeviceChangeString ( spec ) ) log . Printf ( "[DEBUG] %s: Create finished" , r ) return spec , nil }
6085	func NewQueue ( conf * Config , logger log . Logger , db * reform . DB , handlers HandlerMap ) Queue { l := logger . Add ( "type" , "job.Queue" ) return & queue { conf : conf , logger : l , db : db , handlers : handlers , subs : map [ string ] [ ] subEntry { } , } }
5285	func MergeConfig ( a , b * Config ) * Config { if a == nil { return b } if b == nil { return a } var result Config = * a if b . Delim != "" { result . Delim = b . Delim } if b . Glue != "" { result . Glue = b . Glue } if b . Prefix != "" { result . Prefix = b . Prefix } if b . Empty != "" { result . Empty = b . Empty } if b . NoTrim { result . NoTrim = true } return & result }
6937	func NewUnstarted ( prefix string , tags ... string ) * Registry { return & Registry { instruments : make ( map [ string ] interface { } ) , prefix : prefix , tags : tags , } }
4462	func ParseDateTime ( data string ) ( DateTime , error ) { if data == "" { return NewDateTime ( ) , nil } var lastError error for _ , layout := range dateTimeFormats { dd , err := time . Parse ( layout , data ) if err != nil { lastError = err continue } lastError = nil return DateTime ( dd ) , nil } return DateTime { } , lastError }
3713	func ( w * Widget ) GetServiceServiceOk ( ) ( string , bool ) { if w == nil || w . ServiceService == nil { return "" , false } return * w . ServiceService , true }
6018	func ( t Typed ) TimeMust ( key string ) time . Time { tt , exists := t . TimeIf ( key ) if exists == false { panic ( "expected time.Time value for " + key ) } return tt }
3598	func ( t * TileDefRequest ) GetTextFilter ( ) string { if t == nil || t . TextFilter == nil { return "" } return * t . TextFilter }
4661	func DirectionTo ( p1 , p2 Point ) Direction { bearing := BearingTo ( p1 , p2 ) index := bearing - 22.5 if index < 0 { index += 360 } indexInt := int ( index / 45.0 ) return Direction ( indexInt ) }
549	func ( ln * InmemoryListener ) Accept ( ) ( net . Conn , error ) { c , ok := <- ln . conns if ! ok { return nil , fmt . Errorf ( "InmemoryListener is already closed: use of closed network connection" ) } close ( c . accepted ) return c . conn , nil }
3467	func ( r * Recurrence ) GetUntilOccurrences ( ) int { if r == nil || r . UntilOccurrences == nil { return 0 } return * r . UntilOccurrences }
1466	func ( c * Container ) ShouldPullWithExecutionRole ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . RegistryAuthentication != nil && c . RegistryAuthentication . Type == AuthTypeECR && c . RegistryAuthentication . ECRAuthData != nil && c . RegistryAuthentication . ECRAuthData . UseExecutionRole }
525	func ( h * RequestHeader ) WriteTo ( w io . Writer ) ( int64 , error ) { n , err := w . Write ( h . Header ( ) ) return int64 ( n ) , err }
2575	func ( r * NetworkInterfaceSubresource ) Create ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Running create" , r ) var spec [ ] types . BaseVirtualDeviceConfigSpec ctlr , err := r . ControllerForCreateUpdate ( l , SubresourceControllerTypePCI , 0 ) if err != nil { return nil , err } net , err := network . FromID ( r . client , r . Get ( "network_id" ) . ( string ) ) if err != nil { return nil , err } bctx , bcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer bcancel ( ) backing , err := net . EthernetCardBackingInfo ( bctx ) if err != nil { return nil , err } device , err := l . CreateEthernetCard ( r . Get ( "adapter_type" ) . ( string ) , backing ) if err != nil { return nil , err } if err := r . assignEthernetCard ( l , device , ctlr ) ; err != nil { return nil , err } l . Connect ( device ) card := device . ( types . BaseVirtualEthernetCard ) . GetVirtualEthernetCard ( ) card . Key = l . NewKey ( ) if r . Get ( "use_static_mac" ) . ( bool ) { card . AddressType = string ( types . VirtualEthernetCardMacTypeManual ) card . MacAddress = r . Get ( "mac_address" ) . ( string ) } version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { alloc := & types . VirtualEthernetCardResourceAllocation { Limit : structure . Int64Ptr ( int64 ( r . Get ( "bandwidth_limit" ) . ( int ) ) ) , Reservation : structure . Int64Ptr ( int64 ( r . Get ( "bandwidth_reservation" ) . ( int ) ) ) , Share : types . SharesInfo { Shares : int32 ( r . Get ( "bandwidth_share_count" ) . ( int ) ) , Level : types . SharesLevel ( r . Get ( "bandwidth_share_level" ) . ( string ) ) , } , } card . ResourceAllocation = alloc } if err := r . SaveDevIDs ( device , ctlr ) ; err != nil { return nil , err } dspec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } spec = append ( spec , dspec ... ) log . Printf ( "[DEBUG] %s: Device config operations from create: %s" , r , DeviceChangeString ( spec ) ) log . Printf ( "[DEBUG] %s: Create finished" , r ) return spec , nil }
5191	func ( b Column ) Less ( other Record ) bool { if ob , ok := other . ( Column ) ; ok { if b . RowID == ob . RowID { return b . ColumnID < ob . ColumnID } return b . RowID < ob . RowID } return false }
4265	func ( w * whitelist ) dropBoundingSet ( ) error { w . pid . Clear ( capability . BOUNDS ) w . pid . Set ( capability . BOUNDS , w . keep ... ) return w . pid . Apply ( capability . BOUNDS ) }
2804	func IsMember ( cluster * object . ClusterComputeResource , host * object . HostSystem ) ( bool , error ) { hprops , err := hostsystem . Properties ( host ) if err != nil { return false , fmt . Errorf ( "error getting properties for cluster %q: %s" , host . Name ( ) , err ) } if hprops . Parent == nil { return false , nil } if * hprops . Parent != cluster . Reference ( ) { return false , nil } return true , nil }
3587	func ( t * ThresholdCount ) GetWarningRecoveryOk ( ) ( json . Number , bool ) { if t == nil || t . WarningRecovery == nil { return "" , false } return * t . WarningRecovery , true }
3550	func ( s * SyntheticsTest ) GetDeletedAt ( ) string { if s == nil || s . DeletedAt == nil { return "" } return * s . DeletedAt }
7183	func ( c Client ) writeMessage ( m irc . Message ) error { buf , err := m . Encode ( ) if err != nil && err != irc . ErrTruncated { return fmt . Errorf ( "unable to encode message: %s" , err ) } if err := c . conn . SetWriteDeadline ( time . Now ( ) . Add ( c . writeTimeout ) ) ; err != nil { return fmt . Errorf ( "unable to set deadline: %s" , err ) } sz , err := c . rw . WriteString ( buf ) if err != nil { return err } if sz != len ( buf ) { return fmt . Errorf ( "short write" ) } if err := c . rw . Flush ( ) ; err != nil { return fmt . Errorf ( "flush error: %s" , err ) } log . Printf ( "client %s: sent: %s" , c . nick , strings . TrimRight ( buf , "\r\n" ) ) \r }
4050	func TextExtent ( text string ) ( int , int ) { if text == "" { return 0 , 0 } parts := strings . Split ( text , "\n" ) \n h := len ( parts ) w := 0 for _ , p := range parts { s := UnColorizeText ( p ) l := len ( s ) if l > w { w = l } } }
170	func TableLinkForExpression ( expr string ) string { escapedExpression := url . QueryEscape ( expr ) return fmt . Sprintf ( "/graph?g0.expr=%s&g0.tab=1" , escapedExpression ) }
4122	func ( b * SparkChart ) SetAutoScale ( auto bool ) { b . mtx . Lock ( ) defer b . mtx . Unlock ( ) b . autosize = auto }
1240	func newWatcher ( ctx context . Context , primaryMAC string , nlWrap netlinkwrapper . NetLink , udevWrap udevwrapper . Udev , state dockerstate . TaskEngineState , stateChangeEvents chan <- statechange . Event ) * UdevWatcher { derivedContext , cancel := context . WithCancel ( ctx ) return & UdevWatcher { ctx : derivedContext , cancel : cancel , netlinkClient : nlWrap , udevMonitor : udevWrap , events : make ( chan * udev . UEvent ) , agentState : state , eniChangeEvent : stateChangeEvents , primaryMAC : primaryMAC , } }
5118	func ( file * GridFile ) Abort ( ) { if file . mode != gfsWriting { panic ( "file.Abort must be called on file opened for writing" ) } file . err = errors . New ( "write aborted" ) }
7195	func ( r * Route ) Handle ( pat string , f ... HandlerFunc ) { entry := r . addPattern ( pat ) batch := batchRoute ( f ) if err := entry . SetHandler ( batch ) ; err != nil { panic ( err ) } }
4649	func ( index * ClusteringIndex ) Range ( topLeft Point , bottomRight Point ) [ ] Point { dist := distance ( topLeft , bottomRight ) if dist < streetLevel { return index . streetLevel . Range ( topLeft , bottomRight ) } else if dist < cityLevel { return index . cityLevel . Range ( topLeft , bottomRight ) } else { return index . worldLevel . Range ( topLeft , bottomRight ) } }
1646	func Since ( t time . Time ) time . Duration { return _time . Now ( ) . Sub ( t ) }
3136	func New ( ) * Cache { c := & Cache { data : make ( [ ] * Shard , shardCount ) , writeStrategy : Noop , } for i := 0 ; i < shardCount ; i ++ { c . data [ i ] = & Shard { items : make ( map [ string ] * points . Points ) , notConfirmed : make ( [ ] * points . Points , 4 ) , } } settings := cacheSettings { maxSize : 1000000 , tagsEnabled : false , xlog : nil , } c . settings . Store ( & settings ) c . writeoutQueue = NewWriteoutQueue ( c ) return c }
6389	func Take ( subject Enumerable , n uint ) Enumerable { return taker { original : subject , n : n , } }
398	func ( u * URI ) CopyTo ( dst * URI ) { dst . Reset ( ) dst . pathOriginal = append ( dst . pathOriginal [ : 0 ] , u . pathOriginal ... ) dst . scheme = append ( dst . scheme [ : 0 ] , u . scheme ... ) dst . path = append ( dst . path [ : 0 ] , u . path ... ) dst . queryString = append ( dst . queryString [ : 0 ] , u . queryString ... ) dst . hash = append ( dst . hash [ : 0 ] , u . hash ... ) dst . host = append ( dst . host [ : 0 ] , u . host ... ) u . queryArgs . CopyTo ( & dst . queryArgs ) dst . parsedQueryArgs = u . parsedQueryArgs dst . h = u . h }
7186	func ( c Client ) GetChannels ( ) [ ] string { var channels [ ] string c . mutex . Lock ( ) for k := range c . channels { channels = append ( channels , k ) } c . mutex . Unlock ( ) return channels }
2605	func Properties ( ds * object . Datastore ) ( * mo . Datastore , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Datastore if err := ds . Properties ( ctx , ds . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
2165	func NewSurface ( s uintptr , needsRef bool ) * Surface { surface := WrapSurface ( s ) if needsRef { surface . reference ( ) } runtime . SetFinalizer ( surface , ( * Surface ) . destroy ) return surface }
6334	func ( c CookieSigner ) EncodeValue ( value string ) string { return fmt . Sprintf ( "%s.%s" , base64 . URLEncoding . EncodeToString ( c . mac ( value ) ) , value ) }
2447	func ( i * Image ) resolveStale ( ) { if ! IsRestoringEnabled ( ) { return } if i . volatile { return } if i . screen { return } if ! i . stale { return } i . readPixelsFromGPU ( ) }
939	func ( rd * RemoteDocker ) URL ( ) ( string , error ) { if rd . HostURL == "" { return "" , fmt . Errorf ( "Docker Host URL not set" ) } return rd . HostURL , nil }
579	func ( mx * Mux ) Put ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mPUT , pattern , handlerFn ) }
5453	func ( c * CallService ) GetNextCallsInRange ( start time . Time , end time . Time , nextPageURI string ) CallPageIterator { if nextPageURI == "" { panic ( "nextpageuri is empty" ) } iter := NewNextPageIterator ( c . client , callsPathPart ) iter . SetNextPageURI ( types . NullString { Valid : true , String : nextPageURI } ) return & callDateIterator { start : start , end : end , p : iter , } }
7027	func ( p Param ) Int32 ( ) ( int32 , error ) { i , err := strconv . ParseInt ( string ( p ) , 10 , 32 ) return int32 ( i ) , err }
5870	func ( cm * CheckManager ) AddMetricTags ( metricName string , tags [ ] string , appendTags bool ) bool { tagsUpdated := false if appendTags && len ( tags ) == 0 { return tagsUpdated } currentTags , exists := cm . metricTags [ metricName ] if ! exists { foundMetric := false if cm . checkBundle != nil { for _ , metric := range cm . checkBundle . Metrics { if metric . Name == metricName { foundMetric = true currentTags = metric . Tags break } } } if ! foundMetric { currentTags = [ ] string { } } } action := "" if appendTags { numNewTags := countNewTags ( currentTags , tags ) if numNewTags > 0 { action = "Added" currentTags = append ( currentTags , tags ... ) tagsUpdated = true } } else { if len ( tags ) != len ( currentTags ) { action = "Set" currentTags = tags tagsUpdated = true } else { numNewTags := countNewTags ( currentTags , tags ) if numNewTags > 0 { action = "Set" currentTags = tags tagsUpdated = true } } } if tagsUpdated { cm . metricTags [ metricName ] = currentTags } if cm . Debug && action != "" { cm . Log . Printf ( "[DEBUG] %s metric tag(s) %s %v\n" , \n , action , metricName ) } tags }
2872	func resourceVSphereComputeClusterVMGroupFindEntry ( cluster * object . ClusterComputeResource , name string , ) ( * types . ClusterVmGroup , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( "error fetching cluster properties: %s" , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . Group { if info . GetClusterGroupInfo ( ) . Name == name { if vmInfo , ok := info . ( * types . ClusterVmGroup ) ; ok { log . Printf ( "[DEBUG] Found VM group %q in cluster %q" , name , cluster . Name ( ) ) return vmInfo , nil } return nil , fmt . Errorf ( "unique group name %q in cluster %q is not a VM group" , name , cluster . Name ( ) ) } } log . Printf ( "[DEBUG] No VM group name %q found in cluster %q" , name , cluster . Name ( ) ) return nil , nil }
3321	func ( g * GraphDefinitionMarker ) HasVal ( ) bool { if g != nil && g . Val != nil { return true } return false }
7229	func ( logger * Logger ) Infof ( format string , a ... interface { } ) { logger . log ( INFO , format , a ... ) }
3958	func ( z * Writer ) Flush ( ) error { if debugFlag { debug ( "flush with index %d" , z . idx ) } if z . idx == 0 { return nil } if err := z . compressBlock ( z . data [ : z . idx ] ) ; err != nil { return err } z . idx = 0 return nil }
2231	func ( v * Clipboard ) WaitIsUrisAvailable ( ) bool { c := C . gtk_clipboard_wait_is_uris_available ( v . native ( ) ) return gobool ( c ) }
1852	func ( eventStream * EventStream ) listen ( ) { seelog . Infof ( "Event stream %s start listening..." , eventStream . name ) for { select { case event := <- eventStream . event : eventStream . broadcast ( event ) case <- eventStream . ctx . Done ( ) : seelog . Infof ( "Event stream %s stopped listening..." , eventStream . name ) eventStream . statusLock . Lock ( ) eventStream . open = false close ( eventStream . event ) eventStream . statusLock . Unlock ( ) return } } }
1176	func ( m * MockProvider ) IsExpired ( ) bool { ret := m . ctrl . Call ( m , "IsExpired" ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 }
2628	func LongPolicy ( n interface { } ) * types . LongPolicy { lp := & types . LongPolicy { } switch v := n . ( type ) { case int : lp . Value = int64 ( v ) case int8 : lp . Value = int64 ( v ) case int16 : lp . Value = int64 ( v ) case int32 : lp . Value = int64 ( v ) case uint : lp . Value = int64 ( v ) case uint8 : lp . Value = int64 ( v ) case uint16 : lp . Value = int64 ( v ) case uint32 : lp . Value = int64 ( v ) case int64 : lp . Value = v default : panic ( fmt . Errorf ( "non-convertible type %T for value" , n ) ) } return lp }
3192	func ( client * Client ) GetSyntheticsLocations ( ) ( [ ] SyntheticsLocation , error ) { var out struct { Locations [ ] SyntheticsLocation `json:"locations,omitempty"` } if err := client . doJsonRequest ( "GET" , "/v1/synthetics/locations" , nil , & out ) ; err != nil { return nil , err } return out . Locations , nil }
5533	func ( lo * LuaObject ) Close ( ) { lo . l . Unref ( lua . LUA_REGISTRYINDEX , lo . ref ) }
6696	func ( s * Server ) FullConsoleUrl ( ) string { if s . ConsoleUrl == "" || s . ConsoleToken == "" { return s . ConsoleUrl } u , err := url . Parse ( s . ConsoleUrl ) if u == nil || err != nil { return s . ConsoleUrl } values := u . Query ( ) if values . Get ( "password" ) != "" { return s . ConsoleUrl } values . Set ( "password" , s . ConsoleToken ) u . RawQuery = values . Encode ( ) return u . String ( ) }
6244	func BytesToUint32 ( b [ ] byte ) ( uint32 , error ) { if len ( b ) != 4 { return 0 , fmt . Errorf ( "wrong len" ) } return binary . BigEndian . Uint32 ( b ) , nil }
6724	func ( c * Client ) Collaboration ( identifier string ) ( * Collaboration , error ) { col := new ( Collaboration ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/user/collaborations/" + identifier , nil , col ) if err != nil { return nil , err } return col , err }
6453	func ( f * filepathPat ) match ( path string ) bool { return f . regexp . MatchString ( path ) }
2312	func ( v * Pattern ) native ( ) * C . cairo_pattern_t { if v == nil { return nil } return v . pattern }
2238	func ( v * CssProvider ) native ( ) * C . GtkCssProvider { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCssProvider ( p ) }
6119	func ( n * discovery ) AddMapping ( protocol string , extPort , intPort int , name string , lifetime time . Duration ) error { if err := n . wait ( ) ; err != nil { return err } return n . found . AddMapping ( protocol , extPort , intPort , name , lifetime ) }
7067	func ataIdentify ( r * ATAArg , rs io . ReadSeeker ) ( * ATAArg , error ) { if r . CmdStatus != ATACmdStatusIdentify { return nil , errATAAbort } if r . SectorCount != 1 { return nil , errATAAbort } ident , ok := rs . ( Identifier ) if ! ok { return nil , ErrNotImplemented } id , err := ident . Identify ( ) if err != nil { return nil , err } return & ATAArg { CmdStatus : ATACmdStatusReadyStatus , Data : id [ : ] , } , nil }
3824	func NewUUID ( ) ( UUID , error ) { nodeMu . Lock ( ) if nodeID == zeroID { setNodeInterface ( "" ) } nodeMu . Unlock ( ) var uuid UUID now , seq , err := GetTime ( ) if err != nil { return uuid , err } timeLow := uint32 ( now & 0xffffffff ) timeMid := uint16 ( ( now >> 32 ) & 0xffff ) timeHi := uint16 ( ( now >> 48 ) & 0x0fff ) timeHi |= 0x1000 binary . BigEndian . PutUint32 ( uuid [ 0 : ] , timeLow ) binary . BigEndian . PutUint16 ( uuid [ 4 : ] , timeMid ) binary . BigEndian . PutUint16 ( uuid [ 6 : ] , timeHi ) binary . BigEndian . PutUint16 ( uuid [ 8 : ] , seq ) copy ( uuid [ 10 : ] , nodeID [ : ] ) return uuid , nil }
3546	func ( s * SyntheticsRequest ) HasTimeout ( ) bool { if s != nil && s . Timeout != nil { return true } return false }
3836	func ( uuid * UUID ) UnmarshalText ( data [ ] byte ) error { id , err := ParseBytes ( data ) if err == nil { * uuid = id } return err }
4422	func ( u * IPv6 ) DeepCopy ( ) * IPv6 { if u == nil { return nil } out := new ( IPv6 ) u . DeepCopyInto ( out ) return out }
7234	func ( e * Entry ) getChildEntry ( pat string ) * Entry { for _ , entry := range e . entries { if pat == entry . Pattern ( ) { return entry } } return nil }
6109	func ( h * Handler ) UpdateBalance ( tkn , account string ) error { logger := h . logger . Add ( "method" , "UpdateBalance" , "account" , account ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } err := h . findByPrimaryKey ( logger , ErrAccountNotFound , & data . Account { } , account ) if err != nil { return err } err = job . AddSimple ( h . queue , nil , data . JobAccountUpdateBalances , data . JobAccount , account , data . JobUser ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil }
3729	func ( w * Widget ) HasTitleText ( ) bool { if w != nil && w . TitleText != nil { return true } return false }
3579	func ( t * ThresholdCount ) HasTimeAggregator ( ) bool { if t != nil && t . TimeAggregator != nil { return true } return false }
4211	func ( v * JWTValidator ) ValidateRequestWithLeeway ( r * http . Request , leeway time . Duration ) ( * jwt . JSONWebToken , error ) { return v . validateRequestWithLeeway ( r , leeway ) }
2830	func flattenClusterDrsVMConfigInfo ( d * schema . ResourceData , obj * types . ClusterDrsVmConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { "drs_automation_level" : obj . Behavior , "drs_enabled" : obj . Enabled , } ) }
6443	func ( l List ) MarshalText ( ) ( text [ ] byte , err error ) { var buf bytes . Buffer l . writeToBuffer ( & buf ) return buf . Bytes ( ) , nil }
2305	func ( v * TreeRowReference ) GetPath ( ) * TreePath { c := C . gtk_tree_row_reference_get_path ( v . native ( ) ) if c == nil { return nil } t := & TreePath { c } runtime . SetFinalizer ( t , ( * TreePath ) . free ) return t }
3852	func ( l * List ) PageUp ( ) { start := l . start - l . size if start < 0 { l . start = 0 } else { l . start = start } cursor := l . start if cursor < l . cursor { l . cursor = cursor } }
5331	func NewShadow ( username string ) * Shadow { loadConfig ( ) return & Shadow { Name : username , changed : _ENABLE_AGING , Min : config . login . PASS_MIN_DAYS , Max : config . login . PASS_MAX_DAYS , Warn : config . login . PASS_WARN_AGE , } }
633	func ( im * InMemoryProvider ) Zones ( ) map [ string ] string { return im . filter . Zones ( im . client . Zones ( ) ) }
19	func NewEndpoints ( l log . Logger , svc , eps , pod cache . SharedInformer ) * Endpoints { if l == nil { l = log . NewNopLogger ( ) } e := & Endpoints { logger : l , endpointsInf : eps , endpointsStore : eps . GetStore ( ) , serviceInf : svc , serviceStore : svc . GetStore ( ) , podInf : pod , podStore : pod . GetStore ( ) , queue : workqueue . NewNamed ( "endpoints" ) , } e . endpointsInf . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( o interface { } ) { eventCount . WithLabelValues ( "endpoints" , "add" ) . Inc ( ) e . enqueue ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( "endpoints" , "update" ) . Inc ( ) e . enqueue ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( "endpoints" , "delete" ) . Inc ( ) e . enqueue ( o ) } , } ) serviceUpdate := func ( o interface { } ) { svc , err := convertToService ( o ) if err != nil { level . Error ( e . logger ) . Log ( "msg" , "converting to Service object failed" , "err" , err ) return } ep := & apiv1 . Endpoints { } ep . Namespace = svc . Namespace ep . Name = svc . Name obj , exists , err := e . endpointsStore . Get ( ep ) if exists && err == nil { e . enqueue ( obj . ( * apiv1 . Endpoints ) ) } if err != nil { level . Error ( e . logger ) . Log ( "msg" , "retrieving endpoints failed" , "err" , err ) } } e . serviceInf . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( o interface { } ) { eventCount . WithLabelValues ( "service" , "add" ) . Inc ( ) serviceUpdate ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( "service" , "update" ) . Inc ( ) serviceUpdate ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( "service" , "delete" ) . Inc ( ) serviceUpdate ( o ) } , } ) return e }
1879	func ( err * WSError ) Error ( ) string { val := reflect . ValueOf ( err . ErrObj ) if val . Kind ( ) == reflect . Ptr { val = val . Elem ( ) } var typeStr = "Unknown type" if val . IsValid ( ) { typeStr = val . Type ( ) . Name ( ) msg := val . FieldByName ( "Message_" ) if msg . IsValid ( ) && msg . CanInterface ( ) { str , ok := msg . Interface ( ) . ( * string ) if ok { if str == nil { return typeStr + ": null" } return typeStr + ": " + * str } } } if asErr , ok := err . ErrObj . ( error ) ; ok { return err . Type + ": " + asErr . Error ( ) } return err . Type + ": Unknown error (" + typeStr + ")" }
1960	func getAgentVersions ( ) [ ] dockerclient . DockerVersion { return [ ] dockerclient . DockerVersion { dockerclient . Version_1_17 , dockerclient . Version_1_18 , dockerclient . Version_1_19 , dockerclient . Version_1_20 , dockerclient . Version_1_21 , dockerclient . Version_1_22 , dockerclient . Version_1_23 , dockerclient . Version_1_24 , dockerclient . Version_1_25 , dockerclient . Version_1_26 , dockerclient . Version_1_27 , dockerclient . Version_1_28 , dockerclient . Version_1_29 , dockerclient . Version_1_30 , dockerclient . Version_1_31 , dockerclient . Version_1_32 , } }
6805	func ( f Flags ) String ( name string ) string { return f . C . String ( name ) }
1742	func ( task * Task ) GetSentStatus ( ) apitaskstatus . TaskStatus { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . SentStatusUnsafe }
4388	func SSNValue ( v * strfmt . SSN ) strfmt . SSN { if v == nil { return strfmt . SSN ( "" ) } return * v }
1715	func ( task * Task ) getAllSSMSecretRequirements ( ) map [ string ] [ ] apicontainer . Secret { reqs := make ( map [ string ] [ ] apicontainer . Secret ) for _ , container := range task . Containers { for _ , secret := range container . Secrets { if secret . Provider == apicontainer . SecretProviderSSM { if _ , ok := reqs [ secret . Region ] ; ! ok { reqs [ secret . Region ] = [ ] apicontainer . Secret { } } reqs [ secret . Region ] = append ( reqs [ secret . Region ] , secret ) } } } return reqs }
759	func newDesignateClient ( ) ( designateClientInterface , error ) { serviceClient , err := createDesignateServiceClient ( ) if err != nil { return nil , err } return & designateClient { serviceClient } , nil }
1099	func treeFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( [ ] * dep . KeyPair , error ) { return func ( s string ) ( [ ] * dep . KeyPair , error ) { result := [ ] * dep . KeyPair { } if len ( s ) == 0 { return result , nil } d , err := dep . NewKVListQuery ( s ) if err != nil { return result , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { for _ , pair := range value . ( [ ] * dep . KeyPair ) { parts := strings . Split ( pair . Key , "/" ) if parts [ len ( parts ) - 1 ] != "" { result = append ( result , pair ) } } return result , nil } missing . Add ( d ) return result , nil } }
6923	func ( p * PushCenter ) Stop ( ) error { if ! p . isRunning { return errors . New ( "the push center is not started" ) } p . stop <- true p . isRunning = false return nil }
1074	func ( r * Runner ) deletePid ( ) error { path := config . StringVal ( r . config . PidFile ) if path == "" { return nil } log . Printf ( "[DEBUG] removing pid file at %q" , path ) stat , err := os . Stat ( path ) if err != nil { return fmt . Errorf ( "runner: could not remove pid file: %s" , err ) } if stat . IsDir ( ) { return fmt . Errorf ( "runner: specified pid file path is directory" ) } err = os . Remove ( path ) if err != nil { return fmt . Errorf ( "runner: could not remove pid file: %s" , err ) } return nil }
3787	func ( client * Client ) GetEvent ( id int ) ( * Event , error ) { var out reqGetEvent if err := client . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/events/%d" , id ) , nil , & out ) ; err != nil { return nil , err } return out . Event , nil }
3340	func ( g * GroupData ) GetTriggeringValue ( ) TriggeringValue { if g == nil || g . TriggeringValue == nil { return TriggeringValue { } } return * g . TriggeringValue }
2070	func NewMockECRFactory ( ctrl * gomock . Controller ) * MockECRFactory { mock := & MockECRFactory { ctrl : ctrl } mock . recorder = & MockECRFactoryMockRecorder { mock } return mock }
2088	func ( m * MockNetLink ) LinkList ( ) ( [ ] netlink . Link , error ) { ret := m . ctrl . Call ( m , "LinkList" ) ret0 , _ := ret [ 0 ] . ( [ ] netlink . Link ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3885	func SortIssueChan ( issues chan * Issue , order [ ] string ) chan * Issue { out := make ( chan * Issue , 1000000 ) sorted := & sortedIssues { issues : [ ] * Issue { } , order : order , } go func ( ) { for issue := range issues { sorted . issues = append ( sorted . issues , issue ) } sort . Sort ( sorted ) for _ , issue := range sorted . issues { out <- issue } close ( out ) } ( ) return out }
5587	func ( as AgentSettings ) DetachPersistentDisk ( diskID string ) AgentSettings { persistenDiskSettings := as . Disks . Persistent delete ( persistenDiskSettings , diskID ) as . Disks . Persistent = persistenDiskSettings return as }
4278	func GetAllSubsystems ( ) ( [ ] string , error ) { f , err := os . Open ( "/proc/cgroups" ) if err != nil { return nil , err } defer f . Close ( ) subsystems := [ ] string { } s := bufio . NewScanner ( f ) for s . Scan ( ) { if err := s . Err ( ) ; err != nil { return nil , err } text := s . Text ( ) if text [ 0 ] != '#' { parts := strings . Fields ( text ) if len ( parts ) >= 4 && parts [ 3 ] != "0" { subsystems = append ( subsystems , parts [ 0 ] ) } } } return subsystems , nil }
2681	func flattenClusterInfraUpdateHaConfigInfo ( d * schema . ResourceData , obj * types . ClusterInfraUpdateHaConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { "proactive_ha_automation_level" : obj . Behavior , "proactive_ha_enabled" : obj . Enabled , "proactive_ha_moderate_remediation" : obj . ModerateRemediation , "proactive_ha_provider_ids" : obj . Providers , "proactive_ha_severe_remediation" : obj . SevereRemediation , } ) }
1824	func ( mtask * managedTask ) waitSteady ( ) { seelog . Infof ( "Managed task [%s]: task at steady state: %s" , mtask . Arn , mtask . GetKnownStatus ( ) . String ( ) ) timeoutCtx , cancel := context . WithTimeout ( mtask . ctx , mtask . steadyStatePollInterval ) defer cancel ( ) timedOut := mtask . waitEvent ( timeoutCtx . Done ( ) ) if timedOut { seelog . Debugf ( "Managed task [%s]: checking to make sure it's still at steadystate" , mtask . Arn ) go mtask . engine . checkTaskState ( mtask . Task ) } }
631	func NewInMemoryProvider ( opts ... InMemoryOption ) * InMemoryProvider { im := & InMemoryProvider { filter : & filter { } , OnApplyChanges : func ( changes * plan . Changes ) { } , OnRecords : func ( ) { } , domain : NewDomainFilter ( [ ] string { "" } ) , client : newInMemoryClient ( ) , } for _ , opt := range opts { opt ( im ) } return im }
3701	func ( w * Widget ) GetMustShowHitsOk ( ) ( bool , bool ) { if w == nil || w . MustShowHits == nil { return false , false } return * w . MustShowHits , true }
462	func ( req * Request ) SetRequestURIBytes ( requestURI [ ] byte ) { req . Header . SetRequestURIBytes ( requestURI ) req . parsedURI = false }
6160	func ( w * Worker ) AgentPreOfferingPopUp ( job * data . Job ) error { logger := w . logger . Add ( "method" , "AgentPreOfferingPopUp" , "job" , job ) offering , err := w . relatedOffering ( logger , job , data . JobAgentPreOfferingPopUp ) if err != nil { return err } logger = logger . Add ( "offering" , offering . ID ) if offering . Status != data . OfferRegistered && offering . Status != data . OfferPoppedUp { return ErrOfferNotRegistered } jobDate , err := w . publishData ( logger , job ) if err != nil { return err } offeringHash , err := data . HexToHash ( offering . Hash ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } err = w . agentOfferingPopUpFindRelatedJobs ( logger , offering . ID , job . ID ) if err != nil { return err } err = w . checkInPeriod ( logger , offeringHash , data . SettingsPeriodPopUp , ErrPopUpPeriodIsNotOver ) if err != nil { return err } key , err := w . accountKey ( logger , offering . Agent ) if err != nil { return err } auth := bind . NewKeyedTransactor ( key ) auth . GasLimit = w . gasConf . PSC . PopupServiceOffering auth . GasPrice = new ( big . Int ) . SetUint64 ( jobDate . GasPrice ) tx , err := w . ethBack . PSCPopupServiceOffering ( auth , offeringHash , offering . SOMCType , offering . SOMCData ) if err != nil { logger . Add ( "GasLimit" , auth . GasLimit , "GasPrice" , auth . GasPrice ) . Error ( err . Error ( ) ) return ErrPSCPopUpOffering } offering . Status = data . OfferPoppingUp if err := w . saveRecord ( logger , w . db . Querier , offering ) ; err != nil { return err } return w . saveEthTX ( logger , job , tx , "PopupServiceOffering" , job . RelatedType , job . RelatedID , offering . Agent , data . HexFromBytes ( w . pscAddr . Bytes ( ) ) ) }
2151	func ( m * Matrix ) Rotate ( radians float64 ) { C . cairo_matrix_rotate ( m . native ( ) , C . double ( radians ) ) }
6664	func ( c * Client ) Discovery ( ) ( * DiscoveryResponse , error ) { discResp := & DiscoveryResponse { } resp , err := c . caller . Call ( "GET" , c . endpoint + "/discovery" , nil ) return discResp , c . json ( resp , err , false , discResp ) }
7041	func ( c * Conn ) receive ( msg * message ) error { if ! c . connected . Load ( ) . ( bool ) { return errors . New ( "use of closed connection" ) } return websocket . JSON . Receive ( c . ws . Load ( ) . ( * websocket . Conn ) , & msg ) }
1056	func ( c * Child ) Reload ( ) error { if c . reloadSignal == nil { log . Printf ( "[INFO] (child) restarting process" ) c . Lock ( ) defer c . Unlock ( ) c . kill ( ) return c . start ( ) } log . Printf ( "[INFO] (child) reloading process" ) c . RLock ( ) defer c . RUnlock ( ) return c . reload ( ) }
6037	func NewWorker ( logger log . Logger , db * reform . DB , ethBack eth . Backend , gasConc * GasConf , pscAddr common . Address , payAddr string , pwdGetter data . PWDGetter , countryConf * country . Config , decryptKeyFunc data . ToPrivateKeyFunc , eptConf * ept . Config , torHostname string , somcClientBuilder somc . ClientBuilderInterface ) ( * Worker , error ) { l := logger . Add ( "type" , "proc/worker.Worker" ) abi , err := abi . JSON ( strings . NewReader ( contract . PrivatixServiceContractABI ) ) if err != nil { return nil , err } eptService , err := ept . New ( db , logger , payAddr , eptConf . Timeout ) if err != nil { return nil , err } return & Worker { abi : abi , logger : l , db : db , decryptKeyFunc : decryptKeyFunc , gasConf : gasConc , ept : eptService , ethBack : ethBack , pscAddr : pscAddr , pwdGetter : pwdGetter , countryConfig : countryConf , torHostName : data . FromBytes ( [ ] byte ( torHostname ) ) , somcClientBuilder : somcClientBuilder , } , nil }
2259	func ( v * MenuItem ) native ( ) * C . GtkMenuItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenuItem ( p ) }
833	func tokenFromFile ( oauthCfg azure . OAuthConfig , tokenPath , clientID , resource string , callback azure . TokenRefreshCallback ) ( * azure . ServicePrincipalToken , error ) { log . Debug ( "Loading auth token from file" , logutil . Fields { "path" : tokenPath } ) if _ , err := os . Stat ( tokenPath ) ; err != nil { if os . IsNotExist ( err ) { return nil , nil } return nil , err } token , err := azure . LoadToken ( tokenPath ) if err != nil { return nil , fmt . Errorf ( "Failed to load token from file: %v" , err ) } spt , err := azure . NewServicePrincipalTokenFromManualToken ( oauthCfg , clientID , resource , * token , callback ) if err != nil { return nil , fmt . Errorf ( "Error constructing service principal token: %v" , err ) } return spt , nil }
660	func ExoscaleWithLogging ( ) ExoscaleOption { return func ( p * ExoscaleProvider ) { p . OnApplyChanges = func ( changes * plan . Changes ) { for _ , v := range changes . Create { log . Infof ( "CREATE: %v" , v ) } for _ , v := range changes . UpdateOld { log . Infof ( "UPDATE (old): %v" , v ) } for _ , v := range changes . UpdateNew { log . Infof ( "UPDATE (new): %v" , v ) } for _ , v := range changes . Delete { log . Infof ( "DELETE: %v" , v ) } } } }
3927	func yaml_emitter_emit_node ( emitter * yaml_emitter_t , event * yaml_event_t , root bool , sequence bool , mapping bool , simple_key bool ) bool { emitter . root_context = root emitter . sequence_context = sequence emitter . mapping_context = mapping emitter . simple_key_context = simple_key switch event . typ { case yaml_ALIAS_EVENT : return yaml_emitter_emit_alias ( emitter , event ) case yaml_SCALAR_EVENT : return yaml_emitter_emit_scalar ( emitter , event ) case yaml_SEQUENCE_START_EVENT : return yaml_emitter_emit_sequence_start ( emitter , event ) case yaml_MAPPING_START_EVENT : return yaml_emitter_emit_mapping_start ( emitter , event ) default : return yaml_emitter_set_emitter_error ( emitter , fmt . Sprintf ( "expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS, but got %v" , event . typ ) ) } }
6250	func GetUint64Setting ( db * reform . DB , key string ) ( uint64 , error ) { var setting Setting err := db . FindByPrimaryKeyTo ( & setting , key ) if err != nil { if err == sql . ErrNoRows { return 0 , fmt . Errorf ( "key %s is not exist" + " in Setting table" , key ) } return 0 , err } value , err := strconv . ParseUint ( setting . Value , 10 , 64 ) if err != nil { return 0 , fmt . Errorf ( "failed to parse %s setting: %v" , key , err ) } return value , nil }
6400	func ( stack * Stack ) IsEmpty ( ) bool { stack . key . RLock ( ) defer stack . key . RUnlock ( ) return stack . underlyer == nil || stack . underlyer . IsEmpty ( ) }
1488	func ( c * Container ) SetHealthStatus ( health HealthStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) if c . Health . Status == health . Status { return } c . Health . Status = health . Status c . Health . Since = aws . Time ( time . Now ( ) ) c . Health . Output = health . Output if c . Health . Status == apicontainerstatus . ContainerUnhealthy { c . Health . ExitCode = health . ExitCode } }
4585	func ( f * Func ) IsExported ( ) bool { name := f . Name ( ) parts := strings . Split ( name , "." ) r , _ := utf8 . DecodeRuneInString ( parts [ len ( parts ) - 1 ] ) if unicode . ToUpper ( r ) == r { return true } return f . PkgName ( ) == "main" && name == "main" }
210	func ( m * Manager ) Collect ( ch chan <- prometheus . Metric ) { for _ , g := range m . RuleGroups ( ) { ch <- prometheus . MustNewConstMetric ( groupInterval , prometheus . GaugeValue , g . interval . Seconds ( ) , groupKey ( g . file , g . name ) ) } }
7302	func ( b Bucket ) CreateBucketIfNotExists ( folders [ ] [ ] byte ) ( Bucket , error ) { bb := b . Bucket for _ , fld := range folders { var err error if bb , err = bb . CreateBucketIfNotExists ( fld ) ; err != nil { return Bucket { } , errorsp . WithStacks ( err ) } } return Bucket { bb } , nil }
2719	func resourceVSphereVirtualMachineRollbackCreate ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , origErr error , ) error { defer d . SetId ( "" ) if err := resourceVSphereVirtualMachineDelete ( d , meta ) ; err != nil { return fmt . Errorf ( formatVirtualMachinePostCloneRollbackError , vm . InventoryPath , origErr , err ) } return fmt . Errorf ( "error reconfiguring virtual machine: %s" , origErr ) }
1134	func ( c * cache ) Items ( ) map [ string ] Item { c . mu . RLock ( ) defer c . mu . RUnlock ( ) m := make ( map [ string ] Item , len ( c . items ) ) now := time . Now ( ) . UnixNano ( ) for k , v := range c . items { if v . Expiration > 0 { if now > v . Expiration { continue } } m [ k ] = v } return m }
4816	func ( r * Repo ) mostRecentCommit ( ) ( string , error ) { command := gitBinary + ` --no-pager log -n 1 --pretty=format:"%H"` c , args , err := caddy . SplitCommandAndArgs ( command ) if err != nil { return "" , err } return runCmdOutput ( c , args , r . Path ) }
3933	func NewHandler ( ) Handler { h := & basicHandler { livenessChecks : make ( map [ string ] Check ) , readinessChecks : make ( map [ string ] Check ) , } h . Handle ( "/live" , http . HandlerFunc ( h . LiveEndpoint ) ) h . Handle ( "/ready" , http . HandlerFunc ( h . ReadyEndpoint ) ) return h }
3419	func ( o * Options ) GetIncludeTags ( ) bool { if o == nil || o . IncludeTags == nil { return false } return * o . IncludeTags }
2382	func decode ( in audio . ReadSeekCloser ) ( * decoded , int , int , error ) { r , err := newDecoder ( in ) if err != nil { return nil , 0 , 0 , err } d := & decoded { totalBytes : int ( r . Length ( ) ) * r . Channels ( ) * 2 , posInBytes : 0 , source : in , decoder : r , } runtime . SetFinalizer ( d , ( * decoded ) . Close ) if _ , err := d . Read ( make ( [ ] byte , 65536 ) ) ; err != nil && err != io . EOF { return nil , 0 , 0 , err } if _ , err := d . Seek ( 0 , io . SeekStart ) ; err != nil { return nil , 0 , 0 , err } return d , r . Channels ( ) , r . SampleRate ( ) , nil }
3070	func ( rb * RequestBody ) String ( ) ( string , error ) { data , err := rb . Bytes ( ) return string ( data ) , err }
804	func listHostOnlyAdapters ( vbox VBoxManager ) ( map [ string ] * hostOnlyNetwork , error ) { out , err := vbox . vbmOut ( "list" , "hostonlyifs" ) if err != nil { return nil , err } byName := map [ string ] * hostOnlyNetwork { } byIP := map [ string ] * hostOnlyNetwork { } n := & hostOnlyNetwork { } err = parseKeyValues ( out , reColonLine , func ( key , val string ) error { switch key { case "Name" : n . Name = val case "GUID" : n . GUID = val case "DHCP" : n . DHCP = ( val != "Disabled" ) case "IPAddress" : n . IPv4 . IP = net . ParseIP ( val ) case "NetworkMask" : n . IPv4 . Mask = parseIPv4Mask ( val ) case "HardwareAddress" : mac , err := net . ParseMAC ( val ) if err != nil { return err } n . HwAddr = mac case "MediumType" : n . Medium = val case "Status" : n . Status = val case "VBoxNetworkName" : n . NetworkName = val if _ , present := byName [ n . NetworkName ] ; present { return fmt . Errorf ( "VirtualBox is configured with multiple host-only adapters with the same name %q. Please remove one" , n . NetworkName ) } byName [ n . NetworkName ] = n if len ( n . IPv4 . IP ) != 0 { if _ , present := byIP [ n . IPv4 . IP . String ( ) ] ; present { return fmt . Errorf ( "VirtualBox is configured with multiple host-only adapters with the same IP %q. Please remove one" , n . IPv4 . IP ) } byIP [ n . IPv4 . IP . String ( ) ] = n } n = & hostOnlyNetwork { } } return nil } ) if err != nil { return nil , err } return byName , nil }
3825	func SetNodeInterface ( name string ) bool { defer nodeMu . Unlock ( ) nodeMu . Lock ( ) return setNodeInterface ( name ) }
6277	func OfferingMessage ( agent * data . Account , template * data . Template , offering * data . Offering ) * Message { msg := & Message { AgentPubKey : agent . PublicKey , TemplateHash : template . Hash , Country : offering . Country , ServiceSupply : offering . Supply , UnitName : offering . UnitName , UnitType : offering . UnitType , BillingType : offering . BillingType , SetupPrice : offering . SetupPrice , UnitPrice : offering . UnitPrice , MinUnits : offering . MinUnits , MaxUnit : offering . MaxUnit , BillingInterval : offering . BillingInterval , MaxBillingUnitLag : offering . MaxBillingUnitLag , MaxSuspendTime : offering . MaxSuspendTime , MaxInactiveTimeSec : offering . MaxInactiveTimeSec , FreeUnits : offering . FreeUnits , Nonce : offering . ID , ServiceSpecificParameters : offering . AdditionalParams , } return msg }
4501	func Sequence ( filters ... Filter ) Filter { if len ( filters ) == 1 { return filters [ 0 ] } return FilterFunc ( func ( arg Arg ) error { e := & filterErrors { } in := arg . In for _ , f := range filters { c := make ( chan string , channelBuffer ) go runFilter ( f , Arg { In : in , Out : c } , e ) in = c } for s := range in { arg . Out <- s } return e . getError ( ) } ) }
2819	func expandVmwareUplinkPortTeamingPolicy ( d * schema . ResourceData ) * types . VmwareUplinkPortTeamingPolicy { obj := & types . VmwareUplinkPortTeamingPolicy { Policy : structure . GetStringPolicy ( d , "teaming_policy" ) , NotifySwitches : structure . GetBoolPolicy ( d , "notify_switches" ) , RollingOrder : structure . GetBoolPolicyReverse ( d , "failback" ) , FailureCriteria : expandDVSFailureCriteria ( d ) , UplinkPortOrder : expandVMwareUplinkPortOrderPolicy ( d ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
3623	func ( t * TraceServiceDefinition ) GetServiceOk ( ) ( string , bool ) { if t == nil || t . Service == nil { return "" , false } return * t . Service , true }
6514	func ( c Client ) CreateOrderFromButtonCode ( buttonCode string ) ( * order , error ) { holder := orderHolder { } if err := c . Post ( "buttons/" + buttonCode + "/create_order" , nil , & holder ) ; err != nil { return nil , err } if err := checkApiErrors ( holder . response , "CreateOrderFromButtonCode" ) ; err != nil { return nil , err } return & holder . Order , nil }
4362	func Chain ( filters ... Op ) OpFunc { return func ( in [ ] byte ) ( [ ] byte , error ) { if filters == nil { return in , nil } var err error data := in for _ , filter := range filters { data , err = filter . Apply ( data ) if err != nil { return nil , err } } return data , nil } }
2481	func ( p * player ) RotateLeft ( ) { p . angle -- if p . angle < 0 { p . angle += maxAngle } p . lean -- if p . lean < - maxLean { p . lean = - maxLean } }
4030	func NewColorParser ( str string , defText , defBack term . Attribute ) * ColorParser { p := new ( ColorParser ) p . text = [ ] rune ( str ) p . defBack , p . defText = defBack , defText p . currBack , p . currText = defBack , defText return p }
2970	func ReadDiskAttrsForDataSource ( l object . VirtualDeviceList , count int ) ( [ ] map [ string ] interface { } , error ) { log . Printf ( "[DEBUG] ReadDiskAttrsForDataSource: Fetching select attributes for disks across %d SCSI controllers" , count ) devices := SelectDisks ( l , count ) log . Printf ( "[DEBUG] ReadDiskAttrsForDataSource: Disk devices located: %s" , DeviceListString ( devices ) ) devSort := virtualDeviceListSorter { Sort : devices , DeviceList : l , } sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( "[DEBUG] ReadDiskAttrsForDataSource: Disk devices order after sort: %s" , DeviceListString ( devices ) ) var out [ ] map [ string ] interface { } for i , device := range devices { disk := device . ( * types . VirtualDisk ) backing , ok := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) if ! ok { return nil , fmt . Errorf ( "disk number %d has an unsupported backing type (expected flat VMDK version 2, got %T)" , i , disk . Backing ) } m := make ( map [ string ] interface { } ) var eager , thin bool if backing . EagerlyScrub != nil { eager = * backing . EagerlyScrub } if backing . ThinProvisioned != nil { thin = * backing . ThinProvisioned } m [ "size" ] = diskCapacityInGiB ( disk ) m [ "eagerly_scrub" ] = eager m [ "thin_provisioned" ] = thin out = append ( out , m ) } log . Printf ( "[DEBUG] ReadDiskAttrsForDataSource: Attributes returned: %+v" , out ) return out , nil }
7012	func ( i * IrcText ) SetBg ( c int ) * IrcText { i . bgColor = c return i }
6040	func ( w * Worker ) PreAccountAddBalanceApprove ( job * data . Job ) error { logger := w . logger . Add ( "method" , "PreAccountAddBalanceApprove" , "job" , job ) acc , err := w . relatedAccount ( logger , job , data . JobPreAccountAddBalanceApprove ) if err != nil { return err } logger = logger . Add ( "account" , acc ) jobData , err := w . balanceData ( logger , job ) if err != nil { return fmt . Errorf ( "failed to parse job data: %v" , err ) } addr , err := data . HexToAddress ( acc . EthAddr ) if err != nil { logger . Error ( err . Error ( ) ) return ErrParseEthAddr } amount , err := w . ethBack . PTCBalanceOf ( & bind . CallOpts { } , addr ) if err != nil { logger . Error ( err . Error ( ) ) return ErrPTCRetrieveBalance } if amount . Uint64 ( ) < uint64 ( jobData . Amount ) { return ErrInsufficientPTCBalance } ethBalance , err := w . ethBalance ( logger , addr ) if err != nil { return err } wantedEthBalance := w . gasConf . PTC . Approve * jobData . GasPrice if wantedEthBalance > ethBalance . Uint64 ( ) { return ErrInsufficientEthBalance } key , err := w . key ( logger , acc . PrivateKey ) if err != nil { return err } auth := bind . NewKeyedTransactor ( key ) auth . GasLimit = w . gasConf . PTC . Approve auth . GasPrice = new ( big . Int ) . SetUint64 ( jobData . GasPrice ) tx , err := w . ethBack . PTCIncreaseApproval ( auth , w . pscAddr , new ( big . Int ) . SetUint64 ( jobData . Amount ) ) if err != nil { logger . Error ( err . Error ( ) ) return ErrPTCIncreaseApproval } return w . saveEthTX ( logger , job , tx , "PTCIncreaseApproval" , job . RelatedType , job . RelatedID , acc . EthAddr , data . HexFromBytes ( w . pscAddr . Bytes ( ) ) ) }
4488	func ( d * Date ) UnmarshalJSON ( data [ ] byte ) error { if string ( data ) == jsonNull { return nil } l := jlexer . Lexer { Data : data } d . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
5134	func ( ui * ColorUI ) Output ( message string ) { ct . ChangeColor ( ui . OutputFGColor . Code , ui . OutputFGColor . Bright , ui . OutputBGColor . Code , ui . OutputBGColor . Bright ) ui . UI . Output ( message ) ct . ResetColor ( ) }
5798	func ( a * API ) UpdateUser ( cfg * User ) ( * User , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid user config [nil]" ) } userCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . UserCIDRegex , userCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid user CID [%s]" , userCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update user, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( userCID , jsonCfg ) if err != nil { return nil , err } user := & User { } if err := json . Unmarshal ( result , user ) ; err != nil { return nil , err } return user , nil }
2980	func ( r * DiskSubresource ) expandDiskSettings ( disk * types . VirtualDisk ) error { b := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) b . DiskMode = r . GetWithRestart ( "disk_mode" ) . ( string ) b . WriteThrough = structure . BoolPtr ( r . GetWithRestart ( "write_through" ) . ( bool ) ) version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { b . Sharing = r . GetWithRestart ( "disk_sharing" ) . ( string ) } if ! r . Get ( "attach" ) . ( bool ) { var err error var v interface { } if v , err = r . GetWithVeto ( "thin_provisioned" ) ; err != nil { return err } b . ThinProvisioned = structure . BoolPtr ( v . ( bool ) ) if v , err = r . GetWithVeto ( "eagerly_scrub" ) ; err != nil { return err } b . EagerlyScrub = structure . BoolPtr ( v . ( bool ) ) os , ns := r . GetChange ( "size" ) if os . ( int ) > ns . ( int ) { return fmt . Errorf ( "virtual disks cannot be shrunk" ) } disk . CapacityInBytes = structure . GiBToByte ( ns . ( int ) ) disk . CapacityInKB = disk . CapacityInBytes / 1024 } alloc := & types . StorageIOAllocationInfo { Limit : structure . Int64Ptr ( int64 ( r . Get ( "io_limit" ) . ( int ) ) ) , Reservation : structure . Int32Ptr ( int32 ( r . Get ( "io_reservation" ) . ( int ) ) ) , Shares : & types . SharesInfo { Shares : int32 ( r . Get ( "io_share_count" ) . ( int ) ) , Level : types . SharesLevel ( r . Get ( "io_share_level" ) . ( string ) ) , } , } disk . StorageIOAllocation = alloc return nil }
2331	func ( v * Context ) Scale ( sx , sy float64 ) { C . cairo_scale ( v . native ( ) , C . double ( sx ) , C . double ( sy ) ) }
4851	func GenFirebird ( u * URL ) ( string , error ) { z := & url . URL { User : u . User , Host : u . Host , Path : u . Path , RawPath : u . RawPath , RawQuery : u . RawQuery , Fragment : u . Fragment , } return strings . TrimPrefix ( z . String ( ) , "//" ) , nil }
6971	func ( c GConfig ) getValue ( key string ) interface { } { v := c . defaultConfig . configs [ key ] if c . profileConfig . fileInfo != nil && s . Contains ( c . profileConfig . fileInfo . Name ( ) , c . Profile ) { v = c . profileConfig . configs [ key ] } if v == nil { v = c . defaultConfig . configs [ key ] } return v }
4481	func ( d * Duration ) DeepCopy ( ) * Duration { if d == nil { return nil } out := new ( Duration ) d . DeepCopyInto ( out ) return out }
1190	func ( task * Task ) platformHostConfigOverride ( hostConfig * dockercontainer . HostConfig ) error { hostConfig . CPUPercent = hostConfig . CPUShares * percentageFactor / int64 ( cpuShareScaleFactor ) if hostConfig . CPUPercent == 0 && hostConfig . CPUShares != 0 { hostConfig . CPUPercent = minimumCPUPercent } hostConfig . CPUShares = 0 return nil }
5092	func Edit ( c * gin . Context ) { db := c . MustGet ( "db" ) . ( * mgo . Database ) article := models . Article { } oID := bson . ObjectIdHex ( c . Param ( "_id" ) ) err := db . C ( models . CollectionArticle ) . FindId ( oID ) . One ( & article ) if err != nil { c . Error ( err ) } c . HTML ( http . StatusOK , "articles/form" , gin . H { "title" : "Edit article" , "article" : article , } ) }
1198	func ( mr * MockTimeMockRecorder ) Now ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Now" , reflect . TypeOf ( ( * MockTime ) ( nil ) . Now ) ) }
452	func ( s * Server ) AppendCertEmbed ( certData , keyData [ ] byte ) error { if len ( certData ) == 0 && len ( keyData ) == 0 { return errNoCertOrKeyProvided } cert , err := tls . X509KeyPair ( certData , keyData ) if err != nil { return fmt . Errorf ( "cannot load TLS key pair from the provided certData(%d) and keyData(%d): %s" , len ( certData ) , len ( keyData ) , err ) } s . configTLS ( ) s . tlsConfig . Certificates = append ( s . tlsConfig . Certificates , cert ) return nil }
1550	func ( m * MockCgroup ) Stat ( arg0 ... cgroups . ErrorHandler ) ( * cgroups . Stats , error ) { varargs := [ ] interface { } { } for _ , a := range arg0 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "Stat" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * cgroups . Stats ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
4731	func NewServer ( ) http . Handler { r := mux . NewRouter ( ) r . Path ( "/hello" ) . Methods ( "GET" ) . HandlerFunc ( handleHello ) return r }
2195	func Take ( ptr unsafe . Pointer ) * Object { obj := newObject ( ToGObject ( ptr ) ) if obj . IsFloating ( ) { obj . RefSink ( ) } else { obj . Ref ( ) } runtime . SetFinalizer ( obj , ( * Object ) . Unref ) return obj }
1585	func ( m * MockSecretsManagerAPI ) DescribeSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . DescribeSecretInput , arg2 ... request . Option ) ( * secretsmanager . DescribeSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "DescribeSecretWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DescribeSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
4806	func Start ( repo * Repo ) { if repo . Interval <= 0 { Logger ( ) . Println ( "interval too small, periodic pull not enabled." ) return } service := & repoService { repo , gos . NewTicker ( repo . Interval ) , make ( chan struct { } ) , } go func ( s * repoService ) { for { select { case <- s . ticker . C ( ) : err := repo . Pull ( ) if err != nil { Logger ( ) . Println ( err ) } case <- s . halt : s . ticker . Stop ( ) return } } } ( service ) Services . add ( service ) }
6488	func ( a clientOAuthAuthentication ) authenticate ( req * http . Request , endpoint string , params [ ] byte ) error { if time . Now ( ) . UTC ( ) . Unix ( ) > a . Tokens . ExpireTime { return errors . New ( "The OAuth tokens are expired. Use refreshTokens to refresh them" ) } req . Header . Set ( "Authorization" , "Bearer " + a . Tokens . AccessToken ) return nil }
4929	func ( w * Writer ) WriteInt64 ( i int64 ) { if w . err != nil { return } binary . LittleEndian . PutUint64 ( w . b [ : 8 ] , uint64 ( i ) ) w . wr . Write ( w . b [ : 8 ] ) }
5117	func ( file * GridFile ) SetUploadDate ( t time . Time ) { file . assertMode ( gfsWriting ) file . m . Lock ( ) file . doc . UploadDate = t file . m . Unlock ( ) }
1050	func New ( i * NewInput ) ( * Child , error ) { if i == nil { i = new ( NewInput ) } if len ( i . Command ) == 0 { return nil , ErrMissingCommand } child := & Child { stdin : i . Stdin , stdout : i . Stdout , stderr : i . Stderr , command : i . Command , args : i . Args , env : i . Env , timeout : i . Timeout , reloadSignal : i . ReloadSignal , killSignal : i . KillSignal , killTimeout : i . KillTimeout , splay : i . Splay , stopCh : make ( chan struct { } , 1 ) , } return child , nil }
3494	func ( s * Series ) GetAggr ( ) string { if s == nil || s . Aggr == nil { return "" } return * s . Aggr }
2493	func ( i * Image ) makeVolatile ( ) { if i . isDisposed ( ) { return } i . mipmap . orig . MakeVolatile ( ) i . disposeMipmaps ( ) }
6204	func ValidateJSON ( schema , data [ ] byte ) bool { sloader := gojsonschema . NewBytesLoader ( schema ) dloader := gojsonschema . NewBytesLoader ( data ) result , err := gojsonschema . Validate ( sloader , dloader ) return err == nil && result . Valid ( ) && len ( result . Errors ( ) ) == 0 }
2510	func ( c * newImageCommand ) Exec ( indexOffset int ) error { i , err := theGraphicsDriver . NewImage ( c . width , c . height ) if err != nil { return err } c . result . image = i return nil }
3304	func ( e * Event ) GetPriority ( ) string { if e == nil || e . Priority == nil { return "" } return * e . Priority }
5282	func NewValueIterator ( format Format , reader io . Reader ) * Iterator { return NewIterator ( reader , FieldValueUnmarshaller ( format ) ) }
2062	func NewPublishMetricsRequest ( metadata * MetricsMetadata , taskMetrics [ ] * TaskMetric ) * PublishMetricsRequest { return & PublishMetricsRequest { Metadata : metadata , TaskMetrics : taskMetrics , Timestamp : aws . Time ( time . Now ( ) ) , } }
2370	func ( p * Player ) Close ( ) error { runtime . SetFinalizer ( p , nil ) return p . p . Close ( ) }
2918	func setSCSIBusSharing ( l * object . VirtualDeviceList , ctlr types . BaseVirtualSCSIController , st string ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { var cspec [ ] types . BaseVirtualDeviceConfigSpec if ctlr . GetVirtualSCSIController ( ) . SharedBus != types . VirtualSCSISharing ( st ) { ctlr . GetVirtualSCSIController ( ) . SharedBus = types . VirtualSCSISharing ( st ) var err error cspec , err = object . VirtualDeviceList { ctlr . ( types . BaseVirtualDevice ) } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } * l = applyDeviceChange ( * l , cspec ) } return cspec , nil }
3020	func validateHostFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeHost { return nil , fmt . Errorf ( "%q is not a host folder" , folder . InventoryPath ) } return folder , nil }
1829	func ( mtask * managedTask ) emitContainerEvent ( task * apitask . Task , cont * apicontainer . Container , reason string ) { event , err := api . NewContainerStateChangeEvent ( task , cont , reason ) if err != nil { seelog . Debugf ( "Managed task [%s]: unable to create state change event for container [%s]: %v" , task . Arn , cont . Name , err ) return } seelog . Infof ( "Managed task [%s]: sending container change event [%s]: %s" , mtask . Arn , cont . Name , event . String ( ) ) mtask . stateChangeEvents <- event seelog . Infof ( "Managed task [%s]: sent container change event [%s]: %s" , mtask . Arn , cont . Name , event . String ( ) ) }
1480	func ( c * Container ) SetKnownPortBindings ( ports [ ] PortBinding ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . KnownPortBindingsUnsafe = ports }
6926	func NewClient ( apiKey string ) * Client { return & Client { client : & http . Client { Transport : & http . Transport { Proxy : http . ProxyFromEnvironment , DialContext : ( & net . Dialer { Timeout : 30 * time . Second , KeepAlive : 30 * time . Second , DualStack : true , } ) . DialContext , DisableKeepAlives : true , TLSHandshakeTimeout : 10 * time . Second , ExpectContinueTimeout : 1 * time . Second , } } , apiKey : apiKey , URL : DefaultURL , } }
3708	func ( w * Widget ) HasMustShowResourceList ( ) bool { if w != nil && w . MustShowResourceList != nil { return true } return false }
3556	func ( s * SyntheticsTest ) GetMonitorStatus ( ) string { if s == nil || s . MonitorStatus == nil { return "" } return * s . MonitorStatus }
4326	func ( c * Client ) GetCheckoutKey ( account , repo , fingerprint string ) ( * CheckoutKey , error ) { checkoutKey := & CheckoutKey { } err := c . request ( "GET" , fmt . Sprintf ( "project/%s/%s/checkout-key/%s" , account , repo , fingerprint ) , & checkoutKey , nil , nil ) if err != nil { return nil , err } return checkoutKey , nil }
522	func ( h * ResponseHeader ) Header ( ) [ ] byte { h . bufKV . value = h . AppendBytes ( h . bufKV . value [ : 0 ] ) return h . bufKV . value }
3221	func ( a * Alert ) GetState ( ) string { if a == nil || a . State == nil { return "" } return * a . State }
6091	func ( q * queue ) Unsubscribe ( subKeys [ ] string , subID string ) error { q . subsMtx . Lock ( ) defer q . subsMtx . Unlock ( ) var err error for _ , v := range subKeys { if err2 := q . unsubscribe ( v , subID ) ; err == nil { err = err2 } } return err }
3679	func ( w * Widget ) GetManageStatusTitleAlign ( ) string { if w == nil || w . ManageStatusTitleAlign == nil { return "" } return * w . ManageStatusTitleAlign }
725	func NewAWSSDProvider ( domainFilter DomainFilter , namespaceType string , assumeRole string , dryRun bool ) ( * AWSSDProvider , error ) { config := aws . NewConfig ( ) config = config . WithHTTPClient ( instrumented_http . NewClient ( config . HTTPClient , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , "/" ) return parts [ len ( parts ) - 1 ] } , } ) , ) sess , err := session . NewSessionWithOptions ( session . Options { Config : * config , SharedConfigState : session . SharedConfigEnable , } ) if err != nil { return nil , err } if assumeRole != "" { log . Infof ( "Assuming role: %s" , assumeRole ) sess . Config . WithCredentials ( stscreds . NewCredentials ( sess , assumeRole ) ) } sess . Handlers . Build . PushBack ( request . MakeAddToUserAgentHandler ( "ExternalDNS" , externaldns . Version ) ) provider := & AWSSDProvider { client : sd . New ( sess ) , namespaceFilter : domainFilter , namespaceTypeFilter : newSdNamespaceFilter ( namespaceType ) , dryRun : dryRun , } return provider , nil }
3328	func ( g * GroupData ) GetLastNoDataTs ( ) int { if g == nil || g . LastNoDataTs == nil { return 0 } return * g . LastNoDataTs }
1168	func ( payloadHandler * payloadRequestHandler ) handleMessages ( ) { for { select { case payload := <- payloadHandler . messageBuffer : payloadHandler . handleSingleMessage ( payload ) case <- payloadHandler . ctx . Done ( ) : return } } }
6594	func ( q * Query ) And ( n int ) * Query { q . headers = append ( q . headers , fmt . Sprintf ( "And: %d" , n ) ) return q }
3311	func ( g * Graph ) GetDefinitionOk ( ) ( GraphDefinition , bool ) { if g == nil || g . Definition == nil { return GraphDefinition { } , false } return * g . Definition , true }
3269	func ( d * DashboardConditionalFormat ) GetCustomImageUrlOk ( ) ( string , bool ) { if d == nil || d . CustomImageUrl == nil { return "" , false } return * d . CustomImageUrl , true }
3286	func ( d * Downtime ) GetMonitorId ( ) int { if d == nil || d . MonitorId == nil { return 0 } return * d . MonitorId }
5685	func adjustErr ( err error , adj int ) error { if err == nil { return nil } if de , ok := err . ( demangleErr ) ; ok { de . off += adj return de } return err }
1382	func ( queue * Queue ) Reset ( ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queue . lastResetTime = time . Now ( ) queue . buffer = queue . buffer [ : 0 ] }
6369	func ( w * Writer ) SetOutput ( out io . Writer ) { w . mutex . Lock ( ) w . printer = newPrinter ( out ) w . mutex . Unlock ( ) }
5696	func doDemangle ( out * bufio . Writer , name string ) { skip := 0 if name [ 0 ] == '.' || name [ 0 ] == '$' { skip ++ } if * stripUnderscore && name [ skip ] == '_' { skip ++ } result := demangle . Filter ( name [ skip : ] , options ( ) ... ) if result == name [ skip : ] { out . WriteString ( name ) } else { if name [ 0 ] == '.' { out . WriteByte ( '.' ) } out . WriteString ( result ) } }
3888	func ( b * builder ) stmtList ( fn * Function , list [ ] ast . Stmt ) { for _ , s := range list { b . stmt ( fn , s ) } }
6262	func ( h * Handler ) PingOfferings ( tkn string , ids [ ] string ) ( map [ string ] bool , error ) { logger := h . logger . Add ( "method" , "PingOfferings" , "ids" , ids ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } now := time . Now ( ) ret := make ( map [ string ] bool ) wg := new ( sync . WaitGroup ) wg . Add ( len ( ids ) ) for _ , id := range ids { offering , err := h . findActiveOfferingByID ( logger , id ) if err != nil { return nil , err } go func ( offering * data . Offering ) { err := h . pingOffering ( logger , offering ) if err == nil { ret [ offering . ID ] = true offering . SOMCSuccessPing = & now err = update ( logger , h . db . Querier , offering ) if err != nil { logger . Warn ( err . Error ( ) ) } } else { ret [ offering . ID ] = false logger . Debug ( err . Error ( ) ) } wg . Done ( ) } ( offering ) } wg . Wait ( ) return ret , nil }
1066	func ( r * Runner ) RenderEvents ( ) map [ string ] * RenderEvent { r . renderEventsLock . RLock ( ) defer r . renderEventsLock . RUnlock ( ) times := make ( map [ string ] * RenderEvent , len ( r . renderEvents ) ) for k , v := range r . renderEvents { times [ k ] = v } return times }
6432	func IsTerminal ( writer io . Writer ) bool { if fd , ok := fileDescriptor ( writer ) ; ok { return terminal . IsTerminal ( fd ) } return false }
7178	func ( s * SessionCache ) Add ( ) string { strSum := s . salter . DefaultToken ( ) err := s . cache . Add ( strSum , nil ) if err != nil { panic ( "Something is seriously wrong, a duplicated token was generated" ) } return strSum }
2112	func anyMessageHandler ( client wsclient . ClientServer ) func ( interface { } ) { return func ( interface { } ) { seelog . Trace ( "TCS activity occurred" ) if err := client . SetReadDeadline ( time . Now ( ) . Add ( wsRWTimeout ) ) ; err != nil { seelog . Warnf ( "Unable to extend read deadline for TCS connection: %v" , err ) } } }
2352	func ( i * Image ) QuadVertices ( sx0 , sy0 , sx1 , sy1 int , a , b , c , d , tx , ty float32 , cr , cg , cb , ca float32 ) [ ] float32 { if i . backend == nil { i . allocate ( true ) } ox , oy , _ , _ := i . region ( ) return i . backend . restorable . QuadVertices ( sx0 + ox , sy0 + oy , sx1 + ox , sy1 + oy , a , b , c , d , tx , ty , cr , cg , cb , ca ) }
2844	func ( r * CdromSubresource ) Update ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Beginning update" , r ) d , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( "cannot find disk device: %s" , err ) } device , ok := d . ( * types . VirtualCdrom ) if ! ok { return nil , fmt . Errorf ( "device at %q is not a virtual CDROM device" , l . Name ( d ) ) } r . mapCdrom ( device , l ) spec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } log . Printf ( "[DEBUG] %s: Device config operations from update: %s" , r , DeviceChangeString ( spec ) ) log . Printf ( "[DEBUG] %s: Update complete" , r ) return spec , nil }
3576	func ( t * ThresholdCount ) HasOk ( ) bool { if t != nil && t . Ok != nil { return true } return false }
2376	func ( c * gamepadConfig ) IsButtonPressed ( b virtualGamepadButton ) bool { if ! c . gamepadIDInitialized { panic ( "not reached" ) } c . initializeIfNeeded ( ) bb , ok := c . buttons [ b ] if ok { return ebiten . IsGamepadButtonPressed ( c . gamepadID , bb ) } a , ok := c . axes [ b ] if ok { v := ebiten . GamepadAxis ( c . gamepadID , a . id ) if a . positive { return axisThreshold <= v && v <= 1.0 } else { return - 1.0 <= v && v <= - axisThreshold } } return false }
4364	func Range ( from , to int ) OpFunc { return func ( in [ ] byte ) ( [ ] byte , error ) { return scanner . FindRange ( in , 0 , from , to ) } }
1154	func ( c * ec2MetadataClientImpl ) DefaultCredentials ( ) ( * RoleCredentials , error ) { securityCredential , err := c . client . GetMetadata ( SecurityCrednetialsResource ) if err != nil { return nil , err } securityCredentialList := strings . Split ( strings . TrimSpace ( securityCredential ) , "\n" ) \n if len ( securityCredentialList ) == 0 { return nil , errors . New ( "No security credentials in response" ) } defaultCredentialName := securityCredentialList [ 0 ] defaultCredentialStr , err := c . client . GetMetadata ( SecurityCrednetialsResource + defaultCredentialName ) if err != nil { return nil , err } var credential RoleCredentials err = json . Unmarshal ( [ ] byte ( defaultCredentialStr ) , & credential ) if err != nil { return nil , err } }
1460	func ( c * Container ) SetDesiredStatus ( status apicontainerstatus . ContainerStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . DesiredStatusUnsafe = status }
6175	func ( m * Monitor ) VerifyBillingLags ( ) error { query := ` SELECT channels.id :: text FROM channels LEFT JOIN sessions ses ON channels.id = ses.channel LEFT JOIN offerings offer ON channels.offering = offer.id INNER JOIN accounts acc ON channels.agent = acc.eth_addr WHERE channels.service_status IN ('pending', 'active') AND channels.channel_status NOT IN ('pending') AND acc.in_use GROUP BY channels.id, offer.billing_interval, offer.setup_price, offer.unit_price, offer.max_billing_unit_lag HAVING COALESCE(SUM(ses.units_used), 0) / offer.billing_interval - (channels.receipt_balance - offer.setup_price ) / offer.unit_price > offer.max_billing_unit_lag;` return m . processEachChannel ( query , m . suspendService ) }
5758	func ( a * API ) FetchCheckBundle ( cid CIDType ) ( * CheckBundle , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid check bundle CID [none]" ) } bundleCID := string ( * cid ) matched , err := regexp . MatchString ( config . CheckBundleCIDRegex , bundleCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid check bundle CID [%v]" , bundleCID ) } result , err := a . Get ( bundleCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch check bundle, received JSON: %s" , string ( result ) ) } checkBundle := & CheckBundle { } if err := json . Unmarshal ( result , checkBundle ) ; err != nil { return nil , err } return checkBundle , nil }
1179	func NewMockContainerMetadataResolver ( ctrl * gomock . Controller ) * MockContainerMetadataResolver { mock := & MockContainerMetadataResolver { ctrl : ctrl } mock . recorder = & MockContainerMetadataResolverMockRecorder { mock } return mock }
6083	func NewProcessor ( conf * Config , db * reform . DB , queue job . Queue ) * Processor { return & Processor { conf : conf , db : db , queue : queue , } }
36	func NewDiscovery ( conf SDConfig , logger log . Logger ) ( * Discovery , error ) { rt , err := config_util . NewRoundTripperFromConfig ( conf . HTTPClientConfig , "marathon_sd" ) if err != nil { return nil , err } if len ( conf . AuthToken ) > 0 { rt , err = newAuthTokenRoundTripper ( conf . AuthToken , rt ) } else if len ( conf . AuthTokenFile ) > 0 { rt , err = newAuthTokenFileRoundTripper ( conf . AuthTokenFile , rt ) } if err != nil { return nil , err } d := & Discovery { client : & http . Client { Transport : rt } , servers : conf . Servers , appsClient : fetchApps , } d . Discovery = refresh . NewDiscovery ( logger , "marathon" , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d , nil }
410	func ( u * URI ) RequestURI ( ) [ ] byte { dst := appendQuotedPath ( u . requestURI [ : 0 ] , u . Path ( ) ) if u . queryArgs . Len ( ) > 0 { dst = append ( dst , '?' ) dst = u . queryArgs . AppendBytes ( dst ) } else if len ( u . queryString ) > 0 { dst = append ( dst , '?' ) dst = append ( dst , u . queryString ... ) } if len ( u . hash ) > 0 { dst = append ( dst , '#' ) dst = append ( dst , u . hash ... ) } u . requestURI = dst return u . requestURI }
635	func NewZoneTagFilter ( tags [ ] string ) ZoneTagFilter { if len ( tags ) == 1 && len ( tags [ 0 ] ) == 0 { tags = [ ] string { } } return ZoneTagFilter { zoneTags : tags } }
4606	func ( p * Palette ) functionColor ( line * stack . Call ) string { if line . IsStdlib { if line . Func . IsExported ( ) { return p . FuncStdLibExported } return p . FuncStdLib } else if line . IsPkgMain ( ) { return p . FuncMain } else if line . Func . IsExported ( ) { return p . FuncOtherExported } return p . FuncOther }
5371	func GetUsername ( ) string { entry , err := LookupUID ( os . Getuid ( ) ) if err != nil { panic ( err ) } return entry . Name }
5946	func ( host rawHost ) cleanHost ( ) Host { output := Host { nil , host . Status . State , host . Address . Address , host . Address . AddressType , [ ] Hostname { } , [ ] Port { } , } for _ , hostname := range host . Hostnames . Hostnames { output . Hostnames = append ( output . Hostnames , Hostname { hostname . Name , hostname . Type } ) } for _ , port := range host . Ports . Ports { output . Ports = append ( output . Ports , port . cleanPort ( ) ) } return output }
4846	func GenOpaque ( u * URL ) ( string , error ) { if u . Opaque == "" { return "" , ErrMissingPath } return u . Opaque + genQueryOptions ( u . Query ( ) ) , nil }
7007	func NewPgDump ( ip string , port int , database , username , password string ) * PgDump { return & PgDump { IP : ip , Port : port , Database : database , Username : username , Password : password , Caller : command . NewLocalExecuter ( ) , RecreateOnRestore : false , } }
1684	func ( cgroup * CgroupResource ) Initialize ( resourceFields * taskresource . ResourceFields , taskKnownStatus status . TaskStatus , taskDesiredStatus status . TaskStatus ) { }
2351	func TexImage3D ( target uint32 , level int32 , internalformat int32 , width int32 , height int32 , depth int32 , border int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexImage3D ( gpTexImage3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) }
5291	func ( m * GorillaPathPrefix ) Build ( u * url . URL , values url . Values ) error { path , err := m . RevertValid ( values ) if err == nil { u . Path = path } return err }
5197	func ( q * PQLBatchQuery ) Add ( query PQLQuery ) { err := query . Error ( ) if err != nil { q . err = err } serializedQuery := query . Serialize ( ) q . hasKeys = q . hasKeys || serializedQuery . HasWriteKeys ( ) q . queries = append ( q . queries , serializedQuery . String ( ) ) }
6319	func ( c * Controller ) UrlFor ( routeName string , args ... string ) * url . URL { return UrlFor ( routeName , args ... ) }
723	func NewPDNSProvider ( config PDNSConfig ) ( * PDNSProvider , error ) { if config . APIKey == "" { return nil , errors . New ( "Missing API Key for PDNS. Specify using --pdns-api-key=" ) } if config . DryRun { return nil , errors . New ( "PDNS Provider does not currently support dry-run" ) } if config . Server == "localhost" { log . Warnf ( "PDNS Server is set to localhost, this may not be what you want. Specify using --pdns-server=" ) } pdnsClientConfig := pgo . NewConfiguration ( ) pdnsClientConfig . BasePath = config . Server + apiBase if err := config . TLSConfig . setHTTPClient ( pdnsClientConfig ) ; err != nil { return nil , err } provider := & PDNSProvider { client : & PDNSAPIClient { dryRun : config . DryRun , authCtx : context . WithValue ( context . TODO ( ) , pgo . ContextAPIKey , pgo . APIKey { Key : config . APIKey } ) , client : pgo . NewAPIClient ( pdnsClientConfig ) , domainFilter : config . DomainFilter , } , } return provider , nil }
955	func printVaultWarnings ( d Dependency , warnings [ ] string ) { for _ , w := range warnings { log . Printf ( "[WARN] %s: %s" , d , w ) } }
5199	func ( io IndexOptions ) String ( ) string { mopt := map [ string ] interface { } { } if io . keysSet { mopt [ "keys" ] = io . keys } if io . trackExistenceSet { mopt [ "trackExistence" ] = io . trackExistence } return fmt . Sprintf ( `{"options":%s}` , encodeMap ( mopt ) ) }
1387	func NewMockCNIClient ( ctrl * gomock . Controller ) * MockCNIClient { mock := & MockCNIClient { ctrl : ctrl } mock . recorder = & MockCNIClientMockRecorder { mock } return mock }
780	func ( in * Endpoint ) DeepCopy ( ) * Endpoint { if in == nil { return nil } out := new ( Endpoint ) in . DeepCopyInto ( out ) return out }
7139	func ( cn * ContentNegotiator ) getEncoder ( req * http . Request ) Encoder { var result = cn . DefaultEncoder accept := req . Header . Get ( "Accept" ) for k , v := range cn . encoderMap { if strings . Contains ( accept , k ) { result = v break } } return result }
6860	func ( dl * DefaultLogger ) Trace ( message string , params ... interface { } ) { dl . logger . Tracef ( fmt . Sprintf ( "%s %s" , caller ( ) , message ) , params ... ) }
2823	func expandVMwareUplinkLacpPolicy ( d * schema . ResourceData ) * types . VMwareUplinkLacpPolicy { obj := & types . VMwareUplinkLacpPolicy { Enable : structure . GetBoolPolicy ( d , "lacp_enabled" ) , Mode : structure . GetStringPolicy ( d , "lacp_mode" ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
221	func Name ( n string ) func ( * Manager ) { return func ( m * Manager ) { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) m . name = n } }
5731	func WithParent ( parent Process ) Process { if parent == nil { panic ( "nil parent Process" ) } q := newProcess ( nil ) parent . AddChild ( q ) return q }
5486	func ( r * ApplicationService ) Delete ( ctx context . Context , sid string ) error { return r . client . DeleteResource ( ctx , applicationPathPart , sid ) }
4109	func ( b * ProgressBar ) SecondaryColors ( ) ( term . Attribute , term . Attribute ) { return b . emptyFg , b . emptyBg }
119	func ParseMetricSelector ( input string ) ( m [ ] * labels . Matcher , err error ) { p := newParser ( input ) defer p . recover ( & err ) name := "" if t := p . peek ( ) . typ ; t == ItemMetricIdentifier || t == ItemIdentifier { name = p . next ( ) . val } vs := p . VectorSelector ( name ) if p . peek ( ) . typ != ItemEOF { p . errorf ( "could not parse remaining input %.15q..." , p . lex . input [ p . lex . lastPos : ] ) } return vs . LabelMatchers , nil }
3961	func ( z * Writer ) writeUint32 ( x uint32 ) error { buf := z . buf [ : 4 ] binary . LittleEndian . PutUint32 ( buf , x ) _ , err := z . dst . Write ( buf ) return err }
5152	func ( ui * ConcurrentUI ) Log ( message string ) { ui . l . Lock ( ) defer ui . l . Unlock ( ) ui . UI . Log ( message ) }
695	func ( p * dnsimpleProvider ) CreateRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . submitChanges ( newDnsimpleChanges ( dnsimpleCreate , endpoints ) ) }
3930	func TCPDialCheck ( addr string , timeout time . Duration ) Check { return func ( ) error { conn , err := net . DialTimeout ( "tcp" , addr , timeout ) if err != nil { return err } return conn . Close ( ) } }
3593	func ( t * ThresholdWindows ) GetTriggerWindowOk ( ) ( string , bool ) { if t == nil || t . TriggerWindow == nil { return "" , false } return * t . TriggerWindow , true }
4970	func ReadPrivate ( raw [ ] byte ) ( key * ecdsa . PrivateKey , err error ) { var encoded * pem . Block if encoded , _ = pem . Decode ( raw ) ; encoded == nil { return nil , errors . New ( "Ecc.ReadPrivate(): Key must be PEM encoded PKCS1 or PKCS8 EC private key" ) } var parsedKey interface { } if parsedKey , err = x509 . ParseECPrivateKey ( encoded . Bytes ) ; err != nil { if parsedKey , err = x509 . ParsePKCS8PrivateKey ( encoded . Bytes ) ; err != nil { return nil , err } } var ok bool if key , ok = parsedKey . ( * ecdsa . PrivateKey ) ; ! ok { return nil , errors . New ( "Ecc.ReadPrivate(): Key is not valid *ecdsa.PrivateKey" ) } return key , nil }
439	func ( ctx * RequestCtx ) SuccessString ( contentType , body string ) { ctx . SetContentType ( contentType ) ctx . SetBodyString ( body ) }
2010	func ( role * TaskIAMRoleCredentials ) GetIAMRoleCredentials ( ) IAMRoleCredentials { role . lock . RLock ( ) defer role . lock . RUnlock ( ) return role . IAMRoleCredentials }
5642	func I64 ( key [ ] byte , data [ ] byte ) ( [ ] byte , [ ] byte ) { mac := hmac . New ( sha512 . New , key ) mac . Write ( data ) I := mac . Sum ( nil ) return I [ : 32 ] , I [ 32 : ] }
675	func ( p * NS1Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . zonesFiltered ( ) if err != nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone := range zones { zoneData , _ , err := p . client . GetZone ( zone . String ( ) ) if err != nil { return nil , err } for _ , record := range zoneData . Records { if supportedRecordType ( record . Type ) { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( record . Domain , record . Type , endpoint . TTL ( record . TTL ) , record . ShortAns ... , ) , ) } } } return endpoints , nil }
2523	func expandHostNetworkPolicy ( d * schema . ResourceData ) * types . HostNetworkPolicy { obj := & types . HostNetworkPolicy { Security : expandHostNetworkSecurityPolicy ( d ) , NicTeaming : expandHostNicTeamingPolicy ( d ) , ShapingPolicy : expandHostNetworkTrafficShapingPolicy ( d ) , } return obj }
303	func ( sp * scrapePool ) reload ( cfg * config . ScrapeConfig ) error { targetScrapePoolReloads . Inc ( ) start := time . Now ( ) sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) client , err := config_util . NewClientFromConfig ( cfg . HTTPClientConfig , cfg . JobName ) if err != nil { targetScrapePoolReloadsFailed . Inc ( ) return errors . Wrap ( err , "error creating HTTP client" ) } sp . config = cfg oldClient := sp . client sp . client = client var ( wg sync . WaitGroup interval = time . Duration ( sp . config . ScrapeInterval ) timeout = time . Duration ( sp . config . ScrapeTimeout ) limit = int ( sp . config . SampleLimit ) honorLabels = sp . config . HonorLabels honorTimestamps = sp . config . HonorTimestamps mrc = sp . config . MetricRelabelConfigs ) for fp , oldLoop := range sp . loops { var ( t = sp . activeTargets [ fp ] s = & targetScraper { Target : t , client : sp . client , timeout : timeout } newLoop = sp . newLoop ( scrapeLoopOptions { target : t , scraper : s , limit : limit , honorLabels : honorLabels , honorTimestamps : honorTimestamps , mrc : mrc , } ) ) wg . Add ( 1 ) go func ( oldLoop , newLoop loop ) { oldLoop . stop ( ) wg . Done ( ) go newLoop . run ( interval , timeout , nil ) } ( oldLoop , newLoop ) sp . loops [ fp ] = newLoop } wg . Wait ( ) oldClient . CloseIdleConnections ( ) targetReloadIntervalLength . WithLabelValues ( interval . String ( ) ) . Observe ( time . Since ( start ) . Seconds ( ) , ) return nil }
863	func deleteResourceIfExists ( resourceType , name string , getFunc func ( ) error , deleteFunc func ( ) ( autorest . Response , error ) ) error { f := logutil . Fields { "name" : name } log . Debug ( fmt . Sprintf ( "Querying if %s exists." , resourceType ) , f ) if exists , err := checkResourceExistsFromError ( getFunc ( ) ) ; err != nil { return err } else if ! exists { log . Info ( fmt . Sprintf ( "%s does not exist. Skipping." , resourceType ) , f ) return nil } log . Info ( fmt . Sprintf ( "Removing %s resource." , resourceType ) , f ) _ , err := deleteFunc ( ) return err }
6736	func ( p * Peer ) OnStart ( ) error { p . BaseService . OnStart ( ) _ , err := p . mconn . Start ( ) return err }
4499	func ( f * defaultFormats ) ContainsFormat ( strfmt Format ) bool { f . Lock ( ) defer f . Unlock ( ) tpe := reflect . TypeOf ( strfmt ) if tpe . Kind ( ) == reflect . Ptr { tpe = tpe . Elem ( ) } for _ , v := range f . data { if v . Type == tpe { return true } } return false }
1998	func ( engine * DockerStatsEngine ) GetInstanceMetrics ( ) ( * ecstcs . MetricsMetadata , [ ] * ecstcs . TaskMetric , error ) { var taskMetrics [ ] * ecstcs . TaskMetric idle := engine . isIdle ( ) metricsMetadata := & ecstcs . MetricsMetadata { Cluster : aws . String ( engine . cluster ) , ContainerInstance : aws . String ( engine . containerInstanceArn ) , Idle : aws . Bool ( idle ) , MessageId : aws . String ( uuid . NewRandom ( ) . String ( ) ) , } if idle { seelog . Debug ( "Instance is idle. No task metrics to report" ) fin := true metricsMetadata . Fin = & fin return metricsMetadata , taskMetrics , nil } engine . lock . Lock ( ) defer engine . lock . Unlock ( ) for taskArn := range engine . tasksToContainers { containerMetrics , err := engine . taskContainerMetricsUnsafe ( taskArn ) if err != nil { seelog . Debugf ( "Error getting container metrics for task: %s, err: %v" , taskArn , err ) continue } if len ( containerMetrics ) == 0 { seelog . Debugf ( "Empty containerMetrics for task, ignoring, task: %s" , taskArn ) continue } taskDef , exists := engine . tasksToDefinitions [ taskArn ] if ! exists { seelog . Debugf ( "Could not map task to definition, task: %s" , taskArn ) continue } metricTaskArn := taskArn taskMetric := & ecstcs . TaskMetric { TaskArn : & metricTaskArn , TaskDefinitionFamily : & taskDef . family , TaskDefinitionVersion : & taskDef . version , ContainerMetrics : containerMetrics , } taskMetrics = append ( taskMetrics , taskMetric ) } if len ( taskMetrics ) == 0 { return nil , nil , EmptyMetricsError } engine . resetStatsUnsafe ( ) return metricsMetadata , taskMetrics , nil }
2731	func isEligibleTagEndpoint ( client * govmomi . Client ) bool { if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return false } clientVer := viapi . ParseVersionFromClient ( client ) if ! clientVer . ProductEqual ( tagsMinVersion ) || clientVer . Older ( tagsMinVersion ) { return false } return true }
4356	func Array ( in [ ] byte , pos int ) ( int , error ) { pos , err := skipSpace ( in , pos ) if err != nil { return 0 , err } if v := in [ pos ] ; v != '[' { return 0 , newError ( pos , v ) } pos ++ pos , err = skipSpace ( in , pos ) if err != nil { return 0 , err } if in [ pos ] == ']' { return pos + 1 , nil } for { pos , err = Any ( in , pos ) if err != nil { return 0 , err } pos , err = skipSpace ( in , pos ) if err != nil { return 0 , err } switch in [ pos ] { case ',' : pos ++ case ']' : return pos + 1 , nil } } }
7002	func ( s * MysqlDump ) Dump ( dest io . Writer ) ( err error ) { err = s . Caller . Execute ( dest , s . getDumpCommand ( ) ) lo . G . Debug ( "mysqldump command called" ) return }
6749	func ( ch * Channel ) nextMsgPacket ( ) msgPacket { packet := msgPacket { } packet . ChannelID = byte ( ch . id ) packet . Bytes = ch . sending [ : cmn . MinInt ( maxMsgPacketPayloadSize , len ( ch . sending ) ) ] if len ( ch . sending ) <= maxMsgPacketPayloadSize { packet . EOF = byte ( 0x01 ) ch . sending = nil atomic . AddInt32 ( & ch . sendQueueSize , - 1 ) } else { packet . EOF = byte ( 0x00 ) ch . sending = ch . sending [ cmn . MinInt ( maxMsgPacketPayloadSize , len ( ch . sending ) ) : ] } return packet }
261	func ( s * alertmanagerSet ) sync ( tgs [ ] * targetgroup . Group ) { allAms := [ ] alertmanager { } allDroppedAms := [ ] alertmanager { } for _ , tg := range tgs { ams , droppedAms , err := alertmanagerFromGroup ( tg , s . cfg ) if err != nil { level . Error ( s . logger ) . Log ( "msg" , "Creating discovered Alertmanagers failed" , "err" , err ) continue } allAms = append ( allAms , ams ... ) allDroppedAms = append ( allDroppedAms , droppedAms ... ) } s . mtx . Lock ( ) defer s . mtx . Unlock ( ) s . ams = [ ] alertmanager { } s . droppedAms = [ ] alertmanager { } s . droppedAms = append ( s . droppedAms , allDroppedAms ... ) seen := map [ string ] struct { } { } for _ , am := range allAms { us := am . url ( ) . String ( ) if _ , ok := seen [ us ] ; ok { continue } s . metrics . sent . WithLabelValues ( us ) s . metrics . errors . WithLabelValues ( us ) seen [ us ] = struct { } { } s . ams = append ( s . ams , am ) } }
3211	func ( client * Client ) CreateBoard ( board * Board ) ( * Board , error ) { var createdBoard Board if err := client . doJsonRequest ( "POST" , "/v1/dashboard" , board , & createdBoard ) ; err != nil { return nil , err } return & createdBoard , nil }
748	func legacyEndpointsFromMoleculeService ( svc * v1 . Service ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint if svc . Labels [ "dns" ] != "route53" { return nil } hostnameAnnotation , exists := svc . Annotations [ moleculeAnnotationKey ] if ! exists { return nil } hostnameList := strings . Split ( strings . Replace ( hostnameAnnotation , " " , "" , - 1 ) , "," ) for _ , hostname := range hostnameList { for _ , lb := range svc . Status . LoadBalancer . Ingress { if lb . IP != "" { endpoints = append ( endpoints , endpoint . NewEndpoint ( hostname , endpoint . RecordTypeA , lb . IP ) ) } if lb . Hostname != "" { endpoints = append ( endpoints , endpoint . NewEndpoint ( hostname , endpoint . RecordTypeCNAME , lb . Hostname ) ) } } } return endpoints }
4092	func ( l * TableView ) EnsureColVisible ( ) { if l . isColVisible ( l . selectedCol ) { return } if l . selectedCol < l . topCol { l . topCol = l . selectedCol return } width := l . width - 1 - l . counterWidth ( ) if l . showRowNo && l . showVLines { width -- } toShow := l . selectedCol for width > 0 { if l . columns [ toShow ] . Width > width { if toShow == l . selectedCol { break } else { toShow ++ break } } else if l . columns [ toShow ] . Width == width { break } else { width -= l . columns [ toShow ] . Width if width < 0 { break } toShow -- if toShow == 0 { break } } } l . topCol = toShow }
3237	func ( b * Board ) HasIsReadOnly ( ) bool { if b != nil && b . IsReadOnly != nil { return true } return false }
6836	func ( d * Device ) PushLink ( title , u , body string ) error { return d . Client . PushLink ( d . Iden , title , u , body ) }
3320	func ( g * GraphDefinitionMarker ) GetValOk ( ) ( json . Number , bool ) { if g == nil || g . Val == nil { return "" , false } return * g . Val , true }
6616	func MustNewCmdWithRunner ( cmdName string , runner func ( ) ) * CmdWithRunner { cmdWithRunner , err := NewCmdWithRunner ( cmdName , runner ) if err != nil { panic ( err ) } return cmdWithRunner }
5666	func ( ps * printState ) print ( a AST ) { c := 0 for _ , v := range ps . printing { if v == a { c ++ if c > 1 { return } } } ps . printing = append ( ps . printing , a ) a . print ( ps ) ps . printing = ps . printing [ : len ( ps . printing ) - 1 ] }
3783	func ( client * Client ) RemoveHostTags ( host , source string ) error { uri := "/v1/tags/hosts/" + host if source != "" { uri += "?source=" + source } return client . doJsonRequest ( "DELETE" , uri , nil , nil ) }
6343	func ( lh * commonLogHandler ) ServeHTTP ( w http . ResponseWriter , req * http . Request ) { logData := LogData { Request : * req , Response : WatchResponseWriter ( w ) , } logData . Start = time . Now ( ) lh . handler . ServeHTTP ( logData . Response , req ) logData . End = time . Now ( ) logOutput := bytes . Buffer { } err := lh . template . Execute ( & logOutput , logData ) if err != nil { panic ( err ) } lh . logger . Println ( logOutput . String ( ) ) }
45	func LoadFile ( filename string ) ( * Config , error ) { content , err := ioutil . ReadFile ( filename ) if err != nil { return nil , err } cfg , err := Load ( string ( content ) ) if err != nil { return nil , errors . Wrapf ( err , "parsing YAML file %s" , filename ) } resolveFilepaths ( filepath . Dir ( filename ) , cfg ) return cfg , nil }
1990	func ( resolver * DockerContainerMetadataResolver ) ResolveContainer ( dockerID string ) ( * apicontainer . DockerContainer , error ) { if resolver . dockerTaskEngine == nil { return nil , fmt . Errorf ( "Docker task engine uninitialized" ) } container , found := resolver . dockerTaskEngine . State ( ) . ContainerByID ( dockerID ) if ! found { return nil , fmt . Errorf ( "Could not map docker id to container: %s" , dockerID ) } return container , nil }
4521	func Grep ( r string ) Filter { re , err := regexp . Compile ( r ) if err != nil { return FilterFunc ( func ( Arg ) error { return err } ) } return If ( re . MatchString ) }
4561	func Render ( input string , ctx hctx . Context ) ( string , error ) { t , err := Parse ( input ) if err != nil { return "" , err } return t . Exec ( ctx ) }
5519	func NewPostbackButton ( title string , payload string ) Button { return Button { Type : ButtonTypePostback , Title : title , Payload : payload , } }
5025	func ( s * Session ) LogoutAll ( ) { s . m . Lock ( ) for _ , cred := range s . creds { if s . masterSocket != nil { s . masterSocket . Logout ( cred . Source ) } if s . slaveSocket != nil { s . slaveSocket . Logout ( cred . Source ) } } s . creds = s . creds [ 0 : 0 ] s . m . Unlock ( ) }
6561	func ( r Record ) Get ( column string ) ( interface { } , error ) { v , ok := r [ column ] if ! ok { return nil , ErrUnknownColumn } return v , nil }
7160	func NewCounter ( options * CounterOptions ) ( c * Counter ) { if options == nil { options = new ( CounterOptions ) } if options . Name == "" { options . Name = "logging_messages_total" } if options . Help == "" { options . Help = "Number of log messages processed, partitioned by log level." } vector := prometheus . NewCounterVec ( prometheus . CounterOpts { Name : options . Name , Help : options . Help , } , [ ] string { "level" } , ) return & Counter { vector : vector , emergencyCounter : vector . WithLabelValues ( "emergency" ) , alertCounter : vector . WithLabelValues ( "alert" ) , criticalCounter : vector . WithLabelValues ( "critical" ) , errorCounter : vector . WithLabelValues ( "error" ) , warningCounter : vector . WithLabelValues ( "warning" ) , noticeCounter : vector . WithLabelValues ( "notice" ) , infoCounter : vector . WithLabelValues ( "info" ) , debugCounter : vector . WithLabelValues ( "debug" ) , } }
33	func ( c * Client ) Write ( samples model . Samples ) error { points := make ( [ ] * influx . Point , 0 , len ( samples ) ) for _ , s := range samples { v := float64 ( s . Value ) if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { level . Debug ( c . logger ) . Log ( "msg" , "cannot send to InfluxDB, skipping sample" , "value" , v , "sample" , s ) c . ignoredSamples . Inc ( ) continue } p , err := influx . NewPoint ( string ( s . Metric [ model . MetricNameLabel ] ) , tagsFromMetric ( s . Metric ) , map [ string ] interface { } { "value" : v } , s . Timestamp . Time ( ) , ) if err != nil { return err } points = append ( points , p ) } bps , err := influx . NewBatchPoints ( influx . BatchPointsConfig { Precision : "ms" , Database : c . database , RetentionPolicy : c . retentionPolicy , } ) if err != nil { return err } bps . AddPoints ( points ) return c . client . Write ( bps ) }
1996	func ( engine * DockerStatsEngine ) addContainerUnsafe ( dockerID string ) ( * StatsContainer , error ) { task , err := engine . resolver . ResolveTask ( dockerID ) if err != nil { return nil , errors . Wrapf ( err , "could not map container to task, ignoring container: %s" , dockerID ) } if len ( task . Arn ) == 0 || len ( task . Family ) == 0 { return nil , errors . Errorf ( "stats add container: invalid task fields, arn: %s, familiy: %s" , task . Arn , task . Family ) } if task . GetKnownStatus ( ) . Terminal ( ) { return nil , errors . Errorf ( "stats add container: task is terminal, ignoring container: %s, task: %s" , dockerID , task . Arn ) } seelog . Debugf ( "Adding container to stats watch list, id: %s, task: %s" , dockerID , task . Arn ) statsContainer := newStatsContainer ( dockerID , engine . client , engine . resolver ) engine . tasksToDefinitions [ task . Arn ] = & taskDefinition { family : task . Family , version : task . Version } watchStatsContainer := false if ! engine . disableMetrics { watchStatsContainer = engine . addToStatsContainerMapUnsafe ( task . Arn , dockerID , statsContainer , engine . containerMetricsMapUnsafe ) } if dockerContainer , err := engine . resolver . ResolveContainer ( dockerID ) ; err != nil { seelog . Debugf ( "Could not map container ID to container, container: %s, err: %s" , dockerID , err ) } else if dockerContainer . Container . HealthStatusShouldBeReported ( ) { engine . addToStatsContainerMapUnsafe ( task . Arn , dockerID , statsContainer , engine . healthCheckContainerMapUnsafe ) seelog . Debugf ( "Adding container to stats health check watch list, id: %s, task: %s" , dockerID , task . Arn ) } if ! watchStatsContainer { return nil , nil } return statsContainer , nil }
1790	func ( cs * ContainerStatus ) BackendStatus ( steadyStateStatus ContainerStatus ) ContainerStatus { if * cs == steadyStateStatus { return ContainerRunning } if * cs == ContainerStopped { return ContainerStopped } return ContainerStatusNone }
1265	func ( vol * VolumeResource ) MarshalJSON ( ) ( [ ] byte , error ) { if vol == nil { return nil , nil } return json . Marshal ( volumeResourceJSON { vol . Name , vol . VolumeConfig , vol . GetCreatedAt ( ) , func ( ) * VolumeStatus { desiredState := VolumeStatus ( vol . GetDesiredStatus ( ) ) ; return & desiredState } ( ) , func ( ) * VolumeStatus { knownState := VolumeStatus ( vol . GetKnownStatus ( ) ) ; return & knownState } ( ) , } ) }
5557	func Decode ( r io . Reader , d Decoder ) error { decoder := & decode { d , make ( [ ] byte , 8 ) , bufio . NewReader ( r ) } return decoder . decode ( ) }
1251	func ( cs * clientServer ) publishHealthMetrics ( ) { if cs . publishTicker == nil { seelog . Debug ( "Skipping publishing health metrics. Publish ticker is uninitialized" ) return } err := cs . publishHealthMetricsOnce ( ) if err != nil { seelog . Warnf ( "Unable to publish health metrics: %v" , err ) } for { select { case <- cs . publishHealthTicker . C : err := cs . publishHealthMetricsOnce ( ) if err != nil { seelog . Warnf ( "Unable to publish health metrics: %v" , err ) } case <- cs . ctx . Done ( ) : return } } }
3806	func crcIP ( ip net . IP , rand uint8 ) uint32 { if ip4 := ip . To4 ( ) ; ip4 != nil { ip = ip4 } ip = append ( make ( net . IP , 0 , len ( ip ) ) , ip ... ) mask := maskForIP ( ip ) for i := range mask { ip [ i ] &= mask [ i ] } r := rand & 7 ip [ 0 ] |= r << 5 return crc32 . Checksum ( ip [ : len ( mask ) ] , crc32 . MakeTable ( crc32 . Castagnoli ) ) }
4377	func IPv6Value ( v * strfmt . IPv6 ) strfmt . IPv6 { if v == nil { return strfmt . IPv6 ( "" ) } return * v }
3034	func New ( opts ... Option ) ( * Discover , error ) { d := new ( Discover ) for _ , opt := range opts { if err := opt ( d ) ; err != nil { return nil , err } } d . once . Do ( d . initProviders ) return d , nil }
948	func ( d * Driver ) PreCreateCheck ( ) error { version , err := d . vbmOut ( "--version" ) if err != nil { return err } if err = checkVBoxManageVersion ( strings . TrimSpace ( version ) ) ; err != nil { return err } if ! d . NoVTXCheck { if isHyperVInstalled ( ) { return ErrNotCompatibleWithHyperV } if d . IsVTXDisabled ( ) { return ErrMustEnableVTX } } if err := d . b2dUpdater . UpdateISOCache ( d . StorePath , d . Boot2DockerURL ) ; err != nil { return err } if _ , err = listHostOnlyAdapters ( d . VBoxManager ) ; err != nil { return err } return nil }
1485	func ( c * Container ) GetNetworkSettings ( ) * types . NetworkSettings { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . NetworkSettingsUnsafe }
6858	func StringToLabels ( s string ) * mesos . Labels { labels := & mesos . Labels { Labels : make ( [ ] * mesos . Label , 0 ) } if s == "" { return labels } pairs := strings . Split ( s , ";" ) for _ , pair := range pairs { kv := strings . Split ( pair , "=" ) key , value := kv [ 0 ] , kv [ 1 ] label := & mesos . Label { Key : proto . String ( key ) , Value : proto . String ( value ) } labels . Labels = append ( labels . Labels , label ) } return labels }
2192	func TimeoutAdd ( timeout uint , f interface { } , args ... interface { } ) ( SourceHandle , error ) { rf := reflect . ValueOf ( f ) if rf . Type ( ) . Kind ( ) != reflect . Func { return 0 , errors . New ( "f is not a function" ) } timeoutSrc := C . g_timeout_source_new ( C . guint ( timeout ) ) if timeoutSrc == nil { return 0 , errNilPtr } return sourceAttach ( timeoutSrc , rf , args ... ) }
485	func ( resp * Response ) Reset ( ) { resp . Header . Reset ( ) resp . resetSkipHeader ( ) resp . SkipBody = false resp . raddr = nil resp . laddr = nil }
1215	func ( imageState * ImageState ) UpdateContainerReference ( container * apicontainer . Container ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) seelog . Infof ( "Updating container reference %v in Image State - %v" , container . Name , imageState . Image . ImageID ) imageState . Containers = append ( imageState . Containers , container ) }
37	func newAuthTokenRoundTripper ( token config_util . Secret , rt http . RoundTripper ) ( http . RoundTripper , error ) { return & authTokenRoundTripper { token , rt } , nil }
878	func ( d * SerialDriver ) GetMachineName ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetMachineName ( ) }
1259	func NewVolumeResource ( ctx context . Context , name string , dockerVolumeName string , scope string , autoprovision bool , driver string , driverOptions map [ string ] string , labels map [ string ] string , client dockerapi . DockerClient ) ( * VolumeResource , error ) { if scope == TaskScope && autoprovision { return nil , errors . Errorf ( "volume [%s] : task scoped volume could not be autoprovisioned" , name ) } v := & VolumeResource { Name : name , VolumeConfig : DockerVolumeConfig { Scope : scope , Autoprovision : autoprovision , Driver : driver , DriverOpts : driverOptions , Labels : labels , DockerVolumeName : dockerVolumeName , } , client : client , ctx : ctx , } v . initStatusToTransitions ( ) return v , nil }
5067	func ( r * Render ) loadTemplate ( name string ) * template . Template { tpl , err := template . ParseFiles ( r . Files [ name ] ... ) if err != nil { panic ( name + " template name mismatch" ) } return template . Must ( tpl , err ) }
2198	func InitI18n ( domain string , dir string ) { domainStr := C . CString ( domain ) defer C . free ( unsafe . Pointer ( domainStr ) ) dirStr := C . CString ( dir ) defer C . free ( unsafe . Pointer ( dirStr ) ) C . init_i18n ( domainStr , dirStr ) }
6510	func ( c Client ) ResendRequest ( id string ) ( bool , error ) { holder := map [ string ] interface { } { } if err := c . Put ( "transactions/" + id + "/resend_request" , nil , & holder ) ; err != nil { return false , err } if holder [ "success" ] . ( bool ) { return true , nil } return false , nil }
2208	func ( v * Action ) GetParameterType ( ) * VariantType { c := C . g_action_get_parameter_type ( v . native ( ) ) if c == nil { return nil } return newVariantType ( ( * C . GVariantType ) ( c ) ) }
6234	func ( s * Server ) RequireBasicAuth ( logger log . Logger , handler HandlerFunc , auth AuthFunc ) HandlerFunc { l := logger . Add ( "method" , "RequireBasicAuth" ) return func ( w http . ResponseWriter , r * http . Request , ctx * Context ) { name , pass , ok := r . BasicAuth ( ) if ! ok || ! auth ( name , pass ) { l . Add ( "sender" , r . RemoteAddr ) . Warn ( "access denied" ) s . RespondError ( logger , w , ErrAccessDenied ) return } ctx . Username = name handler ( w , r , ctx ) } }
6228	func ( w * Worker ) DecrementCurrentSupply ( job * data . Job ) error { logger := w . logger . Add ( "method" , "DecrementCurrentSupply" , "job" , job ) offering , err := w . relatedOffering ( logger , job , data . JobDecrementCurrentSupply ) if err != nil { return err } offering . CurrentSupply -- err = data . Save ( w . db . Querier , offering ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil }
1340	func ( mr * MockClientSDKMockRecorder ) DescribeTags ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "DescribeTags" , reflect . TypeOf ( ( * MockClientSDK ) ( nil ) . DescribeTags ) , arg0 ) }
6141	func ( b * backendInstance ) PSCPopupServiceOffering ( opts * bind . TransactOpts , offeringHash [ 32 ] byte , somcType uint8 , somcData data . Base64String ) ( * types . Transaction , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 tx , err := b . psc . PopupServiceOffering ( opts , offeringHash , somcType , string ( somcData ) ) if err != nil { err = fmt . Errorf ( "failed to pop up service offering: %v" , err ) } return tx , err }
4465	func ( t DateTime ) Value ( ) ( driver . Value , error ) { return driver . Value ( t . String ( ) ) , nil }
3448	func ( o * Options ) HasTimeoutH ( ) bool { if o != nil && o . TimeoutH != nil { return true } return false }
3250	func ( c * Check ) GetHostName ( ) string { if c == nil || c . HostName == nil { return "" } return * c . HostName }
5822	func ( cm * CheckManager ) IsReady ( ) bool { cm . initializedmu . RLock ( ) defer cm . initializedmu . RUnlock ( ) return cm . initialized }
5628	func SimpleHashFromHashers ( items [ ] Hasher ) [ ] byte { hashes := make ( [ ] [ ] byte , len ( items ) ) for i , item := range items { hash := item . Hash ( ) hashes [ i ] = hash } return simpleHashFromHashes ( hashes ) }
46	func resolveFilepaths ( baseDir string , cfg * Config ) { join := func ( fp string ) string { if len ( fp ) > 0 && ! filepath . IsAbs ( fp ) { fp = filepath . Join ( baseDir , fp ) } return fp } for i , rf := range cfg . RuleFiles { cfg . RuleFiles [ i ] = join ( rf ) } tlsPaths := func ( cfg * config_util . TLSConfig ) { cfg . CAFile = join ( cfg . CAFile ) cfg . CertFile = join ( cfg . CertFile ) cfg . KeyFile = join ( cfg . KeyFile ) } clientPaths := func ( scfg * config_util . HTTPClientConfig ) { if scfg . BasicAuth != nil { scfg . BasicAuth . PasswordFile = join ( scfg . BasicAuth . PasswordFile ) } scfg . BearerTokenFile = join ( scfg . BearerTokenFile ) tlsPaths ( & scfg . TLSConfig ) } sdPaths := func ( cfg * sd_config . ServiceDiscoveryConfig ) { for _ , kcfg := range cfg . KubernetesSDConfigs { clientPaths ( & kcfg . HTTPClientConfig ) } for _ , mcfg := range cfg . MarathonSDConfigs { mcfg . AuthTokenFile = join ( mcfg . AuthTokenFile ) clientPaths ( & mcfg . HTTPClientConfig ) } for _ , consulcfg := range cfg . ConsulSDConfigs { tlsPaths ( & consulcfg . TLSConfig ) } for _ , cfg := range cfg . OpenstackSDConfigs { tlsPaths ( & cfg . TLSConfig ) } for _ , cfg := range cfg . TritonSDConfigs { tlsPaths ( & cfg . TLSConfig ) } for _ , filecfg := range cfg . FileSDConfigs { for i , fn := range filecfg . Files { filecfg . Files [ i ] = join ( fn ) } } } for _ , cfg := range cfg . ScrapeConfigs { clientPaths ( & cfg . HTTPClientConfig ) sdPaths ( & cfg . ServiceDiscoveryConfig ) } for _ , cfg := range cfg . AlertingConfig . AlertmanagerConfigs { clientPaths ( & cfg . HTTPClientConfig ) sdPaths ( & cfg . ServiceDiscoveryConfig ) } for _ , cfg := range cfg . RemoteReadConfigs { clientPaths ( & cfg . HTTPClientConfig ) } for _ , cfg := range cfg . RemoteWriteConfigs { clientPaths ( & cfg . HTTPClientConfig ) } }
2042	func ( m * MockEngine ) GetInstanceMetrics ( ) ( * ecstcs . MetricsMetadata , [ ] * ecstcs . TaskMetric , error ) { ret := m . ctrl . Call ( m , "GetInstanceMetrics" ) ret0 , _ := ret [ 0 ] . ( * ecstcs . MetricsMetadata ) ret1 , _ := ret [ 1 ] . ( [ ] * ecstcs . TaskMetric ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 }
3643	func ( t * TraceServiceDefinition ) GetSizeFormat ( ) string { if t == nil || t . SizeFormat == nil { return "" } return * t . SizeFormat }
6703	func ( c * Client ) LoadBalancer ( identifier string ) ( * LoadBalancer , error ) { lb := new ( LoadBalancer ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/load_balancers/" + identifier , nil , lb ) if err != nil { return nil , err } return lb , err }
6801	func ( s * Session ) InteractionCount ( ) int { s . mu . Lock ( ) defer s . mu . Unlock ( ) if v , ok := s . Decoded [ "interaction_count" ] . ( string ) ; ok { if count , err := strconv . Atoi ( v ) ; err == nil { return count } } return - 1 }
3052	func tagCategoryByName ( ctx context . Context , client * tags . RestClient , name string ) ( string , error ) { cats , err := client . GetCategoriesByName ( ctx , name ) if err != nil { return "" , fmt . Errorf ( "could not get category for name %q: %s" , name , err ) } if len ( cats ) < 1 { return "" , fmt . Errorf ( "category name %q not found" , name ) } if len ( cats ) > 1 { return "" , fmt . Errorf ( "multiple categories with name %q found" , name ) } return cats [ 0 ] . ID , nil }
3617	func ( t * TimeseriesRequestStyle ) GetLineWidthOk ( ) ( string , bool ) { if t == nil || t . LineWidth == nil { return "" , false } return * t . LineWidth , true }
3173	func ( client * Client ) CreateDashboardList ( list * DashboardList ) ( * DashboardList , error ) { var out DashboardList if err := client . doJsonRequest ( "POST" , "/v1/dashboard/lists/manual" , list , & out ) ; err != nil { return nil , err } return & out , nil }
6006	func ( t Typed ) BoolOr ( key string , d bool ) bool { if value , exists := t . BoolIf ( key ) ; exists { return value } return d }
6308	func Prefix ( prefix string , p AssetPipeline ) AssetPipeline { if prefix == "" { return p } return & prefixPipeline { prefix : prefix , AssetPipeline : p , } }
2944	func resourceVSphereDatastoreClusterApplyNameChange ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod , ) ( * object . StoragePod , error ) { log . Printf ( "[DEBUG] %s: Applying any name changes (old path = %q)" , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) var changed bool var err error if d . HasChange ( "name" ) { if err = storagepod . Rename ( pod , d . Get ( "name" ) . ( string ) ) ; err != nil { return nil , fmt . Errorf ( "error renaming datastore cluster: %s" , err ) } changed = true } if changed { pod , err = resourceVSphereDatastoreClusterGetPod ( d , meta ) if err != nil { return nil , fmt . Errorf ( "error refreshing datastore cluster after name change: %s" , err ) } log . Printf ( "[DEBUG] %s: Name changed, new path = %q" , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) } return pod , nil }
1581	func ( m * MockSecretsManagerAPI ) DeleteSecretRequest ( arg0 * secretsmanager . DeleteSecretInput ) ( * request . Request , * secretsmanager . DeleteSecretOutput ) { ret := m . ctrl . Call ( m , "DeleteSecretRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . DeleteSecretOutput ) return ret0 , ret1 }
3053	func tagByName ( ctx context . Context , client * tags . RestClient , name , categoryID string ) ( string , error ) { tids , err := client . GetTagByNameForCategory ( ctx , name , categoryID ) if err != nil { return "" , fmt . Errorf ( "could not get tag for name %q: %s" , name , err ) } if len ( tids ) < 1 { return "" , fmt . Errorf ( "tag name %q not found in category ID %q" , name , categoryID ) } if len ( tids ) > 1 { return "" , fmt . Errorf ( "multiple tags with name %q found" , name ) } logger . Printf ( "[DEBUG] Tag ID is %q" , tids [ 0 ] . ID ) return tids [ 0 ] . ID , nil }
654	func ( sc * serviceSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { services , err := sc . serviceInformer . Lister ( ) . Services ( sc . namespace ) . List ( labels . Everything ( ) ) if err != nil { return nil , err } services , err = sc . filterByAnnotations ( services ) if err != nil { return nil , err } if len ( sc . serviceTypeFilter ) > 0 { services = sc . filterByServiceType ( services ) } nodeTargets , err := sc . extractNodeTargets ( ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , svc := range services { controller , ok := svc . Annotations [ controllerAnnotationKey ] if ok && controller != controllerAnnotationValue { log . Debugf ( "Skipping service %s/%s because controller value does not match, found: %s, required: %s" , svc . Namespace , svc . Name , controller , controllerAnnotationValue ) continue } svcEndpoints := sc . endpoints ( svc , nodeTargets ) if len ( svcEndpoints ) == 0 && sc . compatibility != "" { svcEndpoints = legacyEndpointsFromService ( svc , sc . compatibility ) } if ( sc . combineFQDNAnnotation || len ( svcEndpoints ) == 0 ) && sc . fqdnTemplate != nil { sEndpoints , err := sc . endpointsFromTemplate ( svc , nodeTargets ) if err != nil { return nil , err } if sc . combineFQDNAnnotation { svcEndpoints = append ( svcEndpoints , sEndpoints ... ) } else { svcEndpoints = sEndpoints } } if len ( svcEndpoints ) == 0 { log . Debugf ( "No endpoints could be generated from service %s/%s" , svc . Namespace , svc . Name ) continue } log . Debugf ( "Endpoints generated from service: %s/%s: %v" , svc . Namespace , svc . Name , svcEndpoints ) sc . setResourceLabel ( svc , svcEndpoints ) endpoints = append ( endpoints , svcEndpoints ... ) } for _ , ep := range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil }
2160	func ( v * SList ) Next ( ) * SList { n := v . native ( ) if n == nil { return nil } return wrapSList ( n . next ) }
1735	func ( task * Task ) GetKnownStatusTime ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . KnownStatusTimeUnsafe }
2057	func NewTaskResponse ( task * apitask . Task , containerMap map [ string ] * apicontainer . DockerContainer ) * TaskResponse { containers := [ ] ContainerResponse { } for _ , container := range containerMap { if container . Container . IsInternal ( ) { continue } containerResponse := NewContainerResponse ( container , task . GetTaskENI ( ) ) containers = append ( containers , containerResponse ) } knownStatus := task . GetKnownStatus ( ) knownBackendStatus := knownStatus . BackendStatus ( ) desiredStatusInAgent := task . GetDesiredStatus ( ) desiredStatus := desiredStatusInAgent . BackendStatus ( ) if ( knownBackendStatus == "STOPPED" && desiredStatus != "STOPPED" ) || ( knownBackendStatus == "RUNNING" && desiredStatus == "PENDING" ) { desiredStatus = "" } return & TaskResponse { Arn : task . Arn , DesiredStatus : desiredStatus , KnownStatus : knownBackendStatus , Family : task . Family , Version : task . Version , Containers : containers , } }
3705	func ( w * Widget ) HasMustShowLatency ( ) bool { if w != nil && w . MustShowLatency != nil { return true } return false }
5830	func ( a * API ) DeleteRuleSetGroup ( cfg * RuleSetGroup ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid rule set group config [nil]" ) } return a . DeleteRuleSetGroupByCID ( CIDType ( & cfg . CID ) ) }
3895	func ( b * builder ) rangeStmt ( fn * Function , s * ast . RangeStmt , label * lblock ) { var tk , tv types . Type if s . Key != nil && ! isBlankIdent ( s . Key ) { tk = fn . Pkg . typeOf ( s . Key ) } if s . Value != nil && ! isBlankIdent ( s . Value ) { tv = fn . Pkg . typeOf ( s . Value ) } if s . Tok == token . DEFINE { if tk != nil { fn . addLocalForIdent ( s . Key . ( * ast . Ident ) ) } if tv != nil { fn . addLocalForIdent ( s . Value . ( * ast . Ident ) ) } } x := b . expr ( fn , s . X ) var k , v Value var loop , done * BasicBlock switch rt := x . Type ( ) . Underlying ( ) . ( type ) { case * types . Slice , * types . Array , * types . Pointer : k , v , loop , done = b . rangeIndexed ( fn , x , tv , s . For ) case * types . Chan : k , loop , done = b . rangeChan ( fn , x , tk , s . For ) case * types . Map , * types . Basic : k , v , loop , done = b . rangeIter ( fn , x , tk , tv , s . For ) default : panic ( "Cannot range over: " + rt . String ( ) ) } var kl , vl lvalue if tk != nil { kl = b . addr ( fn , s . Key , false ) } if tv != nil { vl = b . addr ( fn , s . Value , false ) } if tk != nil { kl . store ( fn , k ) } if tv != nil { vl . store ( fn , v ) } if label != nil { label . _break = done label . _continue = loop } fn . targets = & targets { tail : fn . targets , _break : done , _continue : loop , } b . stmt ( fn , s . Body ) fn . targets = fn . targets . tail emitJump ( fn , loop ) fn . currentBlock = done }
2452	func ( i * Image ) IsInvalidated ( ) ( bool , error ) { graphicscommand . FlushCommands ( ) if ! IsRestoringEnabled ( ) { return false , nil } return i . image . IsInvalidated ( ) , nil }
5097	func IsObjectIdHex ( s string ) bool { if len ( s ) != 24 { return false } _ , err := hex . DecodeString ( s ) return err == nil }
1820	func ( engine * DockerTaskEngine ) newManagedTask ( task * apitask . Task ) * managedTask { ctx , cancel := context . WithCancel ( engine . ctx ) t := & managedTask { ctx : ctx , cancel : cancel , Task : task , acsMessages : make ( chan acsTransition ) , dockerMessages : make ( chan dockerContainerChange ) , resourceStateChangeEvent : make ( chan resourceStateChange ) , engine : engine , cfg : engine . cfg , stateChangeEvents : engine . stateChangeEvents , containerChangeEventStream : engine . containerChangeEventStream , saver : engine . saver , credentialsManager : engine . credentialsManager , cniClient : engine . cniClient , taskStopWG : engine . taskStopGroup , steadyStatePollInterval : engine . taskSteadyStatePollInterval , } engine . managedTasks [ task . Arn ] = t return t }
5891	func NewTokenSource ( signer jwt . Signer , tokenURL string , ctxt context . Context , opts ... Option ) ( * Bearer , error ) { var err error b := & Bearer { signer : signer , tokenURL : tokenURL , context : ctxt , claims : make ( map [ string ] interface { } ) , } for _ , o := range opts { if err = o ( b ) ; err != nil { return nil , fmt . Errorf ( "jwt/bearer: %v" , err ) } } return b , nil }
5008	func DecodeAll ( dst , src [ ] uint32 ) error { j := 0 for _ , v := range src { sel := v >> 28 if sel >= 9 { return fmt . Errorf ( "invalid selector value: %b" , sel ) } selector [ sel ] . unpack ( v , dst [ j : ] ) j += selector [ sel ] . n } return nil }
2600	func FromKey ( client * govmomi . Client , dvsUUID , pgKey string ) ( * object . DistributedVirtualPortgroup , error ) { dvsm := types . ManagedObjectReference { Type : "DistributedVirtualSwitchManager" , Value : "DVSManager" } req := & types . DVSManagerLookupDvPortGroup { This : dvsm , SwitchUuid : dvsUUID , PortgroupKey : pgKey , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) resp , err := methods . DVSManagerLookupDvPortGroup ( ctx , client , req ) if err != nil { return nil , err } if resp . Returnval == nil { return nil , NewMissingPortGroupReferenceError ( fmt . Sprintf ( "portgroup lookup by key returned nil result for DVS UUID %q and portgroup key %q" , dvsUUID , pgKey , ) , ) } return FromMOID ( client , resp . Returnval . Reference ( ) . Value ) }
6065	func newClient ( cfg * Config , logger log . Logger ) ( * client , error ) { logger2 := logger . Add ( "method" , "newClient" , "config" , cfg ) u , err := url . Parse ( cfg . GethURL ) if err != nil { return nil , err } ctx , cancel := context . WithCancel ( context . Background ( ) ) c := & client { cancel : cancel , cfg : cfg , logger : logger } var rpcClient * rpc . Client switch u . Scheme { case httpProtocol , https : httpTransport := transport ( cfg . HTTPClient ) rpcClient , err = rpc . DialHTTPWithClient ( cfg . GethURL , httpClient ( cfg . HTTPClient , httpTransport ) ) c . httpTransport = httpTransport case ws , wss : rpcClient , err = rpc . DialWebsocket ( ctx , cfg . GethURL , "" ) case stdIO : rpcClient , err = rpc . DialStdIO ( ctx ) case ipc : rpcClient , err = rpc . DialIPC ( ctx , cfg . GethURL ) default : logger2 . Add ( "scheme" , u . Scheme ) . Error ( err . Error ( ) ) return nil , ErrURLScheme } if err != nil { logger2 . Error ( err . Error ( ) ) return nil , ErrCreateClient } c . client = ethclient . NewClient ( rpcClient ) return c , nil }
5649	func ( kb dbKeybase ) CreateLedger ( name string , path crypto . DerivationPath , algo SignAlgo ) ( Info , error ) { if algo != AlgoSecp256k1 { return nil , fmt . Errorf ( "Only secp256k1 is supported for Ledger devices" ) } priv , err := crypto . NewPrivKeyLedgerSecp256k1 ( path ) if err != nil { return nil , err } pub := priv . PubKey ( ) return kb . writeLedgerKey ( pub , path , name ) , nil }
1324	func ( m * MockSSMClientCreator ) NewSSMClient ( arg0 string , arg1 credentials . IAMRoleCredentials ) ssm . SSMClient { ret := m . ctrl . Call ( m , "NewSSMClient" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( ssm . SSMClient ) return ret0 }
6938	func ( r * Registry ) Subscribe ( rep Reporter ) { r . mutex . Lock ( ) r . reporters = append ( r . reporters , rep ) r . mutex . Unlock ( ) }
5975	func Marshal ( otp * HOTP ) ( [ ] byte , error ) { var asnHOTP struct { Key [ ] byte Counter * big . Int Digits int } asnHOTP . Key = otp . Key [ : ] asnHOTP . Counter = new ( big . Int ) . SetUint64 ( otp . Counter ( ) ) asnHOTP . Digits = otp . Digits return asn1 . Marshal ( asnHOTP ) }
6484	func ( h * Handler ) Rule ( r rule . Rule ) * Handler { if r == nil { r = rule . Satisfied ( ) } h . rule = r return h }
4546	func NewRegistryResolver ( opt registry . Opt ) Resolver { return & registryResolver { opt : opt , cache : make ( map [ string ] string ) , } }
112	func newAzureResourceFromID ( id string , logger log . Logger ) ( azureResource , error ) { s := strings . Split ( id , "/" ) if len ( s ) != 9 && len ( s ) != 11 { err := errors . Errorf ( "invalid ID '%s'. Refusing to create azureResource" , id ) level . Error ( logger ) . Log ( "err" , err ) return azureResource { } , err } return azureResource { Name : strings . ToLower ( s [ 8 ] ) , ResourceGroup : strings . ToLower ( s [ 4 ] ) , } , nil }
347	func ( rule * RecordingRule ) HTMLSnippet ( pathPrefix string ) template . HTML { ruleExpr := rule . vector . String ( ) labels := make ( map [ string ] string , len ( rule . labels ) ) for _ , l := range rule . labels { labels [ l . Name ] = template . HTMLEscapeString ( l . Value ) } r := rulefmt . Rule { Record : fmt . Sprintf ( `<a href="%s">%s</a>` , pathPrefix + strutil . TableLinkForExpression ( rule . name ) , rule . name ) , Expr : fmt . Sprintf ( `<a href="%s">%s</a>` , pathPrefix + strutil . TableLinkForExpression ( ruleExpr ) , template . HTMLEscapeString ( ruleExpr ) ) , Labels : labels , } byt , err := yaml . Marshal ( r ) if err != nil { return template . HTML ( fmt . Sprintf ( "error marshaling recording rule: %q" , template . HTMLEscapeString ( err . Error ( ) ) ) ) } return template . HTML ( byt ) }
5558	func ( lo * largeObject ) retryPutPart ( part * part ) { defer lo . wg . Done ( ) var err error for i := 0 ; i < 3 ; i ++ { time . Sleep ( time . Duration ( math . Exp2 ( float64 ( i ) ) ) * 100 * time . Millisecond ) err = lo . putPart ( part ) if err == nil { lo . bp . give <- part . b return } lo . logger . Error ( swiftLargeObjectLogTag , fmt . Sprintf ( "Error on attempt %d: Retrying part: %v, Error: %s" , i , part , err ) ) } lo . err = err }
2670	func flattenClusterDasVMSettings ( d * schema . ResourceData , obj * types . ClusterDasVmSettings , version viapi . VSphereVersion ) error { err := structure . SetBatch ( d , map [ string ] interface { } { "ha_host_isolation_response" : obj . IsolationResponse , "ha_vm_restart_priority" : obj . RestartPriority , } ) if err != nil { return err } if err := flattenClusterVMToolsMonitoringSettings ( d , obj . VmToolsMonitoringSettings ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := flattenClusterVMComponentProtectionSettings ( d , obj . VmComponentProtectionSettings ) ; err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return d . Set ( "ha_vm_restart_timeout" , obj . RestartPriorityTimeout ) } return nil }
43	func extractPortMapping ( portMappings [ ] portMapping , containerNet bool ) ( [ ] uint32 , [ ] map [ string ] string ) { ports := make ( [ ] uint32 , len ( portMappings ) ) labels := make ( [ ] map [ string ] string , len ( portMappings ) ) for i := 0 ; i < len ( portMappings ) ; i ++ { labels [ i ] = portMappings [ i ] . Labels if containerNet { ports [ i ] = portMappings [ i ] . ContainerPort } else { ports [ i ] = portMappings [ i ] . HostPort } } return ports , labels }
155	func ( t * QueueManager ) Stop ( ) { level . Info ( t . logger ) . Log ( "msg" , "Stopping remote storage..." ) defer level . Info ( t . logger ) . Log ( "msg" , "Remote storage stopped." ) close ( t . quit ) t . wg . Wait ( ) t . shards . stop ( ) t . watcher . Stop ( ) t . seriesMtx . Lock ( ) defer t . seriesMtx . Unlock ( ) for _ , labels := range t . seriesLabels { release ( labels ) } name := t . client . Name ( ) queueHighestSentTimestamp . DeleteLabelValues ( name ) queuePendingSamples . DeleteLabelValues ( name ) enqueueRetriesTotal . DeleteLabelValues ( name ) droppedSamplesTotal . DeleteLabelValues ( name ) numShards . DeleteLabelValues ( name ) failedSamplesTotal . DeleteLabelValues ( name ) sentBatchDuration . DeleteLabelValues ( name ) succeededSamplesTotal . DeleteLabelValues ( name ) retriedSamplesTotal . DeleteLabelValues ( name ) shardCapacity . DeleteLabelValues ( name ) }
5237	func ( u * URI ) SetHost ( host string ) error { m := hostRegexp . FindStringSubmatch ( host ) if m == nil { return errors . New ( "invalid host" ) } u . host = host return nil }
246	func ( q externalLabelsQuerier ) Select ( p * storage . SelectParams , matchers ... * labels . Matcher ) ( storage . SeriesSet , storage . Warnings , error ) { m , added := q . addExternalLabels ( matchers ) s , warnings , err := q . Querier . Select ( p , m ... ) if err != nil { return nil , warnings , err } return newSeriesSetFilter ( s , added ) , warnings , nil }
6611	func ( m * OuiDb ) VendorLookup ( s string ) ( string , error ) { addr , err := net . ParseMAC ( s ) if err != nil { return "" , err } block := m . Lookup ( HardwareAddr ( addr ) ) if block == nil { return "" , ErrInvalidMACAddress } return block . Organization , nil }
1061	func ( d * HealthServiceQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , Near : d . near , } ) u := & url . URL { Path : "/v1/health/service/" + d . name , RawQuery : opts . String ( ) , } if d . tag != "" { q := u . Query ( ) q . Set ( "tag" , d . tag ) u . RawQuery = q . Encode ( ) } log . Printf ( "[TRACE] %s: GET %s" , d , u ) passingOnly := len ( d . filters ) == 1 && d . filters [ 0 ] == HealthPassing entries , qm , err := clients . Consul ( ) . Health ( ) . Service ( d . name , d . tag , passingOnly , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( "[TRACE] %s: returned %d results" , d , len ( entries ) ) list := make ( [ ] * HealthService , 0 , len ( entries ) ) for _ , entry := range entries { status := entry . Checks . AggregatedStatus ( ) if ! acceptStatus ( d . filters , status ) { continue } address := entry . Service . Address if address == "" { address = entry . Node . Address } list = append ( list , & HealthService { Node : entry . Node . Node , NodeID : entry . Node . ID , NodeAddress : entry . Node . Address , NodeTaggedAddresses : entry . Node . TaggedAddresses , NodeMeta : entry . Node . Meta , ServiceMeta : entry . Service . Meta , Address : address , ID : entry . Service . ID , Name : entry . Service . Service , Tags : ServiceTags ( deepCopyAndSortTags ( entry . Service . Tags ) ) , Status : status , Checks : entry . Checks , Port : entry . Service . Port , } ) } log . Printf ( "[TRACE] %s: returned %d results after filtering" , d , len ( list ) ) if d . near == "" { sort . Stable ( ByNodeThenID ( list ) ) } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return list , rm , nil }
1369	func ( handler * TaskHandler ) taskStateChangesToSend ( ) [ ] api . TaskStateChange { handler . lock . RLock ( ) defer handler . lock . RUnlock ( ) var events [ ] api . TaskStateChange for taskARN := range handler . tasksToContainerStates { if task , ok := handler . state . TaskByArn ( taskARN ) ; ok { knownStatus := task . GetKnownStatus ( ) if knownStatus >= apitaskstatus . TaskStopped { continue } event := api . TaskStateChange { TaskARN : taskARN , Status : task . GetKnownStatus ( ) , Task : task , } event . SetTaskTimestamps ( ) events = append ( events , event ) } } return events }
7153	func ( s * Container ) Inspect ( ) ( [ ] Inspect , error ) { out , err := s . docker . Run ( "inspect" , s . id ) if err != nil { return nil , err } var list [ ] Inspect err = json . NewDecoder ( strings . NewReader ( out ) ) . Decode ( & list ) if err != nil { return nil , UnexpectedOutputError ( fmt . Sprintf ( "Error parsing output when inspecting container: %v" , err ) ) } if len ( list ) == 0 { return nil , UnexpectedOutputError ( "Empty output when inspecting container" ) } return list , nil }
526	func ( h * RequestHeader ) Header ( ) [ ] byte { h . bufKV . value = h . AppendBytes ( h . bufKV . value [ : 0 ] ) return h . bufKV . value }
6867	func ( api * API ) GetPasteTextById ( paste_id string ) ( string , error ) { response , err := http . Get ( "http://pastebin.com/raw.php?i=" + paste_id ) defer response . Body . Close ( ) if err != nil { return "" , err } if response . StatusCode != 200 { return "" , PasteGetError } buf := bytes . Buffer { } _ , err = buf . ReadFrom ( response . Body ) if err != nil { return "" , err } return buf . String ( ) , nil }
3146	func ParseText ( line string ) ( * Points , error ) { row := strings . Split ( strings . Trim ( line , "\n \t\r" ) , \n ) \t \r " " if len ( row ) != 3 { return nil , fmt . Errorf ( "bad message: %#v" , line ) } value , err := strconv . ParseFloat ( row [ 1 ] , 64 ) if err != nil || math . IsNaN ( value ) { return nil , fmt . Errorf ( "bad message: %#v" , line ) } }
1911	func ( m * MockSSMClient ) GetParameters ( arg0 * ssm . GetParametersInput ) ( * ssm . GetParametersOutput , error ) { ret := m . ctrl . Call ( m , "GetParameters" , arg0 ) ret0 , _ := ret [ 0 ] . ( * ssm . GetParametersOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5343	func CommentOutM ( filename string , reLine [ ] string ) error { e , err := NewEdit ( filename ) if err != nil { return err } err = e . CommentOut ( reLine ) err2 := e . Close ( ) if err != nil { return err } return err2 }
734	func ( p * AWSSDProvider ) RegisterInstance ( service * sd . Service , ep * endpoint . Endpoint ) error { for _ , target := range ep . Targets { log . Infof ( "Registering a new instance \"%s\" for service \"%s\" (%s)" , \" , \" , \" ) \" target * service . Name } * service . Id }
425	func ListenAndServe ( addr string , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ListenAndServe ( addr ) }
6662	func ( c * Client ) Status ( id string ) ( * StatusResponse , error ) { statResp := & StatusResponse { } resp , err := c . caller . Call ( "GET" , c . endpoint + "/opengdpr_requests/" + id , nil ) return statResp , c . json ( resp , err , true , statResp ) }
3245	func ( c * ChannelSlackRequest ) GetChannelNameOk ( ) ( string , bool ) { if c == nil || c . ChannelName == nil { return "" , false } return * c . ChannelName , true }
528	func ServeFileUncompressed ( ctx * RequestCtx , path string ) { ctx . Request . Header . DelBytes ( strAcceptEncoding ) ServeFile ( ctx , path ) }
6509	func ( c Client ) RequestMoney ( params * TransactionParams ) ( * transactionConfirmation , error ) { return c . transactionRequest ( "POST" , "request_money" , params ) }
1319	func ( mr * MockOSMockRecorder ) Create ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Create" , reflect . TypeOf ( ( * MockOS ) ( nil ) . Create ) , arg0 ) }
3762	func ( t * templateData ) addArrayType ( x * ast . ArrayType , receiverType , fieldName string ) { var eltType string switch elt := x . Elt . ( type ) { case * ast . Ident : eltType = elt . String ( ) default : logf ( "addArrayType: type %q, field %q: unknown element type: %T %+v; skipping." , receiverType , fieldName , elt , elt ) return } t . Accessors = append ( t . Accessors , newAccessor ( receiverType , fieldName , "[]" + eltType , "nil" ) ) }
5462	func ( a * AlertService ) GetAlertsInRange ( start time . Time , end time . Time , data url . Values ) AlertPageIterator { if start . After ( end ) { panic ( "start date is after end date" ) } d := url . Values { } if data != nil { for k , v := range data { d [ k ] = v } } d . Del ( "Page" ) if start != Epoch { startFormat := start . UTC ( ) . Format ( time . RFC3339 ) d . Set ( "StartDate" , startFormat ) } if end != HeatDeath { endFormat := end . UTC ( ) . Format ( time . RFC3339 ) d . Set ( "EndDate" , endFormat ) } iter := NewPageIterator ( a . client , d , alertPathPart ) return & alertDateIterator { start : start , end : end , p : iter , } }
7	func ( ng * Engine ) cumulativeSubqueryOffset ( path [ ] Node ) time . Duration { var subqOffset time . Duration for _ , node := range path { switch n := node . ( type ) { case * SubqueryExpr : subqOffset += n . Range + n . Offset } } return subqOffset }
4678	func parseBytes ( data [ ] byte , rslt * result , src * source , opts * Options , f * File ) ( [ ] element , error ) { var elements [ ] element lines := strings . Split ( formatLF ( string ( data ) ) , lf ) i := 0 l := len ( lines ) if l > 0 && lines [ l - 1 ] == "" { l -- } for i < l { ln := newLine ( i + 1 , lines [ i ] , opts , f ) i ++ if ln . isEmpty ( ) { continue } if ln . isTopIndent ( ) { e , err := newElement ( ln , rslt , src , nil , opts ) if err != nil { return nil , err } if err := appendChildren ( e , rslt , lines , & i , l , src , opts , f ) ; err != nil { return nil , err } elements = append ( elements , e ) } } return elements , nil }
92	func ( t * Target ) Metadata ( metric string ) ( MetricMetadata , bool ) { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) if t . metadata == nil { return MetricMetadata { } , false } return t . metadata . getMetadata ( metric ) }
3720	func ( w * Widget ) HasTextSize ( ) bool { if w != nil && w . TextSize != nil { return true } return false }
599	func ArticleCtx ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { var article * Article var err error if articleID := chi . URLParam ( r , "articleID" ) ; articleID != "" { article , err = dbGetArticle ( articleID ) } else if articleSlug := chi . URLParam ( r , "articleSlug" ) ; articleSlug != "" { article , err = dbGetArticleBySlug ( articleSlug ) } else { render . Render ( w , r , ErrNotFound ) return } if err != nil { render . Render ( w , r , ErrNotFound ) return } ctx := context . WithValue ( r . Context ( ) , "article" , article ) next . ServeHTTP ( w , r . WithContext ( ctx ) ) } ) }
7242	func ( l * logger ) Debugln ( vals ... interface { } ) { l . mut . Lock ( ) defer l . mut . Unlock ( ) s := fmt . Sprintln ( vals ... ) l . logger . Output ( 2 , "DEBUG: " + s ) l . callHandlers ( LevelDebug , s ) }
4242	func ( b Box ) Round ( ) ( lat , lng float64 ) { x := maxDecimalPower ( b . MaxLat - b . MinLat ) lat = math . Ceil ( b . MinLat / x ) * x x = maxDecimalPower ( b . MaxLng - b . MinLng ) lng = math . Ceil ( b . MinLng / x ) * x return }
168	func Parse ( content [ ] byte ) ( * RuleGroups , [ ] error ) { var groups RuleGroups if err := yaml . UnmarshalStrict ( content , & groups ) ; err != nil { return nil , [ ] error { err } } return & groups , groups . Validate ( ) }
946	func ( d * Driver ) generateKeyBundle ( ) error { log . Debugf ( "Creating Tar key bundle..." ) magicString := "boot2docker, this is vmware speaking" tf , err := os . Create ( d . ResolveStorePath ( "userdata.tar" ) ) if err != nil { return err } defer tf . Close ( ) var fileWriter = tf tw := tar . NewWriter ( fileWriter ) defer tw . Close ( ) file := & tar . Header { Name : magicString , Size : int64 ( len ( magicString ) ) } if err := tw . WriteHeader ( file ) ; err != nil { return err } if _ , err := tw . Write ( [ ] byte ( magicString ) ) ; err != nil { return err } file = & tar . Header { Name : ".ssh" , Typeflag : tar . TypeDir , Mode : 0700 } if err := tw . WriteHeader ( file ) ; err != nil { return err } pubKey , err := ioutil . ReadFile ( d . publicSSHKeyPath ( ) ) if err != nil { return err } file = & tar . Header { Name : ".ssh/authorized_keys" , Size : int64 ( len ( pubKey ) ) , Mode : 0644 } if err := tw . WriteHeader ( file ) ; err != nil { return err } if _ , err := tw . Write ( [ ] byte ( pubKey ) ) ; err != nil { return err } file = & tar . Header { Name : ".ssh/authorized_keys2" , Size : int64 ( len ( pubKey ) ) , Mode : 0644 } if err := tw . WriteHeader ( file ) ; err != nil { return err } if _ , err := tw . Write ( [ ] byte ( pubKey ) ) ; err != nil { return err } err = tw . Close ( ) return err }
4258	func ( c * linuxConsole ) open ( flag int ) ( * os . File , error ) { r , e := syscall . Open ( c . slavePath , flag , 0 ) if e != nil { return nil , & os . PathError { Op : "open" , Path : c . slavePath , Err : e , } } return os . NewFile ( uintptr ( r ) , c . slavePath ) , nil }
6924	func Logger ( ) * logging . Logger { if defaultLogger == nil { logger , _ := logging . SimpleLogger ( "bambou" ) defaultLogger = logger logger . SetLevel ( logging . ERROR ) } return defaultLogger }
2409	func IsGamepadButtonJustReleased ( id int , button ebiten . GamepadButton ) bool { theInputState . m . RLock ( ) prev := 0 if _ , ok := theInputState . prevGamepadButtonDurations [ id ] ; ok { prev = theInputState . prevGamepadButtonDurations [ id ] [ button ] } current := 0 if _ , ok := theInputState . gamepadButtonDurations [ id ] ; ok { current = theInputState . gamepadButtonDurations [ id ] [ button ] } theInputState . m . RUnlock ( ) return current == 0 && prev > 0 }
1762	func ( task * Task ) GetTerminalReason ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . terminalReason }
2914	func ( r * Subresource ) FindVirtualDevice ( l object . VirtualDeviceList ) ( types . BaseVirtualDevice , error ) { if key := r . Get ( "key" ) . ( int ) ; key > 0 { log . Printf ( "[DEBUG] FindVirtualDevice: Looking for device with key %d" , key ) if dev := l . FindByKey ( int32 ( key ) ) ; dev != nil { log . Printf ( "[DEBUG] FindVirtualDevice: Device found: %s" , l . Name ( dev ) ) return dev , nil } return nil , fmt . Errorf ( "could not find device with key %d" , key ) } return r . FindVirtualDeviceByAddr ( l ) }
5470	func ( c * MessageService ) GetNextMessagesInRange ( start time . Time , end time . Time , nextPageURI string ) MessagePageIterator { if nextPageURI == "" { panic ( "nextpageuri is empty" ) } iter := NewNextPageIterator ( c . client , messagesPathPart ) iter . SetNextPageURI ( types . NullString { Valid : true , String : nextPageURI } ) return & messageDateIterator { start : start , end : end , p : iter , } }
3742	func ( w * WidgetConditionalFormat ) GetHideValue ( ) bool { if w == nil || w . HideValue == nil { return false } return * w . HideValue }
1898	func ( engine * DockerTaskEngine ) openEventstream ( ctx context . Context ) error { events , err := engine . client . ContainerEvents ( ctx ) if err != nil { return err } engine . events = events return nil }
7252	func ( l * logger ) SetDebug ( facility string , enabled bool ) { l . mut . Lock ( ) l . debug [ facility ] = enabled l . mut . Unlock ( ) }
1117	func regexReplaceAll ( re , pl , s string ) ( string , error ) { compiled , err := regexp . Compile ( re ) if err != nil { return "" , err } return compiled . ReplaceAllString ( s , pl ) , nil }
3463	func ( q * QueryConfig ) HasTimeRange ( ) bool { if q != nil && q . TimeRange != nil { return true } return false }
5539	func NewClient ( user , pass , resource , authType string ) ( * Client , error ) { return NewClientWithServerInfo ( user , pass , resource , authType , defaultHost , defaultDomain , defaultConf ) }
6583	func EnablePassiveSvcChecks ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "ENABLE_PASSIVE_SVC_CHECKS" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
1129	func ( c * cache ) Add ( k string , x interface { } , d time . Duration ) error { c . mu . Lock ( ) _ , found := c . get ( k ) if found { c . mu . Unlock ( ) return fmt . Errorf ( "Item %s already exists" , k ) } c . set ( k , x , d ) c . mu . Unlock ( ) return nil }
4261	func joinExistingNamespaces ( namespaces [ ] configs . Namespace ) error { for _ , ns := range namespaces { if ns . Path != "" { f , err := os . OpenFile ( ns . Path , os . O_RDONLY , 0 ) if err != nil { return err } err = system . Setns ( f . Fd ( ) , uintptr ( ns . Syscall ( ) ) ) f . Close ( ) if err != nil { return err } } } return nil }
6193	func NewMonitor ( conf * Config , logger log . Logger , db * reform . DB , pr * proc . Processor , pscAddr string , pw data . PWDGetter ) * Monitor { return & Monitor { conf : conf , logger : logger . Add ( "type" , "client/bill.Monitor" ) , db : db , pr : pr , psc : pscAddr , pw : pw , post : pay . PostCheque , } }
2093	func ( m * MockCNI ) DelNetwork ( arg0 * libcni . NetworkConfig , arg1 * libcni . RuntimeConf ) error { ret := m . ctrl . Call ( m , "DelNetwork" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
4474	func ( d * Duration ) Scan ( raw interface { } ) error { switch v := raw . ( type ) { case int64 : * d = Duration ( v ) case float64 : * d = Duration ( int64 ( v ) ) case nil : * d = Duration ( 0 ) default : return fmt . Errorf ( "cannot sql.Scan() strfmt.Duration from: %#v" , v ) } return nil }
4022	func ( c * Composer ) DestroyWindow ( view Control ) { ev := Event { Type : EventClose } c . sendEventToActiveWindow ( ev ) windows := c . getWindowList ( ) var newOrder [ ] Control for i := 0 ; i < len ( windows ) ; i ++ { if windows [ i ] != view { newOrder = append ( newOrder , windows [ i ] ) } } if len ( newOrder ) == 0 { go Stop ( ) return } c . BeginUpdate ( ) c . windows = newOrder c . EndUpdate ( ) c . activateWindow ( c . topWindow ( ) ) }
5881	func doDec ( signer jwt . Signer , in [ ] byte ) ( [ ] byte , error ) { var err error ut := UnstructuredToken { } err = signer . Decode ( bytes . TrimSpace ( in ) , & ut ) if err != nil { return nil , err } out , err := json . MarshalIndent ( & ut , "" , " " ) if err != nil { return nil , err } return out , nil }
2104	func ( eni * ENIAttachment ) HasExpired ( ) bool { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return time . Now ( ) . After ( eni . ExpiresAt ) }
580	func ( mx * Mux ) Trace ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mTRACE , pattern , handlerFn ) }
7089	func NewRandomSourceListSecure ( ) RandomSourceList { return RandomSourceList { RandomSource { Reader : rand . Reader , Weight : DEFAULT_SYS_RAND_SIZE , } , RandomSource { Reader : NewRandom ( ) , Weight : DEFAULT_RAIQUB_RAND_SIZE , } , } }
3131	func ( p * Protocol ) MarshalText ( ) ( [ ] byte , error ) { switch * p { case ProtocolPlain : return [ ] byte ( "plain" ) , nil case ProtocolProtobuf : return [ ] byte ( "protobuf" ) , nil case ProtocolPickle : return [ ] byte ( "pickle" ) , nil } return nil , fmt . Errorf ( "Unsupported offset type %v, supported offsets: %v" , p , supportedProtocols ) }
926	func ( b * b2dReleaseGetter ) getReleaseURL ( apiURL string ) ( string , error ) { if apiURL == "" { apiURL = defaultURL } re := regexp . MustCompile ( "(https?)://([^/]+)(/api/v3)?/repos/([^/]+)/([^/]+)/releases" ) matches := re . FindStringSubmatch ( apiURL ) if len ( matches ) != 6 { return apiURL , nil } scheme , host , org , repo := matches [ 1 ] , matches [ 2 ] , matches [ 4 ] , matches [ 5 ] if host == "api.github.com" { host = "github.com" } tag , err := b . getReleaseTag ( apiURL ) if err != nil { return "" , err } log . Infof ( "Latest release for %s/%s/%s is %s" , host , org , repo , tag ) bugURL , ok := AUFSBugB2DVersions [ tag ] if ok { log . Warnf ( `Boot2Docker %s has a known issue with AUFS.See here for more details: %sConsider specifying another storage driver (e.g. 'overlay') using '--engine-storage-driver' instead.` , tag , bugURL ) } url := fmt . Sprintf ( "%s://%s/%s/%s/releases/download/%s/%s" , scheme , host , org , repo , tag , b . isoFilename ) return url , nil }
5784	func ( a * API ) UpdateAccount ( cfg * Account ) ( * Account , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid account config [nil]" ) } accountCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . AccountCIDRegex , accountCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid account CID [%s]" , accountCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] account update, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( accountCID , jsonCfg ) if err != nil { return nil , err } account := & Account { } if err := json . Unmarshal ( result , account ) ; err != nil { return nil , err } return account , nil }
4828	func ( g GitOS ) Command ( name string , args ... string ) Cmd { return & gitCmd { exec . Command ( name , args ... ) } }
4590	func ( c * Call ) equal ( r * Call ) bool { return c . SrcPath == r . SrcPath && c . Line == r . Line && c . Func == r . Func && c . Args . equal ( & r . Args ) }
3537	func ( s * SyntheticsOptions ) HasTickEvery ( ) bool { if s != nil && s . TickEvery != nil { return true } return false }
3826	func NodeID ( ) [ ] byte { defer nodeMu . Unlock ( ) nodeMu . Lock ( ) if nodeID == zeroID { setNodeInterface ( "" ) } nid := nodeID return nid [ : ] }
6685	func ErrMissingRequiredField ( field string ) error { return ErrorResponse { Code : http . StatusBadRequest , Message : fmt . Sprintf ( "missing required field: %s" , field ) , } }
4458	func ( r Password ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( r ) ) }
2502	func ( q * commandQueue ) EnqueueDrawTrianglesCommand ( dst , src * Image , vertices [ ] float32 , indices [ ] uint16 , color * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) { if len ( indices ) > graphics . IndicesNum { panic ( fmt . Sprintf ( "graphicscommand: len(indices) must be <= graphics.IndicesNum but not at EnqueueDrawTrianglesCommand: len(indices): %d, graphics.IndicesNum: %d" , len ( indices ) , graphics . IndicesNum ) ) } split := false if q . tmpNumIndices + len ( indices ) > graphics . IndicesNum { q . tmpNumIndices = 0 q . nextIndex = 0 split = true } q . appendVertices ( vertices ) q . appendIndices ( indices , uint16 ( q . nextIndex ) ) q . nextIndex += len ( vertices ) / graphics . VertexFloatNum q . tmpNumIndices += len ( indices ) q . doEnqueueDrawTrianglesCommand ( dst , src , len ( vertices ) , len ( indices ) , color , mode , filter , address , split ) }
4646	func ( geoIndex * geoIndex ) Range ( topLeft Point , bottomRight Point ) [ ] interface { } { topLeftIndex := cellOf ( topLeft , geoIndex . resolution ) bottomRightIndex := cellOf ( bottomRight , geoIndex . resolution ) return geoIndex . get ( bottomRightIndex . x , topLeftIndex . x , topLeftIndex . y , bottomRightIndex . y ) }
3248	func ( c * ChannelSlackRequest ) GetTransferAllUserCommentsOk ( ) ( bool , bool ) { if c == nil || c . TransferAllUserComments == nil { return false , false } return * c . TransferAllUserComments , true }
6688	func ( c * Client ) SnapshotDatabaseServer ( identifier string ) ( * DatabaseSnapshot , error ) { dbs := new ( DatabaseServer ) res , err := c . MakeApiRequest ( "POST" , "/1.0/database_servers/" + identifier + "/snapshot" , nil , & dbs ) if err != nil { return nil , err } snapID := getLinkRel ( res . Header . Get ( "Link" ) , "dbi" , "snapshot" ) if snapID != nil { snap := new ( DatabaseSnapshot ) snap . Id = * snapID return snap , nil } return nil , nil }
6011	func ( t Typed ) IntIf ( key string ) ( int , bool ) { value , exists := t [ key ] if exists == false { return 0 , false } switch t := value . ( type ) { case int : return t , true case int16 : return int ( t ) , true case int32 : return int ( t ) , true case int64 : return int ( t ) , true case float64 : return int ( t ) , true case string : i , err := strconv . Atoi ( t ) return i , err == nil } return 0 , false }
4420	func ( u * IPv4 ) DeepCopy ( ) * IPv4 { if u == nil { return nil } out := new ( IPv4 ) u . DeepCopyInto ( out ) return out }
3602	func ( t * TimeRange ) GetFromOk ( ) ( json . Number , bool ) { if t == nil || t . From == nil { return "" , false } return * t . From , true }
5984	func NewMeasuredWriter ( w io . Writer ) * MeasuredWriter { return & MeasuredWriter { wrap : w , rate : newCounter ( ) } }
7164	func readBlockAt ( reader io . ReadSeeker , offset int64 ) ( fileBlock , error ) { var block fileBlock _ , err := reader . Seek ( offset , os . SEEK_SET ) if err != nil { return block , err } return block , binary . Read ( reader , binary . LittleEndian , & block ) }
6215	func ( w * Worker ) ClientAfterUncooperativeClose ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientAfterUncooperativeClose" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientAfterUncooperativeClose ) if err != nil { return err } logger = logger . Add ( "channel" , ch ) ch . ChannelStatus = data . ChannelClosedUncoop if err := w . saveRecord ( logger , w . db . Querier , ch ) ; err != nil { return err } client , err := w . account ( logger , ch . Client ) if err != nil { return err } return w . addJob ( logger , nil , data . JobAccountUpdateBalances , data . JobAccount , client . ID ) }
6507	func ( c Client ) GenerateReceiveAddress ( params * AddressParams ) ( string , error ) { holder := map [ string ] interface { } { } if err := c . Post ( "account/generate_receive_address" , params , & holder ) ; err != nil { return "" , err } return holder [ "address" ] . ( string ) , nil }
5952	func ( s Scan ) AddHosts ( hosts ... string ) Scan { s . configHosts = append ( s . configHosts , hosts ... ) return s }
4904	func NewReaderSize ( r io . Reader , size int ) * Reader { return & Reader { rd : bufio . NewReaderSize ( r , size ) , tr : unicode . Cesu8ToUtf8Transformer , } }
1932	func ( m * MockTaskEngineState ) AddENIAttachment ( arg0 * eni . ENIAttachment ) { m . ctrl . Call ( m , "AddENIAttachment" , arg0 ) }
6626	func ( c4 * Seefor ) UseTimer ( timer * Timer ) * Timer { if timer == nil { if c4 . timer != nil { return c4 . timer } timer = NewTimer ( ) } c4 . timer = timer return c4 . timer }
4539	func SetMetaDataLabel ( obj metav1 . Object , key , value string ) { l := obj . GetLabels ( ) if l == nil { l = make ( map [ string ] string ) } l [ key ] = value obj . SetLabels ( l ) }
1060	func NewHealthServiceQuery ( s string ) ( * HealthServiceQuery , error ) { if ! HealthServiceQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "health.service: invalid format: %q" , s ) } m := regexpMatch ( HealthServiceQueryRe , s ) var filters [ ] string if filter := m [ "filter" ] ; filter != "" { split := strings . Split ( filter , "," ) for _ , f := range split { f = strings . TrimSpace ( f ) switch f { case HealthAny , HealthPassing , HealthWarning , HealthCritical , HealthMaint : filters = append ( filters , f ) case "" : default : return nil , fmt . Errorf ( "health.service: invalid filter: %q in %q" , f , s ) } } sort . Strings ( filters ) } else { filters = [ ] string { HealthPassing } } return & HealthServiceQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ "dc" ] , filters : filters , name : m [ "name" ] , near : m [ "near" ] , tag : m [ "tag" ] , } , nil }
972	func ( b * Brain ) Recall ( d dep . Dependency ) ( interface { } , bool ) { b . RLock ( ) defer b . RUnlock ( ) if _ , ok := b . receivedData [ d . String ( ) ] ; ! ok { return nil , false } return b . data [ d . String ( ) ] , true }
4089	func ( c * CheckBox ) SetAllow3State ( enable bool ) { if ! enable && c . state == 2 { c . state = 0 } c . allow3state = enable }
1439	func ( state * DockerTaskEngineState ) TaskByID ( cid string ) ( * apitask . Task , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) arn , found := state . idToTask [ cid ] if ! found { return nil , false } return state . taskByArn ( arn ) }
3279	func ( d * DashboardLite ) HasModified ( ) bool { if d != nil && d . Modified != nil { return true } return false }
2582	func virtualMachineFromSearchIndex ( ctx context . Context , client * govmomi . Client , uuid string ) ( object . Reference , error ) { log . Printf ( "[DEBUG] Using SearchIndex to look up UUID %q" , uuid ) search := object . NewSearchIndex ( client . Client ) result , err := search . FindByUuid ( ctx , nil , uuid , true , structure . BoolPtr ( false ) ) if err != nil { return nil , err } if result == nil { return nil , newUUIDNotFoundError ( fmt . Sprintf ( "virtual machine with UUID %q not found" , uuid ) ) } return result , nil }
4503	func Items ( items ... string ) Filter { return FilterFunc ( func ( arg Arg ) error { for _ , s := range items { arg . Out <- s } return nil } ) }
472	func ( resp * Response ) ResetBody ( ) { resp . bodyRaw = nil resp . closeBodyStream ( ) if resp . body != nil { if resp . keepBodyBuffer { resp . body . Reset ( ) } else { responseBodyPool . Put ( resp . body ) resp . body = nil } } }
1229	func ( client * cniClient ) CleanupNS ( ctx context . Context , cfg * Config , timeout time . Duration ) error { derivedCtx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) err := make ( chan error ) go func ( err chan error ) { err <- client . cleanupNS ( cfg ) } ( err ) select { case <- derivedCtx . Done ( ) : return errors . Wrap ( derivedCtx . Err ( ) , "cni cleanup: container namespace cleanup failed" ) case err := <- err : return err } }
3239	func ( b * BoardWidget ) GetLayoutOk ( ) ( WidgetLayout , bool ) { if b == nil || b . Layout == nil { return WidgetLayout { } , false } return * b . Layout , true }
5154	func ( m * MongoStore ) New ( r * http . Request , name string ) ( * sessions . Session , error ) { session := sessions . NewSession ( m , name ) session . Options = & sessions . Options { Path : m . Options . Path , MaxAge : m . Options . MaxAge , Domain : m . Options . Domain , Secure : m . Options . Secure , HttpOnly : m . Options . HttpOnly , } session . IsNew = true var err error if cook , errToken := m . Token . GetToken ( r , name ) ; errToken == nil { err = securecookie . DecodeMulti ( name , cook , & session . ID , m . Codecs ... ) if err == nil { err = m . load ( session ) if err == nil { session . IsNew = false } else { err = nil } } } return session , err }
2204	func ActionNameIsValid ( actionName string ) bool { cstr := ( * C . gchar ) ( C . CString ( actionName ) ) return gobool ( C . g_action_name_is_valid ( cstr ) ) }
7207	func ( lw DebugLogWriter ) Write ( p [ ] byte ) ( int , error ) { lw . Debug ( string ( bytes . TrimRightFunc ( p , unicode . IsSpace ) ) ) return len ( p ) , nil }
7161	func ( c * Counter ) Metrics ( ) ( cs [ ] prometheus . Collector ) { return [ ] prometheus . Collector { c . vector } }
3289	func ( d * Downtime ) GetParentId ( ) int { if d == nil || d . ParentId == nil { return 0 } return * d . ParentId }
5389	func OwnerHas ( name string , p ... perm ) ( bool , error ) { i , err := NewInfo ( name ) if err != nil { return false , err } return i . OwnerHas ( p ... ) , nil }
41	func randomAppsURL ( servers [ ] string ) string { server := servers [ rand . Intn ( len ( servers ) ) ] return fmt . Sprintf ( "%s%s" , server , appListPath ) }
3583	func ( t * ThresholdCount ) GetWarning ( ) json . Number { if t == nil || t . Warning == nil { return "" } return * t . Warning }
3209	func ( client * Client ) GetBoard ( id string ) ( * Board , error ) { var board Board if err := client . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/dashboard/%s" , id ) , nil , & board ) ; err != nil { return nil , err } return & board , nil }
5809	func ( m * CirconusMetrics ) snapshot ( ) ( c map [ string ] uint64 , g map [ string ] interface { } , h map [ string ] * circonusllhist . Histogram , t map [ string ] string ) { c = m . snapCounters ( ) g = m . snapGauges ( ) h = m . snapHistograms ( ) t = m . snapText ( ) return }
3892	func ( b * builder ) switchStmt ( fn * Function , s * ast . SwitchStmt , label * lblock ) { if s . Init != nil { b . stmt ( fn , s . Init ) } var tag Value = vTrue if s . Tag != nil { tag = b . expr ( fn , s . Tag ) } done := fn . newBasicBlock ( "switch.done" ) if label != nil { label . _break = done } var dfltBody * [ ] ast . Stmt var dfltFallthrough * BasicBlock var fallthru , dfltBlock * BasicBlock ncases := len ( s . Body . List ) for i , clause := range s . Body . List { body := fallthru if body == nil { body = fn . newBasicBlock ( "switch.body" ) } fallthru = done if i + 1 < ncases { fallthru = fn . newBasicBlock ( "switch.body" ) } cc := clause . ( * ast . CaseClause ) if cc . List == nil { dfltBody = & cc . Body dfltFallthrough = fallthru dfltBlock = body continue } var nextCond * BasicBlock for _ , cond := range cc . List { nextCond = fn . newBasicBlock ( "switch.next" ) cond := emitCompare ( fn , token . EQL , tag , b . expr ( fn , cond ) , cond . Pos ( ) ) emitIf ( fn , cond , body , nextCond ) fn . currentBlock = nextCond } fn . currentBlock = body fn . targets = & targets { tail : fn . targets , _break : done , _fallthrough : fallthru , } b . stmtList ( fn , cc . Body ) fn . targets = fn . targets . tail emitJump ( fn , done ) fn . currentBlock = nextCond } if dfltBlock != nil { emitJump ( fn , dfltBlock ) fn . currentBlock = dfltBlock fn . targets = & targets { tail : fn . targets , _break : done , _fallthrough : dfltFallthrough , } b . stmtList ( fn , * dfltBody ) fn . targets = fn . targets . tail } emitJump ( fn , done ) fn . currentBlock = done }
3222	func ( a * Alert ) GetStateOk ( ) ( string , bool ) { if a == nil || a . State == nil { return "" , false } return * a . State , true }
600	func SearchArticles ( w http . ResponseWriter , r * http . Request ) { render . RenderList ( w , r , NewArticleListResponse ( articles ) ) }
3869	func ( p * Package ) Const ( name string ) ( c * NamedConst ) { c , _ = p . Members [ name ] . ( * NamedConst ) return }
727	func ( p * AWSSDProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { namespaces , err := p . ListNamespaces ( ) if err != nil { return nil , err } for _ , ns := range namespaces { services , err := p . ListServicesByNamespaceID ( ns . Id ) if err != nil { return nil , err } for _ , srv := range services { instances , err := p . ListInstancesByServiceID ( srv . Id ) if err != nil { return nil , err } if len ( instances ) > 0 { ep := p . instancesToEndpoint ( ns , srv , instances ) endpoints = append ( endpoints , ep ) } } } return endpoints , nil }
4657	func NewCountIndex ( resolution Meters ) * CountIndex { newCounter := func ( ) interface { } { return & singleValueAccumulatingCounter { } } return & CountIndex { newGeoIndex ( resolution , newCounter ) , make ( map [ string ] Point ) } }
5346	func ReplaceAtLineN ( filename string , r [ ] ReplacerAtLine , n int ) error { e , err := NewEdit ( filename ) if err != nil { return err } err = e . genReplaceAtLine ( r , n ) err2 := e . Close ( ) if err != nil { return err } return err2 }
1481	func ( c * Container ) GetKnownPortBindings ( ) [ ] PortBinding { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . KnownPortBindingsUnsafe }
2380	func ( i * Input ) GamepadIDButtonPressed ( ) int { for _ , id := range ebiten . GamepadIDs ( ) { for b := ebiten . GamepadButton ( 0 ) ; b <= ebiten . GamepadButtonMax ; b ++ { if ebiten . IsGamepadButtonPressed ( id , b ) { return id } } } return - 1 }
7251	func ( l * logger ) ShouldDebug ( facility string ) bool { l . mut . Lock ( ) res := l . debug [ facility ] l . mut . Unlock ( ) return res }
6360	func From ( ctx context . Context ) Context { if c , ok := ctx . ( Context ) ; ok { return c } return & contextT { ctx : ctx } }
661	func NewLinodeProvider ( domainFilter DomainFilter , dryRun bool , appVersion string ) ( * LinodeProvider , error ) { token , ok := os . LookupEnv ( "LINODE_TOKEN" ) if ! ok { return nil , fmt . Errorf ( "no token found" ) } tokenSource := oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token } ) oauth2Client := & http . Client { Transport : & oauth2 . Transport { Source : tokenSource , } , } linodeClient := linodego . NewClient ( oauth2Client ) linodeClient . SetUserAgent ( fmt . Sprintf ( "ExternalDNS/%s linodego/%s" , appVersion , linodego . Version ) ) provider := & LinodeProvider { Client : & linodeClient , domainFilter : domainFilter , DryRun : dryRun , } return provider , nil }
7035	func ( c * Conn ) RemoteAddr ( ) net . Addr { ws := c . ws . Load ( ) . ( * websocket . Conn ) if ws == nil { return nil } return ws . RemoteAddr ( ) }
764	func ( c designateClient ) CreateRecordSet ( zoneID string , opts recordsets . CreateOpts ) ( string , error ) { r , err := recordsets . Create ( c . serviceClient , zoneID , opts ) . Extract ( ) if err != nil { return "" , err } return r . ID , nil }
4311	func ( c * Client ) FollowProject ( account , repo string ) ( * Project , error ) { project := & Project { } err := c . request ( "POST" , fmt . Sprintf ( "project/%s/%s/follow" , account , repo ) , project , nil , nil ) if err != nil { return nil , err } if err := cleanupProject ( project ) ; err != nil { return nil , err } return project , nil }
3069	func SetConfig ( source interface { } , others ... interface { } ) ( _ * ini . File , err error ) { cfg , err = ini . Load ( source , others ... ) return Config ( ) , err }
1258	func ( rm * ResourcesMap ) UnmarshalJSON ( data [ ] byte ) error { resources := make ( map [ string ] json . RawMessage ) err := json . Unmarshal ( data , & resources ) if err != nil { return err } result := make ( map [ string ] [ ] taskresource . TaskResource ) for key , value := range resources { switch key { case CgroupKey : if unmarshlCgroup ( key , value , result ) != nil { return err } case DockerVolumeKey : if unmarshalDockerVolume ( key , value , result ) != nil { return err } case ASMAuthKey : if unmarshalASMAuthKey ( key , value , result ) != nil { return err } case SSMSecretKey : if unmarshalSSMSecretKey ( key , value , result ) != nil { return err } case ASMSecretKey : if unmarshalASMSecretKey ( key , value , result ) != nil { return err } default : return errors . New ( "Unsupported resource type" ) } } * rm = result return nil }
2359	func ( b * Board ) Draw ( boardImage * ebiten . Image ) { boardImage . Fill ( frameColor ) for j := 0 ; j < b . size ; j ++ { for i := 0 ; i < b . size ; i ++ { v := 0 op := & ebiten . DrawImageOptions { } x := i * tileSize + ( i + 1 ) * tileMargin y := j * tileSize + ( j + 1 ) * tileMargin op . GeoM . Translate ( float64 ( x ) , float64 ( y ) ) r , g , b , a := colorToScale ( tileBackgroundColor ( v ) ) op . ColorM . Scale ( r , g , b , a ) boardImage . DrawImage ( tileImage , op ) } } animatingTiles := map [ * Tile ] struct { } { } nonAnimatingTiles := map [ * Tile ] struct { } { } for t := range b . tiles { if t . IsMoving ( ) { animatingTiles [ t ] = struct { } { } } else { nonAnimatingTiles [ t ] = struct { } { } } } for t := range nonAnimatingTiles { t . Draw ( boardImage ) } for t := range animatingTiles { t . Draw ( boardImage ) } }
5505	func ( f * FileLogger ) fileMonitor ( ) { defer func ( ) { if err := recover ( ) ; err != nil { f . lg . Printf ( "FileLogger's FileMonitor() catch panic: %v\n" , \n ) } } err ( ) logScan := DEFAULT_LOG_SCAN timer := time . NewTicker ( time . Duration ( logScan ) * time . Second ) }
4748	func FirstError ( errs ... error ) error { for _ , err := range errs { if err != nil { return err } } return nil }
4909	func ( r * Reader ) ReadBool ( ) bool { if r . err != nil { return false } return ! ( r . ReadB ( ) == 0 ) }
5842	func ( a * API ) FetchAlert ( cid CIDType ) ( * Alert , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid alert CID [none]" ) } alertCID := string ( * cid ) matched , err := regexp . MatchString ( config . AlertCIDRegex , alertCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid alert CID [%s]" , alertCID ) } result , err := a . Get ( alertCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch alert, received JSON: %s" , string ( result ) ) } alert := & Alert { } if err := json . Unmarshal ( result , alert ) ; err != nil { return nil , err } return alert , nil }
4016	func ( d * FileSelectDialog ) pathDown ( dir string ) { d . currPath = filepath . Join ( d . currPath , dir ) d . populateFiles ( ) d . selectFirst ( ) }
2680	func expandClusterInfraUpdateHaConfigInfo ( d * schema . ResourceData ) * types . ClusterInfraUpdateHaConfigInfo { obj := & types . ClusterInfraUpdateHaConfigInfo { Behavior : d . Get ( "proactive_ha_automation_level" ) . ( string ) , Enabled : structure . GetBool ( d , "proactive_ha_enabled" ) , ModerateRemediation : d . Get ( "proactive_ha_moderate_remediation" ) . ( string ) , Providers : structure . SliceInterfacesToStrings ( d . Get ( "proactive_ha_provider_ids" ) . ( * schema . Set ) . List ( ) ) , SevereRemediation : d . Get ( "proactive_ha_severe_remediation" ) . ( string ) , } return obj }
4659	func ( countIndex * CountIndex ) Range ( topLeft Point , bottomRight Point ) [ ] Point { counters := countIndex . index . Range ( topLeft , bottomRight ) points := make ( [ ] Point , 0 ) for _ , c := range counters { if c . ( counter ) . Point ( ) != nil { points = append ( points , c . ( counter ) . Point ( ) ) } } return points }
5965	func ( otp HOTP ) Increment ( ) { for i := ctrSize - 1 ; i >= 0 ; i -- { if otp . counter [ i ] ++ ; otp . counter [ i ] != 0 { return } } }
6192	func ( n * npmp ) DeleteMapping ( protocol string , extPort , intPort int ) ( err error ) { _ , err = n . c . AddPortMapping ( strings . ToLower ( protocol ) , intPort , 0 , 0 ) return err }
2086	func ( m * MockNetLink ) LinkByName ( arg0 string ) ( netlink . Link , error ) { ret := m . ctrl . Call ( m , "LinkByName" , arg0 ) ret0 , _ := ret [ 0 ] . ( netlink . Link ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
156	func ( t * QueueManager ) StoreSeries ( series [ ] tsdb . RefSeries , index int ) { t . seriesMtx . Lock ( ) defer t . seriesMtx . Unlock ( ) temp := make ( map [ uint64 ] [ ] prompb . Label , len ( series ) ) for _ , s := range series { ls := processExternalLabels ( s . Labels , t . externalLabels ) rl := relabel . Process ( ls , t . relabelConfigs ... ) if len ( rl ) == 0 { t . droppedSeries [ s . Ref ] = struct { } { } continue } temp [ s . Ref ] = labelsToLabelsProto ( rl ) } for ref , labels := range temp { t . seriesSegmentIndexes [ ref ] = index if orig , ok := t . seriesLabels [ ref ] ; ok { release ( orig ) } t . seriesLabels [ ref ] = labels } }
6617	func importBreakPaths ( file * ast . File ) [ ] string { var output [ ] string for _ , decl := range file . Decls { if gen , ok := decl . ( * ast . GenDecl ) ; ok && gen . Tok == token . IMPORT { for srcIndex , currSpec := range gen . Specs { if srcIndex > 0 { currGroup := importGroup ( importPath ( currSpec ) ) prevGroup := importGroup ( importPath ( gen . Specs [ srcIndex - 1 ] ) ) if currGroup != prevGroup { output = append ( output , importPath ( gen . Specs [ srcIndex ] ) ) } } } break } } return output }
5082	func ( socket * mongoSocket ) InitialAcquire ( serverInfo * mongoServerInfo , timeout time . Duration ) error { socket . Lock ( ) if socket . references > 0 { panic ( "Socket acquired out of cache with references" ) } if socket . dead != nil { dead := socket . dead socket . Unlock ( ) return dead } socket . references ++ socket . serverInfo = serverInfo socket . timeout = timeout stats . socketsInUse ( + 1 ) stats . socketRefs ( + 1 ) socket . Unlock ( ) return nil }
5514	func fileSize ( file string ) int64 { f , e := os . Stat ( file ) if e != nil { return 0 } return f . Size ( ) }
4801	func ( g GitlabHook ) handleToken ( r * http . Request , body [ ] byte , secret string ) error { token := r . Header . Get ( "X-Gitlab-Token" ) if token != "" { if secret == "" { Logger ( ) . Print ( "Unable to verify request. Secret not set in caddyfile!\n" ) } else \n } { if token != secret { return errors . New ( "Unable to verify request. The token and specified secret do not match!" ) } } }
2306	func ( v * TreeRowReference ) GetModel ( ) ITreeModel { c := C . gtk_tree_row_reference_get_model ( v . native ( ) ) if c == nil { return nil } m := wrapTreeModel ( glib . Take ( unsafe . Pointer ( c ) ) ) return m }
6371	func All ( subject Enumerable , p Predicate ) bool { done := make ( chan struct { } ) defer close ( done ) return subject . Enumerate ( done ) . All ( p ) }
3056	func ipAddrsForVirtualMachines ( ctx context . Context , client * vSphereClient , vms [ ] * object . VirtualMachine ) ( [ ] string , error ) { var addrs [ ] string for _ , vm := range vms { as , err := buildAndSelectGuestIPs ( ctx , vm ) if err != nil { return nil , err } addrs = append ( addrs , as ... ) } return addrs , nil }
5168	func ( t * tx ) End ( ) error { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) for t . ss . Peek ( ) != rootSegment { t . EndSegment ( ) } return t . Tracer . EndTransaction ( t . id ) }
6051	func NewHTTPClient ( sock uint ) ( * http . Client , error ) { torProxyURL , err := url . Parse ( fmt . Sprint ( "socks5://127.0.0.1:" , sock ) ) if err != nil { return nil , err } torTransport := & http . Transport { Proxy : http . ProxyURL ( torProxyURL ) } return & http . Client { Transport : torTransport , Timeout : time . Second * 10 , } , nil }
634	func ( c * inMemoryClient ) validateChangeBatch ( zone string , changes * inMemoryChange ) error { curZone , ok := c . zones [ zone ] if ! ok { return ErrZoneNotFound } mesh := map [ string ] map [ string ] bool { } for _ , newEndpoint := range changes . Create { if c . findByType ( newEndpoint . Type , curZone [ newEndpoint . Name ] ) != nil { return ErrRecordAlreadyExists } if err := c . updateMesh ( mesh , newEndpoint ) ; err != nil { return err } } for _ , updateEndpoint := range changes . UpdateNew { if c . findByType ( updateEndpoint . Type , curZone [ updateEndpoint . Name ] ) == nil { return ErrRecordNotFound } if err := c . updateMesh ( mesh , updateEndpoint ) ; err != nil { return err } } for _ , updateOldEndpoint := range changes . UpdateOld { if rec := c . findByType ( updateOldEndpoint . Type , curZone [ updateOldEndpoint . Name ] ) ; rec == nil || rec . Target != updateOldEndpoint . Target { return ErrRecordNotFound } } for _ , deleteEndpoint := range changes . Delete { if rec := c . findByType ( deleteEndpoint . Type , curZone [ deleteEndpoint . Name ] ) ; rec == nil || rec . Target != deleteEndpoint . Target { return ErrRecordNotFound } if err := c . updateMesh ( mesh , deleteEndpoint ) ; err != nil { return err } } return nil }
5912	func ( ks * Keystore ) PublicKey ( ) ( crypto . PublicKey , bool ) { ks . rw . RLock ( ) key , pub := ks . Key , ks . PubKey ks . rw . RUnlock ( ) if pub != nil { return pub , true } if key != nil { ks . rw . Lock ( ) defer ks . rw . Unlock ( ) if x , ok := key . ( interface { Public ( ) crypto . PublicKey } ) ; ok { ks . PubKey = x . Public ( ) } return ks . PubKey , ks . PubKey != nil } return nil , false }
715	func ( c etcdClient ) DeleteService ( key string ) error { ctx , cancel := context . WithTimeout ( c . ctx , etcdTimeout ) defer cancel ( ) _ , err := c . client . Delete ( ctx , key , etcdcv3 . WithPrefix ( ) ) return err }
421	func ( cc * LBClient ) Do ( req * Request , resp * Response ) error { timeout := cc . Timeout if timeout <= 0 { timeout = DefaultLBClientTimeout } return cc . DoTimeout ( req , resp , timeout ) }
4688	func readFiles ( basePath , innerPath string , opts * Options ) ( * source , error ) { base , err := readFile ( basePath , opts ) if err != nil { return nil , err } inner , err := readFile ( innerPath , opts ) if err != nil { return nil , err } var includes [ ] * File if err := findIncludes ( base . data , opts , & includes , base ) ; err != nil { return nil , err } if err := findIncludes ( inner . data , opts , & includes , inner ) ; err != nil { return nil , err } return NewSource ( base , inner , includes ) , nil }
7277	func ( s * Cache ) Flush ( ) { s . Lock ( ) defer s . Unlock ( ) s . values = make ( map [ string ] * cacheItem ) }
4120	func ( w * Window ) SetVisible ( visible bool ) { if w . hidden == visible { w . hidden = ! visible if w . hidden { w . SetModal ( false ) if WindowManager ( ) . topWindow ( ) == w { WindowManager ( ) . moveActiveWindowToBottom ( ) } } else { WindowManager ( ) . activateWindow ( w ) } } }
6271	func ( t * SimpleToken ) Check ( s string ) bool { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return s == t . token }
5413	func ( w * World ) AddSystem ( system System ) { if initializer , ok := system . ( Initializer ) ; ok { initializer . New ( w ) } w . systems = append ( w . systems , system ) sort . Sort ( w . systems ) }
5534	func ( lo * LuaObject ) Get ( a interface { } , subfields ... interface { } ) error { lo . Push ( ) defer lo . l . Pop ( 1 ) err := get ( lo . l , subfields ... ) if err != nil { return err } defer lo . l . Pop ( 1 ) return LuaToGo ( lo . l , - 1 , a ) }
4804	func setup ( c * caddy . Controller ) error { git , err := parse ( c ) if err != nil { return err } var hookRepos [ ] * Repo var startupFuncs [ ] func ( ) error for i := range git { repo := git . Repo ( i ) if repo . Hook . URL != "" { hookRepos = append ( hookRepos , repo ) startupFuncs = append ( startupFuncs , func ( ) error { return repo . Pull ( ) } ) } else { startupFuncs = append ( startupFuncs , func ( ) error { Start ( repo ) return repo . Pull ( ) } ) } } c . OncePerServerBlock ( func ( ) error { for i := range startupFuncs { c . OnStartup ( startupFuncs [ i ] ) } return nil } ) if len ( hookRepos ) > 0 { webhook := & WebHook { Repos : hookRepos } httpserver . GetConfig ( c ) . AddMiddleware ( func ( next httpserver . Handler ) httpserver . Handler { webhook . Next = next return webhook } ) } return nil }
1525	func ( cfg * Config ) validateAndOverrideBounds ( ) error { err := cfg . checkMissingAndDepreciated ( ) if err != nil { return err } if cfg . DockerStopTimeout < minimumDockerStopTimeout { return fmt . Errorf ( "config: invalid value for docker container stop timeout: %v" , cfg . DockerStopTimeout . String ( ) ) } if cfg . ContainerStartTimeout < minimumContainerStartTimeout { return fmt . Errorf ( "config: invalid value for docker container start timeout: %v" , cfg . ContainerStartTimeout . String ( ) ) } var badDrivers [ ] string for _ , driver := range cfg . AvailableLoggingDrivers { _ , ok := dockerclient . LoggingDriverMinimumVersion [ driver ] if ! ok { badDrivers = append ( badDrivers , string ( driver ) ) } } if len ( badDrivers ) > 0 { return errors . New ( "Invalid logging drivers: " + strings . Join ( badDrivers , ", " ) ) } if cfg . TaskCleanupWaitDuration < minimumTaskCleanupWaitDuration { seelog . Warnf ( "Invalid value for image cleanup duration, will be overridden with the default value: %s. Parsed value: %v, minimum value: %v." , DefaultTaskCleanupWaitDuration . String ( ) , cfg . TaskCleanupWaitDuration , minimumTaskCleanupWaitDuration ) cfg . TaskCleanupWaitDuration = DefaultTaskCleanupWaitDuration } if cfg . ImagePullInactivityTimeout < minimumImagePullInactivityTimeout { seelog . Warnf ( "Invalid value for image pull inactivity timeout duration, will be overridden with the default value: %s. Parsed value: %v, minimum value: %v." , defaultImagePullInactivityTimeout . String ( ) , cfg . ImagePullInactivityTimeout , minimumImagePullInactivityTimeout ) cfg . ImagePullInactivityTimeout = defaultImagePullInactivityTimeout } if cfg . ImageCleanupInterval < minimumImageCleanupInterval { seelog . Warnf ( "Invalid value for image cleanup duration, will be overridden with the default value: %s. Parsed value: %v, minimum value: %v." , DefaultImageCleanupTimeInterval . String ( ) , cfg . ImageCleanupInterval , minimumImageCleanupInterval ) cfg . ImageCleanupInterval = DefaultImageCleanupTimeInterval } if cfg . NumImagesToDeletePerCycle < minimumNumImagesToDeletePerCycle { seelog . Warnf ( "Invalid value for number of images to delete for image cleanup, will be overridden with the default value: %d. Parsed value: %d, minimum value: %d." , DefaultImageDeletionAge , cfg . NumImagesToDeletePerCycle , minimumNumImagesToDeletePerCycle ) cfg . NumImagesToDeletePerCycle = DefaultNumImagesToDeletePerCycle } if cfg . TaskMetadataSteadyStateRate <= 0 || cfg . TaskMetadataBurstRate <= 0 { seelog . Warnf ( "Invalid values for rate limits, will be overridden with default values: %d,%d." , DefaultTaskMetadataSteadyStateRate , DefaultTaskMetadataBurstRate ) cfg . TaskMetadataSteadyStateRate = DefaultTaskMetadataSteadyStateRate cfg . TaskMetadataBurstRate = DefaultTaskMetadataBurstRate } cfg . pollMetricsOverrides ( ) cfg . platformOverrides ( ) return nil }
3292	func ( d * Downtime ) GetRecurrence ( ) Recurrence { if d == nil || d . Recurrence == nil { return Recurrence { } } return * d . Recurrence }
5054	func ( bi * BuildInfo ) VersionAtLeast ( version ... int ) bool { for i := range version { if i == len ( bi . VersionArray ) { return false } if bi . VersionArray [ i ] < version [ i ] { return false } } return true }
1388	func ( m * MockCNIClient ) Capabilities ( arg0 string ) ( [ ] string , error ) { ret := m . ctrl . Call ( m , "Capabilities" , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1037	func SignalGoString ( s * os . Signal ) string { if s == nil { return "(*os.Signal)(nil)" } if * s == nil { return "<nil>" } return fmt . Sprintf ( "%q" , * s ) }
2826	func flattenDVSTrafficShapingPolicyIngress ( d * schema . ResourceData , obj * types . DVSTrafficShapingPolicy ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , "ingress_shaping_enabled" , obj . Enabled ) structure . SetLongPolicy ( d , "ingress_shaping_average_bandwidth" , obj . AverageBandwidth ) structure . SetLongPolicy ( d , "ingress_shaping_peak_bandwidth" , obj . PeakBandwidth ) structure . SetLongPolicy ( d , "ingress_shaping_burst_size" , obj . BurstSize ) return nil }
4914	func ( r * Reader ) ReadInt64 ( ) int64 { if r . err != nil { return 0 } var n int n , r . err = io . ReadFull ( r . rd , r . b [ : 8 ] ) r . cnt += n if r . err != nil { return 0 } return int64 ( binary . LittleEndian . Uint64 ( r . b [ : 8 ] ) ) }
4197	func ( c * UpdateSpaceConfigurationCommand ) Execute ( args [ ] string ) error { c . initConfig ( ) spaceConfig , err := c . ConfigManager . GetSpaceConfig ( c . OrgName , c . SpaceName ) if err != nil { return err } asgConfigs , err := c . ConfigManager . GetASGConfigs ( ) if err != nil { return err } if c . Quota . EnableSpaceQuota == "true" && c . NamedQuota != "" { return fmt . Errorf ( "cannot enable space quota and use named quotas" ) } errorString := "" convertToBool ( "enable-remove-users" , & spaceConfig . RemoveUsers , c . EnableRemoveUsers , & errorString ) convertToBool ( "enable-security-group" , & spaceConfig . EnableSecurityGroup , c . EnableSecurityGroup , & errorString ) convertToBool ( "enable-unassign-security-group" , & spaceConfig . EnableUnassignSecurityGroup , c . EnableUnassignSecurityGroup , & errorString ) if c . IsoSegment != "" { spaceConfig . IsoSegment = c . IsoSegment } if c . ClearIsolationSegment { spaceConfig . IsoSegment = "" } spaceConfig . ASGs = removeFromSlice ( addToSlice ( spaceConfig . ASGs , c . ASGs , & errorString ) , c . ASGsToRemove ) validateASGsExist ( asgConfigs , spaceConfig . ASGs , & errorString ) updateSpaceQuotaConfig ( spaceConfig , c . Quota , & errorString ) if c . NamedQuota != "" { spaceConfig . NamedQuota = c . NamedQuota } if c . ClearNamedQuota { spaceConfig . NamedQuota = "" } c . updateUsers ( spaceConfig , & errorString ) c . sshConfig ( spaceConfig , & errorString ) if errorString != "" { return errors . New ( errorString ) } if err := c . ConfigManager . SaveSpaceConfig ( spaceConfig ) ; err != nil { return err } fmt . Println ( fmt . Sprintf ( "The org/space [%s/%s] has been updated" , c . OrgName , c . SpaceName ) ) return nil }
3380	func ( i * IntegrationGCPUpdateRequest ) GetProjectIDOk ( ) ( string , bool ) { if i == nil || i . ProjectID == nil { return "" , false } return * i . ProjectID , true }
1910	func NewMockSSMClient ( ctrl * gomock . Controller ) * MockSSMClient { mock := & MockSSMClient { ctrl : ctrl } mock . recorder = & MockSSMClientMockRecorder { mock } return mock }
4125	func Get ( key string , value string ) string { gil . RLock ( ) defer gil . RUnlock ( ) if v , ok := env [ key ] ; ok { return v } return value }
4553	func New ( input string ) * Lexer { l := & Lexer { input : input , curLine : 1 } l . readChar ( ) return l }
3473	func ( r * reqComment ) GetComment ( ) Comment { if r == nil || r . Comment == nil { return Comment { } } return * r . Comment }
591	func GetLogEntry ( r * http . Request ) LogEntry { entry , _ := r . Context ( ) . Value ( LogEntryCtxKey ) . ( LogEntry ) return entry }
3319	func ( g * GraphDefinitionMarker ) GetVal ( ) json . Number { if g == nil || g . Val == nil { return "" } return * g . Val }
5862	func ( a * API ) FetchContactGroup ( cid CIDType ) ( * ContactGroup , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid contact group CID [none]" ) } groupCID := string ( * cid ) matched , err := regexp . MatchString ( config . ContactGroupCIDRegex , groupCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid contact group CID [%s]" , groupCID ) } result , err := a . Get ( groupCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch contact group, received JSON: %s" , string ( result ) ) } group := new ( ContactGroup ) if err := json . Unmarshal ( result , group ) ; err != nil { return nil , err } return group , nil }
1913	func NewMockFactory ( ctrl * gomock . Controller ) * MockFactory { mock := & MockFactory { ctrl : ctrl } mock . recorder = & MockFactoryMockRecorder { mock } return mock }
4644	func ( geoIndex * geoIndex ) AddEntryAt ( point Point ) interface { } { square := cellOf ( point , geoIndex . resolution ) if _ , ok := geoIndex . index [ square ] ; ! ok { geoIndex . index [ square ] = geoIndex . newEntry ( ) } return geoIndex . index [ square ] }
6539	func ( d * Dialer ) subDialerForAddr ( raddr ma . Multiaddr ) transport . Dialer { for _ , pd := range d . Dialers { if pd . Matches ( raddr ) { return pd } } if d . fallback . Matches ( raddr ) { return d . fallback } return nil }
6837	func ( d * Device ) PushSMS ( deviceIden , phoneNumber , message string ) error { return d . Client . PushSMS ( d . Iden , deviceIden , phoneNumber , message ) }
5655	func ( kb dbKeybase ) ExportPubKey ( name string ) ( armor string , err error ) { bz := kb . db . Get ( infoKey ( name ) ) if bz == nil { return "" , errors . New ( "No key to export with name " + name ) } info , err := readInfo ( bz ) if err != nil { return } return armorPubKeyBytes ( info . GetPubKey ( ) . Bytes ( ) ) , nil }
6213	func ( w * Worker ) ClientAfterChannelCreate ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientAfterChannelCreate" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientAfterChannelCreate ) if err != nil { return err } ethLog , err := w . ethLog ( logger , job ) if err != nil { return err } logger = logger . Add ( "channel" , ch , "ethLog" , ethLog ) ch . Block = uint32 ( ethLog . Block ) ch . ChannelStatus = data . ChannelActive if err = w . saveRecord ( logger , w . db . Querier , ch ) ; err != nil { return err } key , err := w . keyFromChannelData ( logger , ch . ID ) if err != nil { return err } logger = logger . Add ( "endpointKey" , key ) var endpointMsgSealed [ ] byte offering , err := w . offering ( logger , ch . Offering ) if err != nil { return err } if err == nil { client , err := w . somcClientBuilder . NewClient ( offering . SOMCType , offering . SOMCData ) if err != nil { logger . Error ( err . Error ( ) ) return ErrGetEndpoint } rawMsg , err := client . Endpoint ( key ) if err != nil { logger . Error ( err . Error ( ) ) return ErrGetEndpoint } endpointMsgSealed , err = data . ToBytes ( rawMsg ) if err != nil { logger . Error ( err . Error ( ) ) return ErrGetEndpoint } } err = w . addJobWithData ( logger , nil , data . JobClientEndpointRestore , data . JobChannel , ch . ID , & data . JobEndpointCreateData { EndpointSealed : endpointMsgSealed } ) if err != nil { return err } client , err := w . account ( logger , ch . Client ) if err != nil { return err } return w . addJob ( logger , nil , data . JobAccountUpdateBalances , data . JobAccount , client . ID ) }
7119	func ( c * Config ) Set ( sectionName , key , value string ) { for i , sect := range c . sections { if sect . name == sectionName { for j , opt := range sect . options { if opt . name == key { c . sections [ i ] . options [ j ] . value = value return } } c . sections [ i ] . options = append ( sect . options , option { key , value } ) return } } c . sections = append ( c . sections , section { name : sectionName , options : [ ] option { { key , value } } , } ) }
1847	func TaskMetadataHandler ( state dockerstate . TaskEngineState , ecsClient api . ECSClient , cluster , az , containerInstanceArn string , propagateTags bool ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 task metadata handler: unable to get task arn from request: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeTaskMetadata ) return } seelog . Infof ( "V3 task metadata handler: writing response for task '%s'" , taskARN ) taskResponse , err := v2 . NewTaskResponse ( taskARN , state , ecsClient , cluster , az , containerInstanceArn , propagateTags ) if err != nil { errResponseJSON , _ := json . Marshal ( "Unable to generate metadata for task: '" + taskARN + "'" ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskMetadata ) return } task , _ := state . TaskByArn ( taskARN ) if task . GetTaskENI ( ) == nil { responses := make ( [ ] v2 . ContainerResponse , 0 ) for _ , containerResponse := range taskResponse . Containers { networks , err := GetContainerNetworkMetadata ( containerResponse . ID , state ) if err != nil { errResponseJSON , _ := json . Marshal ( err . Error ( ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerMetadata ) return } containerResponse . Networks = networks responses = append ( responses , containerResponse ) } taskResponse . Containers = responses } responseJSON , _ := json . Marshal ( taskResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeTaskMetadata ) } }
3669	func ( w * Widget ) HasHTML ( ) bool { if w != nil && w . HTML != nil { return true } return false }
2207	func ( v * Action ) GetStateHint ( ) * Variant { c := C . g_action_get_state_hint ( v . native ( ) ) if c == nil { return nil } return newVariant ( ( * C . GVariant ) ( c ) ) }
1062	func acceptStatus ( list [ ] string , s string ) bool { for _ , status := range list { if status == s || status == HealthAny { return true } } return false }
6962	func ( s * Set ) Iterator ( ) Iterator { s . RLock ( ) defer s . RUnlock ( ) iterChan := make ( chan interface { } , len ( s . m ) ) for k := range s . m { iterChan <- k } close ( iterChan ) return IterFunc ( func ( ) ( interface { } , bool ) { value , ok := <- iterChan return value , ok } ) }
1334	func ( mr * MockHttpClientMockRecorder ) GetUserData ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "GetUserData" , reflect . TypeOf ( ( * MockHttpClient ) ( nil ) . GetUserData ) ) }
7199	func ( r * Route ) Patch ( pat string , f ... HandlerFunc ) { r . HandleMethod ( pat , "PATCH" , f ... ) }
4477	func ( d Duration ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( time . Duration ( d ) . String ( ) ) }
6312	func NewHandler ( factory ControllerFactoryFunc , methodName string ) ControllerHandler { handler := ControllerHandler { factory : factory , methodName : methodName } if ! handler . isValid ( ) { panic ( "Invalid handler: " + methodName ) } return handler }
81	func New ( db func ( ) * tsdb . DB , enableAdmin bool , ) * API { return & API { db : db , enableAdmin : enableAdmin , } }
3362	func ( i * IntegrationGCPCreateRequest ) HasAuthURI ( ) bool { if i != nil && i . AuthURI != nil { return true } return false }
3123	func ( rcv * PubSub ) Stat ( send helper . StatCallback ) { messagesReceived := atomic . LoadUint32 ( & rcv . messagesReceived ) send ( "messagesReceived" , float64 ( messagesReceived ) ) metricsReceived := atomic . LoadUint32 ( & rcv . metricsReceived ) send ( "metricsReceived" , float64 ( metricsReceived ) ) errors := atomic . LoadUint32 ( & rcv . errors ) send ( "errors" , float64 ( errors ) ) if ! rcv . statsAsCounters { atomic . AddUint32 ( & rcv . messagesReceived , - messagesReceived ) atomic . AddUint32 ( & rcv . metricsReceived , - metricsReceived ) atomic . AddUint32 ( & rcv . errors , - errors ) } }
219	func NewZookeeperTreeCache ( conn * zk . Conn , path string , events chan ZookeeperTreeCacheEvent , logger log . Logger ) * ZookeeperTreeCache { tc := & ZookeeperTreeCache { conn : conn , prefix : path , events : events , stop : make ( chan struct { } ) , logger : logger , } tc . head = & zookeeperTreeCacheNode { events : make ( chan zk . Event ) , children : map [ string ] * zookeeperTreeCacheNode { } , stopped : true , } go tc . loop ( path ) return tc }
6557	func NewCommand ( name string , args ... string ) * Command { return & Command { name : name , args : args , } }
3516	func ( s * SyntheticsConfig ) HasRequest ( ) bool { if s != nil && s . Request != nil { return true } return false }
2785	func schemaHostPortGroupSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { "name" : { Type : schema . TypeString , Required : true , Description : "The name of the port group." , ForceNew : true , } , "vlan_id" : { Type : schema . TypeInt , Optional : true , Description : "The VLAN ID/trunk mode for this port group. An ID of 0 denotes no tagging, an ID of 1-4094 tags with the specific ID, and an ID of 4095 enables trunk mode, allowing the guest to manage its own tagging." , Default : 0 , ValidateFunc : validation . IntBetween ( 0 , 4095 ) , } , "virtual_switch_name" : { Type : schema . TypeString , Required : true , Description : "The name of the virtual switch to bind this port group to." , ForceNew : true , } , } structure . MergeSchema ( s , schemaHostNetworkPolicy ( ) ) return s }
6363	func NewWriter ( out io . Writer ) * Writer { w := & Writer { printer : newPrinter ( out ) , } return w }
5265	func OptClientManualServerAddress ( enabled bool ) ClientOption { return func ( options * ClientOptions ) error { options . manualServerAddress = enabled return nil } }
4301	func ( v * veth ) attach ( n * configs . Network ) ( err error ) { bridge , err := net . InterfaceByName ( n . Bridge ) if err != nil { return err } host , err := net . InterfaceByName ( n . HostInterfaceName ) if err != nil { return err } if err := netlink . AddToBridge ( host , bridge ) ; err != nil { return err } if err := netlink . NetworkSetMTU ( host , n . Mtu ) ; err != nil { return err } if n . HairpinMode { if err := netlink . SetHairpinMode ( host , true ) ; err != nil { return err } } if err := netlink . NetworkLinkUp ( host ) ; err != nil { return err } return nil }
5734	func ( p * process ) doClose ( ) { close ( p . closing ) for len ( p . children ) > 0 || len ( p . waitfors ) > 0 { for plc , _ := range p . children { child := plc . Child ( ) if child != nil { go child . Close ( ) } plc . ParentClear ( ) } p . children = nil wf := p . waitfors p . waitfors = nil for w , _ := range wf { p . Unlock ( ) <- w . ChildClosed ( ) p . Lock ( ) w . ParentClear ( ) } } if p . teardown != nil { p . closeErr = p . teardown ( ) } close ( p . closed ) go func ( waiters [ ] * processLink ) { for _ , pl := range waiters { pl . ClearChild ( ) pr , ok := pl . Parent ( ) . ( * process ) if ! ok { continue } pr . Lock ( ) delete ( pr . waitfors , pl ) delete ( pr . children , pl ) pr . Unlock ( ) } } ( p . waiters ) p . waiters = nil }
6660	func NewVerifier ( opts * KeyOptions ) ( Verifier , error ) { publicKey := opts . KeyBytes if opts . KeyPath != "" { raw , err := ioutil . ReadFile ( opts . KeyPath ) if err != nil { return nil , err } publicKey = raw } block , _ := pem . Decode ( publicKey ) cert , err := x509 . ParseCertificate ( block . Bytes ) if err != nil { return nil , err } if cert . PublicKeyAlgorithm != x509 . RSA { return nil , fmt . Errorf ( "unsupported public key type" ) } return & rsaVerifier { publicKey : cert . PublicKey . ( * rsa . PublicKey ) , cert : cert } , nil }
5603	func ( o * AddVMParams ) WithBody ( body * models . VM ) * AddVMParams { o . SetBody ( body ) return o }
2941	func resourceVSphereDatastoreClusterGetPod ( d structure . ResourceIDStringer , meta interface { } ) ( * object . StoragePod , error ) { log . Printf ( "[DEBUG] %s: Fetching StoragePod object from resource ID" , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , err } return storagepod . FromID ( client , d . Id ( ) ) }
4290	func DeleteBridge ( name string ) error { s , err := getIfSocket ( ) if err != nil { return err } defer syscall . Close ( s ) nameBytePtr , err := syscall . BytePtrFromString ( name ) if err != nil { return err } var ifr ifreqFlags copy ( ifr . IfrnName [ : len ( ifr . IfrnName ) - 1 ] , [ ] byte ( name ) ) if _ , _ , err := syscall . Syscall ( syscall . SYS_IOCTL , uintptr ( s ) , syscall . SIOCSIFFLAGS , uintptr ( unsafe . Pointer ( & ifr ) ) ) ; err != 0 { return err } if _ , _ , err := syscall . Syscall ( syscall . SYS_IOCTL , uintptr ( s ) , SIOC_BRDELBR , uintptr ( unsafe . Pointer ( nameBytePtr ) ) ) ; err != 0 { return err } return nil }
5549	func Copy ( dst interface { } , src interface { } ) error { if dst == nil { return fmt . Errorf ( "dst cannot be nil" ) } if src == nil { return fmt . Errorf ( "src cannot be nil" ) } bytes , err := json . Marshal ( src ) if err != nil { return fmt . Errorf ( "Unable to marshal src: %s" , err ) } err = json . Unmarshal ( bytes , dst ) if err != nil { return fmt . Errorf ( "Unable to unmarshal into dst: %s" , err ) } return nil }
366	func ( a * Args ) AppendBytes ( dst [ ] byte ) [ ] byte { for i , n := 0 , len ( a . args ) ; i < n ; i ++ { kv := & a . args [ i ] dst = AppendQuotedArg ( dst , kv . key ) if ! kv . noValue { dst = append ( dst , '=' ) if len ( kv . value ) > 0 { dst = AppendQuotedArg ( dst , kv . value ) } } if i + 1 < n { dst = append ( dst , '&' ) } } return dst }
1103	func base64URLEncode ( s string ) ( string , error ) { return base64 . URLEncoding . EncodeToString ( [ ] byte ( s ) ) , nil }
3596	func ( t * TileDefRequest ) GetQueryTypeOk ( ) ( string , bool ) { if t == nil || t . QueryType == nil { return "" , false } return * t . QueryType , true }
4292	func DelFromBridge ( iface , master * net . Interface ) error { return ifIoctBridge ( iface , master , SIOC_BRDELIF ) }
5473	func ( c * QueueService ) Delete ( ctx context . Context , sid string ) error { return c . client . DeleteResource ( ctx , queuePathPart , sid ) }
5104	func ( b * Bulk ) Insert ( docs ... interface { } ) { b . inserts = append ( b . inserts , docs ... ) }
3203	func ( client * Client ) InviteUsers ( emails [ ] string ) error { return client . doJsonRequest ( "POST" , "/v1/invite_users" , reqInviteUsers { Emails : emails } , nil ) }
4742	func StringFindBetween ( s , start , stop string ) ( between , remainder string , found bool ) { begin := strings . Index ( s , start ) if begin == - 1 { return "" , s , false } between = s [ begin + len ( start ) : ] end := strings . Index ( between , stop ) if end == - 1 { return "" , s , false } return between [ : end ] , s [ begin + len ( start ) + end + len ( stop ) : ] , true }
2179	func ( v * Binding ) GetFlags ( ) BindingFlags { flags := C . g_binding_get_flags ( v . native ( ) ) return BindingFlags ( flags ) }
1798	func ( m * MockDockerClient ) ContainerEvents ( arg0 context . Context ) ( <- chan dockerapi . DockerContainerChangeEvent , error ) { ret := m . ctrl . Call ( m , "ContainerEvents" , arg0 ) ret0 , _ := ret [ 0 ] . ( <- chan dockerapi . DockerContainerChangeEvent ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
164	func computeExternalURL ( u , listenAddr string ) ( * url . URL , error ) { if u == "" { hostname , err := os . Hostname ( ) if err != nil { return nil , err } _ , port , err := net . SplitHostPort ( listenAddr ) if err != nil { return nil , err } u = fmt . Sprintf ( "http://%s:%s/" , hostname , port ) } if startsOrEndsWithQuote ( u ) { return nil , errors . New ( "URL must not begin or end with quotes" ) } eu , err := url . Parse ( u ) if err != nil { return nil , err } ppref := strings . TrimRight ( eu . Path , "/" ) if ppref != "" && ! strings . HasPrefix ( ppref , "/" ) { ppref = "/" + ppref } eu . Path = ppref return eu , nil }
3019	func validateDatastoreFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeDatastore { return nil , fmt . Errorf ( "%q is not a datastore folder" , folder . InventoryPath ) } return folder , nil }
4677	func ParseSource ( src * source , opts * Options ) ( * result , error ) { opts = InitializeOptions ( opts ) rslt := newResult ( nil , nil , nil ) base , err := parseBytes ( src . base . data , rslt , src , opts , src . base ) if err != nil { return nil , err } inner , err := parseBytes ( src . inner . data , rslt , src , opts , src . inner ) if err != nil { return nil , err } includes := make ( map [ string ] [ ] element ) for _ , f := range src . includes { includes [ f . path ] , err = parseBytes ( f . data , rslt , src , opts , f ) if err != nil { return nil , err } } rslt . base = base rslt . inner = inner rslt . includes = includes return rslt , nil }
6844	func ( c * Client ) PushSMS ( userIden , deviceIden , phoneNumber , message string ) error { data := Ephemeral { Type : "push" , Push : EphemeralPush { Type : "messaging_extension_reply" , PackageName : "com.pushbullet.android" , SourceUserIden : userIden , TargetDeviceIden : deviceIden , ConversationIden : phoneNumber , Message : message , } , } return c . Push ( "/ephemerals" , data ) }
3909	func yaml_emitter_initialize ( emitter * yaml_emitter_t ) { * emitter = yaml_emitter_t { buffer : make ( [ ] byte , output_buffer_size ) , raw_buffer : make ( [ ] byte , 0 , output_raw_buffer_size ) , states : make ( [ ] yaml_emitter_state_t , 0 , initial_stack_size ) , events : make ( [ ] yaml_event_t , 0 , initial_queue_size ) , } }
3403	func ( n * NoteDefinition ) HasBackgroundColor ( ) bool { if n != nil && n . BackgroundColor != nil { return true } return false }
883	func ( d * SerialDriver ) Remove ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Remove ( ) }
3505	func ( s * Series ) GetUnitsOk ( ) ( UnitPair , bool ) { if s == nil || s . Units == nil { return UnitPair { } , false } return * s . Units , true }
6408	func ( list * LinkedList ) Get ( pos uint ) ( interface { } , bool ) { list . key . RLock ( ) defer list . key . RUnlock ( ) node , ok := get ( list . first , pos ) if ok { return node . payload , true } return nil , false }
6975	func readMimetypes ( filename string ) ( map [ string ] string , error ) { mimetypes := make ( map [ string ] string ) data , err := ioutil . ReadFile ( filename ) if err != nil { return nil , err } for _ , line := range bytes . Split ( data , [ ] byte ( "\n" ) ) \n { fields := bytes . Fields ( line ) if len ( fields ) > 1 { for _ , ext := range fields [ 1 : ] { mimetypes [ string ( ext ) ] = string ( fields [ 0 ] ) } } } }
3870	func ( p * Package ) Type ( name string ) ( t * Type ) { t , _ = p . Members [ name ] . ( * Type ) return }
5377	func ParseFile ( name string ) ( * Config , error ) { file , err := os . Open ( name ) if err != nil { return nil , err } cfg := & Config { sync . RWMutex { } , make ( map [ string ] string ) , make ( [ ] byte , 0 ) , file . Name ( ) , } cfg . Lock ( ) defer cfg . Unlock ( ) defer file . Close ( ) gotSeparator := false s := NewScanner ( file ) for found := s . Scan ( ) ; found ; found = s . Scan ( ) { if found { k , v := s . Text ( ) cfg . data [ k ] = v if ! gotSeparator { cfg . separator = s . Separator ( ) gotSeparator = true } continue } else if s . Err ( ) != nil { return nil , err } } return cfg , nil }
1927	func ( agent * ecsAgent ) setVPCSubnet ( ) ( error , bool ) { mac , err := agent . ec2MetadataClient . PrimaryENIMAC ( ) if err != nil { return fmt . Errorf ( "unable to get mac address of instance's primary ENI from instance metadata: %v" , err ) , false } vpcID , err := agent . ec2MetadataClient . VPCID ( mac ) if err != nil { if isInstanceLaunchedInVPC ( err ) { return fmt . Errorf ( "unable to get vpc id from instance metadata: %v" , err ) , true } return instanceNotLaunchedInVPCError , false } subnetID , err := agent . ec2MetadataClient . SubnetID ( mac ) if err != nil { return fmt . Errorf ( "unable to get subnet id from instance metadata: %v" , err ) , false } agent . vpc = vpcID agent . subnet = subnetID agent . mac = mac return nil , false }
2764	func schemaVirtualMachineResourceAllocation ( ) map [ string ] * schema . Schema { s := make ( map [ string ] * schema . Schema ) shareLevelFmt := "The allocation level for %s resources. Can be one of high, low, normal, or custom." shareCountFmt := "The amount of shares to allocate to %s for a custom share level." limitFmt := "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources." reservationFmt := "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed." for _ , t := range virtualMachineResourceAllocationTypeValues { shareLevelKey := fmt . Sprintf ( "%s_share_level" , t ) shareCountKey := fmt . Sprintf ( "%s_share_count" , t ) limitKey := fmt . Sprintf ( "%s_limit" , t ) reservationKey := fmt . Sprintf ( "%s_reservation" , t ) s [ shareLevelKey ] = & schema . Schema { Type : schema . TypeString , Optional : true , Default : string ( types . SharesLevelNormal ) , Description : fmt . Sprintf ( shareLevelFmt , t ) , ValidateFunc : validation . StringInSlice ( sharesLevelAllowedValues , false ) , } s [ shareCountKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Computed : true , Description : fmt . Sprintf ( shareCountFmt , t ) , ValidateFunc : validation . IntAtLeast ( 0 ) , } s [ limitKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Default : - 1 , Description : fmt . Sprintf ( limitFmt , t ) , ValidateFunc : validation . IntAtLeast ( - 1 ) , } s [ reservationKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Description : fmt . Sprintf ( reservationFmt , t ) , ValidateFunc : validation . IntAtLeast ( 0 ) , } } return s }
2693	func CloneVM ( client * govmomi . Client , src * object . VirtualMachine , fo * object . Folder , name string , spec types . VirtualMachineCloneSpec , timeout int , pod * object . StoragePod , ) ( * object . VirtualMachine , error ) { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return nil , err } if ! sdrsEnabled { return nil , fmt . Errorf ( "storage DRS is not enabled on datastore cluster %q" , pod . Name ( ) ) } log . Printf ( "[DEBUG] Cloning virtual machine %q to %q on datastore cluster %q" , src . InventoryPath , fmt . Sprintf ( "%s/%s" , fo . InventoryPath , name ) , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Folder : types . NewReference ( fo . Reference ( ) ) , Vm : types . NewReference ( src . Reference ( ) ) , CloneName : name , CloneSpec : & spec , PodSelectionSpec : types . StorageDrsPodSelectionSpec { StoragePod : types . NewReference ( pod . Reference ( ) ) , } , Type : string ( types . StoragePlacementSpecPlacementTypeClone ) , } return recommendAndApplySDRS ( client , sps , time . Minute * time . Duration ( timeout ) ) }
2477	func ( i * images ) remove ( img * Image ) { i . makeStaleIfDependingOnImpl ( img ) delete ( i . images , img ) }
3709	func ( w * Widget ) GetParams ( ) Params { if w == nil || w . Params == nil { return Params { } } return * w . Params }
4729	func ( v Value ) Equal ( val interface { } ) bool { var str string var ok bool if str , ok = v . Data . ( string ) ; ! ok { return v . Data == val } if isRegex ( str ) { regex := regexp . MustCompile ( str [ 1 : len ( str ) - 1 ] ) valStr := fmt . Sprintf ( "%v" , val ) if regex . Match ( [ ] byte ( valStr ) ) { return true } } return fmt . Sprintf ( "%v" , v . Data ) == fmt . Sprintf ( "%v" , val ) }
2212	func SimpleActionNew ( name string , parameterType * VariantType ) * SimpleAction { c := C . g_simple_action_new ( ( * C . gchar ) ( C . CString ( name ) ) , parameterType . native ( ) ) if c == nil { return nil } return wrapSimpleAction ( wrapObject ( unsafe . Pointer ( c ) ) ) }
2604	func Create ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , spec types . DVPortgroupConfigSpec ) ( * object . Task , error ) { req := & types . CreateDVPortgroup_Task { This : dvs . Reference ( ) , Spec : spec , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) resp , err := methods . CreateDVPortgroup_Task ( ctx , client , req ) if err != nil { return nil , err } return object . NewTask ( client . Client , resp . Returnval . Reference ( ) ) , nil }
2545	func expandCustomizationSysprep ( d * schema . ResourceData ) * types . CustomizationSysprep { obj := & types . CustomizationSysprep { GuiUnattended : expandCustomizationGuiUnattended ( d ) , UserData : expandCustomizationUserData ( d ) , GuiRunOnce : expandCustomizationGuiRunOnce ( d ) , Identification : expandCustomizationIdentification ( d ) , } return obj }
1278	func GetDockerAuthFromASM ( secretID string , client secretsmanageriface . SecretsManagerAPI ) ( types . AuthConfig , error ) { in := & secretsmanager . GetSecretValueInput { SecretId : aws . String ( secretID ) , } out , err := client . GetSecretValue ( in ) if err != nil { return types . AuthConfig { } , errors . Wrapf ( err , "asm fetching secret from the service for %s" , secretID ) } return extractASMValue ( out ) }
5880	func buildEncArgs ( args [ ] string ) ( [ ] byte , error ) { m := make ( map [ string ] interface { } ) for _ , arg := range args { a := strings . SplitN ( arg , "=" , 2 ) var val interface { } if len ( a ) == 1 { val = true } else if u , err := strconv . ParseUint ( a [ 1 ] , 10 , 64 ) ; err == nil { val = u } else if i , err := strconv . ParseInt ( a [ 1 ] , 10 , 64 ) ; err == nil { val = i } else if f , err := strconv . ParseFloat ( a [ 1 ] , 64 ) ; err == nil { val = f } else if b , err := strconv . ParseBool ( a [ 1 ] ) ; err == nil { val = b } else if s , err := strconv . Unquote ( a [ 1 ] ) ; err == nil { val = s } else { val = a [ 1 ] } m [ a [ 0 ] ] = val } return json . Marshal ( m ) }
3652	func ( t * TriggeringValue ) GetToTs ( ) int { if t == nil || t . ToTs == nil { return 0 } return * t . ToTs }
1738	func ( task * Task ) SetExecutionRoleCredentialsID ( id string ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . ExecutionCredentialsID = id }
6135	func ( b * backendInstance ) PSCAddBalanceERC20 ( opts * bind . TransactOpts , amount uint64 ) ( * types . Transaction , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 tx , err := b . psc . AddBalanceERC20 ( opts , amount ) if err != nil { return nil , fmt . Errorf ( "failed to add ERC20 balance: %s" , err ) } return tx , nil }
328	func ( p * OpenMetricsParser ) Metric ( l * labels . Labels ) string { s := string ( p . series ) * l = append ( * l , labels . Label { Name : labels . MetricName , Value : s [ : p . offsets [ 0 ] - p . start ] , } ) for i := 1 ; i < len ( p . offsets ) ; i += 4 { a := p . offsets [ i ] - p . start b := p . offsets [ i + 1 ] - p . start c := p . offsets [ i + 2 ] - p . start d := p . offsets [ i + 3 ] - p . start if strings . IndexByte ( s [ c : d ] , byte ( '\\' ) ) >= 0 { * l = append ( * l , labels . Label { Name : s [ a : b ] , Value : lvalReplacer . Replace ( s [ c : d ] ) } ) continue } * l = append ( * l , labels . Label { Name : s [ a : b ] , Value : s [ c : d ] } ) } sort . Sort ( ( * l ) [ 1 : ] ) return s }
25	func Dedupe ( next log . Logger , repeat time . Duration ) * Deduper { d := & Deduper { next : next , repeat : repeat , quit : make ( chan struct { } ) , seen : map [ string ] time . Time { } , } go d . run ( ) return d }
4448	func ( h HexColor ) MarshalJSON ( ) ( [ ] byte , error ) { var w jwriter . Writer h . MarshalEasyJSON ( & w ) return w . BuildBytes ( ) }
2612	func FromID ( client * govmomi . Client , id string ) ( * object . VirtualApp , error ) { log . Printf ( "[DEBUG] Locating vApp container with ID %s" , id ) finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : "VirtualApp" , Value : id , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) obj , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , err } log . Printf ( "[DEBUG] vApp container found: %s" , obj . Reference ( ) . Value ) return obj . ( * object . VirtualApp ) , nil }
749	func getTargetsFromTargetAnnotation ( annotations map [ string ] string ) endpoint . Targets { var targets endpoint . Targets targetAnnotation , exists := annotations [ targetAnnotationKey ] if exists && targetAnnotation != "" { targetsList := strings . Split ( strings . Replace ( targetAnnotation , " " , "" , - 1 ) , "," ) for _ , targetHostname := range targetsList { targetHostname = strings . TrimSuffix ( targetHostname , "." ) targets = append ( targets , targetHostname ) } } return targets }
2172	func ( v * ListBox ) native ( ) * C . GtkListBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkListBox ( p ) }
2193	func sourceAttach ( src * C . struct__GSource , rf reflect . Value , args ... interface { } ) ( SourceHandle , error ) { if src == nil { return 0 , errNilPtr } if rf . Type ( ) . Kind ( ) != reflect . Func { C . g_source_destroy ( src ) return 0 , errors . New ( "rf is not a function" ) } var closure * C . GClosure closure , _ = ClosureNew ( rf . Interface ( ) , args ... ) C . _g_closure_add_finalize_notifier ( closure ) C . g_source_set_closure ( src , closure ) cid := C . g_source_attach ( src , nil ) return SourceHandle ( cid ) , nil }
4520	func ( f * FindFilter ) RunFilter ( arg Arg ) error { return filepath . Walk ( f . dir , func ( n string , s os . FileInfo , e error ) error { if e != nil { return e } if s . Mode ( ) . IsDir ( ) && f . skipdirif ( n ) { return filepath . SkipDir } if f . ifmode ( s . Mode ( ) ) { arg . Out <- n } return nil } ) }
3365	func ( i * IntegrationGCPCreateRequest ) HasClientID ( ) bool { if i != nil && i . ClientID != nil { return true } return false }
3231	func ( a * ApmOrLogQueryGroupBySort ) HasOrder ( ) bool { if a != nil && a . Order != nil { return true } return false }
3236	func ( b * Board ) GetIsReadOnlyOk ( ) ( bool , bool ) { if b == nil || b . IsReadOnly == nil { return false , false } return * b . IsReadOnly , true }
1708	func ( task * Task ) updateContainerVolumeDependency ( name string ) { for _ , container := range task . Containers { for _ , mountpoint := range container . MountPoints { if mountpoint . SourceVolume == name { container . BuildResourceDependency ( name , resourcestatus . ResourceCreated , apicontainerstatus . ContainerPulled ) } } } }
3497	func ( s * Series ) GetDisplayNameOk ( ) ( string , bool ) { if s == nil || s . DisplayName == nil { return "" , false } return * s . DisplayName , true }
1982	func ( m * MockClient ) ImagePull ( arg0 context . Context , arg1 string , arg2 types . ImagePullOptions ) ( io . ReadCloser , error ) { ret := m . ctrl . Call ( m , "ImagePull" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( io . ReadCloser ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3035	func WithUserAgent ( agent string ) Option { return func ( d * Discover ) error { d . userAgent = agent return nil } }
1750	func ( task * Task ) SetPullStartedAt ( timestamp time . Time ) bool { task . lock . Lock ( ) defer task . lock . Unlock ( ) if task . PullStartedAtUnsafe . IsZero ( ) { task . PullStartedAtUnsafe = timestamp return true } return false }
1881	func NewMockDockerStateResolver ( ctrl * gomock . Controller ) * MockDockerStateResolver { mock := & MockDockerStateResolver { ctrl : ctrl } mock . recorder = & MockDockerStateResolverMockRecorder { mock } return mock }
4587	func ( a * Args ) equal ( r * Args ) bool { if a . Elided != r . Elided || len ( a . Values ) != len ( r . Values ) { return false } for i , l := range a . Values { if l != r . Values [ i ] { return false } } return true }
2092	func ( m * MockCNI ) AddNetworkList ( arg0 * libcni . NetworkConfigList , arg1 * libcni . RuntimeConf ) ( types . Result , error ) { ret := m . ctrl . Call ( m , "AddNetworkList" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
4602	func ( s * Signature ) less ( r * Signature ) bool { if s . Stack . less ( & r . Stack ) { return true } if r . Stack . less ( & s . Stack ) { return false } if s . Locked && ! r . Locked { return true } if r . Locked && ! s . Locked { return false } if s . State < r . State { return true } if s . State > r . State { return false } return false }
2209	func ( v * Action ) GetStateType ( ) * VariantType { c := C . g_action_get_state_type ( v . native ( ) ) if c == nil { return nil } return newVariantType ( ( * C . GVariantType ) ( c ) ) }
5100	func ( id ObjectId ) MarshalJSON ( ) ( [ ] byte , error ) { return [ ] byte ( fmt . Sprintf ( `"%x"` , string ( id ) ) ) , nil }
6377	func ( iter Enumerator ) Merge ( others ... Enumerator ) Enumerator { retval := make ( chan interface { } ) var wg sync . WaitGroup wg . Add ( len ( others ) + 1 ) funnel := func ( prevResult Enumerator ) { for entry := range prevResult { retval <- entry } wg . Done ( ) } go funnel ( iter ) for _ , item := range others { go funnel ( item ) } go func ( ) { wg . Wait ( ) close ( retval ) } ( ) return retval }
2961	func getDatacenter ( c * govmomi . Client , dc string ) ( * object . Datacenter , error ) { finder := find . NewFinder ( c . Client , true ) t := c . ServiceContent . About . ApiType switch t { case "HostAgent" : return finder . DefaultDatacenter ( context . TODO ( ) ) case "VirtualCenter" : if dc != "" { return finder . Datacenter ( context . TODO ( ) , dc ) } return finder . DefaultDatacenter ( context . TODO ( ) ) } return nil , fmt . Errorf ( "unsupported ApiType: %s" , t ) }
3517	func ( s * SyntheticsDevice ) GetIsMobile ( ) bool { if s == nil || s . IsMobile == nil { return false } return * s . IsMobile }
5820	func ( cm * CheckManager ) fetchCheckBySubmissionURL ( submissionURL api . URLType ) ( * api . Check , error ) { if string ( submissionURL ) == "" { return nil , errors . New ( "[ERROR] Invalid submission URL (blank)" ) } u , err := url . Parse ( string ( submissionURL ) ) if err != nil { return nil , err } if ! strings . Contains ( u . Path , "/module/httptrap/" ) { return nil , fmt . Errorf ( "[ERROR] Invalid submission URL '%s', unrecognized path" , submissionURL ) } pathParts := strings . Split ( strings . Replace ( u . Path , "/module/httptrap/" , "" , 1 ) , "/" ) if len ( pathParts ) != 2 { return nil , fmt . Errorf ( "[ERROR] Invalid submission URL '%s', UUID not where expected" , submissionURL ) } uuid := pathParts [ 0 ] filter := api . SearchFilterType { "f__check_uuid" : [ ] string { uuid } } checks , err := cm . apih . SearchChecks ( nil , & filter ) if err != nil { return nil , err } if len ( * checks ) == 0 { return nil , fmt . Errorf ( "[ERROR] No checks found with UUID %s" , uuid ) } numActive := 0 checkID := - 1 for idx , check := range * checks { if check . Active { numActive ++ checkID = idx } } if numActive > 1 { return nil , fmt . Errorf ( "[ERROR] Multiple checks with same UUID %s" , uuid ) } check := ( * checks ) [ checkID ] return & check , nil }
5499	func NewNextPageIterator ( client * Client , nextPageURI string ) * PageIterator { if nextPageURI == "" { panic ( "nextpageuri is empty" ) } return & PageIterator { data : url . Values { } , client : client , nextPageURI : types . NullString { Valid : true , String : nextPageURI } , pathPart : "" , count : 0 , } }
2109	func heartbeatHandler ( timer * time . Timer ) func ( * ecstcs . HeartbeatMessage ) { return func ( * ecstcs . HeartbeatMessage ) { seelog . Debug ( "Received HeartbeatMessage from tcs" ) timer . Reset ( retry . AddJitter ( defaultHeartbeatTimeout , defaultHeartbeatJitter ) ) } }
2122	func ( v * ApplicationWindow ) native ( ) * C . GtkApplicationWindow { if v == nil || v . Window . GObject == nil { return nil } p := unsafe . Pointer ( v . Window . GObject ) return C . toGtkApplicationWindow ( p ) }
1812	func ( m * MockDockerClient ) RemoveImage ( arg0 context . Context , arg1 string , arg2 time . Duration ) error { ret := m . ctrl . Call ( m , "RemoveImage" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
2418	func square ( out [ ] int16 , volume float64 , freq float64 , sequence float64 ) { if freq == 0 { for i := 0 ; i < len ( out ) ; i ++ { out [ i ] = 0 } return } length := int ( float64 ( sampleRate ) / freq ) if length == 0 { panic ( "invalid freq" ) } for i := 0 ; i < len ( out ) ; i ++ { a := int16 ( volume * math . MaxInt16 ) if i % length < int ( float64 ( length ) * sequence ) { a = - a } out [ i ] = a } }
3190	func ( self * Client ) GetMonitorsByTags ( tags [ ] string ) ( [ ] Monitor , error ) { var out reqMonitors query , err := url . ParseQuery ( fmt . Sprintf ( "monitor_tags=%v" , strings . Join ( tags , "," ) ) ) if err != nil { return nil , err } err = self . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/monitor?%v" , query . Encode ( ) ) , nil , & out . Monitors ) if err != nil { return nil , err } return out . Monitors , nil }
4459	func ( r * Password ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { * r = Password ( data ) return nil } return errors . New ( "couldn't unmarshal bson raw value as Password" ) }
6361	func ( c * contextT ) With ( keyvals ... interface { } ) context . Context { return & contextT { ctx : newContext ( c . ctx , keyvals ) } }
4582	func ( f * Func ) String ( ) string { s , _ := url . QueryUnescape ( f . Raw ) return s }
737	func matchingNamespaces ( hostname string , namespaces [ ] * sd . NamespaceSummary ) [ ] * sd . NamespaceSummary { matchingNamespaces := make ( [ ] * sd . NamespaceSummary , 0 ) for _ , ns := range namespaces { if * ns . Name == hostname { matchingNamespaces = append ( matchingNamespaces , ns ) } } return matchingNamespaces }
4243	func BoundingBox ( hash string ) Box { bits := uint ( 5 * len ( hash ) ) inthash := base32encoding . Decode ( hash ) return BoundingBoxIntWithPrecision ( inthash , bits ) }
816	func ( a AzureClient ) cleanupResourceIfExists ( r cleanupResource ) error { f := r . LogFields ( ) log . Info ( fmt . Sprintf ( "Attempting to clean up %s resource..." , r . ResourceType ( ) ) , f ) err := r . Get ( a ) if exists , err := checkResourceExistsFromError ( err ) ; err != nil { return err } else if ! exists { log . Debug ( fmt . Sprintf ( "%s resource does not exist. Skipping." , r . ResourceType ( ) ) , f ) return nil } if ! r . HasAttachedResources ( ) { log . Debug ( fmt . Sprintf ( "%s does not have any attached dependent resource." , r . ResourceType ( ) ) , f ) log . Info ( fmt . Sprintf ( "Removing %s resource..." , r . ResourceType ( ) ) , f ) return r . Delete ( a ) } log . Info ( fmt . Sprintf ( "%s is still in use by other resources, skipping removal." , r . ResourceType ( ) ) , f ) return nil }
4785	func LoadWithEnvJSONBytes ( conf interface { } , src [ ] byte ) error { return loadConfigBytes ( conf , src , envReplacer , json . Unmarshal ) }
5629	func ( sp * SimpleProof ) Verify ( index int , total int , leafHash [ ] byte , rootHash [ ] byte ) bool { computedHash := computeHashFromAunts ( index , total , leafHash , sp . Aunts ) return computedHash != nil && bytes . Equal ( computedHash , rootHash ) }
3318	func ( g * GraphDefinition ) HasIncludeUngroupedHosts ( ) bool { if g != nil && g . IncludeUngroupedHosts != nil { return true } return false }
4210	func ( v * JWTValidator ) ValidateRequest ( r * http . Request ) ( * jwt . JSONWebToken , error ) { return v . validateRequestWithLeeway ( r , jwt . DefaultLeeway ) }
2161	func ( v * ActionMap ) LookupAction ( actionName string ) * Action { c := C . g_action_map_lookup_action ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) if c == nil { return nil } return wrapAction ( wrapObject ( unsafe . Pointer ( c ) ) ) }
4169	func classify ( desired [ ] cfclient . IsolationSegment , current [ ] cfclient . IsolationSegment ) classification { currentSegments := make ( map [ string ] * cfclient . IsolationSegment ) for i := range current { currentSegments [ current [ i ] . Name ] = & current [ i ] } desiredSegments := make ( map [ string ] * cfclient . IsolationSegment ) for i := range desired { desiredSegments [ desired [ i ] . Name ] = & desired [ i ] } var missing [ ] cfclient . IsolationSegment for name , seg := range desiredSegments { if _ , ok := currentSegments [ name ] ; ! ok { missing = append ( missing , * seg ) } } var extra [ ] cfclient . IsolationSegment for name , seg := range currentSegments { if _ , ok := desiredSegments [ name ] ; ! ok { extra = append ( extra , * seg ) } } return classification { missing , extra } }
6978	func GetFileSize ( filename string ) ( fileSize int64 ) { var ( fileInfo os . FileInfo err error file * os . File ) if file , err = os . Open ( filename ) ; err == nil { fileInfo , err = file . Stat ( ) fileSize = fileInfo . Size ( ) } else { fileSize = - 1 } return }
2827	func expandVMwareDVSPortSetting ( d * schema . ResourceData ) * types . VMwareDVSPortSetting { obj := & types . VMwareDVSPortSetting { DVPortSetting : types . DVPortSetting { Blocked : structure . GetBoolPolicy ( d , "block_all_ports" ) , InShapingPolicy : expandDVSTrafficShapingPolicyIngress ( d ) , OutShapingPolicy : expandDVSTrafficShapingPolicyEgress ( d ) , VmDirectPathGen2Allowed : structure . GetBoolPolicy ( d , "directpath_gen2_allowed" ) , } , Vlan : expandBaseVmwareDistributedVirtualSwitchVlanSpec ( d ) , UplinkTeamingPolicy : expandVmwareUplinkPortTeamingPolicy ( d ) , SecurityPolicy : expandDVSSecurityPolicy ( d ) , IpfixEnabled : structure . GetBoolPolicy ( d , "netflow_enabled" ) , TxUplink : structure . GetBoolPolicy ( d , "tx_uplink" ) , LacpPolicy : expandVMwareUplinkLacpPolicy ( d ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
6796	func MakeHub ( config HubConfig ) ( Hub , error ) { if config == nil { return NewHub ( ) , nil } driverName := getDriverName ( config ) if len ( driverName ) == 0 { return nil , fmt . Errorf ( "driver name is not specified" ) } d , ok := drivers [ driverName ] if ok { h , err := d . Create ( config ) if err != nil { log . Errorf ( "unable to connect to %s pubsub server: %+v" , driverName , err ) return nil , err } log . Info ( "connected to %s pubsub" , driverName ) return h , nil } return nil , fmt . Errorf ( "unknown driver: %s" , driverName ) }
5944	func ( r * BasicReporter ) PostEZValueTime ( statName , ezkey string , value float64 , timestamp int64 ) error { x := newEZStatValue ( statName , ezkey , value ) x . Timestamp = timestamp r . add ( x ) return nil }
5409	func AddUsersToGroup ( name string , members ... string ) error { if len ( members ) == 0 { return fmt . Errorf ( "no members to add" ) } for i , v := range members { if v == "" { return EmptyMemberError ( fmt . Sprintf ( "members[%s]" , strconv . Itoa ( i ) ) ) } } gr , err := LookupGroup ( name ) if err != nil { return err } if err = _addMembers ( & gr . UserList , members ... ) ; err != nil { return err } sg , err := LookupGShadow ( name ) if err != nil { return err } if err = _addMembers ( & sg . UserList , members ... ) ; err != nil { return err } if err = edit ( name , gr ) ; err != nil { return err } if err = edit ( name , sg ) ; err != nil { return err } return nil }
6054	func ( s * Server ) ListenAndServe ( ) error { if s . conf . TLS != nil { return s . httpsrv . ListenAndServeTLS ( s . conf . TLS . CertFile , s . conf . TLS . KeyFile ) } return s . httpsrv . ListenAndServe ( ) }
6008	func ( t Typed ) BoolIf ( key string ) ( bool , bool ) { value , exists := t [ key ] if exists == false { return false , false } if n , ok := value . ( bool ) ; ok { return n , true } return false , false }
7180	func ( s * SessionCache ) Set ( token string , value interface { } ) error { err := s . cache . Set ( token , value ) if err != nil { return s . getInvalidTokenError ( token ) } return nil }
1441	func ( state * DockerTaskEngineState ) AddTask ( task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) state . tasks [ task . Arn ] = task }
4752	func ( list ErrorList ) Last ( ) error { if len ( list ) == 0 { return nil } return list [ len ( list ) - 1 ] }
6599	func ( q * Query ) WaitTrigger ( event string ) * Query { q . headers = append ( q . headers , "WaitTrigger: " + event ) return q }
5376	func DelUser ( name string ) ( err error ) { err = del ( name , & User { } ) if err == nil { err = del ( name , & Shadow { } ) } return }
2554	func flattenHostVirtualSwitchBeaconConfig ( d * schema . ResourceData , obj * types . HostVirtualSwitchBeaconConfig ) error { d . Set ( "beacon_interval" , obj . Interval ) return nil }
4800	func bashScript ( gitSSHPath string , repo * Repo , params [ ] string ) [ ] byte { scriptTemplate := `#!/usr/bin/env {shell}mkdir -p ~/.ssh;touch ~/.ssh/known_hosts;ssh-keyscan -t rsa,dsa {repo_host} 2>&1 | sort -u - ~/.ssh/known_hosts > ~/.ssh/tmp_hosts;cat ~/.ssh/tmp_hosts | while read linedo grep -q "$line" ~/.ssh/known_hosts || echo $line >> ~/.ssh/known_hosts;done{git_ssh_path} -i {ssh_key_path} {ssh_params};` replacer := strings . NewReplacer ( "{shell}" , shell , "{repo_host}" , repo . Host , "{git_ssh_path}" , gitSSHPath , "{ssh_key_path}" , repo . KeyPath , "{ssh_params}" , strings . Join ( params , " " ) , ) return [ ] byte ( replacer . Replace ( scriptTemplate ) ) }
4895	func ( s * Session ) Prepare ( query string ) ( QueryType , uint64 , * ParameterFieldSet , * ResultFieldSet , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) if err := s . writeRequest ( mtPrepare , false , command ( query ) ) ; err != nil { return QtNone , 0 , nil , nil , err } var id uint64 var prmFieldSet * ParameterFieldSet var resultFieldSet * ResultFieldSet f := func ( p replyPart ) { switch p := p . ( type ) { case * statementID : p . id = & id case * parameterMetadata : prmFieldSet = newParameterFieldSet ( p . numArg ) p . prmFieldSet = prmFieldSet case * resultMetadata : resultFieldSet = newResultFieldSet ( p . numArg ) p . resultFieldSet = resultFieldSet } } if err := s . readReply ( f ) ; err != nil { return QtNone , 0 , nil , nil , err } return s . sh . functionCode . queryType ( ) , id , prmFieldSet , resultFieldSet , nil }
6291	func ( m * Marshaller ) MarshalRaw ( bs [ ] byte ) { if m . Error != nil { return } if len ( m . Data ) < m . offset + len ( bs ) { m . Error = io . ErrShortBuffer return } m . offset += copy ( m . Data [ m . offset : ] , bs ) }
7293	func ( tx Tx ) CopyFile ( path string , mode os . FileMode ) error { return errorsp . WithStacks ( tx . Tx . CopyFile ( path , mode ) ) }
630	func InMemoryInitZones ( zones [ ] string ) InMemoryOption { return func ( p * InMemoryProvider ) { for _ , z := range zones { if err := p . CreateZone ( z ) ; err != nil { log . Warnf ( "Unable to initialize zones for inmemory provider" ) } } } }
1084	func NewVaultTokenQuery ( token string ) ( * VaultTokenQuery , error ) { vaultSecret := & api . Secret { Auth : & api . SecretAuth { ClientToken : token , Renewable : true , LeaseDuration : 1 , } , } return & VaultTokenQuery { stopCh : make ( chan struct { } , 1 ) , vaultSecret : vaultSecret , secret : transformSecret ( vaultSecret ) , } , nil }
6743	func ( c * MConnection ) Send ( chID byte , msg interface { } ) bool { if ! c . IsRunning ( ) { return false } log . Debug ( "Send" , "channel" , chID , "conn" , c , "msg" , msg ) channel , ok := c . channelsIdx [ chID ] if ! ok { log . Error ( cmn . Fmt ( "Cannot send bytes, unknown channel %X" , chID ) ) return false } success := channel . sendBytes ( wire . BinaryBytes ( msg ) ) if success { select { case c . send <- struct { } { } : default : } } else { log . Warn ( "Send failed" , "channel" , chID , "conn" , c , "msg" , msg ) } return success }
4031	func ( p * ColorParser ) NextElement ( ) TextElement { if p . index >= len ( p . text ) { return TextElement { Type : ElemEndOfText } } if p . text [ p . index ] == '\n' { p . index ++ return TextElement { Type : ElemLineBreak } } if p . text [ p . index ] != '<' { p . index ++ return TextElement { Type : ElemPrintable , Ch : p . text [ p . index - 1 ] , Fg : p . currText , Bg : p . currBack } } attr , atype , ok := p . parseColor ( ) if ! ok { p . index ++ return TextElement { Type : ElemPrintable , Ch : p . text [ p . index - 1 ] , Fg : p . currText , Bg : p . currBack } } if atype == ElemBackColor { if attr == ColorDefault { p . currBack = p . defBack } else { p . currBack = attr } } else if atype == ElemTextColor { if attr == ColorDefault { p . currText = p . defText } else { p . currText = attr } } return TextElement { Type : atype , Fg : p . currText , Bg : p . currBack } }
5412	func Detect ( ) ( Distro , error ) { var id string var err error if _ , err = os . Stat ( "/etc/os-release" ) ; ! os . IsNotExist ( err ) { cfg , err := shconf . ParseFile ( "/etc/os-release" ) if err != nil { return 0 , err } if id , err = cfg . Get ( "ID" ) ; err != nil { return 0 , err } if v , found := idToDistro [ id ] ; found { return v , nil } } else if _ , err = os . Stat ( "/etc/centos-release" ) ; ! os . IsNotExist ( err ) { return CentOS , nil } else if _ , err = os . Stat ( "/etc/pclinuxos-release" ) ; ! os . IsNotExist ( err ) { return PCLinuxOS , nil } panic ( "Linux distribution unsopported" ) }
5598	func ( o * UpdateVMWithStateParams ) WithContext ( ctx context . Context ) * UpdateVMWithStateParams { o . SetContext ( ctx ) return o }
57	func NewMatcher ( t MatchType , n , v string ) ( * Matcher , error ) { m := & Matcher { Type : t , Name : n , Value : v , } if t == MatchRegexp || t == MatchNotRegexp { re , err := regexp . Compile ( "^(?:" + v + ")$" ) if err != nil { return nil , err } m . re = re } return m , nil }
6282	func ( i * Ipvs ) Save ( ) error { out , err := backendRun ( [ ] string { "ipvsadm" , "-S" , "-n" } ) if err != nil { return err } i . Services = make ( [ ] Service , 0 , 0 ) serviceStrings := strings . Split ( string ( out ) , "-A" ) for j := range serviceStrings { if serviceStrings [ j ] == "" { continue } serverStrings := strings . Split ( serviceStrings [ j ] , "-a" ) serviceString := serverStrings [ 0 ] serverStrings = serverStrings [ 1 : ] service := parseService ( serviceString ) for k := range serverStrings { server := parseServer ( serverStrings [ k ] ) service . Servers = append ( service . Servers , server ) } i . Services = append ( i . Services , service ) } return nil }
4969	func DerivePBKDF2 ( password , salt [ ] byte , iterationCount , keyBitLength int , h hash . Hash ) [ ] byte { prf := hmac . New ( func ( ) hash . Hash { return h } , password ) hLen := prf . Size ( ) dkLen := keyBitLength >> 3 l := int ( math . Ceil ( float64 ( dkLen ) / float64 ( hLen ) ) ) r := dkLen - ( l - 1 ) * hLen if dkLen > MaxInt { panic ( fmt . Sprintf ( "kdf.DerivePBKDF2: expects derived key size to be not more that (2^32-1) bits, but was requested %v bits." , keyBitLength ) ) } dk := make ( [ ] byte , 0 , dkLen ) for i := 0 ; i < l ; i ++ { t := f ( salt , iterationCount , i + 1 , prf ) if i == ( l - 1 ) { t = t [ : r ] } dk = append ( dk , t ... ) } return dk }
3351	func ( h * HostmapRequests ) HasFill ( ) bool { if h != nil && h . Fill != nil { return true } return false }
211	func NewWALWatcher ( logger log . Logger , name string , writer writeTo , walDir string ) * WALWatcher { if logger == nil { logger = log . NewNopLogger ( ) } return & WALWatcher { logger : logger , writer : writer , walDir : path . Join ( walDir , "wal" ) , name : name , quit : make ( chan struct { } ) , done : make ( chan struct { } ) , maxSegment : - 1 , } }
1519	func ( imageManager * dockerImageManager ) RemoveContainerReferenceFromImageState ( container * apicontainer . Container ) error { defer imageManager . saver . ForceSave ( ) imageManager . updateLock . RLock ( ) defer imageManager . updateLock . RUnlock ( ) if container . ImageID == "" { return fmt . Errorf ( "Invalid container reference: Empty image id" ) } imageState , ok := imageManager . getImageState ( container . ImageID ) if ! ok { return fmt . Errorf ( "Cannot find image state for the container to be removed" ) } return imageState . RemoveContainerReference ( container ) }
468	func ( req * Request ) BodyWriteTo ( w io . Writer ) error { if req . bodyStream != nil { _ , err := copyZeroAlloc ( w , req . bodyStream ) req . closeBodyStream ( ) return err } if req . onlyMultipartForm ( ) { return WriteMultipartForm ( w , req . multipartForm , req . multipartFormBoundary ) } _ , err := w . Write ( req . bodyBytes ( ) ) return err }
4043	func DrawHorizontalLine ( x , y , w int , r rune ) { x , y , w , _ = clip ( x , y , w , 1 ) if w == 0 { return } for i := x ; i < x + w ; i ++ { putCharUnsafe ( i , y , r ) } }
4217	func FromMultiple ( extractors ... RequestTokenExtractor ) RequestTokenExtractor { return RequestTokenExtractorFunc ( func ( r * http . Request ) ( * jwt . JSONWebToken , error ) { for _ , e := range extractors { token , err := e . Extract ( r ) if err == ErrTokenNotFound { continue } else if err != nil { return nil , err } return token , nil } return nil , ErrTokenNotFound } ) }
6712	func ( c * Client ) ApiClient ( identifier string ) ( * ApiClient , error ) { apiClient := new ( ApiClient ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/api_clients/" + identifier , nil , apiClient ) if err != nil { return nil , err } return apiClient , err }
4965	func Decode ( data string ) ( [ ] byte , error ) { data = strings . Replace ( data , "-" , "+" , - 1 ) data = strings . Replace ( data , "_" , "/" , - 1 ) switch ( len ( data ) % 4 ) { case 0 : case 2 : data += "==" case 3 : data += "=" } return base64 . StdEncoding . DecodeString ( data ) }
4891	func ( c * sessionConn ) Write ( b [ ] byte ) ( int , error ) { if err := c . conn . SetWriteDeadline ( time . Now ( ) . Add ( c . timeout ) ) ; err != nil { return 0 , err } n , err := c . conn . Write ( b ) if err != nil { errLogger . Printf ( "Connection write error local address %s remote address %s: %s" , c . conn . LocalAddr ( ) , c . conn . RemoteAddr ( ) , err ) c . isBad = true c . badError = err return n , driver . ErrBadConn } return n , nil }
2350	func EdgeFlag ( flag bool ) { C . glowEdgeFlag ( gpEdgeFlag , ( C . GLboolean ) ( boolToInt ( flag ) ) ) }
608	func init ( ) { render . Respond = func ( w http . ResponseWriter , r * http . Request , v interface { } ) { if err , ok := v . ( error ) ; ok { if _ , ok := r . Context ( ) . Value ( render . StatusCtxKey ) . ( int ) ; ! ok { w . WriteHeader ( 400 ) } fmt . Printf ( "Logging err: %s\n" , \n ) err . Error ( ) render . DefaultResponder ( w , r , render . M { "status" : "error" } ) } return } }
1260	func ( vol * VolumeResource ) KnownCreated ( ) bool { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . knownStatusUnsafe == resourcestatus . ResourceStatus ( VolumeCreated ) }
1450	func ( state * DockerTaskEngineState ) storeV3EndpointIDToTaskUnsafe ( v3EndpointID , taskARN string ) { state . v3EndpointIDToTask [ v3EndpointID ] = taskARN }
2950	func flattenStorageDrsPodConfigInfo ( d * schema . ResourceData , obj types . StorageDrsPodConfigInfo , version viapi . VSphereVersion ) error { attrs := map [ string ] interface { } { "sdrs_default_intra_vm_affinity" : obj . DefaultIntraVmAffinity , "sdrs_automation_level" : obj . DefaultVmBehavior , "sdrs_enabled" : obj . Enabled , "sdrs_io_load_balance_enabled" : obj . IoLoadBalanceEnabled , "sdrs_load_balance_interval" : obj . LoadBalanceInterval , } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( "error setting attribute %q: %s" , k , err ) } } if err := flattenStorageDrsIoLoadBalanceConfig ( d , obj . IoLoadBalanceConfig , version ) ; err != nil { return err } if err := flattenStorageDrsSpaceLoadBalanceConfig ( d , obj . SpaceLoadBalanceConfig , version ) ; err != nil { return err } if err := flattenStorageDrsOptionSpec ( d , obj . Option ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := flattenStorageDrsAutomationConfig ( d , obj . AutomationOverrides ) ; err != nil { return err } } return nil }
6232	func ( s * Server ) HandleFunc ( pattern string , handler HandlerFunc ) { s . Mux ( ) . HandleFunc ( pattern , func ( w http . ResponseWriter , r * http . Request ) { handler ( w , r , & Context { } ) } ) }
3880	func sanityCheck ( fn * Function , reporter io . Writer ) bool { if reporter == nil { reporter = os . Stderr } return ( & sanity { reporter : reporter } ) . checkFunction ( fn ) }
4987	func zpool ( arg ... string ) ( [ ] [ ] string , error ) { c := command { Command : "zpool" } return c . Run ( arg ... ) }
6898	func flush ( ) { if focus == nil { return } for y := 0 ; y < focus . y ; y ++ { for x := 0 ; x < focus . x ; x ++ { c := focus . getCell ( x , y ) if c == nil { continue } if ! c . dirty { continue } c . dirty = false termbox . SetCell ( x , y , c . Ch , c . Fg , c . Bg ) } } _ = termbox . Flush ( ) }
2155	func ( v * ButtonBox ) native ( ) * C . GtkButtonBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkButtonBox ( p ) }
456	func WriteGunzip ( w io . Writer , p [ ] byte ) ( int , error ) { r := & byteSliceReader { p } zr , err := acquireGzipReader ( r ) if err != nil { return 0 , err } n , err := copyZeroAlloc ( w , zr ) releaseGzipReader ( zr ) nn := int ( n ) if int64 ( nn ) != n { return 0 , fmt . Errorf ( "too much data gunzipped: %d" , n ) } return nn , err }
1	func ( q * query ) Exec ( ctx context . Context ) * Result { if span := opentracing . SpanFromContext ( ctx ) ; span != nil { span . SetTag ( queryTag , q . stmt . String ( ) ) } res , warnings , err := q . ng . exec ( ctx , q ) return & Result { Err : err , Value : res , Warnings : warnings } }
6393	func ( iter Enumerator ) Tee ( ) ( Enumerator , Enumerator ) { left , right := make ( chan interface { } ) , make ( chan interface { } ) go func ( ) { for entry := range iter { left <- entry right <- entry } close ( left ) close ( right ) } ( ) return left , right }
1087	func datacentersFunc ( b * Brain , used , missing * dep . Set ) func ( ignore ... bool ) ( [ ] string , error ) { return func ( i ... bool ) ( [ ] string , error ) { result := [ ] string { } var ignore bool switch len ( i ) { case 0 : ignore = false case 1 : ignore = i [ 0 ] default : return result , fmt . Errorf ( "datacenters: wrong number of arguments, expected 0 or 1" + ", but got %d" , len ( i ) ) } d , err := dep . NewCatalogDatacentersQuery ( ignore ) if err != nil { return result , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] string ) , nil } missing . Add ( d ) return result , nil } }
4705	func ( l * line ) isHelperMethod ( ) bool { return len ( l . tokens ) > 1 && l . tokens [ 0 ] == equal }
3370	func ( i * IntegrationGCPCreateRequest ) GetPrivateKey ( ) string { if i == nil || i . PrivateKey == nil { return "" } return * i . PrivateKey }
7284	func NewLocation ( host uuid . UUID , lp Profile ) ( * Location , error ) { l := new ( Location ) l . UUID , _ = uuid . V4 ( ) l . Active = true l . Host = host if err := mergo . MergeWithOverwrite ( & l . Profile , lp ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not set initial location profile" ) } if err := storage . Store ( l ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not write location to storage" ) } return l , nil }
6185	func ( h * Handler ) CreateProduct ( tkn string , product data . Product ) ( * string , error ) { logger := h . logger . Add ( "method" , "CreateProduct" , "product" , product ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } if product . ServiceEndpointAddress != nil && ! isValidSEAddress ( * product . ServiceEndpointAddress ) { return nil , ErrBadServiceEndpointAddress } product . ID = util . NewUUID ( ) if err := insert ( logger , h . db . Querier , & product ) ; err != nil { return nil , err } return & product . ID , nil }
5825	func ( cm * CheckManager ) RefreshTrap ( ) error { if cm . trapURL == "" { return nil } if time . Since ( cm . trapLastUpdate ) >= cm . trapMaxURLAge { return cm . ResetTrap ( ) } return nil }
2131	func ( v * VariantBuilder ) native ( ) * C . GVariantBuilder { if v == nil || v . GVariantBuilder == nil { return nil } p := unsafe . Pointer ( v . GVariantBuilder ) return C . toGVariantBuilder ( p ) }
6266	func ( l * reportLogger ) Printf ( format string , v ... interface { } ) { if l . logger != nil { l . logger . Debug ( fmt . Sprintf ( format , v ... ) ) } }
5475	func ( c * ConferenceService ) GetNextConferencesInRange ( start time . Time , end time . Time , nextPageURI string ) ConferencePageIterator { if nextPageURI == "" { panic ( "nextpageuri is empty" ) } iter := NewNextPageIterator ( c . client , conferencePathPart ) iter . SetNextPageURI ( types . NullString { Valid : true , String : nextPageURI } ) return & conferenceDateIterator { start : start , end : end , p : iter , } }
1446	func ( state * DockerTaskEngineState ) removeV3EndpointIDToTaskContainerUnsafe ( v3EndpointID string ) { if v3EndpointID != "" { delete ( state . v3EndpointIDToTask , v3EndpointID ) delete ( state . v3EndpointIDToDockerID , v3EndpointID ) } }
598	func ( n * node ) findRoute ( rctx * Context , method methodTyp , path string ) * node { nn := n search := path for t , nds := range nn . children { ntyp := nodeTyp ( t ) if len ( nds ) == 0 { continue } var xn * node xsearch := search var label byte if search != "" { label = search [ 0 ] } switch ntyp { case ntStatic : xn = nds . findEdge ( label ) if xn == nil || ! strings . HasPrefix ( xsearch , xn . prefix ) { continue } xsearch = xsearch [ len ( xn . prefix ) : ] case ntParam , ntRegexp : if xsearch == "" { continue } for idx := 0 ; idx < len ( nds ) ; idx ++ { xn = nds [ idx ] p := strings . IndexByte ( xsearch , xn . tail ) if p < 0 { if xn . tail == '/' { p = len ( xsearch ) } else { continue } } if ntyp == ntRegexp && xn . rex != nil { if xn . rex . Match ( [ ] byte ( xsearch [ : p ] ) ) == false { continue } } else if strings . IndexByte ( xsearch [ : p ] , '/' ) != - 1 { continue } rctx . routeParams . Values = append ( rctx . routeParams . Values , xsearch [ : p ] ) xsearch = xsearch [ p : ] break } default : rctx . routeParams . Values = append ( rctx . routeParams . Values , search ) xn = nds [ 0 ] xsearch = "" } if xn == nil { continue } if len ( xsearch ) == 0 { if xn . isLeaf ( ) { h , _ := xn . endpoints [ method ] if h != nil && h . handler != nil { rctx . routeParams . Keys = append ( rctx . routeParams . Keys , h . paramKeys ... ) return xn } rctx . methodNotAllowed = true } } fin := xn . findRoute ( rctx , method , xsearch ) if fin != nil { return fin } if xn . typ > ntStatic { if len ( rctx . routeParams . Values ) > 0 { rctx . routeParams . Values = rctx . routeParams . Values [ : len ( rctx . routeParams . Values ) - 1 ] } } } return nil }
2268	func ( v * ProgressBar ) native ( ) * C . GtkProgressBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkProgressBar ( p ) }
819	func ( d * Driver ) Start ( ) error { cs := d . client ( ) _ , err := cs . RequestWithContext ( context . TODO ( ) , & egoscale . StartVirtualMachine { ID : d . ID , } ) return err }
6445	func repl ( match string , t time . Time ) string { if match == "%%" { return "%" } formatFunc , ok := formats [ match ] if ok { return formatFunc ( t ) } return formatNanoForMatch ( match , t ) }
4047	func DrawRawTextVertical ( x , y int , text string ) { cx , cy , cw , ch := ClipRect ( ) if y >= cy + ch || x < cx || x >= cx + cw { return } length := xs . Len ( text ) if y + length < cy { return } if y < cy { text = xs . Slice ( text , cy - y , - 1 ) length = length - ( cy - y ) y = cy } text = CutText ( text , ch ) dy := 0 for _ , ch := range text { putCharUnsafe ( x , y + dy , ch ) dy ++ } }
3366	func ( i * IntegrationGCPCreateRequest ) GetClientX509CertURL ( ) string { if i == nil || i . ClientX509CertURL == nil { return "" } return * i . ClientX509CertURL }
6438	func ( l * List ) Length ( ) uint { l . key . RLock ( ) defer l . key . RUnlock ( ) return uint ( len ( l . underlyer ) ) }
5125	func ( h * windowsAnsiEventHandler ) executeLF ( ) error { handled , err := h . simulateLF ( false ) if err != nil { return err } if ! handled { pos , _ , err := h . getCurrentInfo ( ) if err != nil { return err } h . buffer . WriteByte ( ansiterm . ANSI_LINE_FEED ) if pos . X != 0 { if err := h . Flush ( ) ; err != nil { return err } h . logf ( "Resetting cursor position for LF without CR" ) if err := SetConsoleCursorPosition ( h . fd , pos ) ; err != nil { return err } } } return nil }
5614	func LoadCodec ( bank string ) ( codec * WordCodec , err error ) { words , err := loadBank ( bank ) if err != nil { return codec , err } return NewCodec ( words ) }
4221	func ( mkc * memoryKeyCacher ) Add ( keyID string , downloadedKeys [ ] jose . JSONWebKey ) ( * jose . JSONWebKey , error ) { var addingKey jose . JSONWebKey for _ , key := range downloadedKeys { if key . KeyID == keyID { addingKey = key } if mkc . maxCacheSize == - 1 { mkc . entries [ key . KeyID ] = keyCacherEntry { addedAt : time . Now ( ) , JSONWebKey : key , } } } if addingKey . Key != nil { if mkc . maxCacheSize != - 1 { mkc . entries [ addingKey . KeyID ] = keyCacherEntry { addedAt : time . Now ( ) , JSONWebKey : addingKey , } mkc . handleOverflow ( ) } return & addingKey , nil } return nil , ErrNoKeyFound }
5559	func ( lo * largeObject ) putPart ( part * part ) error { container := lo . container objectName := lo . objectName + "/" + lo . timestamp + "/" + fmt . Sprintf ( "%d" , part . PartNumber ) lo . logger . Debug ( swiftLargeObjectLogTag , "Upload Part: (" , container , objectName , part . len , fmt . Sprintf ( "%x" , part . contentMd5 ) , part . ETag , ")" ) if _ , err := part . r . Seek ( 0 , 0 ) ; err != nil { return err } headers , err := lo . c . ObjectPut ( container , objectName , part . r , true , "" , "" , nil ) if err != nil { return err } s := headers [ "Etag" ] if part . ETag != s { return fmt . Errorf ( "Response etag does not match. Remote:%s Calculated: %s" , s , part . ETag ) } return nil }
4796	func runCmdOutput ( command string , args [ ] string , dir string ) ( string , error ) { cmd := gos . Command ( command , args ... ) cmd . Dir ( dir ) var err error if output , err := cmd . Output ( ) ; err == nil { return string ( bytes . TrimSpace ( output ) ) , nil } return "" , err }
3218	func ( a * Alert ) GetSilenced ( ) bool { if a == nil || a . Silenced == nil { return false } return * a . Silenced }
7217	func ( logger * Logger ) AddHandler ( handler Handler ) { logger . lock . Lock ( ) logger . Handlers = append ( logger . Handlers , handler ) logger . flushBuffer ( ) logger . lock . Unlock ( ) }
6066	func Loop ( ctx context . Context , logger log . Logger , db * reform . DB , queue job . Queue , duration time . Duration , f func ( ) [ ] * data . Job ) { tik := time . NewTicker ( duration ) logger = logger . Add ( "method" , "Loop" ) go loop ( ctx , tik , db , queue , f , logger , nil ) }
2091	func ( m * MockCNI ) AddNetwork ( arg0 * libcni . NetworkConfig , arg1 * libcni . RuntimeConf ) ( types . Result , error ) { ret := m . ctrl . Call ( m , "AddNetwork" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6295	func ( m * Marshaller ) MarshalUint32 ( v uint32 ) { if m . Error != nil { return } if len ( m . Data ) < m . offset + 4 { m . Error = io . ErrShortBuffer return } m . Data [ m . offset + 0 ] = byte ( v >> 24 ) m . Data [ m . offset + 1 ] = byte ( v >> 16 ) m . Data [ m . offset + 2 ] = byte ( v >> 8 ) m . Data [ m . offset + 3 ] = byte ( v ) m . offset += 4 }
4525	func ReadLines ( reader io . Reader ) Filter { return FilterFunc ( func ( arg Arg ) error { return splitIntoLines ( reader , arg ) } ) }
4463	func ( t * DateTime ) UnmarshalText ( text [ ] byte ) error { tt , err := ParseDateTime ( string ( text ) ) if err != nil { return err } * t = tt return nil }
2419	func playNote ( scoreIndex int ) rune { note := score [ scoreIndex ] if note == 'R' { return rune ( note ) } freqs := [ ] float64 { freqC , freqD , freqE , freqF , freqG , freqA * 2 , freqB * 2 } freq := 0.0 switch { case 'A' <= note && note <= 'B' : freq = freqs [ int ( note ) + len ( freqs ) - int ( 'C' ) ] case 'C' <= note && note <= 'G' : freq = freqs [ note - 'C' ] default : panic ( "note out of range" ) } const vol = 1.0 / 16.0 size := ( ebiten . MaxTPS ( ) / 2 - 2 ) * sampleRate / ebiten . MaxTPS ( ) l := make ( [ ] int16 , size ) r := make ( [ ] int16 , size ) square ( l , vol , freq , 0.25 ) square ( r , vol , freq , 0.25 ) p , _ := audio . NewPlayerFromBytes ( audioContext , toBytes ( l , r ) ) p . Play ( ) return rune ( note ) }
4394	func ( id * ObjectId ) UnmarshalJSON ( data [ ] byte ) error { l := jlexer . Lexer { Data : data } id . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
5541	func ( c * Client ) Status ( s string ) { c . connection . Presence ( c . Id , s ) }
3385	func ( l * LogSet ) HasID ( ) bool { if l != nil && l . ID != nil { return true } return false }
2664	func flattenClusterFailoverResourcesAdmissionControlPolicy ( d * schema . ResourceData , obj * types . ClusterFailoverResourcesAdmissionControlPolicy , version viapi . VSphereVersion , ) error { if obj . AutoComputePercentages == nil || ! * obj . AutoComputePercentages { err := structure . SetBatch ( d , map [ string ] interface { } { "ha_admission_control_resource_percentage_cpu" : obj . CpuFailoverResourcesPercent , "ha_admission_control_resource_percentage_memory" : obj . MemoryFailoverResourcesPercent , } ) if err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return structure . SetBatch ( d , map [ string ] interface { } { "ha_admission_control_resource_percentage_auto_compute" : obj . AutoComputePercentages , "ha_admission_control_host_failure_tolerance" : obj . FailoverLevel , } ) } return nil }
7308	func ( m * MongoDb ) Drop ( ) error { err := m . db . DropDatabase ( ) if err != nil { return e . New ( err ) } m . db = m . session . DB ( m . dbname ) m . c = m . db . C ( m . collection ) return nil }
1098	func servicesFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( [ ] * dep . CatalogSnippet , error ) { return func ( s ... string ) ( [ ] * dep . CatalogSnippet , error ) { result := [ ] * dep . CatalogSnippet { } d , err := dep . NewCatalogServicesQuery ( strings . Join ( s , "" ) ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] * dep . CatalogSnippet ) , nil } missing . Add ( d ) return result , nil } }
2431	func newFramebufferFromTexture ( context * context , texture textureNative , width , height int ) ( * framebuffer , error ) { native , err := context . newFramebuffer ( texture ) if err != nil { return nil , err } return & framebuffer { native : native , width : width , height : height , } , nil }
5853	func ( m * CirconusMetrics ) RemoveCounterFunc ( metric string ) { m . cfm . Lock ( ) defer m . cfm . Unlock ( ) delete ( m . counterFuncs , metric ) }
3684	func ( w * Widget ) HasManageStatusTitleSize ( ) bool { if w != nil && w . ManageStatusTitleSize != nil { return true } return false }
5410	func DelUsersInGroup ( name string , members ... string ) error { if len ( members ) == 0 { return ErrNoMembers } for i , v := range members { if v == "" { return EmptyMemberError ( fmt . Sprintf ( "members[%s]" , strconv . Itoa ( i ) ) ) } } gr , err := LookupGroup ( name ) if err != nil { return err } if err = _delMembers ( & gr . UserList , members ... ) ; err != nil { return err } sg , err := LookupGShadow ( name ) if err != nil { return err } if err = _delMembers ( & sg . UserList , members ... ) ; err != nil { return err } if err = edit ( name , gr ) ; err != nil { return err } if err = edit ( name , sg ) ; err != nil { return err } return nil }
2025	func NewNamedError ( err error ) * DefaultNamedError { if namedErr , ok := err . ( NamedError ) ; ok { return & DefaultNamedError { Err : namedErr . Error ( ) , Name : namedErr . ErrorName ( ) } } return & DefaultNamedError { Err : err . Error ( ) } }
1745	func ( task * Task ) GetTaskENI ( ) * apieni . ENI { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ENI }
2187	func ( v * TreeView ) native ( ) * C . GtkTreeView { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeView ( p ) }
2410	func GamepadButtonPressDuration ( id int , button ebiten . GamepadButton ) int { theInputState . m . RLock ( ) s := 0 if _ , ok := theInputState . gamepadButtonDurations [ id ] ; ok { s = theInputState . gamepadButtonDurations [ id ] [ button ] } theInputState . m . RUnlock ( ) return s }
5902	func Claim ( name string , v interface { } ) Option { return func ( tok * Bearer ) error { if tok . claims == nil { return errors . New ( "attempting to add claim to improperly created token" ) } tok . claims [ name ] = v return nil } }
1112	func parseInt ( s string ) ( int64 , error ) { if s == "" { return 0 , nil } result , err := strconv . ParseInt ( s , 10 , 64 ) if err != nil { return 0 , errors . Wrap ( err , "parseInt" ) } return result , nil }
3	func NewEngine ( opts EngineOpts ) * Engine { if opts . Logger == nil { opts . Logger = log . NewNopLogger ( ) } metrics := & engineMetrics { currentQueries : prometheus . NewGauge ( prometheus . GaugeOpts { Namespace : namespace , Subsystem : subsystem , Name : "queries" , Help : "The current number of queries being executed or waiting." , } ) , maxConcurrentQueries : prometheus . NewGauge ( prometheus . GaugeOpts { Namespace : namespace , Subsystem : subsystem , Name : "queries_concurrent_max" , Help : "The max number of concurrent queries." , } ) , queryQueueTime : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : "query_duration_seconds" , Help : "Query timings" , ConstLabels : prometheus . Labels { "slice" : "queue_time" } , } ) , queryPrepareTime : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : "query_duration_seconds" , Help : "Query timings" , ConstLabels : prometheus . Labels { "slice" : "prepare_time" } , } ) , queryInnerEval : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : "query_duration_seconds" , Help : "Query timings" , ConstLabels : prometheus . Labels { "slice" : "inner_eval" } , } ) , queryResultSort : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : "query_duration_seconds" , Help : "Query timings" , ConstLabels : prometheus . Labels { "slice" : "result_sort" } , } ) , } metrics . maxConcurrentQueries . Set ( float64 ( opts . MaxConcurrent ) ) if opts . Reg != nil { opts . Reg . MustRegister ( metrics . currentQueries , metrics . maxConcurrentQueries , metrics . queryQueueTime , metrics . queryPrepareTime , metrics . queryInnerEval , metrics . queryResultSort , ) } return & Engine { gate : gate . New ( opts . MaxConcurrent ) , timeout : opts . Timeout , logger : opts . Logger , metrics : metrics , maxSamplesPerQuery : opts . MaxSamples , } }
469	func ( resp * Response ) BodyWriteTo ( w io . Writer ) error { if resp . bodyStream != nil { _ , err := copyZeroAlloc ( w , resp . bodyStream ) resp . closeBodyStream ( ) return err } _ , err := w . Write ( resp . bodyBytes ( ) ) return err }
1661	func ( m * MockTaskResource ) StatusString ( arg0 status0 . ResourceStatus ) string { ret := m . ctrl . Call ( m , "StatusString" , arg0 ) ret0 , _ := ret [ 0 ] . ( string ) return ret0 }
2882	func validateCloneSnapshots ( props * mo . VirtualMachine ) error { if props . Snapshot == nil { return fmt . Errorf ( "virtual machine or template %s must have a snapshot to be used as a linked clone" , props . Config . Uuid ) } if len ( props . Snapshot . RootSnapshotList ) != 1 { return fmt . Errorf ( "virtual machine or template %s must have exactly one root snapshot (has: %d)" , props . Config . Uuid , len ( props . Snapshot . RootSnapshotList ) ) } if len ( props . Snapshot . RootSnapshotList [ 0 ] . ChildSnapshotList ) > 0 { return fmt . Errorf ( "virtual machine or template %s's root snapshot must not have children" , props . Config . Uuid ) } if props . Snapshot . CurrentSnapshot . Value != props . Snapshot . RootSnapshotList [ 0 ] . Snapshot . Value { return fmt . Errorf ( "virtual machine or template %s's current snapshot must match root snapshot" , props . Config . Uuid ) } return nil }
1878	func ( c * control ) Init ( ) error { seelog . Infof ( "Creating root ecs cgroup: %s" , config . DefaultTaskCgroupPrefix ) cgroupSpec := & Spec { Root : config . DefaultTaskCgroupPrefix , Specs : & specs . LinuxResources { } , } _ , err := c . Create ( cgroupSpec ) return err }
2220	func ( v * CellRenderer ) native ( ) * C . GtkCellRenderer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRenderer ( p ) }
6957	func ( s * Set ) RemoveAll ( values ... interface { } ) { s . Lock ( ) defer s . Unlock ( ) for _ , value := range values { delete ( s . m , value ) } }
5540	func NewClientWithServerInfo ( user , pass , resource , authType , host , domain , conf string ) ( * Client , error ) { connection , err := xmpp . Dial ( host ) var b bytes . Buffer if err := xml . EscapeText ( & b , [ ] byte ( pass ) ) ; err != nil { return nil , err } c := & Client { AuthType : authType , Username : user , Password : b . String ( ) , Resource : resource , Id : user + "@" + domain , connection : connection , mentionNames : make ( map [ string ] string ) , receivedUsers : make ( chan [ ] * User ) , receivedRooms : make ( chan [ ] * Room ) , receivedMessage : make ( chan * Message ) , host : host , domain : domain , conf : conf , } if err != nil { return c , err } err = c . authenticate ( ) if err != nil { return c , err } go c . listen ( ) return c , nil }
6765	func NewNetAddressIPPort ( ip net . IP , port uint16 ) * NetAddress { na := & NetAddress { IP : ip , Port : port , str : net . JoinHostPort ( ip . String ( ) , strconv . FormatUint ( uint64 ( port ) , 10 ) , ) , } return na }
3538	func ( s * SyntheticsRequest ) GetBody ( ) string { if s == nil || s . Body == nil { return "" } return * s . Body }
1165	func newPayloadRequestHandler ( ctx context . Context , taskEngine engine . TaskEngine , ecsClient api . ECSClient , cluster string , containerInstanceArn string , acsClient wsclient . ClientServer , saver statemanager . Saver , refreshHandler refreshCredentialsHandler , credentialsManager credentials . Manager , taskHandler * eventhandler . TaskHandler ) payloadRequestHandler { derivedContext , cancel := context . WithCancel ( ctx ) return payloadRequestHandler { messageBuffer : make ( chan * ecsacs . PayloadMessage , payloadMessageBufferSize ) , ackRequest : make ( chan string , payloadMessageBufferSize ) , taskEngine : taskEngine , ecsClient : ecsClient , saver : saver , taskHandler : taskHandler , ctx : derivedContext , cancel : cancel , cluster : cluster , containerInstanceArn : containerInstanceArn , acsClient : acsClient , refreshHandler : refreshHandler , credentialsManager : credentialsManager , } }
5698	func MultipartForm ( formStruct interface { } , ifacePtr ... interface { } ) martini . Handler { return func ( context martini . Context , req * http . Request ) { var errors Errors ensureNotPointer ( formStruct ) formStruct := reflect . New ( reflect . TypeOf ( formStruct ) ) if req . MultipartForm == nil { if multipartReader , err := req . MultipartReader ( ) ; err != nil { errors . Add ( [ ] string { } , DeserializationError , err . Error ( ) ) } else { form , parseErr := multipartReader . ReadForm ( MaxMemory ) if parseErr != nil { errors . Add ( [ ] string { } , DeserializationError , parseErr . Error ( ) ) } req . MultipartForm = form } } mapForm ( formStruct , req . MultipartForm . Value , req . MultipartForm . File , errors ) validateAndMap ( formStruct , context , errors , ifacePtr ... ) } }
4682	func newHelperMethodConditionalComment ( ln * line , rslt * result , src * source , parent element , opts * Options ) ( * helperMethodConditionalComment , error ) { switch len ( ln . tokens ) { case 2 : return nil , fmt . Errorf ( "no comment type is specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) case 3 : return nil , fmt . Errorf ( "no condition is specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } commentType := ln . tokens [ 2 ] if commentType != commentTypeHidden && commentType != commentTypeRevealed { return nil , fmt . Errorf ( "the comment type is invalid [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } e := & helperMethodConditionalComment { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , commentType : commentType , condition : strings . Join ( ln . tokens [ 3 : ] , space ) , } return e , nil }
5193	func ( s * Schema ) Index ( name string , options ... IndexOption ) * Index { if index , ok := s . indexes [ name ] ; ok { return index } indexOptions := & IndexOptions { } indexOptions . addOptions ( options ... ) return s . indexWithOptions ( name , 0 , indexOptions ) }
1447	func ( state * DockerTaskEngineState ) RemoveImageState ( imageState * image . ImageState ) { if imageState == nil { log . Debug ( "Cannot remove empty image state" ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) imageState , ok := state . imageStates [ imageState . Image . ImageID ] if ! ok { log . Debug ( "Image State is not found. Cannot be removed" ) return } delete ( state . imageStates , imageState . Image . ImageID ) }
4367	func Must ( op Op , err error ) Op { if err != nil { panic ( fmt . Errorf ( "unable to parse selector; %v" , err . Error ( ) ) ) } return op }
6567	func ChangeContactModattr ( contact_name string , value string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_CONTACT_MODATTR" , stringifyArg ( "contact_name" , "string" , contact_name ) , stringifyArg ( "value" , "string" , value ) , ) }
4412	func ( e * Email ) UnmarshalJSON ( data [ ] byte ) error { l := jlexer . Lexer { Data : data } e . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
5702	func ( d * localeStore ) Get ( lang , section , format string ) ( string , bool ) { if locale , ok := d . store [ lang ] ; ok { if section == "" { section = goconfig . DEFAULT_SECTION } if value , err := locale . message . GetValue ( section , format ) ; err == nil { return value , true } } return "" , false }
3071	func ( ctx * Context ) RemoteAddr ( ) string { addr := ctx . Req . Header . Get ( "X-Real-IP" ) if len ( addr ) == 0 { addr = ctx . Req . Header . Get ( "X-Forwarded-For" ) if addr == "" { addr = ctx . Req . RemoteAddr if i := strings . LastIndex ( addr , ":" ) ; i > - 1 { addr = addr [ : i ] } } } return addr }
1506	func ( secret * ASMSecretResource ) Create ( ) error { executionCredentials , ok := secret . credentialsManager . GetTaskCredentials ( secret . getExecutionCredentialsID ( ) ) if ! ok { err := errors . New ( "ASM secret resource: unable to find execution role credentials" ) secret . setTerminalReason ( err . Error ( ) ) return err } iamCredentials := executionCredentials . GetIAMRoleCredentials ( ) var wg sync . WaitGroup errorEvents := make ( chan error , len ( secret . requiredSecrets ) ) seelog . Infof ( "ASM secret resource: retrieving secrets for containers in task: [%s]" , secret . taskARN ) secret . secretData = make ( map [ string ] string ) for _ , asmsecret := range secret . getRequiredSecrets ( ) { wg . Add ( 1 ) go secret . retrieveASMSecretValue ( asmsecret , iamCredentials , & wg , errorEvents ) } wg . Wait ( ) close ( errorEvents ) if len ( errorEvents ) > 0 { var terminalReasons [ ] string for err := range errorEvents { terminalReasons = append ( terminalReasons , err . Error ( ) ) } errorString := strings . Join ( terminalReasons , ";" ) secret . setTerminalReason ( errorString ) return errors . New ( errorString ) } return nil }
805	func removeOrphanDHCPServers ( vbox VBoxManager ) error { dhcps , err := listDHCPServers ( vbox ) if err != nil { return err } if len ( dhcps ) == 0 { return nil } log . Debug ( "Removing orphan DHCP servers..." ) nets , err := listHostOnlyAdapters ( vbox ) if err != nil { return err } for name := range dhcps { if strings . HasPrefix ( name , dhcpPrefix ) { if _ , present := nets [ name ] ; ! present { if err := vbox . vbm ( "dhcpserver" , "remove" , "--netname" , name ) ; err != nil { log . Warnf ( "Unable to remove orphan dhcp server %q: %s" , name , err ) } } } } return nil }
1890	func ( engine * DockerTaskEngine ) isTaskManaged ( arn string ) bool { engine . tasksLock . RLock ( ) defer engine . tasksLock . RUnlock ( ) _ , ok := engine . managedTasks [ arn ] return ok }
4209	func NewValidator ( config Configuration , extractor RequestTokenExtractor ) * JWTValidator { if extractor == nil { extractor = RequestTokenExtractorFunc ( FromHeader ) } return & JWTValidator { config , extractor } }
7221	func ( logger * Logger ) Logf ( level Level , format string , a ... interface { } ) { logger . log ( level , format , a ... ) }
3353	func ( h * HostmapRequests ) GetSizeOk ( ) ( HostmapRequest , bool ) { if h == nil || h . Size == nil { return HostmapRequest { } , false } return * h . Size , true }
6779	func Wrap ( h http . Handler , onPanic PanicHandler ) http . Handler { return & recoveryHandler { h : h , p : onPanic } }
2427	func ( g * GeoM ) Invert ( ) { det := g . det ( ) if det == 0 { panic ( "ebiten: g is not invertible" ) } a := ( g . d_1 + 1 ) / det b := - g . b / det c := - g . c / det d := ( g . a_1 + 1 ) / det tx := ( - ( g . d_1 + 1 ) * g . tx + g . b * g . ty ) / det ty := ( g . c * g . tx + - ( g . a_1 + 1 ) * g . ty ) / det g . a_1 = a - 1 g . b = b g . c = c g . d_1 = d - 1 g . tx = tx g . ty = ty }
2984	func diskRelocateListString ( relocators [ ] types . VirtualMachineRelocateSpecDiskLocator ) string { var out [ ] string for _ , relocate := range relocators { out = append ( out , diskRelocateString ( relocate ) ) } return strings . Join ( out , "," ) }
5445	func ( c * Call ) Ended ( ) bool { switch c . Status { case StatusCompleted , StatusCanceled , StatusFailed , StatusBusy , StatusNoAnswer : return true default : return false } }
1563	func ( me MultiErr ) Error ( ) string { ret := make ( [ ] string , len ( me . errors ) + 1 ) ret [ 0 ] = "Multiple error:" for ndx , err := range me . errors { ret [ ndx + 1 ] = fmt . Sprintf ( "\t%d: %s" , \t , ndx ) } err . Error ( ) }
4449	func ( h HexColor ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( h ) ) }
1195	func ( m * MockTime ) After ( arg0 time . Duration ) <- chan time . Time { ret := m . ctrl . Call ( m , "After" , arg0 ) ret0 , _ := ret [ 0 ] . ( <- chan time . Time ) return ret0 }
4397	func ( id * ObjectId ) DeepCopy ( ) * ObjectId { if id == nil { return nil } out := new ( ObjectId ) id . DeepCopyInto ( out ) return out }
2631	func AllFieldsEmpty ( v interface { } ) bool { if v == nil { return true } t := reflect . TypeOf ( v ) if t . Kind ( ) != reflect . Struct && ( t . Kind ( ) == reflect . Ptr && t . Elem ( ) . Kind ( ) != reflect . Struct ) { if reflect . Zero ( t ) . Interface ( ) != reflect . ValueOf ( v ) . Interface ( ) { return false } return true } if t . Kind ( ) == reflect . Ptr { t = t . Elem ( ) } for i := 0 ; i < t . NumField ( ) ; i ++ { var fv reflect . Value if reflect . ValueOf ( v ) . Kind ( ) == reflect . Ptr { fv = reflect . ValueOf ( v ) . Elem ( ) . Field ( i ) } else { fv = reflect . ValueOf ( v ) . Elem ( ) . Field ( i ) } ft := t . Field ( i ) . Type fz := reflect . Zero ( ft ) switch ft . Kind ( ) { case reflect . Map , reflect . Slice : if fv . Len ( ) > 0 { return false } default : if fz . Interface ( ) != fv . Interface ( ) { return false } } } return true }
4207	func NewConfiguration ( provider SecretProvider , audience [ ] string , issuer string , method jose . SignatureAlgorithm ) Configuration { return Configuration { secretProvider : provider , expectedClaims : jwt . Expected { Issuer : issuer , Audience : audience } , signIn : method , } }
5222	func ( f * Field ) ClearRow ( rowIDOrKey interface { } ) * PQLBaseQuery { rowStr , err := formatIDKeyBool ( rowIDOrKey ) if err != nil { return NewPQLBaseQuery ( "" , f . index , err ) } text := fmt . Sprintf ( "ClearRow(%s=%s)" , f . name , rowStr ) q := NewPQLBaseQuery ( text , f . index , nil ) return q }
4728	func ( l Lines ) Bytes ( ) [ ] byte { var lines [ ] [ ] byte for _ , line := range l { lines = append ( lines , line . Bytes ) } return bytes . Join ( lines , [ ] byte ( "\n" ) ) }
2153	func ( ps * PaperSize ) native ( ) * C . GtkPaperSize { if ps == nil { return nil } return ps . GtkPaperSize }
6350	func CacheControl ( maxage uint , delegate http . Handler ) http . Handler { return & cacheDecorator { delegate , maxage } }
5599	func ( o * UpdateVMWithStateParams ) WithBody ( body * models . VMState ) * UpdateVMWithStateParams { o . SetBody ( body ) return o }
1315	func ( m * MockFile ) Chmod ( arg0 os . FileMode ) error { ret := m . ctrl . Call ( m , "Chmod" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
5517	func ( m * Messenger ) DeleteGetStartedButton ( ) error { result , err := m . changeThreadSettings ( http . MethodDelete , & threadSettings { Type : settingTypeCallToActions , State : threadStateNew , } ) if err != nil { return err } if result . Result != "Successfully deleted all new_thread's CTAs" { return fmt . Errorf ( "Error occured while deleting get started button, invalid result: %s" , result . Result ) } return nil }
3039	func ( d * Discover ) Addrs ( cfg string , l * log . Logger ) ( [ ] string , error ) { d . once . Do ( d . initProviders ) args , err := Parse ( cfg ) if err != nil { return nil , fmt . Errorf ( "discover: %s" , err ) } name := args [ "provider" ] if name == "" { return nil , fmt . Errorf ( "discover: no provider" ) } providers := d . Providers if providers == nil { providers = Providers } p := providers [ name ] if p == nil { return nil , fmt . Errorf ( "discover: unknown provider " + name ) } l . Printf ( "[DEBUG] discover: Using provider %q" , name ) if typ , ok := p . ( ProviderWithUserAgent ) ; ok { typ . SetUserAgent ( d . userAgent ) return p . Addrs ( args , l ) } return p . Addrs ( args , l ) }
2318	func ( v * DeviceManager ) native ( ) * C . GdkDeviceManager { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDeviceManager ( p ) }
4791	func NewLongThen ( command string , args ... string ) Then { return & gitCmd { command : command , args : args , background : true , haltChan : make ( chan struct { } ) } }
2115	func ( v * ComboBox ) native ( ) * C . GtkComboBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkComboBox ( p ) }
5597	func ( o * UpdateVMWithStateParams ) WithTimeout ( timeout time . Duration ) * UpdateVMWithStateParams { o . SetTimeout ( timeout ) return o }
184	func ( r * AlertingRule ) forStateSample ( alert * Alert , ts time . Time , v float64 ) promql . Sample { lb := labels . NewBuilder ( r . labels ) for _ , l := range alert . Labels { lb . Set ( l . Name , l . Value ) } lb . Set ( labels . MetricName , alertForStateMetricName ) lb . Set ( labels . AlertName , r . name ) s := promql . Sample { Metric : lb . Labels ( ) , Point : promql . Point { T : timestamp . FromTime ( ts ) , V : v } , } return s }
6183	func ( h * Handler ) GetTemplates ( tkn , tplType string ) ( [ ] data . Template , error ) { logger := h . logger . Add ( "method" , "GetTemplates" , "type" , tplType ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } var templates [ ] reform . Struct var err error if tplType != "" { templates , err = h . selectAllFrom ( logger , data . TemplateTable , "WHERE kind = $1" , tplType ) } else { templates , err = h . selectAllFrom ( logger , data . TemplateTable , "" ) } if err != nil { return nil , err } result := make ( [ ] data . Template , 0 ) for _ , v := range templates { result = append ( result , * v . ( * data . Template ) ) } return result , nil }
4206	func NewKeyProvider ( key interface { } ) SecretProvider { return SecretProviderFunc ( func ( _ * http . Request ) ( interface { } , error ) { return key , nil } ) }
2182	func ( v * ActionGroup ) ChangeActionState ( actionName string , value * Variant ) { C . g_action_group_change_action_state ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) , value . native ( ) ) }
89	func ( te Expander ) Funcs ( fm text_template . FuncMap ) { for k , v := range fm { te . funcMap [ k ] = v } }
3004	func expandClusterVMHostRuleInfo ( d * schema . ResourceData ) ( * types . ClusterVmHostRuleInfo , error ) { obj := & types . ClusterVmHostRuleInfo { ClusterRuleInfo : types . ClusterRuleInfo { Enabled : structure . GetBool ( d , "enabled" ) , Mandatory : structure . GetBool ( d , "mandatory" ) , Name : d . Get ( "name" ) . ( string ) , UserCreated : structure . BoolPtr ( true ) , } , AffineHostGroupName : d . Get ( "affinity_host_group_name" ) . ( string ) , AntiAffineHostGroupName : d . Get ( "anti_affinity_host_group_name" ) . ( string ) , VmGroupName : d . Get ( "vm_group_name" ) . ( string ) , } return obj , nil }
7064	func SetErrorHandlerFunc ( status int , handler func ( ctx context . Context , w http . ResponseWriter , r * http . Request , status int , err error ) ) scaffold . Middleware { return SetErrorHandler ( status , ErrorHandlerFunc ( handler ) ) }
2475	func ( i * InfiniteLoop ) Read ( b [ ] byte ) ( int , error ) { if err := i . ensurePos ( ) ; err != nil { return 0 , err } if i . pos + int64 ( len ( b ) ) > i . length ( ) { b = b [ : i . length ( ) - i . pos ] } n , err := i . src . Read ( b ) i . pos += int64 ( n ) if i . pos > i . length ( ) { panic ( fmt . Sprintf ( "audio: position must be <= length but not at (*InfiniteLoop).Read: pos: %d, length: %d" , i . pos , i . length ( ) ) ) } if err != nil && err != io . EOF { return 0 , err } if err == io . EOF || i . pos == i . length ( ) { pos , err := i . Seek ( i . lstart , io . SeekStart ) if err != nil { return 0 , err } i . pos = pos } return n , nil }
111	func createAzureClient ( cfg SDConfig ) ( azureClient , error ) { env , err := azure . EnvironmentFromName ( cfg . Environment ) if err != nil { return azureClient { } , err } activeDirectoryEndpoint := env . ActiveDirectoryEndpoint resourceManagerEndpoint := env . ResourceManagerEndpoint var c azureClient var spt * adal . ServicePrincipalToken switch cfg . AuthenticationMethod { case authMethodManagedIdentity : msiEndpoint , err := adal . GetMSIVMEndpoint ( ) if err != nil { return azureClient { } , err } spt , err = adal . NewServicePrincipalTokenFromMSI ( msiEndpoint , resourceManagerEndpoint ) if err != nil { return azureClient { } , err } case authMethodOAuth : oauthConfig , err := adal . NewOAuthConfig ( activeDirectoryEndpoint , cfg . TenantID ) if err != nil { return azureClient { } , err } spt , err = adal . NewServicePrincipalToken ( * oauthConfig , cfg . ClientID , string ( cfg . ClientSecret ) , resourceManagerEndpoint ) if err != nil { return azureClient { } , err } } bearerAuthorizer := autorest . NewBearerAuthorizer ( spt ) c . vm = compute . NewVirtualMachinesClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . vm . Authorizer = bearerAuthorizer c . nic = network . NewInterfacesClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . nic . Authorizer = bearerAuthorizer c . vmss = compute . NewVirtualMachineScaleSetsClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . vmss . Authorizer = bearerAuthorizer c . vmssvm = compute . NewVirtualMachineScaleSetVMsClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . vmssvm . Authorizer = bearerAuthorizer return c , nil }
5960	func ( s Scan ) ToString ( ) ( out string ) { for _ , host := range s . Hosts { out += fmt . Sprintf ( "%s\n" , \n ) } host . ToString ( ) }
2915	func ( r * Subresource ) String ( ) string { devaddr := r . Get ( "device_address" ) . ( string ) if devaddr == "" { devaddr = "<new device>" } return fmt . Sprintf ( "%s (key %d at %s)" , r . Addr ( ) , r . Get ( "key" ) . ( int ) , devaddr ) }
3297	func ( d * Downtime ) HasTimezone ( ) bool { if d != nil && d . Timezone != nil { return true } return false }
2954	func flattenStorageDrsIoLoadBalanceConfig ( d * schema . ResourceData , obj * types . StorageDrsIoLoadBalanceConfig , version viapi . VSphereVersion , ) error { attrs := map [ string ] interface { } { "sdrs_io_latency_threshold" : obj . IoLatencyThreshold , "sdrs_io_load_imbalance_threshold" : obj . IoLoadImbalanceThreshold , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { attrs [ "sdrs_io_reservable_threshold_mode" ] = obj . ReservableThresholdMode if obj . ReservableThresholdMode == string ( types . StorageDrsPodConfigInfoBehaviorManual ) { attrs [ "sdrs_io_reservable_iops_threshold" ] = obj . ReservableIopsThreshold } else { attrs [ "sdrs_io_reservable_percent_threshold" ] = obj . ReservablePercentThreshold } } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( "error setting attribute %q: %s" , k , err ) } } return nil }
2616	func ResourceIDString ( d ResourceIDStringer , name string ) string { id := d . Id ( ) if id == "" { id = "<new resource>" } return fmt . Sprintf ( "%s (ID = %s)" , name , id ) }
6439	func ( l * List ) Remove ( pos uint ) ( interface { } , bool ) { l . key . Lock ( ) defer l . key . Unlock ( ) if pos > uint ( len ( l . underlyer ) ) { return nil , false } retval := l . underlyer [ pos ] l . underlyer = append ( l . underlyer [ : pos ] , l . underlyer [ pos + 1 : ] ... ) return retval , true }
66	func ( ls Labels ) Get ( name string ) string { for _ , l := range ls { if l . Name == name { return l . Value } } return "" }
3099	func ( l * Leaf ) URLPath ( pairs ... string ) string { if len ( pairs ) % 2 != 0 { panic ( "number of pairs does not match" ) } urlPath := l . rawPattern parent := l . parent for parent != nil { urlPath = parent . rawPattern + "/" + urlPath parent = parent . parent } for i := 0 ; i < len ( pairs ) ; i += 2 { if len ( pairs [ i ] ) == 0 { panic ( "pair value cannot be empty: " + com . ToStr ( i ) ) } else if pairs [ i ] [ 0 ] != ':' && pairs [ i ] != "*" && pairs [ i ] != "*.*" { pairs [ i ] = ":" + pairs [ i ] } urlPath = strings . Replace ( urlPath , pairs [ i ] , pairs [ i + 1 ] , 1 ) } return urlPath }
2078	func ( m * MockGPUManager ) SetDriverVersion ( arg0 string ) { m . ctrl . Call ( m , "SetDriverVersion" , arg0 ) }
5920	func ( it * Iterator ) SetMeta ( meta uint16 ) error { if meta > decodeMeta ( it . value ) { valOffset , valSize := decodeValue ( it . value ) new := encodeValue ( valOffset , valSize , meta ) return it . trySetValue ( new ) } return it . Set ( it . Value ( ) , meta ) }
2618	func SliceStringsToInterfaces ( s [ ] string ) [ ] interface { } { var d [ ] interface { } for _ , v := range s { d = append ( d , v ) } return d }
5992	func ( ds * DNSServer ) qualifySrv ( service , protocol string ) string { return fmt . Sprintf ( "_%s._%s.%s" , service , protocol , ds . Domain ) }
4051	func ( l * ListBox ) EnsureVisible ( ) { length := len ( l . items ) if length <= l . height || l . currSelection == - 1 { return } diff := l . currSelection - l . topLine if diff >= 0 && diff < l . height { return } if diff < 0 { l . topLine = l . currSelection } else { top := l . currSelection - l . height + 1 if length - top > l . height { l . topLine = top } else { l . topLine = length - l . height } } }
5312	func Contain ( filename string , b [ ] byte ) ( bool , error ) { f , err := os . Open ( filename ) if err != nil { return false , fmt . Errorf ( "Contain: %s" , err ) } defer f . Close ( ) buf := bufio . NewReader ( f ) for { line , err := buf . ReadBytes ( '\n' ) if err == io . EOF { break } if bytes . Contains ( line , b ) { return true , nil } } return false , nil }
5531	func NewLuaObjectFromName ( L * lua . State , subfields ... interface { } ) * LuaObject { L . GetGlobal ( "_G" ) defer L . Pop ( 1 ) err := get ( L , subfields ... ) if err != nil { return nil } val := NewLuaObject ( L , - 1 ) L . Pop ( 1 ) return val }
6915	func ( s * Session ) AssignChildren ( parent Identifiable , children [ ] Identifiable , identity Identity ) * Error { url , berr := s . getURLForChildrenIdentity ( parent , identity ) if berr != nil { return berr } var ids [ ] string for _ , c := range children { if i := c . Identifier ( ) ; i != "" { ids = append ( ids , c . Identifier ( ) ) } else { return NewBambouError ( "VSD Error" , "One of the object to assign has no ID" ) } } buffer := & bytes . Buffer { } json . NewEncoder ( buffer ) . Encode ( ids ) request , err := http . NewRequest ( "PUT" , url , buffer ) if err != nil { return NewBambouError ( "HTTP transaction error" , err . Error ( ) ) } response , berr := s . send ( request , nil ) if berr != nil { return berr } defer response . Body . Close ( ) return nil }
7134	func ( e * Entity ) encryptionKey ( now time . Time ) ( Key , bool ) { candidateSubkey := - 1 for i , subkey := range e . Subkeys { if subkey . Sig . FlagsValid && subkey . Sig . FlagEncryptCommunications && subkey . PublicKey . PubKeyAlgo . CanEncrypt ( ) && ! subkey . Sig . KeyExpired ( now ) { candidateSubkey = i break } } if candidateSubkey != - 1 { subkey := e . Subkeys [ candidateSubkey ] return Key { e , subkey . PublicKey , subkey . PrivateKey , subkey . Sig } , true } i := e . primaryIdentity ( ) if ! i . SelfSignature . FlagsValid || i . SelfSignature . FlagEncryptCommunications && e . PrimaryKey . PubKeyAlgo . CanEncrypt ( ) && ! i . SelfSignature . KeyExpired ( now ) { return Key { e , e . PrimaryKey , e . PrivateKey , i . SelfSignature } , true } return Key { } , false }
1245	func ( udevWatcher * UdevWatcher ) sendENIStateChangeWithRetries ( parentCtx context . Context , macAddress string , timeout time . Duration ) error { backoff := retry . NewExponentialBackoff ( sendENIStateChangeBackoffMin , sendENIStateChangeBackoffMax , sendENIStateChangeBackoffJitter , sendENIStateChangeBackoffMultiple ) ctx , cancel := context . WithTimeout ( parentCtx , timeout ) defer cancel ( ) err := retry . RetryWithBackoffCtx ( ctx , backoff , func ( ) error { sendErr := udevWatcher . sendENIStateChange ( macAddress ) if sendErr != nil { if _ , ok := sendErr . ( * unmanagedENIError ) ; ok { log . Debugf ( "Unable to send state change for unmanaged ENI: %v" , sendErr ) return sendErr } return apierrors . NewRetriableError ( apierrors . NewRetriable ( false ) , sendErr ) } return nil } ) if err != nil { return err } if err = ctx . Err ( ) ; err != nil { return errors . Wrapf ( err , "udev watcher send ENI state change: timed out waiting for eni '%s' in state" , macAddress ) } return nil }
5176	func TraceExternal ( ctx context . Context , host , name string ) * Trace { return trace ( ctx , name , func ( tx Tx ) error { return tx . StartExternal ( host , name ) } ) }
3176	func ( client * Client ) Snapshot ( query string , start , end time . Time , eventQuery string ) ( string , error ) { options := map [ string ] string { "metric_query" : query , "event_query" : eventQuery } return client . SnapshotGeneric ( options , start , end ) }
2491	func ( i * Image ) Dispose ( ) error { i . copyCheck ( ) if i . isDisposed ( ) { return nil } if i . isSubImage ( ) { return nil } i . mipmap . dispose ( ) i . resolvePendingPixels ( false ) return nil }
4424	func ( u * CIDR ) DeepCopy ( ) * CIDR { if u == nil { return nil } out := new ( CIDR ) u . DeepCopyInto ( out ) return out }
4531	func ( h * Hosts ) Remove ( ip string , hosts ... string ) error { var outputLines [ ] HostsLine if net . ParseIP ( ip ) == nil { return errors . New ( fmt . Sprintf ( "%q is an invalid IP address." , ip ) ) } for _ , line := range h . Lines { if line . Err != nil || line . IsComment ( ) || line . IP != ip { outputLines = append ( outputLines , line ) continue } var newHosts [ ] string for _ , checkHost := range line . Hosts { if ! itemInSlice ( checkHost , hosts ) { newHosts = append ( newHosts , checkHost ) } } if len ( newHosts ) > 0 { newLineRaw := line . IP for _ , host := range newHosts { newLineRaw = fmt . Sprintf ( "%s %s" , newLineRaw , host ) } newLine := NewHostsLine ( newLineRaw ) outputLines = append ( outputLines , newLine ) } } h . Lines = outputLines return nil }
3905	func ParseVerb ( f string ) ( Verb , int , error ) { if len ( f ) < 2 { return Verb { } , 0 , ErrInvalid } const ( flags = 1 width = 2 widthStar = 3 widthIndex = 5 dot = 6 prec = 7 precStar = 8 precIndex = 10 verbIndex = 11 verb = 12 ) m := re . FindStringSubmatch ( f ) if m == nil { return Verb { } , 0 , ErrInvalid } v := Verb { Letter : [ ] rune ( m [ verb ] ) [ 0 ] , Flags : m [ flags ] , Raw : m [ 0 ] , } if m [ width ] != "" { v . Width = Literal ( atoi ( m [ width ] ) ) } else if m [ widthStar ] != "" { if m [ widthIndex ] != "" { v . Width = Star { atoi ( m [ widthIndex ] ) } } else { v . Width = Star { - 1 } } } else { v . Width = Default { } } if m [ dot ] == "" { v . Precision = Default { } } else { if m [ prec ] != "" { v . Precision = Literal ( atoi ( m [ prec ] ) ) } else if m [ precStar ] != "" { if m [ precIndex ] != "" { v . Precision = Star { atoi ( m [ precIndex ] ) } } else { v . Precision = Star { - 1 } } } else { v . Precision = Zero { } } } if m [ verb ] == "%" { v . Value = 0 } else if m [ verbIndex ] != "" { v . Value = atoi ( m [ verbIndex ] ) } else { v . Value = - 1 } return v , len ( m [ 0 ] ) , nil }
770	func ( p designateProvider ) getZones ( ) ( map [ string ] string , error ) { result := map [ string ] string { } err := p . client . ForEachZone ( func ( zone * zones . Zone ) error { if zone . Type != "" && strings . ToUpper ( zone . Type ) != "PRIMARY" || zone . Status != "ACTIVE" { return nil } zoneName := canonicalizeDomainName ( zone . Name ) if ! p . domainFilter . Match ( zoneName ) { return nil } result [ zone . ID ] = zoneName return nil } , ) return result , err }
4276	func joinBlkio ( c * configs . Cgroup , pid int ) error { path , err := getSubsystemPath ( c , "blkio" ) if err != nil { return err } if c . BlkioWeightDevice != "" { if err := writeFile ( path , "blkio.weight_device" , c . BlkioWeightDevice ) ; err != nil { return err } } if c . BlkioThrottleReadBpsDevice != "" { if err := writeFile ( path , "blkio.throttle.read_bps_device" , c . BlkioThrottleReadBpsDevice ) ; err != nil { return err } } if c . BlkioThrottleWriteBpsDevice != "" { if err := writeFile ( path , "blkio.throttle.write_bps_device" , c . BlkioThrottleWriteBpsDevice ) ; err != nil { return err } } if c . BlkioThrottleReadIOpsDevice != "" { if err := writeFile ( path , "blkio.throttle.read_iops_device" , c . BlkioThrottleReadIOpsDevice ) ; err != nil { return err } } if c . BlkioThrottleWriteIOpsDevice != "" { if err := writeFile ( path , "blkio.throttle.write_iops_device" , c . BlkioThrottleWriteIOpsDevice ) ; err != nil { return err } } return nil }
3688	func ( w * Widget ) GetMonitor ( ) ScreenboardMonitor { if w == nil || w . Monitor == nil { return ScreenboardMonitor { } } return * w . Monitor }
6096	func ( h * Handler ) GetClientChannels ( tkn string , channelStatus , serviceStatus [ ] string , offset , limit uint ) ( * GetClientChannelsResult , error ) { logger := h . logger . Add ( "method" , "GetClientChannels" , "channelStatus" , channelStatus , "serviceStatus" , serviceStatus ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } chs , total , err := h . getChannels ( logger , channelStatus , serviceStatus , clientChannelsCondition , offset , limit ) if err != nil { return nil , err } items := make ( [ ] ClientChannelInfo , 0 ) for _ , channel := range chs { result , err := h . createClientChannelResult ( logger , & channel ) if err != nil { return nil , err } items = append ( items , * result ) } return & GetClientChannelsResult { items , total } , nil }
2525	func schemaHostNasVolumeSpec ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { "access_mode" : { Type : schema . TypeString , Default : hostNasVolumeAccessModeReadWrite , Description : "Access mode for the mount point. Can be one of readOnly or readWrite." , ForceNew : true , Optional : true , ValidateFunc : validation . StringInSlice ( [ ] string { hostNasVolumeAccessModeReadOnly , hostNasVolumeAccessModeReadWrite , } , false , ) , } , "remote_hosts" : { Type : schema . TypeList , Description : "The hostnames or IP addresses of the remote server or servers. Only one element should be present for NFS v3 but multiple can be present for NFS v4.1." , Elem : & schema . Schema { Type : schema . TypeString } , ForceNew : true , MinItems : 1 , Required : true , } , "remote_path" : { Type : schema . TypeString , Description : "The remote path of the mount point." , ForceNew : true , Required : true , } , "security_type" : { Type : schema . TypeString , Description : "The security type to use." , ForceNew : true , Optional : true , ValidateFunc : validation . StringInSlice ( [ ] string { hostNasVolumeSecurityTypeAuthSys , hostNasVolumeSecurityTypeSecKrb5 , hostNasVolumeSecurityTypeSecKrb5i , } , false , ) , } , "type" : { Type : schema . TypeString , Default : "NFS" , Description : "The type of NAS volume. Can be one of NFS (to denote v3) or NFS41 (to denote NFS v4.1)." , ForceNew : true , Optional : true , ValidateFunc : validation . StringInSlice ( [ ] string { string ( types . HostFileSystemVolumeFileSystemTypeNFS ) , string ( types . HostFileSystemVolumeFileSystemTypeNFS41 ) , } , false , ) , } , "protocol_endpoint" : { Type : schema . TypeString , Description : "Indicates that this NAS volume is a protocol endpoint. This field is only populated if the host supports virtual datastores." , Computed : true , } , } }
6494	func ( o OAuth ) CreateAuthorizeUrl ( scope [ ] string ) string { Url , _ := url . Parse ( "https://coinbase.com" ) Url . Path += "/oauth/authorize" parameters := url . Values { } parameters . Add ( "response_type" , "code" ) parameters . Add ( "client_id" , o . ClientId ) parameters . Add ( "redirect_uri" , o . RedirectUri ) parameters . Add ( "scope" , strings . Join ( scope , " " ) ) Url . RawQuery = parameters . Encode ( ) return Url . String ( ) }
1398	func ( manager * metadataManager ) Update ( ctx context . Context , dockerID string , task * apitask . Task , containerName string ) error { dockerContainer , err := manager . client . InspectContainer ( ctx , dockerID , dockerclient . InspectContainerTimeout ) if err != nil { return err } if dockerContainer == nil || ! dockerContainer . State . Running { return fmt . Errorf ( "container metadata update for container %s in task %s: container not running or invalid" , containerName , task . Arn ) } metadata := manager . parseMetadata ( dockerContainer , task , containerName ) return manager . marshalAndWrite ( metadata , task . Arn , containerName ) }
377	func ( a * Args ) SetBytesKV ( key , value [ ] byte ) { a . args = setArgBytes ( a . args , key , value , argsHasValue ) }
4200	func ( m * Manager ) ListServiceInfo ( ) ( * ServiceInfo , error ) { serviceInfo := & ServiceInfo { } services , err := m . Client . ListServices ( ) if err != nil { return nil , err } for _ , service := range services { plans , err := m . Client . ListServicePlansByQuery ( url . Values { "q" : [ ] string { fmt . Sprintf ( "%s:%s" , "service_guid" , service . Guid ) } , } ) if err != nil { return nil , err } for _ , plan := range plans { servicePlanInfo := serviceInfo . AddPlan ( service . Label , plan ) visibilities , err := m . Client . ListServicePlanVisibilitiesByQuery ( url . Values { "q" : [ ] string { fmt . Sprintf ( "%s:%s" , "service_plan_guid" , plan . Guid ) } , } ) if err != nil { return nil , err } for _ , visibility := range visibilities { servicePlanInfo . AddOrg ( visibility . OrganizationGuid , visibility ) } } } return serviceInfo , nil }
4599	func ( s * Signature ) equal ( r * Signature ) bool { if s . State != r . State || ! s . CreatedBy . equal ( & r . CreatedBy ) || s . Locked != r . Locked || s . SleepMin != r . SleepMin || s . SleepMax != r . SleepMax { return false } return s . Stack . equal ( & r . Stack ) }
1729	func ( task * Task ) shouldOverridePIDMode ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer ) ( bool , string ) { if container . IsInternal ( ) { return false , "" } switch task . getPIDMode ( ) { case pidModeHost : return true , pidModeHost case pidModeTask : pauseCont , ok := task . ContainerByName ( NamespacePauseContainerName ) if ! ok { seelog . Criticalf ( "Namespace Pause container not found in the task: %s; Setting Task's Desired Status to Stopped" , task . Arn ) task . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false , "" } pauseDockerID , ok := dockerContainerMap [ pauseCont . Name ] if ! ok || pauseDockerID == nil { seelog . Criticalf ( "Namespace Pause docker container not found in the task: %s; Setting Task's Desired Status to Stopped" , task . Arn ) task . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false , "" } return true , dockerMappingContainerPrefix + pauseDockerID . DockerID default : return false , "" } }
2111	func ackPublishHealthMetricHandler ( timer * time . Timer ) func ( * ecstcs . AckPublishHealth ) { return func ( * ecstcs . AckPublishHealth ) { seelog . Debug ( "Received ACKPublishHealth from tcs" ) timer . Reset ( retry . AddJitter ( defaultHeartbeatTimeout , defaultHeartbeatJitter ) ) } }
4417	func ( h * Hostname ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { * h = Hostname ( data ) return nil } return errors . New ( "couldn't unmarshal bson raw value as Hostname" ) }
4270	func ( p * Process ) NewConsole ( rootuid int ) ( Console , error ) { console , err := newConsole ( rootuid , rootuid ) if err != nil { return nil , err } p . consolePath = console . Path ( ) return console , nil }
5246	func ( c * Client ) EnsureIndex ( index * Index ) error { err := c . CreateIndex ( index ) if err == ErrIndexExists { return nil } return err }
1623	func ( m * MockSecretsManagerAPI ) UpdateSecretVersionStageRequest ( arg0 * secretsmanager . UpdateSecretVersionStageInput ) ( * request . Request , * secretsmanager . UpdateSecretVersionStageOutput ) { ret := m . ctrl . Call ( m , "UpdateSecretVersionStageRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . UpdateSecretVersionStageOutput ) return ret0 , ret1 }
1193	func ( retrier * oneDayRetrier ) RetryRules ( r * request . Request ) time . Duration { if r . RetryCount <= submitStateChangeInitialRetries { delay := int ( math . Pow ( 2 , float64 ( r . RetryCount ) ) ) * ( rand . Intn ( 30 ) + 30 ) return time . Duration ( delay ) * time . Millisecond } return 5 * time . Minute }
638	func ( sc * ingressSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { ingresses , err := sc . ingressInformer . Lister ( ) . Ingresses ( sc . namespace ) . List ( labels . Everything ( ) ) if err != nil { return nil , err } ingresses , err = sc . filterByAnnotations ( ingresses ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , ing := range ingresses { controller , ok := ing . Annotations [ controllerAnnotationKey ] if ok && controller != controllerAnnotationValue { log . Debugf ( "Skipping ingress %s/%s because controller value does not match, found: %s, required: %s" , ing . Namespace , ing . Name , controller , controllerAnnotationValue ) continue } ingEndpoints := endpointsFromIngress ( ing , sc . ignoreHostnameAnnotation ) if ( sc . combineFQDNAnnotation || len ( ingEndpoints ) == 0 ) && sc . fqdnTemplate != nil { iEndpoints , err := sc . endpointsFromTemplate ( ing ) if err != nil { return nil , err } if sc . combineFQDNAnnotation { ingEndpoints = append ( ingEndpoints , iEndpoints ... ) } else { ingEndpoints = iEndpoints } } if len ( ingEndpoints ) == 0 { log . Debugf ( "No endpoints could be generated from ingress %s/%s" , ing . Namespace , ing . Name ) continue } log . Debugf ( "Endpoints generated from ingress: %s/%s: %v" , ing . Namespace , ing . Name , ingEndpoints ) sc . setResourceLabel ( ing , ingEndpoints ) endpoints = append ( endpoints , ingEndpoints ... ) } for _ , ep := range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil }
165	func sendAlerts ( s sender , externalURL string ) rules . NotifyFunc { return func ( ctx context . Context , expr string , alerts ... * rules . Alert ) { var res [ ] * notifier . Alert for _ , alert := range alerts { a := & notifier . Alert { StartsAt : alert . FiredAt , Labels : alert . Labels , Annotations : alert . Annotations , GeneratorURL : externalURL + strutil . TableLinkForExpression ( expr ) , } if ! alert . ResolvedAt . IsZero ( ) { a . EndsAt = alert . ResolvedAt } else { a . EndsAt = alert . ValidUntil } res = append ( res , a ) } if len ( alerts ) > 0 { s . Send ( res ... ) } } }
6034	func AutoOfferingPopUp ( logger log . Logger , abi abi . ABI , db * reform . DB , ethBack eth . Backend , timeNowFunc func ( ) time . Time , period uint ) [ ] * data . Job { logger = logger . Add ( "method" , "AutoOfferingPopUp" ) do , err := data . ReadBoolSetting ( db . Querier , data . SettingOfferingAutoPopUp ) if err != nil { logger . Warn ( err . Error ( ) ) } var jobs [ ] * data . Job if do { jobs = autoOfferingPopUp ( logger , abi , db , ethBack , timeNowFunc , period ) logger . Debug ( fmt . Sprintf ( "found %d offerings to pop upped" , len ( jobs ) ) ) } return jobs }
1047	func NewVaultAgentTokenQuery ( path string ) ( * VaultAgentTokenQuery , error ) { return & VaultAgentTokenQuery { stopCh : make ( chan struct { } , 1 ) , path : path , } , nil }
4086	func ( c * CheckBox ) ProcessEvent ( event Event ) bool { if ( ! c . Active ( ) && event . Type == EventKey ) || ! c . Enabled ( ) { return false } if ( event . Type == EventKey && event . Key == term . KeySpace ) || ( event . Type == EventClick ) { if c . state == 0 { c . SetState ( 1 ) } else if c . state == 2 { c . SetState ( 0 ) } else { if c . allow3state { c . SetState ( 2 ) } else { c . SetState ( 0 ) } } return true } return false }
4940	func ( c * Connector ) Timeout ( ) int { c . mu . RLock ( ) defer c . mu . RUnlock ( ) return c . timeout }
7241	func MergeRoutes ( r ... Routable ) Routes { routes := make ( Routes , 0 ) for _ , v := range r { routes = append ( routes , v . Routes ( ) ... ) } return routes }
2536	func resourceVSphereComputeClusterHostGroupFetchObjects ( meta interface { } , clusterID string , name string , ) ( * object . ClusterComputeResource , string , error ) { client , err := resourceVSphereComputeClusterHostGroupClient ( meta ) if err != nil { return nil , "" , err } cluster , err := clustercomputeresource . FromID ( client , clusterID ) if err != nil { return nil , "" , fmt . Errorf ( "cannot locate cluster: %s" , err ) } return cluster , name , nil }
4685	func ( e * elementBase ) AppendChild ( child element ) { e . children = append ( e . children , child ) }
4668	func NewFile ( path string , data [ ] byte ) * File { return & File { path : path , data : data , } }
3798	func ( c * Conn ) Reply ( ctx context . Context , id ID , result interface { } ) error { resp := & Response { ID : id } if err := resp . SetResult ( result ) ; err != nil { return err } _ , err := c . send ( ctx , & anyMessage { response : resp } , false ) return err }
4827	func ( g GitOS ) ReadDir ( dirname string ) ( [ ] os . FileInfo , error ) { return ioutil . ReadDir ( dirname ) }
1210	func ( dg * dockerGoClient ) ContainerEvents ( ctx context . Context ) ( <- chan DockerContainerChangeEvent , error ) { client , err := dg . sdkDockerClient ( ) if err != nil { return nil , err } events := make ( chan * events . Message ) buffer := NewInfiniteBuffer ( ) derivedCtx , cancel := context . WithCancel ( ctx ) dockerEvents , eventErr := client . Events ( derivedCtx , types . EventsOptions { } ) go buffer . StartListening ( derivedCtx , dockerEvents ) go func ( ) { for { select { case err := <- eventErr : if err == io . EOF || err == io . ErrUnexpectedEOF { seelog . Info ( "DockerGoClient: All events have been received" ) cancel ( ) return } else { seelog . Errorf ( "DockerGoClient: error while listening to Docker Events : %v" , err ) nextCtx , nextCancel := context . WithCancel ( ctx ) dockerEvents , eventErr = client . Events ( nextCtx , types . EventsOptions { } ) go buffer . StartListening ( nextCtx , dockerEvents ) cancel ( ) cancel = nextCancel } case <- ctx . Done ( ) : return } } } ( ) go buffer . Consume ( events ) changedContainers := make ( chan DockerContainerChangeEvent ) go dg . handleContainerEvents ( ctx , events , changedContainers ) return changedContainers , nil }
1038	func SignalPresent ( s * os . Signal ) bool { if s == nil { return false } return * s != signals . SIGNIL }
2972	func ( r * DiskSubresource ) Read ( l object . VirtualDeviceList ) error { log . Printf ( "[DEBUG] %s: Reading state" , r ) disk , err := r . findVirtualDisk ( l , true ) if err != nil { return fmt . Errorf ( "cannot find disk device: %s" , err ) } unit , ctlr , err := r . findControllerInfo ( l , disk ) if err != nil { return err } r . Set ( "unit_number" , unit ) if err := r . SaveDevIDs ( disk , ctlr ) ; err != nil { return err } var attach bool if r . Get ( "attach" ) != nil { attach = r . Get ( "attach" ) . ( bool ) } b , ok := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) if ! ok { return fmt . Errorf ( "disk backing at %s is of an unsupported type (type %T)" , r . Get ( "device_address" ) . ( string ) , disk . Backing ) } r . Set ( "uuid" , b . Uuid ) r . Set ( "disk_mode" , b . DiskMode ) r . Set ( "write_through" , b . WriteThrough ) version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) && b . Sharing != "" { r . Set ( "disk_sharing" , b . Sharing ) } if ! attach { r . Set ( "thin_provisioned" , b . ThinProvisioned ) r . Set ( "eagerly_scrub" , b . EagerlyScrub ) } r . Set ( "datastore_id" , b . Datastore . Value ) if ! attach { dp := & object . DatastorePath { } if ok := dp . FromString ( b . FileName ) ; ! ok { return fmt . Errorf ( "could not parse path from filename: %s" , b . FileName ) } r . Set ( "path" , dp . Path ) r . Set ( "size" , diskCapacityInGiB ( disk ) ) } if allocation := disk . StorageIOAllocation ; allocation != nil { r . Set ( "io_limit" , allocation . Limit ) r . Set ( "io_reservation" , allocation . Reservation ) if shares := allocation . Shares ; shares != nil { r . Set ( "io_share_level" , string ( shares . Level ) ) r . Set ( "io_share_count" , shares . Shares ) } } log . Printf ( "[DEBUG] %s: Read finished (key and device address may have changed)" , r ) return nil }
6759	func ( a * AddrBook ) loadFromFile ( filePath string ) bool { _ , err := os . Stat ( filePath ) if os . IsNotExist ( err ) { return false } r , err := os . Open ( filePath ) if err != nil { PanicCrisis ( Fmt ( "Error opening file %s: %v" , filePath , err ) ) } defer r . Close ( ) aJSON := & addrBookJSON { } dec := json . NewDecoder ( r ) err = dec . Decode ( aJSON ) if err != nil { PanicCrisis ( Fmt ( "Error reading file %s: %v" , filePath , err ) ) } a . key = aJSON . Key for _ , ka := range aJSON . Addrs { for _ , bucketIndex := range ka . Buckets { bucket := a . getBucket ( ka . BucketType , bucketIndex ) bucket [ ka . Addr . String ( ) ] = ka } a . addrLookup [ ka . Addr . String ( ) ] = ka if ka . BucketType == bucketTypeNew { a . nNew ++ } else { a . nOld ++ } } return true }
1270	func NewTransportProtocol ( protocol string ) ( TransportProtocol , error ) { switch protocol { case tcp : return TransportProtocolTCP , nil case udp : return TransportProtocolUDP , nil default : return TransportProtocolTCP , errors . New ( protocol + " is not a recognized transport protocol" ) } }
4838	func convertOptions ( q url . Values , pairs ... string ) url . Values { n := make ( url . Values ) for k , v := range q { x := make ( [ ] string , len ( v ) ) for i , z := range v { for j := 0 ; j < len ( pairs ) ; j += 2 { if pairs [ j ] == z { z = pairs [ j + 1 ] } } x [ i ] = z } n [ k ] = x } return n }
5717	func NewFromServers ( servers Servers ) * Client { return & Client { timeout : DefaultTimeout , maxIdlePerAddr : maxIdleConnsPerAddr , servers : servers , freeconn : make ( map [ string ] chan * conn ) , bufPool : make ( chan [ ] byte , poolSize ( ) ) , } }
5710	func ( s * Sentinel ) SlaveAddrs ( ) ( [ ] string , error ) { res , err := s . doUntilSuccess ( func ( c redis . Conn ) ( interface { } , error ) { return queryForSlaveAddrs ( c , s . MasterName ) } ) if err != nil { return nil , err } return res . ( [ ] string ) , nil }
7177	func ( s * SessionCache ) Get ( token string ) ( interface { } , error ) { v , err := s . cache . Get ( token ) if err != nil { return nil , s . getInvalidTokenError ( token ) } return v , err }
3198	func GetStringId ( id interface { } ) ( string , error ) { switch v := id . ( type ) { case int : return strconv . Itoa ( v ) , nil case string : return v , nil default : return "" , errors . New ( "unsupported id type" ) } }
6589	func StartObsessingOverSvc ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "START_OBSESSING_OVER_SVC" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
2699	func ( c * Config ) Client ( ) ( * VSphereClient , error ) { client := new ( VSphereClient ) u , err := c . vimURL ( ) if err != nil { return nil , fmt . Errorf ( "Error generating SOAP endpoint url: %s" , err ) } err = c . EnableDebug ( ) if err != nil { return nil , fmt . Errorf ( "Error setting up client debug: %s" , err ) } client . vimClient , err = c . SavedVimSessionOrNew ( u ) if err != nil { return nil , err } log . Printf ( "[DEBUG] VMWare vSphere Client configured for URL: %s" , c . VSphereServer ) if isEligibleTagEndpoint ( client . vimClient ) { client . tagsClient , err = c . SavedRestSessionOrNew ( u ) if err != nil { return nil , err } log . Println ( "[DEBUG] CIS REST client configuration successful" ) } else { log . Printf ( "[DEBUG] Connected endpoint does not support tags (%s)" , viapi . ParseVersionFromClient ( client . vimClient ) ) } if err := c . SaveVimClient ( client . vimClient ) ; err != nil { return nil , fmt . Errorf ( "error persisting SOAP session to disk: %s" , err ) } if err := c . SaveRestClient ( client . tagsClient ) ; err != nil { return nil , fmt . Errorf ( "error persisting REST session to disk: %s" , err ) } return client , nil }
383	func ( a * Args ) PeekMultiBytes ( key [ ] byte ) [ ] [ ] byte { return a . PeekMulti ( b2s ( key ) ) }
4509	func SampleWithSeed ( n int , seed int64 ) Filter { return FilterFunc ( func ( arg Arg ) error { r := rand . New ( rand . NewSource ( seed ) ) reservoir := make ( [ ] string , 0 , n ) i := 0 for s := range arg . In { if i < n { reservoir = append ( reservoir , s ) } else { j := r . Intn ( i + 1 ) if j < n { reservoir [ j ] = s } } i ++ } for _ , s := range reservoir { arg . Out <- s } return nil } ) }
4938	func ( c * Connector ) Locale ( ) string { c . mu . RLock ( ) defer c . mu . RUnlock ( ) return c . locale }
6249	func ValidatePassword ( hash Base64String , password , salt string ) error { salted := [ ] byte ( fmt . Sprint ( password , salt ) ) hashB , err := ToBytes ( hash ) if err != nil { return err } return bcrypt . CompareHashAndPassword ( hashB , salted ) }
5583	func ( o * UpdateVMParams ) WithContext ( ctx context . Context ) * UpdateVMParams { o . SetContext ( ctx ) return o }
5638	func DerivePublicKey ( pubKeyBytes [ ] byte , chainCode [ ] byte , index uint32 ) ( [ ] byte , [ ] byte ) { data := [ ] byte { } data = append ( data , pubKeyBytes ... ) data = append ( data , uint32ToBytes ( index ) ... ) data2 , chainCode2 := I64 ( chainCode , data ) data2p := PubKeyBytesFromPrivKeyBytes ( data2 , true ) return addPoints ( pubKeyBytes , data2p ) , chainCode2 }
2909	func splitDevAddr ( id string ) ( string , int , int , error ) { parts := strings . Split ( id , ":" ) if len ( parts ) < 3 { return "" , 0 , 0 , fmt . Errorf ( "invalid ID %q" , id ) } ct , cbs , dus := parts [ 0 ] , parts [ 1 ] , parts [ 2 ] cb , cbe := strconv . Atoi ( cbs ) du , due := strconv . Atoi ( dus ) var found bool for _ , v := range subresourceIDControllerTypeAllowedValues { if v == ct { found = true } } if ! found { return ct , cb , du , fmt . Errorf ( "invalid controller type %q found in ID" , ct ) } if cbe != nil { return ct , cb , du , fmt . Errorf ( "invalid bus number %q found in ID" , cbs ) } if due != nil { return ct , cb , du , fmt . Errorf ( "invalid disk unit number %q found in ID" , dus ) } return ct , cb , du , nil }
5437	func ( bot * Bot ) SetNick ( nick string ) { bot . Nick = nick bot . Send ( fmt . Sprintf ( "NICK %s" , nick ) ) }
5007	func EncodeAll ( src [ ] uint32 ) ( [ ] uint32 , error ) { i := 0 dst := make ( [ ] uint32 , len ( src ) ) j := 0 for { if i >= len ( src ) { break } remaining := src [ i : ] if canPack ( remaining , 1 , 28 ) { dst [ j ] = pack28 ( src [ i : i + 28 ] ) i += 28 } else if canPack ( remaining , 2 , 14 ) { dst [ j ] = pack14 ( src [ i : i + 14 ] ) i += 14 } else if canPack ( remaining , 3 , 9 ) { dst [ j ] = pack9 ( src [ i : i + 9 ] ) i += 9 } else if canPack ( remaining , 4 , 7 ) { dst [ j ] = pack7 ( src [ i : i + 7 ] ) i += 7 } else if canPack ( remaining , 5 , 5 ) { dst [ j ] = pack5 ( src [ i : i + 5 ] ) i += 5 } else if canPack ( remaining , 7 , 4 ) { dst [ j ] = pack4 ( src [ i : i + 4 ] ) i += 4 } else if canPack ( remaining , 9 , 3 ) { dst [ j ] = pack3 ( src [ i : i + 3 ] ) i += 3 } else if canPack ( remaining , 14 , 2 ) { dst [ j ] = pack2 ( src [ i : i + 2 ] ) i += 2 } else if canPack ( remaining , 28 , 1 ) { dst [ j ] = pack1 ( src [ i : i + 1 ] ) i += 1 } else { return nil , fmt . Errorf ( "value out of bounds" ) } j += 1 } return dst [ : j ] , nil }
1562	func MapTaskToContainerStatus ( desiredState TaskStatus , steadyState apicontainerstatus . ContainerStatus ) apicontainerstatus . ContainerStatus { switch desiredState { case TaskStatusNone : return apicontainerstatus . ContainerStatusNone case TaskCreated : return apicontainerstatus . ContainerCreated case TaskRunning : return steadyState case TaskStopped : return apicontainerstatus . ContainerStopped } return apicontainerstatus . ContainerStatusNone }
3889	func ( b * builder ) assignOp ( fn * Function , loc lvalue , incr Value , op token . Token , pos token . Pos ) { oldv := loc . load ( fn ) loc . store ( fn , emitArith ( fn , op , oldv , emitConv ( fn , incr , oldv . Type ( ) ) , loc . typ ( ) , pos ) ) }
1311	func GetSecretsFromSSM ( names [ ] string , client SSMClient ) ( map [ string ] string , error ) { var secretNames [ ] * string for _ , name := range names { secretNames = append ( secretNames , aws . String ( name ) ) } in := & ssm . GetParametersInput { Names : secretNames , WithDecryption : aws . Bool ( true ) , } out , err := client . GetParameters ( in ) if err != nil { return nil , err } return extractSSMValues ( out ) }
2892	func dvsFromPath ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . VmwareDistributedVirtualSwitch , error ) { net , err := network . FromPath ( client , name , dc ) if err != nil { return nil , err } if net . Reference ( ) . Type != "VmwareDistributedVirtualSwitch" { return nil , fmt . Errorf ( "network at path %q is not a VMware distributed virtual switch (type %s)" , name , net . Reference ( ) . Type ) } return dvsFromMOID ( client , net . Reference ( ) . Value ) }
2393	func NewWorld ( width , height int , maxInitLiveCells int ) * World { w := & World { area : make ( [ ] bool , width * height ) , width : width , height : height , } w . init ( maxInitLiveCells ) return w }
4945	func ( c * Connector ) BasicAuthDSN ( ) string { values := url . Values { } if c . locale != "" { values . Set ( DSNLocale , c . locale ) } if c . fetchSize != 0 { values . Set ( DSNFetchSize , fmt . Sprintf ( "%d" , c . fetchSize ) ) } if c . timeout != 0 { values . Set ( DSNTimeout , fmt . Sprintf ( "%d" , c . timeout ) ) } return ( & url . URL { Scheme : DriverName , User : url . UserPassword ( c . username , c . password ) , Host : c . host , RawQuery : values . Encode ( ) , } ) . String ( ) }
1264	func ( vol * VolumeResource ) Cleanup ( ) error { if vol . VolumeConfig . Scope != TaskScope { seelog . Debugf ( "Volume [%s] is shared, not removing" , vol . Name ) return nil } seelog . Debugf ( "Removing volume with name %s" , vol . Name ) err := vol . client . RemoveVolume ( vol . ctx , vol . VolumeConfig . DockerVolumeName , dockerclient . RemoveVolumeTimeout ) if err != nil { return err } return nil }
3440	func ( o * Options ) GetThresholds ( ) ThresholdCount { if o == nil || o . Thresholds == nil { return ThresholdCount { } } return * o . Thresholds }
374	func ( a * Args ) AddBytesKNoValue ( key [ ] byte ) { a . args = appendArg ( a . args , b2s ( key ) , "" , argsNoValue ) }
6064	func ( m * Monitor ) Start ( ) { logger := m . logger . Add ( "method" , "Start" ) ctx , cancel := context . WithCancel ( context . Background ( ) ) ticker := time . NewTicker ( m . queryPause ) m . stopMonitor = func ( ) { ticker . Stop ( ) cancel ( ) } go func ( ) { for { select { case <- ctx . Done ( ) : return case <- ticker . C : err := m . queryLogsAndCreateJobs ( m . getFilterLogQueries , m . jobsProducers ) if err != nil { logger . Warn ( err . Error ( ) ) } } } } ( ) }
4234	func ( s * Spinner ) erase ( ) { n := utf8 . RuneCountInString ( s . lastOutput ) if runtime . GOOS == "windows" { clearString := "\r" \r for i := 0 ; i < n ; i ++ { clearString += " " } fmt . Fprintf ( s . Writer , clearString ) } return del , _ := hex . DecodeString ( "7f" ) for _ , c := range [ ] string { "\b" , \b , string ( del ) , "\b" , } \b }
1501	func getMetadataFilePath ( taskARN string , containerName string , dataDir string ) ( string , error ) { taskID , err := getTaskIDfromARN ( taskARN ) if err != nil { return "" , fmt . Errorf ( "get metdata file path of task %s container %s: %v" , taskARN , containerName , err ) } return filepath . Join ( dataDir , metadataJoinSuffix , taskID , containerName ) , nil }
5324	func ExecSudo ( cmd string , args ... string ) error { return Exec ( "sudo" , append ( [ ] string { cmd } , args ... ) ... ) }
2977	func ( r * DiskSubresource ) normalizeDiskDatastore ( ) error { podID := r . rdd . Get ( "datastore_cluster_id" ) . ( string ) dsID , _ := r . GetChange ( "datastore_id" ) if podID == "" { r . Set ( "datastore_id" , dsID ) return nil } log . Printf ( "[DEBUG] %s: Checking datastore cluster membership of disk" , r ) pod , err := storagepod . FromID ( r . client , podID ) if err != nil { return fmt . Errorf ( "error fetching datastore cluster ID %q: %s" , podID , err ) } ds , err := datastore . FromID ( r . client , dsID . ( string ) ) if err != nil { return fmt . Errorf ( "error fetching datastore ID %q: %s" , dsID , err ) } isMember , err := storagepod . IsMember ( pod , ds ) if err != nil { return fmt . Errorf ( "error checking storage pod membership: %s" , err ) } if ! isMember { log . Printf ( "[DEBUG] %s: Disk's datastore %q not a member of cluster %q, marking datastore ID as computed" , r , ds . Name ( ) , pod . Name ( ) , ) dsID = diskDatastoreComputedName } r . Set ( "datastore_id" , dsID ) return nil }
3902	func ( p * parser ) peek ( ) yaml_event_type_t { if p . event . typ != yaml_NO_EVENT { return p . event . typ } if ! yaml_parser_parse ( & p . parser , & p . event ) { p . fail ( ) } return p . event . typ }
7202	func NewSalter ( sources RandomSourceList , input [ ] byte ) * Salter { if input == nil { input = [ ] byte ( "" ) } hash := sha256 . New ( ) hash . Write ( input ) sum := 0 for _ , v := range sources { sum += v . Weight } return & Salter { salt : hash . Sum ( nil ) , rndSources : sources , sumWeight : sum , } }
3278	func ( d * DashboardLite ) GetModifiedOk ( ) ( string , bool ) { if d == nil || d . Modified == nil { return "" , false } return * d . Modified , true }
6721	func setAuthHeader ( t * oauth2 . Token , r * http . Request ) { r . Header . Set ( "X-Auth-Token" , t . AccessToken ) }
2710	func ( c * Config ) SavedVimSessionOrNew ( u * url . URL ) ( * govmomi . Client , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) client , err := c . LoadVimClient ( ) if err != nil { return nil , fmt . Errorf ( "error trying to load vSphere SOAP session from disk: %s" , err ) } if client == nil { log . Printf ( "[DEBUG] Creating new SOAP API session on endpoint %s" , c . VSphereServer ) client , err = govmomi . NewClient ( ctx , u , c . InsecureFlag ) if err != nil { return nil , fmt . Errorf ( "error setting up new vSphere SOAP client: %s" , err ) } log . Println ( "[DEBUG] SOAP API session creation successful" ) } return client , nil }
5594	func ( o * DeleteVMParams ) WithCid ( cid int32 ) * DeleteVMParams { o . SetCid ( cid ) return o }
354	func CheckMetrics ( ) int { l := promlint . New ( os . Stdin ) problems , err := l . Lint ( ) if err != nil { fmt . Fprintln ( os . Stderr , "error while linting:" , err ) return 1 } for _ , p := range problems { fmt . Fprintln ( os . Stderr , p . Metric , p . Text ) } if len ( problems ) > 0 { return 3 } return 0 }
5700	func validateStruct ( errors Errors , obj interface { } ) Errors { typ := reflect . TypeOf ( obj ) val := reflect . ValueOf ( obj ) if typ . Kind ( ) == reflect . Ptr { typ = typ . Elem ( ) val = val . Elem ( ) } for i := 0 ; i < typ . NumField ( ) ; i ++ { field := typ . Field ( i ) if field . Tag . Get ( "form" ) == "-" || ! val . Field ( i ) . CanInterface ( ) { continue } fieldValue := val . Field ( i ) . Interface ( ) zero := reflect . Zero ( field . Type ) . Interface ( ) if field . Type . Kind ( ) == reflect . Struct || ( field . Type . Kind ( ) == reflect . Ptr && ! reflect . DeepEqual ( zero , fieldValue ) && field . Type . Elem ( ) . Kind ( ) == reflect . Struct ) { errors = validateStruct ( errors , fieldValue ) } if strings . Index ( field . Tag . Get ( "binding" ) , "required" ) > - 1 { if reflect . DeepEqual ( zero , fieldValue ) { name := field . Name if j := field . Tag . Get ( "json" ) ; j != "" { name = j } else if f := field . Tag . Get ( "form" ) ; f != "" { name = f } errors . Add ( [ ] string { name } , RequiredError , "Required" ) } } } return errors }
1983	func ( m * MockClient ) ImageRemove ( arg0 context . Context , arg1 string , arg2 types . ImageRemoveOptions ) ( [ ] types . ImageDeleteResponseItem , error ) { ret := m . ctrl . Call ( m , "ImageRemove" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( [ ] types . ImageDeleteResponseItem ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
566	func ( mx * Mux ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { if mx . handler == nil { mx . NotFoundHandler ( ) . ServeHTTP ( w , r ) return } rctx , _ := r . Context ( ) . Value ( RouteCtxKey ) . ( * Context ) if rctx != nil { mx . handler . ServeHTTP ( w , r ) return } rctx = mx . pool . Get ( ) . ( * Context ) rctx . Reset ( ) rctx . Routes = mx r = r . WithContext ( context . WithValue ( r . Context ( ) , RouteCtxKey , rctx ) ) mx . handler . ServeHTTP ( w , r ) mx . pool . Put ( rctx ) }
947	func NewDriver ( hostName , storePath string ) * Driver { return & Driver { VBoxManager : NewVBoxManager ( ) , b2dUpdater : NewB2DUpdater ( ) , sshKeyGenerator : NewSSHKeyGenerator ( ) , diskCreator : NewDiskCreator ( ) , logsReader : NewLogsReader ( ) , ipWaiter : NewIPWaiter ( ) , randomInter : NewRandomInter ( ) , sleeper : NewSleeper ( ) , HostInterfaces : NewHostInterfaces ( ) , Memory : defaultMemory , CPU : defaultCPU , DiskSize : defaultDiskSize , NatNicType : defaultHostOnlyNictype , HostOnlyCIDR : defaultHostOnlyCIDR , HostOnlyNicType : defaultHostOnlyNictype , HostOnlyPromiscMode : defaultHostOnlyPromiscMode , UIType : defaultUIType , HostOnlyNoDHCP : defaultHostOnlyNoDHCP , DNSProxy : defaultDNSProxy , HostDNSResolver : defaultDNSResolver , BaseDriver : & drivers . BaseDriver { MachineName : hostName , StorePath : storePath , } , } }
490	func ( resp * Response ) Write ( w * bufio . Writer ) error { sendBody := ! resp . mustSkipBody ( ) if resp . bodyStream != nil { return resp . writeBodyStream ( w , sendBody ) } body := resp . bodyBytes ( ) bodyLen := len ( body ) if sendBody || bodyLen > 0 { resp . Header . SetContentLength ( bodyLen ) } if err := resp . Header . Write ( w ) ; err != nil { return err } if sendBody { if _ , err := w . Write ( body ) ; err != nil { return err } } return nil }
3970	func ( bus * EventBus ) doSubscribe ( topic string , fn interface { } , handler * eventHandler ) error { bus . lock . Lock ( ) defer bus . lock . Unlock ( ) if ! ( reflect . TypeOf ( fn ) . Kind ( ) == reflect . Func ) { return fmt . Errorf ( "%s is not of type reflect.Func" , reflect . TypeOf ( fn ) . Kind ( ) ) } bus . handlers [ topic ] = append ( bus . handlers [ topic ] , handler ) return nil }
1694	func NewContainerStateChangeEvent ( task * apitask . Task , cont * apicontainer . Container , reason string ) ( ContainerStateChange , error ) { var event ContainerStateChange contKnownStatus := cont . GetKnownStatus ( ) if ! contKnownStatus . ShouldReportToBackend ( cont . GetSteadyStateStatus ( ) ) { return event , errors . Errorf ( "create container state change event api: status not recognized by ECS: %v" , contKnownStatus ) } if cont . IsInternal ( ) { return event , errors . Errorf ( "create container state change event api: internal container: %s" , cont . Name ) } if cont . GetSentStatus ( ) >= contKnownStatus { return event , errors . Errorf ( "create container state change event api: status [%s] already sent for container %s, task %s" , contKnownStatus . String ( ) , cont . Name , task . Arn ) } if reason == "" && cont . ApplyingError != nil { reason = cont . ApplyingError . Error ( ) } event = ContainerStateChange { TaskArn : task . Arn , ContainerName : cont . Name , Status : contKnownStatus . BackendStatus ( cont . GetSteadyStateStatus ( ) ) , ExitCode : cont . GetKnownExitCode ( ) , PortBindings : cont . GetKnownPortBindings ( ) , Reason : reason , Container : cont , } return event , nil }
3922	func ( d * directiveParser ) IsIgnored ( issue * Issue ) bool { d . lock . Lock ( ) path := issue . Path . Relative ( ) ranges , ok := d . files [ path ] if ! ok { ranges = d . parseFile ( path ) sort . Sort ( ranges ) d . files [ path ] = ranges } d . lock . Unlock ( ) for _ , r := range ranges { if r . matches ( issue ) { debug ( "nolint: matched %s to issue %s" , r , issue ) r . matched = true return true } } return false }
7083	func ( s * RunConfig ) Name ( name string ) { s . Options = append ( s . Options , "--name" , name ) }
390	func ( a * Args ) GetBool ( key string ) bool { switch b2s ( a . Peek ( key ) ) { case "1" , "t" , "T" , "true" , "TRUE" , "True" , "y" , "yes" , "Y" , "YES" , "Yes" : return true default : return false } }
2241	func ( v * EntryBuffer ) native ( ) * C . GtkEntryBuffer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEntryBuffer ( p ) }
3721	func ( w * Widget ) GetTick ( ) bool { if w == nil || w . Tick == nil { return false } return * w . Tick }
3376	func ( i * IntegrationGCPCreateRequest ) GetTokenURI ( ) string { if i == nil || i . TokenURI == nil { return "" } return * i . TokenURI }
931	func targetHost ( c CommandLine , api libmachine . API ) ( string , error ) { if len ( c . Args ( ) ) == 0 { defaultExists , err := api . Exists ( defaultMachineName ) if err != nil { return "" , fmt . Errorf ( "Error checking if host %q exists: %s" , defaultMachineName , err ) } if defaultExists { return defaultMachineName , nil } return "" , ErrNoDefault } return c . Args ( ) [ 0 ] , nil }
4001	func ( l * torValidityTooLarge ) CheckApplies ( c * x509 . Certificate ) bool { return util . IsSubscriberCert ( c ) && util . CertificateSubjInTLD ( c , onionTLD ) }
4066	func Ellipsize ( str string , maxWidth int ) string { ln := xs . Len ( str ) if ln <= maxWidth { return str } if maxWidth < 5 { return xs . Slice ( str , 0 , maxWidth ) } left := int ( ( maxWidth - 3 ) / 2 ) right := maxWidth - left - 3 return xs . Slice ( str , 0 , left ) + "..." + xs . Slice ( str , ln - right , - 1 ) }
3327	func ( g * GraphDefinitionRequest ) HasStacked ( ) bool { if g != nil && g . Stacked != nil { return true } return false }
1689	func ( authProvider * ecrAuthProvider ) getAuthConfigFromCache ( key cacheKey ) * types . AuthConfig { token , ok := authProvider . tokenCache . Get ( key . String ( ) ) if ! ok { return nil } cachedToken , ok := token . ( * ecrapi . AuthorizationData ) if ! ok { log . Warnf ( "Reading ECR credentials from cache failed" ) return nil } if authProvider . IsTokenValid ( cachedToken ) { auth , err := extractToken ( cachedToken ) if err != nil { log . Errorf ( "Extract docker auth from cache failed, err: %v" , err ) authProvider . tokenCache . Delete ( key . String ( ) ) return nil } return & auth } else { authProvider . tokenCache . Delete ( key . String ( ) ) } return nil }
2686	func Properties ( pod * object . StoragePod ) ( * mo . StoragePod , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . StoragePod if err := pod . Properties ( ctx , pod . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
5553	func ( f * Feature ) LongestLine ( ) int { if f . longestLine == 0 { f . longestLine = len ( "Feature: " + f . Title ) for _ , s := range f . Scenarios { if l := s . LongestLine ( ) ; l > f . longestLine { f . longestLine = l } } } return f . longestLine }
1548	func ( m * MockCgroup ) OOMEventFD ( ) ( uintptr , error ) { ret := m . ctrl . Call ( m , "OOMEventFD" ) ret0 , _ := ret [ 0 ] . ( uintptr ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6849	func ( c * cachedLoader ) Import ( data [ ] byte ) error { conf := make ( map [ string ] interface { } ) err := json . Unmarshal ( data , & conf ) if err != nil { return fmt . Errorf ( "Unable to parse json data: %v" , err ) } kvMap , err := c . compileKeyValues ( conf , c . namespace ) if err != nil { return fmt . Errorf ( "Unable to complie KVs: %v" , err ) } if err != nil { return fmt . Errorf ( "Could not create consul client: %v" , err ) } for k , v := range kvMap { p := & api . KVPair { Key : k , Value : v } _ , err = c . consulKV . Put ( p , nil ) if err != nil { return fmt . Errorf ( "Could not write key to consul (%s | %s) %v" , k , v , err ) } } return nil }
2611	func FromPath ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . VirtualApp , error ) { finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) if dc != nil { finder . SetDatacenter ( dc ) } return finder . VirtualApp ( ctx , name ) }
6420	func merge ( left , right * llNode , comparator Comparator ) ( first * llNode , err error ) { curLeft := left curRight := right var last * llNode appendResults := func ( updated * llNode ) { if last == nil { last = updated } else { last . next = updated last = last . next } if first == nil { first = last } } for curLeft != nil && curRight != nil { var res int if res , err = comparator ( curLeft . payload , curRight . payload ) ; nil != err { break } else if res < 0 { appendResults ( curLeft ) curLeft = curLeft . next } else { appendResults ( curRight ) curRight = curRight . next } } if curLeft != nil { appendResults ( curLeft ) } if curRight != nil { appendResults ( curRight ) } return }
2170	func ( v * Actionable ) native ( ) * C . GtkActionable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkActionable ( p ) }
2162	func ( v * ActionMap ) AddAction ( action IAction ) { C . g_action_map_add_action ( v . native ( ) , action . toGAction ( ) ) }
2469	func ( a * arrayBufferLayout ) newArrayBuffer ( context * context ) buffer { return context . newArrayBuffer ( a . totalBytes ( ) * graphics . IndicesNum ) }
2048	func RetryNWithBackoffCtx ( ctx context . Context , backoff Backoff , n int , fn func ( ) error ) error { var err error RetryWithBackoffCtx ( ctx , backoff , func ( ) error { err = fn ( ) n -- if n == 0 { return nil } return err } ) return err }
1709	func ( task * Task ) initializeCredentialsEndpoint ( credentialsManager credentials . Manager ) { id := task . GetCredentialsID ( ) if id == "" { return } taskCredentials , ok := credentialsManager . GetTaskCredentials ( id ) if ! ok { seelog . Errorf ( "Unable to get credentials for task: %s" , task . Arn ) return } credentialsEndpointRelativeURI := taskCredentials . IAMRoleCredentials . GenerateCredentialsEndpointRelativeURI ( ) for _ , container := range task . Containers { if container . Environment == nil { container . Environment = make ( map [ string ] string ) } container . Environment [ awsSDKCredentialsRelativeURIPathEnvironmentVariableName ] = credentialsEndpointRelativeURI } }
6265	func NewLogger ( conf * Config ) ( log . Logger , error ) { l := & reportLogger { } base , err := log . NewLoggerBase ( conf . BaseConfig , l . log ) if err != nil { return nil , err } l . LoggerBase = base return l , nil }
6320	func ( r * Request ) CookieValue ( name string ) string { c , err := r . Cookie ( name ) if err != nil { return "" } return c . Value }
1590	func ( m * MockSecretsManagerAPI ) GetResourcePolicyRequest ( arg0 * secretsmanager . GetResourcePolicyInput ) ( * request . Request , * secretsmanager . GetResourcePolicyOutput ) { ret := m . ctrl . Call ( m , "GetResourcePolicyRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . GetResourcePolicyOutput ) return ret0 , ret1 }
4418	func ( h * Hostname ) DeepCopy ( ) * Hostname { if h == nil { return nil } out := new ( Hostname ) h . DeepCopyInto ( out ) return out }
5894	func ( r RSAMethod ) Verify ( pub * rsa . PublicKey , hash crypto . Hash , hashed [ ] byte , sig [ ] byte ) error { return r . VerifyFunc ( pub , hash , hashed , sig ) }
1544	func ( m * MockCgroup ) Add ( arg0 cgroups . Process ) error { ret := m . ctrl . Call ( m , "Add" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
1431	func ( state * DockerTaskEngineState ) AllENIAttachments ( ) [ ] * apieni . ENIAttachment { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . allENIAttachmentsUnsafe ( ) }
2339	func ( v * Context ) DeviceToUserDistance ( x , y float64 ) ( float64 , float64 ) { C . cairo_device_to_user_distance ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y }
4374	func EmailValue ( v * strfmt . Email ) strfmt . Email { if v == nil { return strfmt . Email ( "" ) } return * v }
7125	func ApplyRuleIf ( condition , rule Ruler ) Ruler { return & apply { condition : condition , rule : rule , } }
718	func newETCDClient ( ) ( coreDNSClient , error ) { cfg , err := getETCDConfig ( ) if err != nil { return nil , err } c , err := etcdcv3 . New ( * cfg ) if err != nil { return nil , err } return etcdClient { c , context . Background ( ) } , nil }
7264	func SplitPath ( pat string ) ( routes [ ] string , err error ) { scanner := bufio . NewScanner ( strings . NewReader ( pat ) ) scanner . Split ( routeSplitFunc ) for scanner . Scan ( ) { routes = append ( routes , scanner . Text ( ) ) } err = scanner . Err ( ) return }
4583	func ( f * Func ) Name ( ) string { parts := strings . SplitN ( filepath . Base ( f . Raw ) , "." , 2 ) if len ( parts ) == 1 { return parts [ 0 ] } return parts [ 1 ] }
2517	func expandHostNicTeamingPolicy ( d * schema . ResourceData ) * types . HostNicTeamingPolicy { obj := & types . HostNicTeamingPolicy { Policy : d . Get ( "teaming_policy" ) . ( string ) , } if v , ok := d . GetOkExists ( "failback" ) ; ok { obj . RollingOrder = structure . BoolPtr ( ! v . ( bool ) ) } if v , ok := d . GetOkExists ( "notify_switches" ) ; ok { obj . NotifySwitches = structure . BoolPtr ( v . ( bool ) ) } obj . FailureCriteria = expandHostNicFailureCriteria ( d ) obj . NicOrder = expandHostNicOrderPolicy ( d ) obj . ReversePolicy = structure . BoolPtr ( true ) return obj }
4142	func ( n Network ) LeastCommonBitPosition ( n1 Network ) ( uint , error ) { maskSize , _ := n . IPNet . Mask . Size ( ) if maskSize1 , _ := n1 . IPNet . Mask . Size ( ) ; maskSize1 < maskSize { maskSize = maskSize1 } maskPosition := len ( n1 . Number ) * BitsPerUint32 - maskSize lcb , err := n . Number . LeastCommonBitPosition ( n1 . Number ) if err != nil { return 0 , err } return uint ( math . Max ( float64 ( maskPosition ) , float64 ( lcb ) ) ) , nil }
1389	func ( mr * MockCNIClientMockRecorder ) Capabilities ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Capabilities" , reflect . TypeOf ( ( * MockCNIClient ) ( nil ) . Capabilities ) , arg0 ) }
3631	func ( t * TraceServiceDefinition ) GetShowErrors ( ) bool { if t == nil || t . ShowErrors == nil { return false } return * t . ShowErrors }
6831	func New ( apikey string ) * Client { endpoint := Endpoint { URL : EndpointURL } return & Client { apikey , http . DefaultClient , endpoint } }
4119	func ( w * Window ) SetMaximized ( maximize bool ) { if maximize == w . maximized { return } if maximize { w . origX , w . origY = w . Pos ( ) w . origWidth , w . origHeight = w . Size ( ) w . maximized = true w . SetPos ( 0 , 0 ) width , height := ScreenSize ( ) w . SetSize ( width , height ) } else { w . maximized = false w . SetPos ( w . origX , w . origY ) w . SetSize ( w . origWidth , w . origHeight ) } w . ResizeChildren ( ) w . PlaceChildren ( ) }
3263	func ( c * ConditionalFormat ) GetInvertOk ( ) ( bool , bool ) { if c == nil || c . Invert == nil { return false , false } return * c . Invert , true }
6702	func ( c * Client ) LoadBalancers ( ) ( [ ] LoadBalancer , error ) { var lbs [ ] LoadBalancer _ , err := c . MakeApiRequest ( "GET" , "/1.0/load_balancers" , nil , & lbs ) if err != nil { return nil , err } return lbs , err }
3876	func ( e * Encoder ) Close ( ) ( err error ) { defer handleErr ( & err ) e . encoder . finish ( ) return nil }
3252	func ( c * Check ) HasHostName ( ) bool { if c != nil && c . HostName != nil { return true } return false }
3244	func ( c * ChannelSlackRequest ) GetChannelName ( ) string { if c == nil || c . ChannelName == nil { return "" } return * c . ChannelName }
6210	func RootPath ( ) string { _ , file , _ , ok := runtime . Caller ( 0 ) if ! ok { return "?" } return filepath . Dir ( filepath . Dir ( file ) ) }
2252	func ( v * Grid ) native ( ) * C . GtkGrid { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkGrid ( p ) }
5612	func ( o * GetVMByCidParams ) WithCid ( cid int32 ) * GetVMByCidParams { o . SetCid ( cid ) return o }
1945	func ( m * MockTaskEngineState ) TaskARNByV3EndpointID ( arg0 string ) ( string , bool ) { ret := m . ctrl . Call ( m , "TaskARNByV3EndpointID" , arg0 ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 }
3672	func ( w * Widget ) HasLayoutVersion ( ) bool { if w != nil && w . LayoutVersion != nil { return true } return false }
206	func ( m * Manager ) LoadGroups ( interval time . Duration , externalLabels labels . Labels , filenames ... string , ) ( map [ string ] * Group , [ ] error ) { groups := make ( map [ string ] * Group ) shouldRestore := ! m . restored for _ , fn := range filenames { rgs , errs := rulefmt . ParseFile ( fn ) if errs != nil { return nil , errs } for _ , rg := range rgs . Groups { itv := interval if rg . Interval != 0 { itv = time . Duration ( rg . Interval ) } rules := make ( [ ] Rule , 0 , len ( rg . Rules ) ) for _ , r := range rg . Rules { expr , err := promql . ParseExpr ( r . Expr ) if err != nil { return nil , [ ] error { err } } if r . Alert != "" { rules = append ( rules , NewAlertingRule ( r . Alert , expr , time . Duration ( r . For ) , labels . FromMap ( r . Labels ) , labels . FromMap ( r . Annotations ) , externalLabels , m . restored , log . With ( m . logger , "alert" , r . Alert ) , ) ) continue } rules = append ( rules , NewRecordingRule ( r . Record , expr , labels . FromMap ( r . Labels ) , ) ) } groups [ groupKey ( rg . Name , fn ) ] = NewGroup ( rg . Name , fn , itv , rules , shouldRestore , m . opts ) } } return groups , nil }
5545	func ( c * Client ) PrivSay ( user , name , body string ) { c . connection . MUCSend ( "chat" , user , c . Id + "/" + name , body ) }
1554	func NewMockUdev ( ctrl * gomock . Controller ) * MockUdev { mock := & MockUdev { ctrl : ctrl } mock . recorder = & MockUdevMockRecorder { mock } return mock }
3151	func ( app * App ) RestoreFromDir ( dumpDir string , storeFunc func ( * points . Points ) ) { startTime := time . Now ( ) logger := zapwriter . Logger ( "restore" ) . With ( zap . String ( "dir" , dumpDir ) ) defer func ( ) { logger . Info ( "restore finished" , zap . Duration ( "runtime" , time . Since ( startTime ) ) , ) } ( ) files , err := ioutil . ReadDir ( dumpDir ) if err != nil { logger . Error ( "readdir failed" , zap . Error ( err ) ) return } list := make ( [ ] string , 0 ) FilesLoop : for _ , file := range files { if file . IsDir ( ) { continue } r := strings . Split ( file . Name ( ) , "." ) if len ( r ) < 3 { continue } var fileWithSortPrefix string switch r [ 0 ] { case "cache" : fileWithSortPrefix = fmt . Sprintf ( "%s_%s:%s" , r [ 2 ] , "1" , file . Name ( ) ) case "input" : fileWithSortPrefix = fmt . Sprintf ( "%s_%s:%s" , r [ 2 ] , "2" , file . Name ( ) ) default : continue FilesLoop } list = append ( list , fileWithSortPrefix ) } if len ( list ) == 0 { logger . Info ( "nothing for restore" ) return } sort . Strings ( list ) for index , fileWithSortPrefix := range list { list [ index ] = strings . SplitN ( fileWithSortPrefix , ":" , 2 ) [ 1 ] } logger . Info ( "start restore" , zap . Int ( "files" , len ( list ) ) ) for _ , fn := range list { filename := path . Join ( dumpDir , fn ) app . RestoreFromFile ( filename , storeFunc ) err = os . Remove ( filename ) if err != nil { logger . Error ( "remove failed" , zap . String ( "filename" , filename ) , zap . Error ( err ) ) } } }
1224	func ( imageState * ImageState ) MarshalJSON ( ) ( [ ] byte , error ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) return json . Marshal ( & struct { Image * Image PulledAt time . Time LastUsedAt time . Time PullSucceeded bool } { Image : imageState . Image , PulledAt : imageState . PulledAt , LastUsedAt : imageState . LastUsedAt , PullSucceeded : imageState . PullSucceeded , } ) }
3552	func ( s * SyntheticsTest ) HasDeletedAt ( ) bool { if s != nil && s . DeletedAt != nil { return true } return false }
6105	func ( h * Handler ) GenerateAccount ( tkn string , params * AccountParams ) ( * string , error ) { logger := h . logger . Add ( "method" , "GenerateAccount" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } account := params . prefilledAccount ( ) id , err := h . fillAndSaveAccount ( logger , account , crypto . GenerateKey , false ) if err != nil { return nil , err } return & id , nil }
4044	func DrawVerticalLine ( x , y , h int , r rune ) { x , y , _ , h = clip ( x , y , 1 , h ) if h == 0 { return } for i := y ; i < y + h ; i ++ { putCharUnsafe ( x , i , r ) } }
4494	func ( f * defaultFormats ) Add ( name string , strfmt Format , validator Validator ) bool { f . Lock ( ) defer f . Unlock ( ) nme := f . normalizeName ( name ) tpe := reflect . TypeOf ( strfmt ) if tpe . Kind ( ) == reflect . Ptr { tpe = tpe . Elem ( ) } for i := range f . data { v := & f . data [ i ] if v . Name == nme { v . Type = tpe v . Validator = validator return false } } f . data = append ( f . data , knownFormat { Name : nme , OrigName : name , Type : tpe , Validator : validator } ) return true }
4997	func ReceiveSnapshot ( input io . Reader , name string ) ( * Dataset , error ) { c := command { Command : "zfs" , Stdin : input } _ , err := c . Run ( "receive" , name ) if err != nil { return nil , err } return GetDataset ( name ) }
3219	func ( a * Alert ) GetSilencedOk ( ) ( bool , bool ) { if a == nil || a . Silenced == nil { return false , false } return * a . Silenced , true }
180	func ( r * AlertingRule ) SetLastError ( err error ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . lastError = err }
6912	func ( s * Session ) DeleteEntity ( object Identifiable ) * Error { url , berr := s . getPersonalURL ( object ) if berr != nil { return berr } url = url + "?responseChoice=1" request , err := http . NewRequest ( "DELETE" , url , nil ) if err != nil { return NewBambouError ( "HTTP transaction error" , err . Error ( ) ) } response , berr := s . send ( request , nil ) if berr != nil { return berr } defer response . Body . Close ( ) return nil }
2639	func removeDatastore ( s * object . HostDatastoreSystem , ds * object . Datastore ) error { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) return s . Remove ( ctx , ds ) }
5018	func ParseURL ( url string ) ( * DialInfo , error ) { uinfo , err := extractURL ( url ) if err != nil { return nil , err } direct := false mechanism := "" service := "" source := "" setName := "" poolLimit := 0 for k , v := range uinfo . options { switch k { case "authSource" : source = v case "authMechanism" : mechanism = v case "gssapiServiceName" : service = v case "replicaSet" : setName = v case "maxPoolSize" : poolLimit , err = strconv . Atoi ( v ) if err != nil { return nil , errors . New ( "bad value for maxPoolSize: " + v ) } case "connect" : if v == "direct" { direct = true break } if v == "replicaSet" { break } fallthrough default : return nil , errors . New ( "unsupported connection URL option: " + k + "=" + v ) } } info := DialInfo { Addrs : uinfo . addrs , Direct : direct , Database : uinfo . db , Username : uinfo . user , Password : uinfo . pass , Mechanism : mechanism , Service : service , Source : source , PoolLimit : poolLimit , ReplicaSetName : setName , } return & info , nil }
1796	func NewMockDockerClient ( ctrl * gomock . Controller ) * MockDockerClient { mock := & MockDockerClient { ctrl : ctrl } mock . recorder = & MockDockerClientMockRecorder { mock } return mock }
652	func ( p * InfobloxProvider ) ApplyChanges ( changes * plan . Changes ) error { zones , err := p . zones ( ) if err != nil { return err } created , deleted := p . mapChanges ( zones , changes ) p . deleteRecords ( deleted ) p . createRecords ( created ) return nil }
1022	func ( d * DedupManager ) Start ( ) error { log . Printf ( "[INFO] (dedup) starting de-duplication manager" ) client := d . clients . Consul ( ) go d . createSession ( client ) for _ , t := range d . templates { go d . watchTemplate ( client , t ) } return nil }
6313	func Handler ( gf GoannaHandlerFunc ) http . HandlerFunc { return func ( w http . ResponseWriter , r * http . Request ) { gr := & Request { Request : r } gf ( gr ) . Send ( w ) } }
1855	func ForModule ( module string ) OldLogger { once . Do ( initLogger ) return logger . New ( "module" , module ) }
2443	func ( i * Image ) DrawTriangles ( img * Image , vertices [ ] float32 , indices [ ] uint16 , colorm * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) { if i . priority { panic ( "restorable: DrawTriangles cannot be called on a priority image" ) } if len ( vertices ) == 0 { return } theImages . makeStaleIfDependingOn ( i ) if img . stale || img . volatile || i . screen || ! IsRestoringEnabled ( ) || i . volatile { i . makeStale ( ) } else { i . appendDrawTrianglesHistory ( img , vertices , indices , colorm , mode , filter , address ) } i . image . DrawTriangles ( img . image , vertices , indices , colorm , mode , filter , address ) }
2095	func ( m * MockCNI ) DelNetworkList ( arg0 * libcni . NetworkConfigList , arg1 * libcni . RuntimeConf ) error { ret := m . ctrl . Call ( m , "DelNetworkList" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
5053	func ( c * Collection ) Count ( ) ( n int , err error ) { return c . Find ( nil ) . Count ( ) }
4427	func ( u UUID ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
4404	func ( b * Base64 ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { * b = Base64 ( data ) return nil } return errors . New ( "couldn't unmarshal bson raw value as Base64" ) }
3992	func getGTLDData ( ) ( [ ] util . GTLDPeriod , error ) { respBody , err := getData ( ICANN_GTLD_JSON ) if err != nil { return nil , fmt . Errorf ( "error getting ICANN gTLD JSON : %s" , err ) } var results struct { GTLDs [ ] util . GTLDPeriod } if err := json . Unmarshal ( respBody , & results ) ; err != nil { return nil , fmt . Errorf ( "unexpected error unmarshaling ICANN gTLD JSON response " + "body from %q : %s" , ICANN_GTLD_JSON , err ) } return results . GTLDs , nil }
3298	func ( e * Event ) GetAlertType ( ) string { if e == nil || e . AlertType == nil { return "" } return * e . AlertType }
5205	func ( idx * Index ) Field ( name string , options ... FieldOption ) * Field { if field , ok := idx . fields [ name ] ; ok { return field } fieldOptions := & FieldOptions { } fieldOptions = fieldOptions . withDefaults ( ) fieldOptions . addOptions ( options ... ) return idx . fieldWithOptions ( name , fieldOptions ) }
1230	func ( client * cniClient ) ReleaseIPResource ( cfg * Config ) error { runtimeConfig := libcni . RuntimeConf { ContainerID : cfg . ContainerID , NetNS : fmt . Sprintf ( netnsFormat , cfg . ContainerPID ) , } seelog . Debugf ( "[ECSCNI] Releasing the ip resource from ipam db, id: [%s], ip: [%v]" , cfg . ID , cfg . IPAMV4Address ) os . Setenv ( "ECS_CNI_LOGLEVEL" , logger . GetLevel ( ) ) defer os . Unsetenv ( "ECS_CNI_LOGLEVEL" ) return client . del ( runtimeConfig , cfg , client . createIPAMNetworkConfig ) }
5012	func pack9 ( in [ ] uint32 ) uint32 { return 2 << 28 | in [ 0 ] << 1 | in [ 1 ] << 4 | in [ 2 ] << 7 | in [ 3 ] << 10 | in [ 4 ] << 13 | in [ 5 ] << 16 | in [ 6 ] << 19 | in [ 7 ] << 22 | in [ 8 ] << 25 }
2356	func ( b * Board ) Update ( input * Input ) error { for t := range b . tiles { if err := t . Update ( ) ; err != nil { return err } } if 0 < len ( b . tasks ) { t := b . tasks [ 0 ] if err := t ( ) ; err == taskTerminated { b . tasks = b . tasks [ 1 : ] } else if err != nil { return err } return nil } if dir , ok := input . Dir ( ) ; ok { if err := b . Move ( dir ) ; err != nil { return err } } return nil }
2386	func ( f * Field ) flushable ( ) bool { for j := fieldBlockNumY - 1 ; 0 <= j ; j -- { if f . flushableLine ( j ) { return true } } return false }
6150	func ( w * Worker ) AgentAfterUncooperativeCloseRequest ( job * data . Job ) error { logger := w . logger . Add ( "method" , "AgentAfterUncooperativeCloseRequest" , "job" , job ) channel , err := w . relatedChannel ( logger , job , data . JobAgentAfterUncooperativeCloseRequest ) if err != nil { return err } logger = logger . Add ( "channel" , channel ) if channel . ServiceStatus != data . ServiceTerminated { _ , err = w . processor . TerminateChannel ( channel . ID , data . JobTask , true ) if err != nil { logger . Error ( err . Error ( ) ) return ErrTerminateChannel } } channel . ChannelStatus = data . ChannelInChallenge if err = w . db . Update ( channel ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil }
3936	func NewPinger ( ) * Pinger { rand . Seed ( time . Now ( ) . UnixNano ( ) ) return & Pinger { id : rand . Intn ( 0xffff ) , seq : rand . Intn ( 0xffff ) , addrs : make ( map [ string ] * net . IPAddr ) , network : "ip" , source : "" , source6 : "" , hasIPv4 : false , hasIPv6 : false , Size : TimeSliceLength , MaxRTT : time . Second , OnRecv : nil , OnIdle : nil , Debug : false , } }
3309	func ( e * Event ) HasSourceType ( ) bool { if e != nil && e . SourceType != nil { return true } return false }
542	func ( c * Cookie ) AppendBytes ( dst [ ] byte ) [ ] byte { if len ( c . key ) > 0 { dst = append ( dst , c . key ... ) dst = append ( dst , '=' ) } dst = append ( dst , c . value ... ) if c . maxAge > 0 { dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieMaxAge ... ) dst = append ( dst , '=' ) dst = AppendUint ( dst , c . maxAge ) } else if ! c . expire . IsZero ( ) { c . bufKV . value = AppendHTTPDate ( c . bufKV . value [ : 0 ] , c . expire ) dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieExpires ... ) dst = append ( dst , '=' ) dst = append ( dst , c . bufKV . value ... ) } if len ( c . domain ) > 0 { dst = appendCookiePart ( dst , strCookieDomain , c . domain ) } if len ( c . path ) > 0 { dst = appendCookiePart ( dst , strCookiePath , c . path ) } if c . httpOnly { dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieHTTPOnly ... ) } if c . secure { dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSecure ... ) } switch c . sameSite { case CookieSameSiteDefaultMode : dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSameSite ... ) case CookieSameSiteLaxMode : dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSameSite ... ) dst = append ( dst , '=' ) dst = append ( dst , strCookieSameSiteLax ... ) case CookieSameSiteStrictMode : dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSameSite ... ) dst = append ( dst , '=' ) dst = append ( dst , strCookieSameSiteStrict ... ) } return dst }
4609	func ( p * Palette ) callLine ( line * stack . Call , srcLen , pkgLen int , fullPath bool ) string { src := "" if fullPath { src = line . FullSrcLine ( ) } else { src = line . SrcLine ( ) } return fmt . Sprintf ( " %s%-*s %s%-*s %s%s%s(%s)%s" , p . Package , pkgLen , line . Func . PkgName ( ) , p . SrcFile , srcLen , src , p . functionColor ( line ) , line . Func . Name ( ) , p . Arguments , & line . Args , p . EOLReset ) }
3506	func ( s * Series ) HasUnits ( ) bool { if s != nil && s . Units != nil { return true } return false }
318	func ( b * BufferedSeriesIterator ) Reset ( it SeriesIterator ) { b . it = it b . lastTime = math . MinInt64 b . ok = true b . buf . reset ( ) b . buf . delta = b . delta it . Next ( ) }
4140	func ( n Network ) Contains ( nn NetworkNumber ) bool { if len ( n . Mask ) != len ( nn ) { return false } if nn [ 0 ] & n . Mask [ 0 ] != n . Number [ 0 ] { return false } if len ( nn ) == IPv6Uint32Count { return nn [ 1 ] & n . Mask [ 1 ] == n . Number [ 1 ] && nn [ 2 ] & n . Mask [ 2 ] == n . Number [ 2 ] && nn [ 3 ] & n . Mask [ 3 ] == n . Number [ 3 ] } return true }
3924	func ( d * directiveParser ) LoadFiles ( paths [ ] string ) error { d . lock . Lock ( ) defer d . lock . Unlock ( ) filenames , err := pathsToFileGlobs ( paths ) if err != nil { return err } for _ , filename := range filenames { ranges := d . parseFile ( filename ) sort . Sort ( ranges ) d . files [ filename ] = ranges } return nil }
435	func SaveMultipartFile ( fh * multipart . FileHeader , path string ) error { f , err := fh . Open ( ) if err != nil { return err } if ff , ok := f . ( * os . File ) ; ok { if err := f . Close ( ) ; err != nil { return err } if os . Rename ( ff . Name ( ) , path ) == nil { return nil } f , err = fh . Open ( ) if err != nil { return err } } defer f . Close ( ) ff , err := os . Create ( path ) if err != nil { return err } defer ff . Close ( ) _ , err = copyZeroAlloc ( ff , f ) return err }
1828	func ( mtask * managedTask ) handleResourceStateChange ( resChange resourceStateChange ) { res := resChange . resource if ! mtask . isResourceFound ( res ) { seelog . Criticalf ( "Managed task [%s]: state error; invoked with another task's resource [%s]" , mtask . Arn , res . GetName ( ) ) return } status := resChange . nextState err := resChange . err currentKnownStatus := res . GetKnownStatus ( ) if status <= currentKnownStatus { seelog . Infof ( "Managed task [%s]: redundant resource state change. %s to %s, but already %s" , mtask . Arn , res . GetName ( ) , res . StatusString ( status ) , res . StatusString ( currentKnownStatus ) ) return } if err == nil { res . SetKnownStatus ( status ) mtask . engine . saver . Save ( ) return } seelog . Debugf ( "Managed task [%s]: error while transitioning resource %s to %s: %v" , mtask . Arn , res . GetName ( ) , res . StatusString ( status ) , err ) if status == res . SteadyState ( ) { seelog . Errorf ( "Managed task [%s]: error while creating resource %s, setting the task's desired status to STOPPED" , mtask . Arn , res . GetName ( ) ) mtask . SetDesiredStatus ( apitaskstatus . TaskStopped ) mtask . Task . SetTerminalReason ( res . GetTerminalReason ( ) ) mtask . engine . saver . Save ( ) } }
4523	func ( x * XargsFilter ) LimitArgs ( n int ) * XargsFilter { x . limitArgs = n return x }
1138	func ( NetLinkClient ) LinkByName ( name string ) ( netlink . Link , error ) { return netlink . LinkByName ( name ) }
5961	func ( s Scan ) CreateNmapArgs ( ) ( [ ] string , error ) { args := [ ] string { "-oX" , "-" } const seperator string = "," portList := "" portList += strings . Join ( uint16ListToStringList ( s . configPorts ) , seperator ) if len ( s . configUDPPorts ) != 0 { if portList != "" { portList += "," } portList += "U:" } portList += strings . Join ( uint16ListToStringList ( s . configUDPPorts ) , seperator ) if len ( s . configTCPPorts ) != 0 { if portList != "" { portList += "," } portList += "T:" } portList += strings . Join ( uint16ListToStringList ( s . configTCPPorts ) , seperator ) tcpOptions := [ ] string { "-sS" , "-sT" , "-sA" , "-sW" , "-sM" } iflag := array . Intersection ( tcpOptions , s . configOpts ) . ( [ ] string ) if len ( iflag ) == 0 { s . configOpts = append ( s . configOpts , tcpOptions [ 1 ] ) } if len ( s . configUDPPorts ) != 0 && ! array . In ( "-sU" , s . configOpts ) { s . configOpts = append ( s . configOpts , "-sU" ) } args = append ( args , s . configOpts ... ) if portList != "" { args = append ( args , "-p" + portList ) } if len ( s . configHosts ) == 0 { s . configErr = errors . New ( "No hosts added" ) } args = append ( args , s . configHosts ... ) fmt . Println ( args ) return args , nil }
1787	func ( m * MockClientServer ) SetConnection ( arg0 wsconn . WebsocketConn ) { m . ctrl . Call ( m , "SetConnection" , arg0 ) }
4327	func ( c * Client ) DeleteCheckoutKey ( account , repo , fingerprint string ) error { return c . request ( "DELETE" , fmt . Sprintf ( "project/%s/%s/checkout-key/%s" , account , repo , fingerprint ) , nil , nil , nil ) }
5787	func ( a * API ) UpdateAnnotation ( cfg * Annotation ) ( * Annotation , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid annotation config [nil]" ) } annotationCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . AnnotationCIDRegex , annotationCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid annotation CID [%s]" , annotationCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update annotation, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( annotationCID , jsonCfg ) if err != nil { return nil , err } annotation := & Annotation { } if err := json . Unmarshal ( result , annotation ) ; err != nil { return nil , err } return annotation , nil }
3452	func ( q * QueryConfig ) GetLogSet ( ) LogSet { if q == nil || q . LogSet == nil { return LogSet { } } return * q . LogSet }
4263	func killCgroupProcesses ( m cgroups . Manager ) error { var procs [ ] * os . Process if err := m . Freeze ( configs . Frozen ) ; err != nil { logrus . Warn ( err ) } pids , err := m . GetPids ( ) if err != nil { m . Freeze ( configs . Thawed ) return err } for _ , pid := range pids { if p , err := os . FindProcess ( pid ) ; err == nil { procs = append ( procs , p ) if err := p . Kill ( ) ; err != nil { logrus . Warn ( err ) } } } if err := m . Freeze ( configs . Thawed ) ; err != nil { logrus . Warn ( err ) } for _ , p := range procs { if _ , err := p . Wait ( ) ; err != nil { logrus . Warn ( err ) } } return nil }
791	func ( sdr * AWSSDRegistry ) ApplyChanges ( changes * plan . Changes ) error { filteredChanges := & plan . Changes { Create : changes . Create , UpdateNew : filterOwnedRecords ( sdr . ownerID , changes . UpdateNew ) , UpdateOld : filterOwnedRecords ( sdr . ownerID , changes . UpdateOld ) , Delete : filterOwnedRecords ( sdr . ownerID , changes . Delete ) , } sdr . updateLabels ( filteredChanges . Create ) sdr . updateLabels ( filteredChanges . UpdateNew ) sdr . updateLabels ( filteredChanges . UpdateOld ) sdr . updateLabels ( filteredChanges . Delete ) return sdr . provider . ApplyChanges ( filteredChanges ) }
1949	func ( containerType * ContainerType ) UnmarshalJSON ( b [ ] byte ) error { strType := string ( b ) switch strType { case "null" : * containerType = ContainerNormal seelog . Warn ( "Unmarshalled nil ContainerType as Normal" ) return nil case "true" : * containerType = ContainerEmptyHostVolume return nil case "false" : * containerType = ContainerNormal return nil } if len ( strType ) < 2 { * containerType = ContainerNormal return errors . New ( "invalid length set for ContainerType: " + string ( b ) ) } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * containerType = ContainerNormal return errors . New ( "invalid value set for ContainerType, must be a string or null; got " + string ( b ) ) } strType = string ( b [ 1 : len ( b ) - 1 ] ) contType , ok := stringToContainerType [ strType ] if ! ok { * containerType = ContainerNormal return errors . New ( "unrecognized ContainerType: " + strType ) } * containerType = contType return nil }
146	func ( p * Pool ) Get ( sz int ) interface { } { for i , bktSize := range p . sizes { if sz > bktSize { continue } b := p . buckets [ i ] . Get ( ) if b == nil { b = p . make ( bktSize ) } return b } return p . make ( sz ) }
1505	func NewASMSecretResource ( taskARN string , asmSecrets map [ string ] apicontainer . Secret , executionCredentialsID string , credentialsManager credentials . Manager , asmClientCreator factory . ClientCreator ) * ASMSecretResource { s := & ASMSecretResource { taskARN : taskARN , requiredSecrets : asmSecrets , credentialsManager : credentialsManager , executionCredentialsID : executionCredentialsID , asmClientCreator : asmClientCreator , } s . initStatusToTransition ( ) return s }
113	func ( t * Timer ) String ( ) string { return fmt . Sprintf ( "%s: %s" , t . name , t . duration ) }
6991	func ( ctx * ResCtx ) Result ( v interface { } ) error { if ! ctx . Success { return errors . New ( "ctx: cannot read result data since server returned an error" ) } if ctx . result == nil { return errors . New ( "ctx: server did not return any response data" ) } if err := json . Unmarshal ( ctx . result , v ) ; err != nil { return fmt . Errorf ( "ctx: cannot deserialize response result: %v" , err ) } return nil }
6578	func DisableServiceFlapDetection ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "DISABLE_SERVICE_FLAP_DETECTION" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
529	func ( fs * FS ) NewRequestHandler ( ) RequestHandler { fs . once . Do ( fs . initRequestHandler ) return fs . h }
3426	func ( o * Options ) GetNewHostDelayOk ( ) ( int , bool ) { if o == nil || o . NewHostDelay == nil { return 0 , false } return * o . NewHostDelay , true }
5904	func NewHMACSigner ( alg Algorithm ) func ( Store , crypto . Hash ) ( Signer , error ) { return func ( store Store , hash crypto . Hash ) ( Signer , error ) { var ok bool var keyRaw interface { } var key [ ] byte if keyRaw , ok = store . PrivateKey ( ) ; ! ok { return nil , ErrMissingPrivateKey } if key , ok = keyRaw . ( [ ] byte ) ; ! ok { return nil , ErrInvalidPrivateKey } return & HmacSigner { alg : alg , hash : hash , key : key , } , nil } }
3423	func ( o * Options ) GetLockedOk ( ) ( bool , bool ) { if o == nil || o . Locked == nil { return false , false } return * o . Locked , true }
6169	func ( h * Handler ) Offering ( hash data . HexString ) ( * data . Base64String , error ) { logger := h . logger . Add ( "method" , "Offering" ) offering , err := h . offeringByHash ( logger , hash ) if err != nil { if err == ErrOfferingNotFound { logger . Warn ( "unexpected request for offering: " + string ( hash ) ) } return nil , err } return & offering . RawMsg , nil }
5928	func PostCountTime ( statKey , userKey string , count int , timestamp int64 ) error { return DefaultReporter . PostCountTime ( statKey , userKey , count , timestamp ) }
1611	func ( m * MockSecretsManagerAPI ) RestoreSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . RestoreSecretInput , arg2 ... request . Option ) ( * secretsmanager . RestoreSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "RestoreSecretWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RestoreSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6795	func Subscribe ( channels [ ] string ) ( Channel , error ) { if hubInstance == nil { return nil , errorNohub } r , err := hubInstance . Subscribe ( channels ) if err != nil { log . Errorf ( "pubsub subscribe failed: %+v" , err ) return nil , err } log . Debug ( "subscibe to %v" , channels ) return r , nil }
5492	func ( ipn * IncomingNumberService ) Release ( ctx context . Context , sid string ) error { return ipn . client . DeleteResource ( ctx , numbersPathPart , sid ) }
3091	func ( ctx * Context ) SetSuperSecureCookie ( secret , name , value string , others ... interface { } ) { key := pbkdf2 . Key ( [ ] byte ( secret ) , [ ] byte ( secret ) , 1000 , 16 , sha256 . New ) text , err := com . AESGCMEncrypt ( key , [ ] byte ( value ) ) if err != nil { panic ( "error encrypting cookie: " + err . Error ( ) ) } ctx . SetCookie ( name , hex . EncodeToString ( text ) , others ... ) }
6274	func ( h * Handler ) AuthClient ( product , productPassword , clientKey , clientPassword string ) error { logger := h . logger . Add ( "method" , "AuthClient" , "product" , product , "clientKey" , clientKey ) logger . Info ( "session auth request" ) prod , err := h . checkProductPassword ( logger , product , productPassword ) if err != nil { return err } ch , err := h . findClientChannel ( logger , prod , clientKey , false ) if err != nil { return err } err = data . ValidatePassword ( ch . Password , clientPassword , string ( ch . Salt ) ) if err != nil { logger . Warn ( "failed to validate client password: " + err . Error ( ) ) return ErrBadClientPassword } return nil }
1459	func ( c * Container ) GetDesiredStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . DesiredStatusUnsafe }
7201	func ( r * Route ) Options ( pat string , f ... HandlerFunc ) { r . HandleMethod ( pat , "OPTIONS" , f ... ) }
530	func FileLastModified ( path string ) ( time . Time , error ) { f , err := os . Open ( path ) if err != nil { return zeroTime , err } fileInfo , err := f . Stat ( ) f . Close ( ) if err != nil { return zeroTime , err } return fsModTime ( fileInfo . ModTime ( ) ) , nil }
4776	func Load ( conf interface { } , configPaths ... string ) error { return loadWithFunc ( conf , configPaths , nil , yaml . Unmarshal ) }
6272	func ( t * SimpleToken ) Make ( ) ( string , error ) { b := make ( [ ] byte , 32 ) _ , err := rand . Read ( b ) if err != nil { return "" , err } t . mtx . Lock ( ) defer t . mtx . Unlock ( ) t . token = string ( data . FromBytes ( b ) ) return t . token , nil }
5860	func ( a * API ) DeleteWorksheet ( cfg * Worksheet ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid worksheet config [nil]" ) } return a . DeleteWorksheetByCID ( CIDType ( & cfg . CID ) ) }
3662	func ( w * Widget ) GetBgcolorOk ( ) ( string , bool ) { if w == nil || w . Bgcolor == nil { return "" , false } return * w . Bgcolor , true }
4638	func ( points * PointsIndex ) Range ( topLeft Point , bottomRight Point ) [ ] Point { entries := points . index . Range ( topLeft , bottomRight ) accept := func ( point Point ) bool { return between ( point . Lat ( ) , bottomRight . Lat ( ) , topLeft . Lat ( ) ) && between ( point . Lon ( ) , topLeft . Lon ( ) , bottomRight . Lon ( ) ) } return getPoints ( entries , accept ) }
3719	func ( w * Widget ) GetTextSizeOk ( ) ( string , bool ) { if w == nil || w . TextSize == nil { return "" , false } return * w . TextSize , true }
5496	func ( cpnps * CountryPhoneNumberPriceService ) Get ( ctx context . Context , isoCountry string ) ( * NumberPrice , error ) { numberPrice := new ( NumberPrice ) err := cpnps . client . GetResource ( ctx , phoneNumbersPathPart + "/Countries" , isoCountry , numberPrice ) return numberPrice , err }
4024	func ( l * Label ) SetTextDisplay ( align Align ) { if align != AlignLeft && align != AlignRight { return } l . textDisplay = align }
3314	func ( g * GraphDefinition ) GetIncludeNoMetricHostsOk ( ) ( bool , bool ) { if g == nil || g . IncludeNoMetricHosts == nil { return false , false } return * g . IncludeNoMetricHosts , true }
6466	func ( sb * syncBuffer ) rotateFile ( now time . Time ) error { if sb . file != nil { sb . Flush ( ) sb . file . Close ( ) } var err error sb . file , _ , err = sb . logger . create ( severityName [ sb . sev ] , now ) sb . nbytes = 0 if err != nil { return err } sb . Writer = bufio . NewWriterSize ( sb . file , bufferSize ) var buf bytes . Buffer fmt . Fprintf ( & buf , "Log file created at: %s\n" , \n ) now . Format ( "2006/01/02 15:04:05" ) fmt . Fprintf ( & buf , "Running on machine: %s\n" , \n ) host fmt . Fprintf ( & buf , "Binary: Built with %s %s for %s/%s\n" , \n , runtime . Compiler , runtime . Version ( ) , runtime . GOOS ) runtime . GOARCH fmt . Fprintf ( & buf , "Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg\n" ) }
1797	func ( m * MockDockerClient ) APIVersion ( ) ( dockerclient . DockerVersion , error ) { ret := m . ctrl . Call ( m , "APIVersion" ) ret0 , _ := ret [ 0 ] . ( dockerclient . DockerVersion ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5834	func ( a * API ) UpdateDashboard ( cfg * Dashboard ) ( * Dashboard , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid dashboard config [nil]" ) } dashboardCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . DashboardCIDRegex , dashboardCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid dashboard CID [%s]" , dashboardCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update dashboard, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( dashboardCID , jsonCfg ) if err != nil { return nil , err } dashboard := & Dashboard { } if err := json . Unmarshal ( result , dashboard ) ; err != nil { return nil , err } return dashboard , nil }
5657	func ( kb dbKeybase ) Update ( name , oldpass , newpass string ) error { info , err := kb . Get ( name ) if err != nil { return err } switch info . ( type ) { case localInfo : linfo := info . ( localInfo ) key , err := unarmorDecryptPrivKey ( linfo . PrivKeyArmor , oldpass ) if err != nil { return err } kb . writeLocalKey ( key , name , newpass ) return nil default : return fmt . Errorf ( "Locally stored key required" ) } }
2488	func ( i * Image ) Size ( ) ( width , height int ) { s := i . Bounds ( ) . Size ( ) return s . X , s . Y }
6843	func ( c * Client ) PushLinkToChannel ( tag , title , u , body string ) error { data := Link { Tag : tag , Type : "link" , Title : title , URL : u , Body : body , } return c . Push ( "/pushes" , data ) }
2589	func Customize ( vm * object . VirtualMachine , spec types . CustomizationSpec ) error { log . Printf ( "[DEBUG] Sending customization spec to virtual machine %q" , vm . InventoryPath ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := vm . Customize ( ctx , spec ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) return task . Wait ( tctx ) }
4500	func ( f * defaultFormats ) Parse ( name , data string ) ( interface { } , error ) { f . Lock ( ) defer f . Unlock ( ) nme := f . normalizeName ( name ) for _ , v := range f . data { if v . Name == nme { nw := reflect . New ( v . Type ) . Interface ( ) if dec , ok := nw . ( encoding . TextUnmarshaler ) ; ok { if err := dec . UnmarshalText ( [ ] byte ( data ) ) ; err != nil { return nil , err } return nw , nil } return nil , errors . InvalidTypeName ( name ) } } return nil , errors . InvalidTypeName ( name ) }
4943	func ( c * Connector ) SessionVariables ( ) SessionVariables { c . mu . RLock ( ) defer c . mu . RUnlock ( ) return c . sessionVariables }
1556	func ( mr * MockUdevMockRecorder ) Monitor ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Monitor" , reflect . TypeOf ( ( * MockUdev ) ( nil ) . Monitor ) , arg0 ) }
6769	func ( na * NetAddress ) ReachabilityTo ( o * NetAddress ) int { const ( Unreachable = 0 Default = iota Teredo Ipv6_weak Ipv4 Ipv6_strong Private ) if ! na . Routable ( ) { return Unreachable } else if na . RFC4380 ( ) { if ! o . Routable ( ) { return Default } else if o . RFC4380 ( ) { return Teredo } else if o . IP . To4 ( ) != nil { return Ipv4 } else { return Ipv6_weak } } else if na . IP . To4 ( ) != nil { if o . Routable ( ) && o . IP . To4 ( ) != nil { return Ipv4 } return Default } else { var tunnelled bool if o . RFC3964 ( ) || o . RFC6052 ( ) || o . RFC6145 ( ) { tunnelled = true } if ! o . Routable ( ) { return Default } else if o . RFC4380 ( ) { return Teredo } else if o . IP . To4 ( ) != nil { return Ipv4 } else if tunnelled { return Ipv6_weak } return Ipv6_strong } }
7261	func parseMatcher ( pat string ) ( matcher Matcher , name string ) { if ! isMatchPattern ( pat ) { panic ( "pattern \"" + \" + pat ) } "\" is not a matcher pattern" \" s := pat [ 1 : len ( pat ) - 1 ] ss := strings . Split ( s , ":" ) var matchType string if len ( ss ) == 1 { name = ss [ 0 ] } else { matchType = ss [ 0 ] name = ss [ 1 ] } if matchType == "" { matchType = "default" } matcher = MatcherMap [ matchType ] }
3499	func ( s * Series ) GetLengthOk ( ) ( int , bool ) { if s == nil || s . Length == nil { return 0 , false } return * s . Length , true }
2769	func flattenVAppConfig ( d * schema . ResourceData , config types . BaseVmConfigInfo ) error { if config == nil { d . Set ( "vapp_transport" , [ ] string { } ) return nil } d . Set ( "vapp_transport" , config . GetVmConfigInfo ( ) . OvfEnvironmentTransport ) props := config . GetVmConfigInfo ( ) . Property if len ( props ) < 1 { return nil } vac := make ( map [ string ] interface { } ) for _ , v := range props { if v . Value != "" && v . Value != v . DefaultValue { vac [ v . Id ] = v . Value } } if len ( vac ) > 0 { return d . Set ( "vapp" , [ ] interface { } { map [ string ] interface { } { "properties" : vac , } , } ) } return nil }
1903	func ( engine * DockerTaskEngine ) GetTaskByArn ( arn string ) ( * apitask . Task , bool ) { return engine . state . TaskByArn ( arn ) }
712	func ( p * AlibabaCloudProvider ) recordsForDNS ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { records , err := p . records ( ) if err != nil { return nil , err } for _ , recordList := range p . groupRecords ( records ) { name := p . getDNSName ( recordList [ 0 ] . RR , recordList [ 0 ] . DomainName ) recordType := recordList [ 0 ] . Type ttl := recordList [ 0 ] . TTL if ttl == defaultAlibabaCloudRecordTTL { ttl = 0 } var targets [ ] string for _ , record := range recordList { target := record . Value if recordType == "TXT" { target = p . unescapeTXTRecordValue ( target ) } targets = append ( targets , target ) } ep := endpoint . NewEndpointWithTTL ( name , recordType , endpoint . TTL ( ttl ) , targets ... ) endpoints = append ( endpoints , ep ) } return endpoints , nil }
5573	func ( c * FakeClient ) Fetch ( instanceID string ) ( registry . AgentSettings , error ) { c . FetchCalled = true return c . FetchSettings , c . FetchErr }
1003	func FromPath ( path string ) ( * Config , error ) { if _ , err := os . Stat ( path ) ; os . IsNotExist ( err ) { return nil , errors . Wrap ( err , "missing file/folder: " + path ) } stat , err := os . Stat ( path ) if err != nil { return nil , errors . Wrap ( err , "failed stating file: " + path ) } if stat . Mode ( ) . IsDir ( ) { _ , err := ioutil . ReadDir ( path ) if err != nil { return nil , errors . Wrap ( err , "failed listing dir: " + path ) } var c * Config err = filepath . Walk ( path , func ( path string , info os . FileInfo , err error ) error { if err != nil { return err } if info . IsDir ( ) { return nil } newConfig , err := FromFile ( path ) if err != nil { return err } c = c . Merge ( newConfig ) return nil } ) if err != nil { return nil , errors . Wrap ( err , "walk error" ) } return c , nil } else if stat . Mode ( ) . IsRegular ( ) { return FromFile ( path ) } return nil , fmt . Errorf ( "unknown filetype: %q" , stat . Mode ( ) . String ( ) ) }
6906	func ( e * Edit ) SetText ( s * string , end bool ) { e . target = s e . display = [ ] rune ( * s ) e . at = 0 ev := termbox . Event { } if end { ev . Key = termbox . KeyCtrlE } else { ev . Key = termbox . KeyCtrlA } e . KeyHandler ( ev ) }
3519	func ( s * SyntheticsDevice ) HasIsMobile ( ) bool { if s != nil && s . IsMobile != nil { return true } return false }
7063	func SetErrorHandler ( status int , handler ErrorHandler ) scaffold . Middleware { return scaffold . Middleware ( func ( next scaffold . Handler ) scaffold . Handler { return scaffold . HandlerFunc ( func ( ctx context . Context , w http . ResponseWriter , r * http . Request ) { key := fmt . Sprintf ( "error_handler_%d" , status ) ctx = context . WithValue ( ctx , key , handler ) next . CtxServeHTTP ( ctx , w , r ) } ) } ) }
6322	func ( r * Request ) QueryValue ( key string ) string { return r . URL . Query ( ) . Get ( key ) }
6428	func ( q * Queue ) ToSlice ( ) [ ] interface { } { q . key . RLock ( ) defer q . key . RUnlock ( ) if q . underlyer == nil { return [ ] interface { } { } } return q . underlyer . ToSlice ( ) }
2459	func MoveTiles ( tiles map [ * Tile ] struct { } , size int , dir Dir ) bool { vx , vy := dir . Vector ( ) tx := [ ] int { } ty := [ ] int { } for i := 0 ; i < size ; i ++ { tx = append ( tx , i ) ty = append ( ty , i ) } if vx > 0 { sort . Sort ( sort . Reverse ( sort . IntSlice ( tx ) ) ) } if vy > 0 { sort . Sort ( sort . Reverse ( sort . IntSlice ( ty ) ) ) } moved := false for _ , j := range ty { for _ , i := range tx { t := tileAt ( tiles , i , j ) if t == nil { continue } if t . next != ( TileData { } ) { panic ( "not reach" ) } if t . IsMoving ( ) { panic ( "not reach" ) } ii := i jj := j for { ni := ii + vx nj := jj + vy if ni < 0 || ni >= size || nj < 0 || nj >= size { break } tt := currentOrNextTileAt ( tiles , ni , nj ) if tt == nil { ii = ni jj = nj moved = true continue } if t . current . value != tt . current . value { break } if 0 < tt . movingCount && tt . current . value != tt . next . value { break } ii = ni jj = nj moved = true break } next := TileData { } next . value = t . current . value if tt := currentOrNextTileAt ( tiles , ii , jj ) ; tt != t && tt != nil { next . value = t . current . value + tt . current . value tt . next . value = 0 tt . next . x = ii tt . next . y = jj tt . movingCount = maxMovingCount } next . x = ii next . y = jj if t . current != next { t . next = next t . movingCount = maxMovingCount } } } if ! moved { for t := range tiles { t . next = TileData { } t . movingCount = 0 } } return moved }
1097	func serviceFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( [ ] * dep . HealthService , error ) { return func ( s ... string ) ( [ ] * dep . HealthService , error ) { result := [ ] * dep . HealthService { } if len ( s ) == 0 || s [ 0 ] == "" { return result , nil } d , err := dep . NewHealthServiceQuery ( strings . Join ( s , "|" ) ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] * dep . HealthService ) , nil } missing . Add ( d ) return result , nil } }
7016	func ( e * Encoder ) Parser ( r * http . Request ) Parser { contentType := r . Header . Get ( "Content-Type" ) info := parseMimeInfo ( contentType ) if info != nil { for encoding , i := range e . encodings { if i . equals ( info ) { return encoding } } } return e . defaultEncoding }
5304	func ( c * Cmp ) CompareFile ( path1 , path2 string ) ( bool , error ) { if c . Opt . MaxSize < 0 { return false , fmt . Errorf ( "negative MaxSize" ) } r1 , openErr1 := os . Open ( path1 ) if openErr1 != nil { return false , openErr1 } defer r1 . Close ( ) info1 , statErr1 := r1 . Stat ( ) if statErr1 != nil { return false , statErr1 } r2 , openErr2 := os . Open ( path2 ) if openErr2 != nil { return false , openErr2 } defer r2 . Close ( ) info2 , statErr2 := r2 . Stat ( ) if statErr2 != nil { return false , statErr2 } if ! c . Opt . ForceFileRead { if os . SameFile ( info1 , info2 ) { c . debugf ( "CompareFile(%s,%s): os reported same file\n" , \n , path1 ) path2 } } return true , nil if info1 . Mode ( ) . IsRegular ( ) && info2 . Mode ( ) . IsRegular ( ) { if info1 . Size ( ) != info2 . Size ( ) { c . debugf ( "CompareFile(%s,%s): distinct file sizes\n" , \n , path1 ) path2 } } return false , nil maxSize := c . Opt . MaxSize if maxSize == 0 { maxSize = info1 . Size ( ) if maxSize < info2 . Size ( ) { maxSize = info2 . Size ( ) } if maxSize == 0 { maxSize = defaultMaxSize } } if c . multipleMode ( ) { h1 , err1 := c . getHash ( path1 , maxSize ) if err1 != nil { return false , err1 } h2 , err2 := c . getHash ( path2 , maxSize ) if err2 != nil { return false , err2 } if ! bytes . Equal ( h1 , h2 ) { return false , nil } if ! c . hashMatchCompare { return true , nil } c . debugf ( "CompareFile(%s,%s): hash match, will compare bytes\n" , \n , path1 ) } path2 c . resetDebugging ( ) }
1267	func NewMockClientCreator ( ctrl * gomock . Controller ) * MockClientCreator { mock := & MockClientCreator { ctrl : ctrl } mock . recorder = & MockClientCreatorMockRecorder { mock } return mock }
2012	func IAMRoleCredentialsFromACS ( roleCredentials * ecsacs . IAMRoleCredentials , roleType string ) IAMRoleCredentials { return IAMRoleCredentials { CredentialsID : aws . StringValue ( roleCredentials . CredentialsId ) , SessionToken : aws . StringValue ( roleCredentials . SessionToken ) , RoleArn : aws . StringValue ( roleCredentials . RoleArn ) , AccessKeyID : aws . StringValue ( roleCredentials . AccessKeyId ) , SecretAccessKey : aws . StringValue ( roleCredentials . SecretAccessKey ) , Expiration : aws . StringValue ( roleCredentials . Expiration ) , RoleType : roleType , } }
1437	func ( state * DockerTaskEngineState ) ContainerMapByArn ( arn string ) ( map [ string ] * apicontainer . DockerContainer , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) ret , ok := state . taskToID [ arn ] if ok { mc := make ( map [ string ] * apicontainer . DockerContainer ) for k , v := range ret { mc [ k ] = v } return mc , ok } return ret , ok }
4343	func BuildDvorak ( ) Graph { data , err := data . Asset ( "data/Dvorak.json" ) if err != nil { panic ( "Can't find asset" ) } return getAdjancencyGraphFromFile ( data , "dvorak" ) }
2937	func resourceVSphereDatastoreClusterApplyCustomAttributes ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { client := meta . ( * VSphereClient ) . vimClient attrsProcessor , err := customattribute . GetDiffProcessorIfAttributesDefined ( client , d ) if err != nil { return err } if attrsProcessor == nil { log . Printf ( "[DEBUG] %s: Custom attributes unsupported on this connection, skipping" , resourceVSphereDatastoreClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying any pending custom attributes" , resourceVSphereDatastoreClusterIDString ( d ) ) return attrsProcessor . ProcessDiff ( pod ) }
5670	func ( ft * FunctionType ) printArgs ( ps * printState ) { paren := false space := false for i := len ( ps . inner ) - 1 ; i >= 0 ; i -- { switch ps . inner [ i ] . ( type ) { case * PointerType , * ReferenceType , * RvalueReferenceType : paren = true case * TypeWithQualifiers , * ComplexType , * ImaginaryType , * PtrMem : space = true paren = true } if paren { break } } if paren { if ! space && ( ps . last != '(' && ps . last != '*' ) { space = true } if space && ps . last != ' ' { ps . writeByte ( ' ' ) } ps . writeByte ( '(' ) } save := ps . printInner ( true ) if paren { ps . writeByte ( ')' ) } ps . writeByte ( '(' ) first := true for _ , a := range ft . Args { if ps . isEmpty ( a ) { continue } if ! first { ps . writeString ( ", " ) } ps . print ( a ) first = false } ps . writeByte ( ')' ) ps . inner = save ps . printInner ( false ) }
6073	func PackWithSignature ( msg [ ] byte , key * ecdsa . PrivateKey ) ( [ ] byte , error ) { sig , err := signature ( key , msg ) if err != nil { return nil , err } return packSignature ( msg , sig ) , nil }
624	func NewTXTRegistry ( provider provider . Provider , txtPrefix , ownerID string , cacheInterval time . Duration ) ( * TXTRegistry , error ) { if ownerID == "" { return nil , errors . New ( "owner id cannot be empty" ) } mapper := newPrefixNameMapper ( txtPrefix ) return & TXTRegistry { provider : provider , ownerID : ownerID , mapper : mapper , cacheInterval : cacheInterval , } , nil }
1360	func mergeTags ( localTags [ ] * ecs . Tag , ec2Tags [ ] * ecs . Tag ) [ ] * ecs . Tag { tagsMap := make ( map [ string ] string ) for _ , ec2Tag := range ec2Tags { tagsMap [ aws . StringValue ( ec2Tag . Key ) ] = aws . StringValue ( ec2Tag . Value ) } for _ , localTag := range localTags { tagsMap [ aws . StringValue ( localTag . Key ) ] = aws . StringValue ( localTag . Value ) } return utils . MapToTags ( tagsMap ) }
5907	func FromFile ( path string , opts ... Option ) ( * GServiceAccount , error ) { buf , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } return FromJSON ( buf , opts ... ) }
3119	func ( g * Graph ) Provide ( objects ... * Object ) error { for _ , o := range objects { o . reflectType = reflect . TypeOf ( o . Value ) o . reflectValue = reflect . ValueOf ( o . Value ) if o . Fields != nil { return fmt . Errorf ( "fields were specified on object %s when it was provided" , o , ) } if o . Name == "" { if ! isStructPtr ( o . reflectType ) { return fmt . Errorf ( "expected unnamed object value to be a pointer to a struct but got type %s " + "with value %v" , o . reflectType , o . Value , ) } if ! o . private { if g . unnamedType == nil { g . unnamedType = make ( map [ reflect . Type ] bool ) } if g . unnamedType [ o . reflectType ] { return fmt . Errorf ( "provided two unnamed instances of type *%s.%s" , o . reflectType . Elem ( ) . PkgPath ( ) , o . reflectType . Elem ( ) . Name ( ) , ) } g . unnamedType [ o . reflectType ] = true } g . unnamed = append ( g . unnamed , o ) } else { if g . named == nil { g . named = make ( map [ string ] * Object ) } if g . named [ o . Name ] != nil { return fmt . Errorf ( "provided two instances named %s" , o . Name ) } g . named [ o . Name ] = o } if g . Logger != nil { if o . created { g . Logger . Debugf ( "created %s" , o ) } else if o . embedded { g . Logger . Debugf ( "provided embedded %s" , o ) } else { g . Logger . Debugf ( "provided %s" , o ) } } } return nil }
2322	func ( v * EventButton ) XRoot ( ) float64 { c := v . native ( ) . x_root return float64 ( c ) }
4964	func Dump ( arr [ ] byte ) string { var buf bytes . Buffer buf . WriteString ( "(" ) buf . WriteString ( fmt . Sprintf ( "%v" , len ( arr ) ) ) buf . WriteString ( " bytes)[" ) for idx , b := range arr { buf . WriteString ( fmt . Sprintf ( "%v" , b ) ) if idx != len ( arr ) - 1 { buf . WriteString ( ", " ) } } buf . WriteString ( "], Hex: [" ) for idx , b := range arr { buf . WriteString ( fmt . Sprintf ( "%X" , b ) ) if idx != len ( arr ) - 1 { buf . WriteString ( " " ) } } buf . WriteString ( "], Base64Url:" ) buf . WriteString ( base64url . Encode ( arr ) ) return buf . String ( ) }
7036	func ( c * Conn ) SendRequest ( method string , params interface { } , resHandler func ( res * ResCtx ) error ) ( reqID string , err error ) { id , err := shortid . UUID ( ) if err != nil { return "" , err } req := request { ID : id , Method : method , Params : params } if err = c . send ( req ) ; err != nil { return "" , err } c . resRoutes . Set ( req . ID , resHandler ) return id , nil }
7315	func ( b * Bus ) Unsubscribe ( h Handler ) bool { b . mu . Lock ( ) defer b . mu . Unlock ( ) for i , v := range b . handlers { if v == h { b . handlers = append ( b . handlers [ : i ] , b . handlers [ i + 1 : ] ... ) return true } } return false }
545	func ( c * Cookie ) Parse ( src string ) error { c . buf = append ( c . buf [ : 0 ] , src ... ) return c . ParseBytes ( c . buf ) }
6895	func Init ( ) error { rawMtx . Lock ( ) defer rawMtx . Unlock ( ) if termRaw { return ErrAlreadyInitialized } err := termbox . Init ( ) if err != nil { return err } bg = termbox . ColorDefault fg = termbox . ColorDefault termbox . HideCursor ( ) termbox . SetInputMode ( termbox . InputAlt ) _ = termbox . Clear ( bg , bg ) maxX , maxY = termbox . Size ( ) _ = termbox . Flush ( ) if ! keyHandler { go initKeyHandler ( ) keyHandler = true } termRaw = true return nil }
1644	func ( * DefaultTime ) After ( d time . Duration ) <- chan time . Time { return time . After ( d ) }
6806	func ( t * T ) Fail ( ) { t . mu . Lock ( ) defer t . mu . Unlock ( ) t . failed = true }
726	func newSdNamespaceFilter ( namespaceTypeConfig string ) * sd . NamespaceFilter { switch namespaceTypeConfig { case sdNamespaceTypePublic : return & sd . NamespaceFilter { Name : aws . String ( sd . NamespaceFilterNameType ) , Values : [ ] * string { aws . String ( sd . NamespaceTypeDnsPublic ) } , } case sdNamespaceTypePrivate : return & sd . NamespaceFilter { Name : aws . String ( sd . NamespaceFilterNameType ) , Values : [ ] * string { aws . String ( sd . NamespaceTypeDnsPrivate ) } , } default : return nil } }
2373	func Decode ( r io . Reader ) ( image . Image , error ) { d := & decoder { r : r , crc : crc32 . NewIEEE ( ) , } if err := d . checkHeader ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return nil , err } for d . stage != dsSeenIEND { if err := d . parseChunk ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return nil , err } } return d . img , nil }
4630	func ( err * Error ) ErrorStack ( ) string { return err . TypeName ( ) + " " + err . Error ( ) + "\n" + \n }
4530	func ( h * Hosts ) Add ( ip string , hosts ... string ) error { if net . ParseIP ( ip ) == nil { return errors . New ( fmt . Sprintf ( "%q is an invalid IP address." , ip ) ) } position := h . getIpPosition ( ip ) if position == - 1 { endLine := NewHostsLine ( buildRawLine ( ip , hosts ) ) h . Lines = append ( h . Lines , endLine ) } else { newHosts := h . Lines [ position ] . Hosts for _ , addHost := range hosts { if itemInSlice ( addHost , newHosts ) { continue } newHosts = append ( newHosts , addHost ) } endLine := NewHostsLine ( buildRawLine ( ip , newHosts ) ) h . Lines [ position ] = endLine } return nil }
4399	func IsEmail ( str string ) bool { addr , e := mail . ParseAddress ( str ) return e == nil && addr . Address != "" }
4381	func UUID3Value ( v * strfmt . UUID3 ) strfmt . UUID3 { if v == nil { return strfmt . UUID3 ( "" ) } return * v }
5651	func ( kb dbKeybase ) Recover ( name , passphrase , seedphrase string ) ( Info , error ) { words := strings . Split ( strings . TrimSpace ( seedphrase ) , " " ) secret , err := kb . codec . WordsToBytes ( words ) if err != nil { return nil , err } typ , secret := secret [ 0 ] , secret [ 1 : ] algo := byteToSignAlgo ( typ ) priv , err := generate ( algo , secret ) if err != nil { return nil , err } public := kb . writeLocalKey ( priv , name , passphrase ) return public , nil }
5972	func ( otp * HOTP ) YubiKey ( in string ) ( string , string , bool ) { if len ( in ) < otp . Digits { return "" , "" , false } otpStart := len ( in ) - otp . Digits code := in [ otpStart : ] pubid := in [ : otpStart ] return code , pubid , true }
6825	func ( e * EventLog ) Printf ( format string , a ... interface { } ) { newfmt , newvals := addEvent ( e , format , a ... ) Log . Printf ( newfmt , newvals ... ) e . el . Printf ( format , a ... ) }
4894	func ( s * Session ) ExecDirect ( query string ) ( driver . Result , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) if err := s . writeRequest ( mtExecuteDirect , ! s . conn . inTx , command ( query ) ) ; err != nil { return nil , err } if err := s . readReply ( nil ) ; err != nil { return nil , err } if s . sh . functionCode == fcDDL { return driver . ResultNoRows , nil } return driver . RowsAffected ( s . rowsAffected . total ( ) ) , nil }
3977	func NewServer ( address , path string , eventBus Bus ) * Server { server := new ( Server ) server . eventBus = eventBus server . address = address server . path = path server . subscribers = make ( map [ string ] [ ] * SubscribeArg ) server . service = & ServerService { server , & sync . WaitGroup { } , false } return server }
1472	func ( c * Container ) SetCreatedAt ( createdAt time . Time ) { if createdAt . IsZero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . createdAt = createdAt }
3900	func ( p * Package ) typeOf ( e ast . Expr ) types . Type { if T := p . info . TypeOf ( e ) ; T != nil { return T } panic ( fmt . Sprintf ( "no type for %T @ %s" , e , p . Prog . Fset . Position ( e . Pos ( ) ) ) ) }
995	func ( s * Scratch ) init ( ) { if s . values == nil { s . values = make ( map [ string ] interface { } ) } }
2652	func resourceVSphereComputeClusterApplyNameChange ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) ( * object . ClusterComputeResource , error ) { log . Printf ( "[DEBUG] %s: Applying any name changes (old path = %q)" , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) var changed bool var err error if d . HasChange ( "name" ) { if err = clustercomputeresource . Rename ( cluster , d . Get ( "name" ) . ( string ) ) ; err != nil { return nil , fmt . Errorf ( "error renaming cluster: %s" , err ) } changed = true } if changed { cluster , err = resourceVSphereComputeClusterGetCluster ( d , meta ) if err != nil { return nil , fmt . Errorf ( "error refreshing cluster after name change: %s" , err ) } log . Printf ( "[DEBUG] %s: Name changed, new path = %q" , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) } return cluster , nil }
559	func Ping ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( "pong" ) ) }
6030	func ( t Typed ) Objects ( key string ) [ ] Typed { value , _ := t . ObjectsIf ( key ) return value }
7249	func ( l * logger ) Fatalln ( vals ... interface { } ) { l . mut . Lock ( ) defer l . mut . Unlock ( ) s := fmt . Sprintln ( vals ... ) l . logger . Output ( 2 , "FATAL: " + s ) l . callHandlers ( LevelFatal , s ) os . Exit ( 1 ) }
1295	func getClientConfig ( httpClient * http . Client , authData * apicontainer . ECRAuthData ) ( * aws . Config , error ) { cfg := aws . NewConfig ( ) . WithRegion ( authData . Region ) . WithHTTPClient ( httpClient ) if authData . EndpointOverride != "" { cfg . Endpoint = aws . String ( authData . EndpointOverride ) } if authData . UseExecutionRole { if authData . GetPullCredentials ( ) == ( credentials . IAMRoleCredentials { } ) { return nil , fmt . Errorf ( "container uses execution credentials, but the credentials are empty" ) } creds := awscreds . NewStaticCredentials ( authData . GetPullCredentials ( ) . AccessKeyID , authData . GetPullCredentials ( ) . SecretAccessKey , authData . GetPullCredentials ( ) . SessionToken ) cfg = cfg . WithCredentials ( creds ) } return cfg , nil }
4113	func ( b * BarChart ) SetMinBarWidth ( size int32 ) { atomic . StoreInt32 ( & b . barWidth , size ) }
1170	func ( payloadHandler * payloadRequestHandler ) addPayloadTasks ( payload * ecsacs . PayloadMessage ) ( [ ] * ecsacs . IAMRoleCredentialsAckRequest , bool ) { allTasksOK := true validTasks := make ( [ ] * apitask . Task , 0 , len ( payload . Tasks ) ) for _ , task := range payload . Tasks { if task == nil { seelog . Criticalf ( "Received nil task for messageId: %s" , aws . StringValue ( payload . MessageId ) ) allTasksOK = false continue } apiTask , err := apitask . TaskFromACS ( task , payload ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } if task . RoleCredentials != nil { taskIAMRoleCredentials := credentials . IAMRoleCredentialsFromACS ( task . RoleCredentials , credentials . ApplicationRoleType ) err = payloadHandler . credentialsManager . SetTaskCredentials ( & ( credentials . TaskIAMRoleCredentials { ARN : aws . StringValue ( task . Arn ) , IAMRoleCredentials : taskIAMRoleCredentials , } ) ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetCredentialsID ( taskIAMRoleCredentials . CredentialsID ) } if len ( task . ElasticNetworkInterfaces ) != 0 { eni , err := apieni . ENIFromACS ( task . ElasticNetworkInterfaces ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetTaskENI ( eni ) } if task . ProxyConfiguration != nil { appmesh , err := apiappmesh . AppMeshFromACS ( task . ProxyConfiguration ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetAppMesh ( appmesh ) } if task . ExecutionRoleCredentials != nil { taskExecutionIAMRoleCredentials := credentials . IAMRoleCredentialsFromACS ( task . ExecutionRoleCredentials , credentials . ExecutionRoleType ) err = payloadHandler . credentialsManager . SetTaskCredentials ( & ( credentials . TaskIAMRoleCredentials { ARN : aws . StringValue ( task . Arn ) , IAMRoleCredentials : taskExecutionIAMRoleCredentials , } ) ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetExecutionRoleCredentialsID ( taskExecutionIAMRoleCredentials . CredentialsID ) } validTasks = append ( validTasks , apiTask ) } stoppedTasksCredentialsAcks , stoppedTasksAddedOK := payloadHandler . addTasks ( payload , validTasks , isTaskStatusNotStopped ) newTasksCredentialsAcks , newTasksAddedOK := payloadHandler . addTasks ( payload , validTasks , isTaskStatusStopped ) if ! stoppedTasksAddedOK || ! newTasksAddedOK { allTasksOK = false } var credentialsAcks [ ] * ecsacs . IAMRoleCredentialsAckRequest credentialsAcks = append ( stoppedTasksCredentialsAcks , newTasksCredentialsAcks ... ) return credentialsAcks , allTasksOK }
1048	func ( d * VaultAgentTokenQuery ) watch ( lastStat os . FileInfo ) <- chan * watchResult { ch := make ( chan * watchResult , 1 ) go func ( lastStat os . FileInfo ) { for { stat , err := os . Stat ( d . path ) if err != nil { select { case <- d . stopCh : return case ch <- & watchResult { err : err } : return } } changed := lastStat == nil || lastStat . Size ( ) != stat . Size ( ) || lastStat . ModTime ( ) != stat . ModTime ( ) if changed { select { case <- d . stopCh : return case ch <- & watchResult { stat : stat } : return } } time . Sleep ( VaultAgentTokenSleepTime ) } } ( lastStat ) return ch }
5206	func ( idx * Index ) BatchQuery ( queries ... PQLQuery ) * PQLBatchQuery { stringQueries := make ( [ ] string , 0 , len ( queries ) ) hasKeys := false for _ , query := range queries { serializedQuery := query . Serialize ( ) hasKeys = hasKeys || serializedQuery . HasWriteKeys ( ) stringQueries = append ( stringQueries , serializedQuery . String ( ) ) } return & PQLBatchQuery { index : idx , queries : stringQueries , hasKeys : hasKeys , } }
1666	func ( tv * TaskVolume ) UnmarshalJSON ( b [ ] byte ) error { intermediate := make ( map [ string ] json . RawMessage ) if err := json . Unmarshal ( b , & intermediate ) ; err != nil { return err } name , ok := intermediate [ "name" ] if ! ok { return errors . New ( "invalid Volume; must include a name" ) } if err := json . Unmarshal ( name , & tv . Name ) ; err != nil { return err } volumeType , ok := intermediate [ "type" ] if ! ok { volumeType = [ ] byte ( `"host"` ) seelog . Infof ( "Unmarshal task volume: volume type not specified, default to host" ) } if err := json . Unmarshal ( volumeType , & tv . Type ) ; err != nil { return err } switch tv . Type { case HostVolumeType : return tv . unmarshalHostVolume ( intermediate [ "host" ] ) case DockerVolumeType : return tv . unmarshalDockerVolume ( intermediate [ "dockerVolumeConfiguration" ] ) default : return errors . Errorf ( "invalid Volume: type must be docker or host, got %q" , tv . Type ) } }
4735	func StringSHA1Base64 ( data string ) string { hash := sha1 . Sum ( [ ] byte ( data ) ) return base64 . StdEncoding . EncodeToString ( hash [ : ] ) }
2939	func resourceVSphereDatastoreClusterApplySDRSConfig ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { if ! resourceVSphereDatastoreClusterHasSDRSConfigChange ( d ) { log . Printf ( "[DEBUG] %s: No SDRS configuration attributes have changed" , resourceVSphereDatastoreClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying SDRS configuration" , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return err } version := viapi . ParseVersionFromClient ( client ) spec := types . StorageDrsConfigSpec { PodConfigSpec : expandStorageDrsPodConfigSpec ( d , version ) , } return storagepod . ApplyDRSConfiguration ( client , pod , spec ) }
3913	func yaml_emitter_flush ( emitter * yaml_emitter_t ) bool { if emitter . write_handler == nil { panic ( "write handler not set" ) } if emitter . buffer_pos == 0 { return true } if err := emitter . write_handler ( emitter , emitter . buffer [ : emitter . buffer_pos ] ) ; err != nil { return yaml_emitter_set_writer_error ( emitter , "write error: " + err . Error ( ) ) } emitter . buffer_pos = 0 return true }
2552	func schemaHostVirtualSwitchBondBridge ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { "beacon_interval" : { Type : schema . TypeInt , Optional : true , Description : "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link." , Default : 1 , ValidateFunc : validation . IntAtLeast ( 0 ) , } , "link_discovery_operation" : { Type : schema . TypeString , Optional : true , Description : "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none." , Default : string ( types . LinkDiscoveryProtocolConfigOperationTypeListen ) , ValidateFunc : validation . StringInSlice ( linkDiscoveryProtocolConfigOperationAllowedValues , false ) , } , "link_discovery_protocol" : { Type : schema . TypeString , Optional : true , Description : "The discovery protocol type. Valid values are cdp and lldp." , Default : string ( types . LinkDiscoveryProtocolConfigProtocolTypeCdp ) , ValidateFunc : validation . StringInSlice ( linkDiscoveryProtocolConfigProtocolAllowedValues , false ) , } , "network_adapters" : { Type : schema . TypeList , Required : true , Description : "The list of network adapters to bind to this virtual switch." , Elem : & schema . Schema { Type : schema . TypeString } , } , } }
1919	func ( m * MockFileSystem ) Exit ( arg0 int ) { m . ctrl . Call ( m , "Exit" , arg0 ) }
387	func ( a * Args ) SetUint ( key string , value int ) { bb := bytebufferpool . Get ( ) bb . B = AppendUint ( bb . B [ : 0 ] , value ) a . SetBytesV ( key , bb . B ) bytebufferpool . Put ( bb ) }
2840	func CdromDiffOperation ( d * schema . ResourceDiff , c * govmomi . Client ) error { log . Printf ( "[DEBUG] CdromDiffOperation: Beginning diff validation" ) cr := d . Get ( subresourceTypeCdrom ) for ci , ce := range cr . ( [ ] interface { } ) { cm := ce . ( map [ string ] interface { } ) r := NewCdromSubresource ( c , d , cm , nil , ci ) if err := r . ValidateDiff ( ) ; err != nil { return fmt . Errorf ( "%s: %s" , r . Addr ( ) , err ) } } log . Printf ( "[DEBUG] CdromDiffOperation: Diff validation complete" ) return nil }
4555	func ( bs * BlockStatement ) InnerText ( ) string { var out bytes . Buffer for _ , s := range bs . Statements { out . WriteString ( s . String ( ) ) } return out . String ( ) }
4251	func ( e * encoding ) Encode ( x uint64 ) string { b := [ 12 ] byte { } for i := 0 ; i < 12 ; i ++ { b [ 11 - i ] = e . encode [ x & 0x1f ] x >>= 5 } return string ( b [ : ] ) }
6778	func LogOnPanic ( id int64 , err interface { } , stacktrace [ ] string , _ * http . Request ) { logMutex . Lock ( ) defer logMutex . Unlock ( ) log . Printf ( "panic=%016x message=%v\n" , \n , id ) err }
1049	func NewKVKeysQuery ( s string ) ( * KVKeysQuery , error ) { if s != "" && ! KVKeysQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "kv.keys: invalid format: %q" , s ) } m := regexpMatch ( KVKeysQueryRe , s ) return & KVKeysQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ "dc" ] , prefix : m [ "prefix" ] , } , nil }
5396	func NewGroup ( name string , members ... string ) * Group { return & Group { Name : name , password : "" , GID : - 1 , UserList : members , } }
6027	func ( t Typed ) Ints64 ( key string ) [ ] int64 { return t . Ints64Or ( key , nil ) }
5132	func ( c * cachedDownloader ) populateCache ( logger lager . Logger , url * url . URL , name string , cachingInfo CachingInfoType , checksum ChecksumInfoType , transformer CacheTransformer , cancelChan <- chan struct { } , ) ( download , bool , int64 , error ) { filename , cachingInfo , err := c . downloader . Download ( logger , url , func ( ) ( * os . File , error ) { return ioutil . TempFile ( c . uncachedPath , name + "-" ) } , cachingInfo , checksum , cancelChan ) if err != nil { return download { } , false , 0 , err } if filename == "" { return download { } , true , 0 , nil } fileInfo , err := os . Stat ( filename ) if err != nil { return download { } , false , 0 , err } defer os . Remove ( filename ) cachedFile , err := ioutil . TempFile ( c . uncachedPath , "transformed" ) if err != nil { return download { } , false , 0 , err } err = cachedFile . Close ( ) if err != nil { return download { } , false , 0 , err } cachedSize , err := transformer ( filename , cachedFile . Name ( ) ) if err != nil { return download { } , false , 0 , err } return download { path : cachedFile . Name ( ) , size : cachedSize , cachingInfo : cachingInfo , } , false , fileInfo . Size ( ) , nil }
5434	func ( bot * Bot ) WaitFor ( filter func ( * Message ) bool ) { for mes := range bot . Incoming { if filter ( mes ) { return } } return }
5223	func ( f * Field ) RowTopN ( n uint64 , row * PQLRowQuery ) * PQLRowQuery { q := NewPQLRowQuery ( fmt . Sprintf ( "TopN(%s,%s,n=%d)" , f . name , row . serialize ( ) , n ) , f . index , nil ) return q }
1952	func NewMockResponseWriter ( ctrl * gomock . Controller ) * MockResponseWriter { mock := & MockResponseWriter { ctrl : ctrl } mock . recorder = & MockResponseWriterMockRecorder { mock } return mock }
4450	func ( h * HexColor ) UnmarshalJSON ( data [ ] byte ) error { l := jlexer . Lexer { Data : data } h . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
6579	func DisableSvcCheck ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "DISABLE_SVC_CHECK" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
2076	func ( m * MockGPUManager ) GetGPUIDsUnsafe ( ) [ ] string { ret := m . ctrl . Call ( m , "GetGPUIDsUnsafe" ) ret0 , _ := ret [ 0 ] . ( [ ] string ) return ret0 }
297	func ( a adapter ) Appender ( ) ( storage . Appender , error ) { return appender { a : a . db . Appender ( ) } , nil }
6992	func ( ctx * ResCtx ) ErrorData ( v interface { } ) error { if ctx . Success { return errors . New ( "ctx: cannot read error data since server returned a success response" ) } if ctx . errorData == nil { return errors . New ( "ctx: server did not return any error data" ) } if err := json . Unmarshal ( ctx . errorData , v ) ; err != nil { return fmt . Errorf ( "ctx: cannot deserialize error data: %v" , err ) } return nil }
1391	func ( m * MockCNIClient ) ReleaseIPResource ( arg0 * ecscni . Config ) error { ret := m . ctrl . Call ( m , "ReleaseIPResource" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
3771	func ( client * Client ) CreateAPIKey ( name string ) ( * APIKey , error ) { toPost := struct { Name * string `json:"name,omitempty"` } { & name , } var out reqAPIKey if err := client . doJsonRequest ( "POST" , "/v1/api_key" , toPost , & out ) ; err != nil { return nil , err } return out . APIKey , nil }
4205	func ( c * DeleteSpacesCommand ) Execute ( [ ] string ) error { var cfMgmt * CFMgmt var err error if cfMgmt , err = InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { err = cfMgmt . SpaceManager . DeleteSpaces ( ) } return err }
1040	func TimeDurationGoString ( t * time . Duration ) string { if t == nil { return "(*time.Duration)(nil)" } return fmt . Sprintf ( "%s" , t ) }
1442	func ( state * DockerTaskEngineState ) AddContainer ( container * apicontainer . DockerContainer , task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) if task == nil || container == nil { log . Crit ( "Addcontainer called with nil task/container" ) return } _ , exists := state . tasks [ task . Arn ] if ! exists { log . Debug ( "AddContainer called with unknown task; adding" , "arn" , task . Arn ) state . tasks [ task . Arn ] = task } state . storeIDToContainerTaskUnsafe ( container , task ) dockerID := container . DockerID v3EndpointID := container . Container . V3EndpointID if dockerID != "" && v3EndpointID != "" { state . storeV3EndpointIDToTaskUnsafe ( v3EndpointID , task . Arn ) state . storeV3EndpointIDToDockerIDUnsafe ( v3EndpointID , dockerID ) } existingMap , exists := state . taskToID [ task . Arn ] if ! exists { existingMap = make ( map [ string ] * apicontainer . DockerContainer , len ( task . Containers ) ) state . taskToID [ task . Arn ] = existingMap } existingMap [ container . Container . Name ] = container }
7149	func NewService ( config ServiceConfig ) ( Service , error ) { if config . BackoffFactory == nil { return nil , maskAnyf ( invalidConfigError , "backoff factory must not be empty" ) } if config . RandFactory == nil { return nil , maskAnyf ( invalidConfigError , "rand factory must not be empty" ) } if config . RandReader == nil { return nil , maskAnyf ( invalidConfigError , "rand reader must not be empty" ) } newService := & service { backoffFactory : config . BackoffFactory , randFactory : config . RandFactory , randReader : config . RandReader , timeout : config . Timeout , } return newService , nil }
3027	func ( opts ListOpts ) ToServerListQuery ( ) ( string , error ) { q , err := gophercloud . BuildQueryString ( opts ) return q . String ( ) , err }
2531	func expandDVPortgroupConfigSpec ( d * schema . ResourceData ) types . DVPortgroupConfigSpec { obj := types . DVPortgroupConfigSpec { ConfigVersion : d . Get ( "config_version" ) . ( string ) , Name : d . Get ( "name" ) . ( string ) , NumPorts : int32 ( d . Get ( "number_of_ports" ) . ( int ) ) , PortNameFormat : d . Get ( "port_name_format" ) . ( string ) , DefaultPortConfig : expandVMwareDVSPortSetting ( d ) , Description : d . Get ( "description" ) . ( string ) , Type : d . Get ( "type" ) . ( string ) , Policy : expandVMwareDVSPortgroupPolicy ( d ) , AutoExpand : structure . GetBoolPtr ( d , "auto_expand" ) , VmVnicNetworkResourcePoolKey : d . Get ( "network_resource_pool_key" ) . ( string ) , } return obj }
200	func ( g * Group ) setEvaluationTimestamp ( ts time . Time ) { g . metrics . groupLastEvalTime . WithLabelValues ( groupKey ( g . file , g . name ) ) . Set ( float64 ( ts . UnixNano ( ) ) / 1e9 ) g . mtx . Lock ( ) defer g . mtx . Unlock ( ) g . evaluationTimestamp = ts }
6327	func Map ( ss [ ] string , callback func ( string ) string ) [ ] string { newStrings := make ( [ ] string , len ( ss ) ) for i , s := range ss { newStrings [ i ] = callback ( s ) } return newStrings }
3998	func ( e LintStatus ) String ( ) string { switch e { case NA : return "NA" case NE : return "NE" case Pass : return "pass" case Notice : return "info" case Warn : return "warn" case Error : return "error" case Fatal : return "fatal" default : return "" } }
5178	func TraceDatastore ( ctx context . Context , table , operation , sql , rollupName string ) * Trace { return trace ( ctx , rollupName , func ( tx Tx ) error { return tx . StartDatastore ( table , operation , sql , rollupName ) } ) }
4959	func Random ( byteCount int ) ( [ ] byte , error ) { data := make ( [ ] byte , byteCount ) if _ , err := rand . Read ( data ) ; err != nil { return nil , err } return data , nil }
5065	func ( r * Render ) Add ( name string , tmpl * template . Template ) { if tmpl == nil { panic ( "template can not be nil" ) } if len ( name ) == 0 { panic ( "template name cannot be empty" ) } r . Templates [ name ] = tmpl }
4674	func newEmptyElement ( ln * line , rslt * result , src * source , parent element , opts * Options ) * emptyElement { return & emptyElement { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , } }
225	func ( sd * StaticProvider ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { select { case ch <- sd . TargetGroups : case <- ctx . Done ( ) : } close ( ch ) }
6720	func ( c * Client ) MapCloudIPtoServer ( identifier string , serverid string ) error { server , err := c . Server ( serverid ) if err != nil { return err } if len ( server . Interfaces ) == 0 { return fmt . Errorf ( "Server %s has no interfaces to map cloud ip %s to" , server . Id , identifier ) } destination := server . Interfaces [ 0 ] . Id err = c . MapCloudIP ( identifier , destination ) if err != nil { return err } return nil }
5632	func ComputeBTCAddressForPrivKey ( privKey string ) string { pubKeyBytes := PubKeyBytesFromPrivKeyBytes ( HexDecode ( privKey ) , true ) return BTCAddrFromPubKeyBytes ( pubKeyBytes ) }
2707	func ( c * Config ) readRestSessionID ( ) ( string , error ) { if ! c . Persist { return "" , nil } p , err := c . restSessionFile ( ) if err != nil { return "" , err } log . Printf ( "[DEBUG] Attempting to locate REST client session data in %q" , p ) id , err := ioutil . ReadFile ( p ) if err != nil { if os . IsNotExist ( err ) { log . Printf ( "[DEBUG] REST client session data not found in %q" , p ) return "" , nil } return "" , err } return string ( id ) , nil }
6441	func ( l * List ) String ( ) string { l . key . RLock ( ) defer l . key . RUnlock ( ) builder := bytes . NewBufferString ( "[" ) for i , entry := range l . underlyer { if i >= 15 { builder . WriteString ( "... " ) break } builder . WriteString ( fmt . Sprintf ( "%v " , entry ) ) } builder . Truncate ( builder . Len ( ) - 1 ) builder . WriteRune ( ']' ) return builder . String ( ) }
708	func ( p * RcodeZeroProvider ) submitChanges ( changes [ ] * rc0 . RRSetChange ) error { if len ( changes ) == 0 { return nil } zones , err := p . Zones ( ) if err != nil { return err } changesByZone := rcodezeroChangesByZone ( zones , changes ) for zoneName , changes := range changesByZone { for _ , change := range changes { logFields := log . Fields { "record" : change . Name , "content" : change . Records [ 0 ] . Content , "type" : change . Type , "action" : change . ChangeType , "zone" : zoneName , } log . WithFields ( logFields ) . Info ( "Changing record." ) if p . DryRun { continue } change . Name = strings . TrimSuffix ( change . Name , "." ) + "." switch change . ChangeType { case rc0 . ChangeTypeADD : sr , err := p . Client . RRSet . Create ( zoneName , [ ] * rc0 . RRSetChange { change } ) if err != nil { return err } if sr . HasError ( ) { return fmt . Errorf ( "adding new RR resulted in an error: %v" , sr . Message ) } case rc0 . ChangeTypeUPDATE : sr , err := p . Client . RRSet . Edit ( zoneName , [ ] * rc0 . RRSetChange { change } ) if err != nil { return err } if sr . HasError ( ) { return fmt . Errorf ( "updating existing RR resulted in an error: %v" , sr . Message ) } case rc0 . ChangeTypeDELETE : sr , err := p . Client . RRSet . Delete ( zoneName , [ ] * rc0 . RRSetChange { change } ) if err != nil { return err } if sr . HasError ( ) { return fmt . Errorf ( "deleting existing RR resulted in an error: %v" , sr . Message ) } default : return fmt . Errorf ( "unsupported changeType submitted: %v" , change . ChangeType ) } } } return nil }
5484	func ( c * Client ) CreateResource ( ctx context . Context , pathPart string , data url . Values , v interface { } ) error { return c . MakeRequest ( ctx , "POST" , pathPart , data , v ) }
3187	func ( client * Client ) UpdateMonitor ( monitor * Monitor ) error { return client . doJsonRequest ( "PUT" , fmt . Sprintf ( "/v1/monitor/%d" , * monitor . Id ) , monitor , nil ) }
976	func ( d * CatalogDatacentersQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { opts = opts . Merge ( & QueryOptions { } ) log . Printf ( "[TRACE] %s: GET %s" , d , & url . URL { Path : "/v1/catalog/datacenters" , RawQuery : opts . String ( ) , } ) if opts . WaitIndex != 0 { log . Printf ( "[TRACE] %s: long polling for %s" , d , CatalogDatacentersQuerySleepTime ) select { case <- d . stopCh : return nil , nil , ErrStopped case <- time . After ( CatalogDatacentersQuerySleepTime ) : } } result , err := clients . Consul ( ) . Catalog ( ) . Datacenters ( ) if err != nil { return nil , nil , errors . Wrapf ( err , d . String ( ) ) } if d . ignoreFailing { dcs := make ( [ ] string , 0 , len ( result ) ) for _ , dc := range result { if _ , _ , err := clients . Consul ( ) . Catalog ( ) . Services ( & api . QueryOptions { Datacenter : dc , AllowStale : false , RequireConsistent : true , } ) ; err == nil { dcs = append ( dcs , dc ) } } result = dcs } log . Printf ( "[TRACE] %s: returned %d results" , d , len ( result ) ) sort . Strings ( result ) return respWithMetadata ( result ) }
4239	func ( mp * Multiplex ) NewNamedStream ( name string ) ( * Stream , error ) { mp . chLock . Lock ( ) if mp . channels == nil { mp . chLock . Unlock ( ) return nil , ErrShutdown } sid := mp . nextChanID ( ) header := ( sid << 3 ) | newStreamTag if name == "" { name = fmt . Sprint ( sid ) } s := mp . newStream ( streamID { id : sid , initiator : true , } , name ) mp . channels [ s . id ] = s mp . chLock . Unlock ( ) err := mp . sendMsg ( context . Background ( ) , header , [ ] byte ( name ) ) if err != nil { return nil , err } return s , nil }
7050	func SafeCreate ( name ... string ) ( file * os . File , err error ) { p , e := ensurePath ( path . Join ( name ... ) ) if e != nil { return nil , e } return os . Create ( p ) }
803	func createHostonlyAdapter ( vbox VBoxManager ) ( * hostOnlyNetwork , error ) { if runtime . GOOS == "windows" { log . Warn ( "Windows might ask for the permission to create a network adapter. Sometimes, such confirmation window is minimized in the taskbar." ) } out , err := vbox . vbmOut ( "hostonlyif" , "create" ) if err != nil { return nil , err } res := reHostOnlyAdapterCreated . FindStringSubmatch ( string ( out ) ) if res == nil { return nil , errors . New ( "Failed to create host-only adapter" ) } return & hostOnlyNetwork { Name : res [ 1 ] } , nil }
4896	func ( s * Session ) Exec ( id uint64 , prmFieldSet * ParameterFieldSet , args [ ] driver . NamedValue ) ( driver . Result , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) s . statementID . id = & id if err := s . writeRequest ( mtExecute , ! s . conn . inTx , s . statementID , newInputParameters ( prmFieldSet . inputFields ( ) , args ) ) ; err != nil { return nil , err } if err := s . readReply ( nil ) ; err != nil { return nil , err } var result driver . Result if s . sh . functionCode == fcDDL { result = driver . ResultNoRows } else { result = driver . RowsAffected ( s . rowsAffected . total ( ) ) } if err := s . writeLobStream ( prmFieldSet , nil , args ) ; err != nil { return nil , err } return result , nil }
6431	func countScalars ( input [ ] interface { } ) int { for i := 0 ; i < len ( input ) ; i ++ { switch input [ i ] . ( type ) { case keyvalser : return i } } return len ( input ) }
6890	func Color ( at , fg , bg int ) ( string , error ) { var a , f , b string if at == AttrNA && fg == AttrNA && bg == AttrNA { return "" , ErrInvalidColor } switch at { case AttrNA : break case AttrBold , AttrUnderline , AttrReverse , AttrReset : a = fmt . Sprintf ( "%v;" , at ) default : return "" , ErrInvalidAttribute } switch { case fg == AttrNA : break case fg >= ColorBlack && fg <= ColorWhite : f = fmt . Sprintf ( "%v;" , fg + ANSIFg ) default : return "" , ErrInvalidForeground } switch { case bg == AttrNA : break case bg >= ColorBlack && bg <= ColorWhite : b = fmt . Sprintf ( "%v;" , bg + ANSIBg ) default : return "" , ErrInvalidBackground } es := fmt . Sprintf ( "\x1b[%v%v%v" , \x1b , a , f ) b es = es [ : len ( es ) - 1 ] + "m" }
4166	func ( c * Client ) handleLine ( line string ) error { go func ( ) { select { case c . messageReceived <- true : default : } } ( ) message := ParseMessage ( line ) switch msg := message . ( type ) { case * WhisperMessage : if c . onWhisperMessage != nil { c . onWhisperMessage ( * msg ) } return nil case * PrivateMessage : if c . onPrivateMessage != nil { c . onPrivateMessage ( * msg ) } return nil case * ClearChatMessage : if c . onClearChatMessage != nil { c . onClearChatMessage ( * msg ) } return nil case * RoomStateMessage : if c . onRoomStateMessage != nil { c . onRoomStateMessage ( * msg ) } return nil case * UserNoticeMessage : if c . onUserNoticeMessage != nil { c . onUserNoticeMessage ( * msg ) } return nil case * UserStateMessage : if c . onUserStateMessage != nil { c . onUserStateMessage ( * msg ) } return nil case * NoticeMessage : if c . onNoticeMessage != nil { c . onNoticeMessage ( * msg ) } return c . handleNoticeMessage ( * msg ) case * UserJoinMessage : if c . handleUserJoinMessage ( * msg ) { if c . onUserJoinMessage != nil { c . onUserJoinMessage ( * msg ) } } return nil case * UserPartMessage : if c . handleUserPartMessage ( * msg ) { if c . onUserPartMessage != nil { c . onUserPartMessage ( * msg ) } } return nil case * ReconnectMessage : if c . onReconnectMessage != nil { c . onReconnectMessage ( * msg ) } return errReconnect case * NamesMessage : if c . onNamesMessage != nil { c . onNamesMessage ( * msg ) } c . handleNamesMessage ( * msg ) return nil case * PingMessage : if c . onPingMessage != nil { c . onPingMessage ( * msg ) } c . handlePingMessage ( * msg ) return nil case * PongMessage : if c . onPongMessage != nil { c . onPongMessage ( * msg ) } c . handlePongMessage ( * msg ) return nil case * RawMessage : if c . onUnsetMessage != nil { c . onUnsetMessage ( * msg ) } } return nil }
3551	func ( s * SyntheticsTest ) GetDeletedAtOk ( ) ( string , bool ) { if s == nil || s . DeletedAt == nil { return "" , false } return * s . DeletedAt , true }
1773	func ( attachENIHandler * attachENIHandler ) handleMessages ( ) { for { select { case message := <- attachENIHandler . messageBuffer : if err := attachENIHandler . handleSingleMessage ( message ) ; err != nil { seelog . Warnf ( "Unable to handle ENI Attachment message [%s]: %v" , message . String ( ) , err ) } case <- attachENIHandler . ctx . Done ( ) : return } } }
7210	func ( lw ErrorLogWriter ) Write ( p [ ] byte ) ( int , error ) { lw . Error ( string ( bytes . TrimRightFunc ( p , unicode . IsSpace ) ) ) return len ( p ) , nil }
6959	func ( s * Set ) ContainsAll ( values ... interface { } ) bool { s . RLock ( ) defer s . RUnlock ( ) for _ , value := range values { _ , ok := s . m [ value ] if ! ok { return false } } return true }
2075	func ( m * MockGPUManager ) GetDevices ( ) [ ] * ecs . PlatformDevice { ret := m . ctrl . Call ( m , "GetDevices" ) ret0 , _ := ret [ 0 ] . ( [ ] * ecs . PlatformDevice ) return ret0 }
5910	func ( alg * Algorithm ) UnmarshalText ( buf [ ] byte ) error { switch string ( buf ) { case "HS256" : * alg = HS256 case "HS384" : * alg = HS384 case "HS512" : * alg = HS512 case "RS256" : * alg = RS256 case "RS384" : * alg = RS384 case "RS512" : * alg = RS512 case "ES256" : * alg = ES256 case "ES384" : * alg = ES384 case "ES512" : * alg = ES512 case "PS256" : * alg = PS256 case "PS384" : * alg = PS384 case "PS512" : * alg = PS512 default : return ErrInvalidAlgorithm } return nil }
7071	func ( r * ReserveReleaseArg ) MarshalBinary ( ) ( [ ] byte , error ) { if int ( r . NMACs ) != len ( r . MACs ) { return nil , ErrorBadArgumentParameter } b := make ( [ ] byte , reserveReleaseArgLen + ( r . NMACs * 6 ) ) b [ 0 ] = uint8 ( r . Command ) b [ 1 ] = uint8 ( r . NMACs ) n := 2 for _ , m := range r . MACs { if len ( m ) != 6 { return nil , ErrorBadArgumentParameter } copy ( b [ n : n + 6 ] , m ) n += 6 } return b , nil }
6414	func ( list * LinkedList ) RemoveBack ( ) ( interface { } , bool ) { list . key . Lock ( ) defer list . key . Unlock ( ) if list . last == nil { return nil , false } retval := list . last . payload list . length -- if list . length == 0 { list . first = nil } else { node , _ := get ( list . first , list . length - 1 ) node . next = nil } return retval , true }
3635	func ( t * TraceServiceDefinition ) GetShowHitsOk ( ) ( bool , bool ) { if t == nil || t . ShowHits == nil { return false , false } return * t . ShowHits , true }
3664	func ( w * Widget ) GetColumns ( ) string { if w == nil || w . Columns == nil { return "" } return * w . Columns }
796	func operationsByZone ( zones map [ string ] * dns . ZoneSummary , ops [ ] dns . RecordOperation ) map [ string ] [ ] dns . RecordOperation { changes := make ( map [ string ] [ ] dns . RecordOperation ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( * z . Id , * z . Name ) changes [ * z . Id ] = [ ] dns . RecordOperation { } } for _ , op := range ops { if zoneID , _ := zoneNameIDMapper . FindZone ( * op . Domain ) ; zoneID != "" { changes [ zoneID ] = append ( changes [ zoneID ] , op ) } else { log . Warnf ( "No matching zone for record operation %s" , op ) } } for zone , ops := range changes { if len ( ops ) == 0 { delete ( changes , zone ) } } return changes }
5846	func ( a * API ) UpdateRuleSet ( cfg * RuleSet ) ( * RuleSet , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid rule set config [nil]" ) } rulesetCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . RuleSetCIDRegex , rulesetCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid rule set CID [%s]" , rulesetCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update rule set, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( rulesetCID , jsonCfg ) if err != nil { return nil , err } ruleset := & RuleSet { } if err := json . Unmarshal ( result , ruleset ) ; err != nil { return nil , err } return ruleset , nil }
3532	func ( s * SyntheticsOptions ) GetMinLocationFailed ( ) int { if s == nil || s . MinLocationFailed == nil { return 0 } return * s . MinLocationFailed }
5417	func ( w * World ) RemoveEntity ( e BasicEntity ) { for _ , sys := range w . systems { sys . Remove ( e ) } }
212	func ( w * WALWatcher ) Start ( ) { w . setMetrics ( ) level . Info ( w . logger ) . Log ( "msg" , "starting WAL watcher" , "queue" , w . name ) go w . loop ( ) }
6540	func ( d * Dialer ) rawConnDial ( ctx context . Context , raddr ma . Multiaddr , remote peer . ID ) ( transport . Conn , error ) { if strings . HasPrefix ( raddr . String ( ) , "/ip4/0.0.0.0" ) { log . Event ( ctx , "connDialZeroAddr" , lgbl . Dial ( "conn" , d . LocalPeer , remote , nil , raddr ) ) return nil , fmt . Errorf ( "Attempted to connect to zero address: %s" , raddr ) } sd := d . subDialerForAddr ( raddr ) if sd == nil { return nil , fmt . Errorf ( "no dialer for %s" , raddr ) } return sd . DialContext ( ctx , raddr ) }
2375	func ( c * ColorM ) Add ( other * ColorM ) * ColorM { lhsb := colorMIdentityBody lhst := colorMIdentityTranslate rhsb := colorMIdentityBody rhst := colorMIdentityTranslate if other . isInited ( ) { if other . body != nil { lhsb = other . body } if other . translate != nil { lhst = other . translate } } if c . isInited ( ) { if c . body != nil { rhsb = c . body } if c . translate != nil { rhst = c . translate } } newC := & ColorM { body : make ( [ ] float32 , 16 ) , translate : make ( [ ] float32 , 4 ) , } for i := range lhsb { newC . body [ i ] = lhsb [ i ] + rhsb [ i ] } for i := range lhst { newC . translate [ i ] = lhst [ i ] + rhst [ i ] } return newC }
6335	func ( sh * StatsdLogHandler ) ServeHTTP ( w http . ResponseWriter , req * http . Request ) { requestStartTime := time . Now ( ) sh . handler . ServeHTTP ( w , req ) requestDuration := time . Now ( ) . Sub ( requestStartTime ) description := sh . RequestFormatter ( req ) if description != "" { sh . statter . Counter ( 1.0 , sh . prefix + "." + description + ".requests" , 1 ) sh . statter . Timing ( 1.0 , sh . prefix + "." + description + ".responsetime" , requestDuration ) } }
4533	func NewOpenAPISchemaFor ( delegate discovery . OpenAPISchemaInterface , gvk schema . GroupVersionKind ) ( * OpenAPISchema , error ) { log . Debugf ( "Fetching schema for %v" , gvk ) doc , err := delegate . OpenAPISchema ( ) if err != nil { return nil , err } res , err := openapi . NewOpenAPIData ( doc ) if err != nil { return nil , err } sc := res . LookupResource ( gvk ) if sc == nil { gvr := schema . GroupResource { Group : "schema" , Resource : "schema" , } return nil , errors . NewNotFound ( gvr , fmt . Sprintf ( "%s" , gvk ) ) } return & OpenAPISchema { schema : sc } , nil }
2807	func expandVmwareDistributedVirtualSwitchVlanIDSpec ( d * schema . ResourceData ) * types . VmwareDistributedVirtualSwitchVlanIdSpec { obj := & types . VmwareDistributedVirtualSwitchVlanIdSpec { VlanId : int32 ( d . Get ( "vlan_id" ) . ( int ) ) , } return obj }
3606	func ( t * TimeRange ) HasLive ( ) bool { if t != nil && t . Live != nil { return true } return false }
1101	func base64Encode ( s string ) ( string , error ) { return base64 . StdEncoding . EncodeToString ( [ ] byte ( s ) ) , nil }
120	func newParser ( input string ) * parser { p := & parser { lex : lex ( input ) , } return p }
1904	func ( engine * DockerTaskEngine ) imagePullRequired ( imagePullBehavior config . ImagePullBehaviorType , container * apicontainer . Container , taskArn string ) bool { switch imagePullBehavior { case config . ImagePullOnceBehavior : imageState , ok := engine . imageManager . GetImageStateFromImageName ( container . Image ) if ok && imageState . GetPullSucceeded ( ) { seelog . Infof ( "Task engine [%s]: image %s for container %s has been pulled once, not pulling it again" , taskArn , container . Image , container . Name ) return false } return true case config . ImagePullPreferCachedBehavior : _ , err := engine . client . InspectImage ( container . Image ) if err != nil { return true } seelog . Infof ( "Task engine [%s]: found cached image %s, use it directly for container %s" , taskArn , container . Image , container . Name ) return false default : return true } }
1019	func NewCatalogServiceQuery ( s string ) ( * CatalogServiceQuery , error ) { if ! CatalogServiceQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "catalog.service: invalid format: %q" , s ) } m := regexpMatch ( CatalogServiceQueryRe , s ) return & CatalogServiceQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ "dc" ] , name : m [ "name" ] , near : m [ "near" ] , tag : m [ "tag" ] , } , nil }
6347	func Parse ( jsondata [ ] byte , v interface { } ) { err := json . Unmarshal ( jsondata , v ) if err != nil { panic ( err . Error ( ) ) } }
6808	func ( t * T ) Logf ( format string , args ... interface { } ) { fmt . Printf ( format , args ... ) }
4131	func request ( client * http . Client , method , url string , body [ ] byte ) ( [ ] byte , error ) { req , err := http . NewRequest ( method , url , bytes . NewBuffer ( body ) ) req . Header . Set ( "Content-Type" , "application/json" ) resp , err := client . Do ( req ) if err != nil { return nil , err } defer resp . Body . Close ( ) return processResponse ( resp ) }
2433	func opaque ( m image . Image ) bool { if o , ok := m . ( opaquer ) ; ok { return o . Opaque ( ) } b := m . Bounds ( ) for y := b . Min . Y ; y < b . Max . Y ; y ++ { for x := b . Min . X ; x < b . Max . X ; x ++ { _ , _ , _ , a := m . At ( x , y ) . RGBA ( ) if a != 0xffff { return false } } } return true }
3257	func ( c * Comment ) GetRelatedIdOk ( ) ( int , bool ) { if c == nil || c . RelatedId == nil { return 0 , false } return * c . RelatedId , true }
406	func ( u * URI ) SetSchemeBytes ( scheme [ ] byte ) { u . scheme = append ( u . scheme [ : 0 ] , scheme ... ) lowercaseBytes ( u . scheme ) }
3472	func ( r * reqAPIKey ) HasAPIKey ( ) bool { if r != nil && r . APIKey != nil { return true } return false }
6434	func ( l * List ) AddAt ( pos uint , entries ... interface { } ) { l . key . Lock ( ) defer l . key . Unlock ( ) l . underlyer = append ( l . underlyer [ : pos ] , append ( entries , l . underlyer [ pos : ] ... ) ... ) }
3942	func MakeLang ( s string , lang string ) ( slug string ) { slug = strings . TrimSpace ( s ) slug = SubstituteRune ( slug , CustomRuneSub ) slug = Substitute ( slug , CustomSub ) switch lang { case "de" : slug = SubstituteRune ( slug , deSub ) case "en" : slug = SubstituteRune ( slug , enSub ) case "es" : slug = SubstituteRune ( slug , esSub ) case "fi" : slug = SubstituteRune ( slug , fiSub ) case "gr" : slug = SubstituteRune ( slug , grSub ) case "nl" : slug = SubstituteRune ( slug , nlSub ) case "pl" : slug = SubstituteRune ( slug , plSub ) case "tr" : slug = SubstituteRune ( slug , trSub ) default : slug = SubstituteRune ( slug , enSub ) } slug = unidecode . Unidecode ( slug ) slug = strings . ToLower ( slug ) slug = regexpNonAuthorizedChars . ReplaceAllString ( slug , "-" ) slug = regexpMultipleDashes . ReplaceAllString ( slug , "-" ) slug = strings . Trim ( slug , "-_" ) if MaxLength > 0 { slug = smartTruncate ( slug ) } return slug }
2705	func ( c * Config ) SaveRestClient ( client * tags . RestClient ) error { if ! c . Persist { return nil } p , err := c . restSessionFile ( ) if err != nil { return err } log . Printf ( "[DEBUG] Will persist REST client session data to %q" , p ) err = os . MkdirAll ( filepath . Dir ( p ) , 0700 ) if err != nil { return err } err = ioutil . WriteFile ( p , [ ] byte ( client . SessionID ( ) ) , 0600 ) if err != nil { return err } return nil }
5489	func ( m * MediaService ) Get ( ctx context . Context , messageSid string , sid string ) ( * Media , error ) { me := new ( Media ) err := m . client . GetResource ( ctx , mediaPathPart ( messageSid ) , sid , me ) return me , err }
1849	func ( eventStream * EventStream ) broadcast ( event interface { } ) { eventStream . handlersLock . RLock ( ) defer eventStream . handlersLock . RUnlock ( ) seelog . Debugf ( "Event stream %s received events, broadcasting to listeners..." , eventStream . name ) for _ , handlerFunc := range eventStream . handlers { go handlerFunc ( event ) } }
3645	func ( t * TraceServiceDefinition ) HasSizeFormat ( ) bool { if t != nil && t . SizeFormat != nil { return true } return false }
4341	func ( c * conn ) flush ( n int ) { if len ( c . buf ) == 0 { return } if n == 0 { n = len ( c . buf ) } _ , err := c . w . Write ( c . buf [ : n - 1 ] ) c . handleError ( err ) if n < len ( c . buf ) { copy ( c . buf , c . buf [ n : ] ) } c . buf = c . buf [ : len ( c . buf ) - n ] }
1902	func ( engine * DockerTaskEngine ) ListTasks ( ) ( [ ] * apitask . Task , error ) { return engine . state . AllTasks ( ) , nil }
4437	func ( u ISBN ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
4869	func ParseForwarded ( ipList string ) string { for _ , ip := range strings . Split ( ipList , "," ) { ip = strings . TrimSpace ( ip ) if parsed := net . ParseIP ( ip ) ; parsed != nil && IsPublicIP ( parsed ) { return ip } } return "" }
4257	func ( c * linuxConsole ) dupStdio ( ) error { slave , err := c . open ( syscall . O_RDWR ) if err != nil { return err } fd := int ( slave . Fd ( ) ) for _ , i := range [ ] int { 0 , 1 , 2 } { if err := syscall . Dup3 ( fd , i , 0 ) ; err != nil { return err } } return nil }
7313	func NewEvent ( name string , body interface { } ) Event { return Event { name : name , body : body , occuredTime : time . Now ( ) , } }
199	func ( g * Group ) GetEvaluationTimestamp ( ) time . Time { g . mtx . Lock ( ) defer g . mtx . Unlock ( ) return g . evaluationTimestamp }
6463	func timeoutFlush ( l * Log , timeout time . Duration ) { done := make ( chan bool , 1 ) go func ( ) { l . lockAndFlushAll ( ) done <- true } ( ) select { case <- done : case <- time . After ( timeout ) : fmt . Fprintln ( os . Stderr , "glog: Flush took longer than" , timeout ) } }
2898	func resourceVSphereDatastoreClusterVMAntiAffinityRuleFindEntryByName ( pod * object . StoragePod , name string , ) ( * types . ClusterAntiAffinityRuleSpec , error ) { props , err := storagepod . Properties ( pod ) if err != nil { return nil , fmt . Errorf ( "error fetching datastore cluster properties: %s" , err ) } for _ , info := range props . PodStorageDrsEntry . StorageDrsConfig . PodConfig . Rule { if info . GetClusterRuleInfo ( ) . Name == name { if vmAntiAffinityRuleInfo , ok := info . ( * types . ClusterAntiAffinityRuleSpec ) ; ok { log . Printf ( "[DEBUG] Found VM anti-affinity rule %q in datastore cluster %q" , name , pod . Name ( ) ) return vmAntiAffinityRuleInfo , nil } return nil , fmt . Errorf ( "rule %q in datastore cluster %q is not a VM anti-affinity rule" , name , pod . Name ( ) ) } } return nil , fmt . Errorf ( "no VM anti-affinity rule %q found in datastore cluster %q" , name , pod . Name ( ) ) }
1636	func ( n * NvidiaGPUManager ) GetDevices ( ) [ ] * ecs . PlatformDevice { n . lock . RLock ( ) defer n . lock . RUnlock ( ) return n . GPUDevices }
984	func StringToFileModeFunc ( ) mapstructure . DecodeHookFunc { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) != reflect . String { return data , nil } if t != reflect . TypeOf ( os . FileMode ( 0 ) ) { return data , nil } v , err := strconv . ParseUint ( data . ( string ) , 8 , 12 ) if err != nil { return data , err } return os . FileMode ( v ) , nil } }
18	func shouldDropMetricName ( op ItemType ) bool { switch op { case ItemADD , ItemSUB , ItemDIV , ItemMUL , ItemPOW , ItemMOD : return true default : return false } }
2335	func ( v * Context ) GetMatrix ( ) * Matrix { var matrix C . cairo_matrix_t C . cairo_get_matrix ( v . native ( ) , & matrix ) return & Matrix { Xx : float64 ( matrix . xx ) , Yx : float64 ( matrix . yx ) , Xy : float64 ( matrix . xy ) , Yy : float64 ( matrix . yy ) , X0 : float64 ( matrix . x0 ) , Y0 : float64 ( matrix . y0 ) , } }
497	func ( h * RequestHeader ) SetHost ( host string ) { h . parseRawHeaders ( ) h . host = append ( h . host [ : 0 ] , host ... ) }
2690	func MoveToFolder ( client * govmomi . Client , pod * object . StoragePod , relative string ) error { f , err := folder . DatastoreFolderFromObject ( client , pod , relative ) if err != nil { return err } return folder . MoveObjectTo ( pod . Reference ( ) , f ) }
5156	func ( s * SegmentStack ) Pop ( ) ( int64 , bool ) { s . Lock ( ) defer s . Unlock ( ) if s . Len ( ) == 0 { return rootSegment , false } id := s . s [ s . Len ( ) - 1 ] s . s = s . s [ : s . Len ( ) - 1 ] return id , true }
237	func ( m * Manager ) TargetsAll ( ) map [ string ] [ ] * Target { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) targets := make ( map [ string ] [ ] * Target , len ( m . scrapePools ) ) for tset , sp := range m . scrapePools { targets [ tset ] = append ( sp . ActiveTargets ( ) , sp . DroppedTargets ( ) ... ) } return targets }
3398	func ( m * Monitor ) GetOverallStateModified ( ) string { if m == nil || m . OverallStateModified == nil { return "" } return * m . OverallStateModified }
1292	func ( * loader ) LoadImage ( ctx context . Context , cfg * config . Config , dockerClient dockerapi . DockerClient ) ( * types . ImageInspect , error ) { return nil , NewUnsupportedPlatformError ( errors . Errorf ( "pause container load: unsupported platform: %s/%s" , runtime . GOOS , runtime . GOARCH ) ) }
2049	func AddJitter ( duration time . Duration , jitter time . Duration ) time . Duration { var randJitter int64 if jitter . Nanoseconds ( ) == 0 { randJitter = 0 } else { randJitter = rand . Int63n ( jitter . Nanoseconds ( ) ) } return time . Duration ( duration . Nanoseconds ( ) + randJitter ) }
5547	func ( c * Client ) RequestRooms ( ) { c . connection . Discover ( c . Id , c . conf ) }
1057	func ( c * Child ) Kill ( ) { log . Printf ( "[INFO] (child) killing process" ) c . Lock ( ) defer c . Unlock ( ) c . kill ( ) }
3603	func ( t * TimeRange ) HasFrom ( ) bool { if t != nil && t . From != nil { return true } return false }
4584	func ( f * Func ) PkgName ( ) string { parts := strings . SplitN ( filepath . Base ( f . Raw ) , "." , 2 ) if len ( parts ) == 1 { return "" } s , _ := url . QueryUnescape ( parts [ 0 ] ) return s }
2293	func ( v * TextBuffer ) SelectRange ( start , end * TextIter ) { C . gtk_text_buffer_select_range ( v . native ( ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) }
645	func ByNames ( p ClientGenerator , names [ ] string , cfg * Config ) ( [ ] Source , error ) { sources := [ ] Source { } for _ , name := range names { source , err := BuildWithConfig ( name , p , cfg ) if err != nil { return nil , err } sources = append ( sources , source ) } return sources , nil }
3384	func ( l * LogSet ) GetIDOk ( ) ( json . Number , bool ) { if l == nil || l . ID == nil { return "" , false } return * l . ID , true }
5047	func ( q * Query ) SetMaxScan ( n int ) * Query { q . m . Lock ( ) q . op . options . MaxScan = n q . op . hasOptions = true q . m . Unlock ( ) return q }
2289	func ( v * Switch ) native ( ) * C . GtkSwitch { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSwitch ( p ) }
5914	func ( t * Transport ) RegisterLocation ( loc string , path string ) { t . mu . Lock ( ) defer t . mu . Unlock ( ) if t . loc == nil { t . loc = make ( map [ string ] string ) } if _ , exists := t . loc [ loc ] ; exists { panic ( "location " + loc + " already registered" ) } t . loc [ loc ] = path }
5983	func ( pool * ReaderPool ) Len ( ) int { pool . mu . Lock ( ) defer pool . mu . Unlock ( ) return len ( pool . givenOut ) }
4774	func NetIP ( ) string { addrs , err := net . InterfaceAddrs ( ) if err != nil { return "" } for _ , addr := range addrs { ip := addr . String ( ) if ip != "127.0.0.1" { return ip } } return "" }
5429	func ( pq * PriorityQueue ) update ( item * Item , value string , priority int ) { item . value = value item . priority = priority heap . Fix ( pq , item . index ) }
6929	func SplitMetricID ( metricID string ) ( name string , tags [ ] string ) { if metricID == "" { return "" , nil } pos := strings . LastIndexByte ( metricID , '|' ) if pos > 0 && pos < len ( metricID ) - 1 { return metricID [ : pos ] , strings . Split ( metricID [ pos + 1 : ] , "," ) } return metricID , nil }
394	func ParseIPv4 ( dst net . IP , ipStr [ ] byte ) ( net . IP , error ) { if len ( ipStr ) == 0 { return dst , errEmptyIPStr } if len ( dst ) < net . IPv4len { dst = make ( [ ] byte , net . IPv4len ) } copy ( dst , net . IPv4zero ) dst = dst . To4 ( ) if dst == nil { panic ( "BUG: dst must not be nil" ) } b := ipStr for i := 0 ; i < 3 ; i ++ { n := bytes . IndexByte ( b , '.' ) if n < 0 { return dst , fmt . Errorf ( "cannot find dot in ipStr %q" , ipStr ) } v , err := ParseUint ( b [ : n ] ) if err != nil { return dst , fmt . Errorf ( "cannot parse ipStr %q: %s" , ipStr , err ) } if v > 255 { return dst , fmt . Errorf ( "cannot parse ipStr %q: ip part cannot exceed 255: parsed %d" , ipStr , v ) } dst [ i ] = byte ( v ) b = b [ n + 1 : ] } v , err := ParseUint ( b ) if err != nil { return dst , fmt . Errorf ( "cannot parse ipStr %q: %s" , ipStr , err ) } if v > 255 { return dst , fmt . Errorf ( "cannot parse ipStr %q: ip part cannot exceed 255: parsed %d" , ipStr , v ) } dst [ 3 ] = byte ( v ) return dst , nil }
4329	func ( c * Client ) Clone ( opts ... Option ) * Client { tf := c . conn . tagFormat conf := & config { Client : clientConfig { Rate : c . rate , Prefix : c . prefix , Tags : splitTags ( tf , c . tags ) , } , } for _ , o := range opts { o ( conf ) } clone := & Client { conn : c . conn , muted : c . muted || conf . Client . Muted , rate : conf . Client . Rate , prefix : conf . Client . Prefix , tags : joinTags ( tf , conf . Client . Tags ) , } clone . conn = c . conn return clone }
7281	func ( s * Image ) Pull ( ) error { _ , err := s . docker . Run ( "pull" , s . name ) if err != nil { return err } return nil }
5256	func ( c * Client ) doRequest ( host * URI , method , path string , headers map [ string ] string , reader io . Reader ) ( * http . Response , error ) { req , err := makeRequest ( host , method , path , headers , reader ) if err != nil { return nil , errors . Wrap ( err , "building request" ) } return c . client . Do ( req ) }
668	func ( f ZoneIDFilter ) Match ( zoneID string ) bool { if len ( f . zoneIDs ) == 0 { return true } for _ , id := range f . zoneIDs { if strings . HasSuffix ( zoneID , id ) { return true } } return false }
5114	func ( file * GridFile ) SetName ( name string ) { file . assertMode ( gfsWriting ) file . m . Lock ( ) file . doc . Filename = name file . m . Unlock ( ) }
408	func ( u * URI ) SetHost ( host string ) { u . host = append ( u . host [ : 0 ] , host ... ) lowercaseBytes ( u . host ) }
2031	func ( task * Task ) platformHostConfigOverride ( hostConfig * dockercontainer . HostConfig ) error { return task . overrideCgroupParent ( hostConfig ) }
2389	func intersection ( l1 , l2 line ) ( float64 , float64 , bool ) { denom := ( l1 . X1 - l1 . X2 ) * ( l2 . Y1 - l2 . Y2 ) - ( l1 . Y1 - l1 . Y2 ) * ( l2 . X1 - l2 . X2 ) tNum := ( l1 . X1 - l2 . X1 ) * ( l2 . Y1 - l2 . Y2 ) - ( l1 . Y1 - l2 . Y1 ) * ( l2 . X1 - l2 . X2 ) uNum := - ( ( l1 . X1 - l1 . X2 ) * ( l1 . Y1 - l2 . Y1 ) - ( l1 . Y1 - l1 . Y2 ) * ( l1 . X1 - l2 . X1 ) ) if denom == 0 { return 0 , 0 , false } t := tNum / denom if t > 1 || t < 0 { return 0 , 0 , false } u := uNum / denom if u > 1 || u < 0 { return 0 , 0 , false } x := l1 . X1 + t * ( l1 . X2 - l1 . X1 ) y := l1 . Y1 + t * ( l1 . Y2 - l1 . Y1 ) return x , y , true }
2917	func NormalizeSCSIBus ( l object . VirtualDeviceList , ct string , count int , st string ) ( object . VirtualDeviceList , [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] NormalizeSCSIBus: Normalizing first %d controllers on SCSI bus to device type %s" , count , ct ) var spec [ ] types . BaseVirtualDeviceConfigSpec ctlrs := make ( [ ] types . BaseVirtualSCSIController , count ) iCount := int32 ( count ) for _ , dev := range l { if sc , ok := dev . ( types . BaseVirtualSCSIController ) ; ok { if busNumber := sc . GetVirtualSCSIController ( ) . BusNumber ; busNumber < iCount { ctlrs [ busNumber ] = sc } } } log . Printf ( "[DEBUG] NormalizeSCSIBus: Current SCSI bus contents: %s" , scsiControllerListString ( ctlrs ) ) for n , ctlr := range ctlrs { if ctlr == nil { log . Printf ( "[DEBUG] NormalizeSCSIBus: Creating SCSI controller of type %s at bus number %d" , ct , n ) cspec , err := createSCSIController ( & l , ct , st ) if err != nil { return nil , nil , err } spec = append ( spec , cspec ... ) continue } if l . Type ( ctlr . ( types . BaseVirtualDevice ) ) == ct { cspec , err := setSCSIBusSharing ( & l , ctlr , st ) if err != nil { return nil , nil , err } spec = append ( spec , cspec ... ) continue } cspec , err := swapSCSIDevice ( l , ctlr , ct , st ) if err != nil { return nil , nil , err } spec = append ( spec , cspec ... ) l = applyDeviceChange ( l , cspec ) continue } log . Printf ( "[DEBUG] NormalizeSCSIBus: Outgoing device list: %s" , DeviceListString ( l ) ) log . Printf ( "[DEBUG] NormalizeSCSIBus: Outgoing device config spec: %s" , DeviceChangeString ( spec ) ) return l , spec , nil }
2354	func scaleUpdater ( ) { for { s := getscale ( 0 , 0 ) atomic . StoreUint64 ( & cachedScale , math . Float64bits ( s ) ) time . Sleep ( cacheUpdateWait ) } }
3148	func ( s WhisperSchemas ) Match ( metric string ) ( Schema , bool ) { for _ , schema := range s { if schema . Pattern . MatchString ( metric ) { return schema , true } } return Schema { } , false }
1394	func ContainerAssociationsHandler ( state dockerstate . TaskEngineState ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { containerID , err := getContainerIDByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 container associations handler: unable to get container id from request: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociations ) return } taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 container associations handler: unable to get task arn from request: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociations ) return } associationType , err := getAssociationTypeByRequest ( r ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 container associations handler: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociations ) return } seelog . Infof ( "V3 container associations handler: writing response for container '%s' for association type %s" , containerID , associationType ) writeContainerAssociationsResponse ( w , containerID , taskARN , associationType , state ) } }
6198	func ( h * Handler ) GetSettings ( tkn string ) ( map [ string ] SettingUI , error ) { logger := h . logger . Add ( "method" , "GetSettings" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } result := make ( map [ string ] SettingUI ) settings , err := h . selectAllFrom ( logger , data . SettingTable , settingsCondition ) if err != nil { return nil , err } for _ , v := range settings { setting := * v . ( * data . Setting ) result [ setting . Key ] = SettingUI { setting . Value , PermissionsToString [ setting . Permissions ] } } return result , err }
1310	func setTaskAttachmentSent ( event * sendableEvent ) { if event . taskChange . Attachment != nil { event . taskChange . Attachment . SetSentStatus ( ) event . taskChange . Attachment . StopAckTimer ( ) } }
4447	func ( u * SSN ) DeepCopy ( ) * SSN { if u == nil { return nil } out := new ( SSN ) u . DeepCopyInto ( out ) return out }
1770	func ( task * Task ) AssociationByTypeAndName ( associationType , associationName string ) ( * Association , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) for _ , association := range task . Associations { if association . Type == associationType && association . Name == associationName { return & association , true } } return nil , false }
5935	func ( r * BasicReporter ) PostCount ( statKey , userKey string , count int ) error { r . add ( newClassicStatCount ( statKey , userKey , count ) ) return nil }
6547	func ( c * Context ) AssuanSend ( cmd string , data AssuanDataCallback , inquiry AssuanInquireCallback , status AssuanStatusCallback , ) error { var operr C . gpgme_error_t dataPtr := callbackAdd ( & data ) inquiryPtr := callbackAdd ( & inquiry ) statusPtr := callbackAdd ( & status ) cmdCStr := C . CString ( cmd ) defer C . free ( unsafe . Pointer ( cmdCStr ) ) err := C . gogpgme_op_assuan_transact_ext ( c . ctx , cmdCStr , C . uintptr_t ( dataPtr ) , C . uintptr_t ( inquiryPtr ) , C . uintptr_t ( statusPtr ) , & operr , ) if handleError ( operr ) != nil { return handleError ( operr ) } return handleError ( err ) }
5179	func trace ( ctx context . Context , name string , fn func ( Tx ) error ) * Trace { if tx , ok := FromContext ( ctx ) ; ok { err := fn ( tx ) return & Trace { err : err , done : func ( ) error { return tx . EndSegment ( ) } , } } return & Trace { nil , func ( ) error { return nil } } }
5392	func ( gs * GShadow ) Passwd ( key [ ] byte ) { loadConfig ( ) gs . password , _ = config . crypter . Generate ( key , nil ) }
3264	func ( c * ConditionalFormat ) HasInvert ( ) bool { if c != nil && c . Invert != nil { return true } return false }
1302	func ( m * MockInfoLogger ) Info ( arg0 ... interface { } ) { varargs := [ ] interface { } { } for _ , a := range arg0 { varargs = append ( varargs , a ) } m . ctrl . Call ( m , "Info" , varargs ... ) }
4074	func DeactivateControls ( parent Control ) { for _ , ctrl := range parent . Children ( ) { if ctrl . Active ( ) { ctrl . SetActive ( false ) ctrl . ProcessEvent ( Event { Type : EventActivate , X : 0 } ) } DeactivateControls ( ctrl ) } }
1149	func ( mr * MockImageManagerMockRecorder ) AddAllImageStates ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "AddAllImageStates" , reflect . TypeOf ( ( * MockImageManager ) ( nil ) . AddAllImageStates ) , arg0 ) }
5500	func containsResultsInRange ( start time . Time , end time . Time , results [ ] time . Time ) bool { for _ , result := range results { if ( result . Equal ( start ) || result . After ( start ) ) && result . Before ( end ) { return true } } return false }
1160	func ( refreshHandler * refreshCredentialsHandler ) handlerFunc ( ) func ( message * ecsacs . IAMRoleCredentialsMessage ) { return func ( message * ecsacs . IAMRoleCredentialsMessage ) { refreshHandler . messageBuffer <- message } }
475	func ( req * Request ) ReleaseBody ( size int ) { if cap ( req . body . B ) > size { req . closeBodyStream ( ) req . body = nil } }
2683	func flattenClusterOrchestrationInfo ( d * schema . ResourceData , obj * types . ClusterOrchestrationInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { "ha_vm_restart_additional_delay" : obj . DefaultVmReadiness . PostReadyDelay , "ha_vm_dependency_restart_condition" : obj . DefaultVmReadiness . ReadyCondition , } ) }
5926	func NewReporter ( bufferSize , poolSize int , transport http . RoundTripper ) Reporter { r := new ( BasicReporter ) if transport == nil { transport = & http . Transport { MaxIdleConnsPerHost : poolSize , } } r . client = & http . Client { Transport : transport } r . reports = make ( chan * statReport , bufferSize ) r . done = make ( chan bool ) r . wg = new ( sync . WaitGroup ) for i := 0 ; i < poolSize ; i ++ { r . wg . Add ( 1 ) go r . processReports ( ) } return r }
323	func ( r * sampleRing ) iterator ( ) SeriesIterator { r . it . r = r r . it . i = - 1 return & r . it }
3953	func NewReader ( src io . Reader ) * Reader { r := & Reader { src : src } return r }
3908	func yaml_parser_set_input_reader ( parser * yaml_parser_t , r io . Reader ) { if parser . read_handler != nil { panic ( "must set the input source only once" ) } parser . read_handler = yaml_reader_read_handler parser . input_reader = r }
1527	func NewSession ( ctx context . Context , config * config . Config , deregisterInstanceEventStream * eventstream . EventStream , containerInstanceArn string , credentialsProvider * credentials . Credentials , ecsClient api . ECSClient , taskEngineState dockerstate . TaskEngineState , stateManager statemanager . StateManager , taskEngine engine . TaskEngine , credentialsManager rolecredentials . Manager , taskHandler * eventhandler . TaskHandler ) Session { resources := newSessionResources ( credentialsProvider ) backoff := retry . NewExponentialBackoff ( connectionBackoffMin , connectionBackoffMax , connectionBackoffJitter , connectionBackoffMultiplier ) derivedContext , cancel := context . WithCancel ( ctx ) return & session { agentConfig : config , deregisterInstanceEventStream : deregisterInstanceEventStream , containerInstanceARN : containerInstanceArn , credentialsProvider : credentialsProvider , ecsClient : ecsClient , state : taskEngineState , stateManager : stateManager , taskEngine : taskEngine , credentialsManager : credentialsManager , taskHandler : taskHandler , ctx : derivedContext , cancel : cancel , backoff : backoff , resources : resources , _heartbeatTimeout : heartbeatTimeout , _heartbeatJitter : heartbeatJitter , _inactiveInstanceReconnectDelay : inactiveInstanceReconnectDelay , } }
1065	func ( r * Runner ) Stop ( ) { r . stopLock . Lock ( ) defer r . stopLock . Unlock ( ) if r . stopped { return } log . Printf ( "[INFO] (runner) stopping" ) r . stopDedup ( ) r . stopWatcher ( ) r . stopChild ( ) if err := r . deletePid ( ) ; err != nil { log . Printf ( "[WARN] (runner) could not remove pid at %v: %s" , r . config . PidFile , err ) } r . stopped = true close ( r . DoneCh ) }
27	func ( g * Gate ) Start ( ctx context . Context ) error { select { case <- ctx . Done ( ) : return ctx . Err ( ) case g . ch <- struct { } { } : return nil } }
1476	func ( c * Container ) GetStartedAt ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . startedAt }
6678	func ( hm HandlerMap ) Merge ( other HandlerMap ) { for key , methods := range other { if _ , ok := hm [ key ] ; ! ok { hm [ key ] = map [ string ] Builder { } } for method , builder := range methods { hm [ key ] [ method ] = builder } } }
4976	func SortContainerMetrics ( messages [ ] * events . ContainerMetric ) [ ] * events . ContainerMetric { sort . Sort ( containerMetricSlice ( messages ) ) return messages }
1070	func ( r * Runner ) TemplateConfigMapping ( ) map [ string ] [ ] config . TemplateConfig { m := make ( map [ string ] [ ] config . TemplateConfig , len ( r . ctemplatesMap ) ) for id , set := range r . ctemplatesMap { ctmpls := make ( [ ] config . TemplateConfig , len ( set ) ) m [ id ] = ctmpls for i , ctmpl := range set { ctmpls [ i ] = * ctmpl } } return m }
5682	func ( st * state ) advance ( add int ) { if len ( st . str ) < add { panic ( "internal error" ) } st . str = st . str [ add : ] st . off += add }
6639	func CopyRect ( r Rectangle ) Rectangle { r1 := NewRect ( ) r1 . Min . Assign ( r . Min ) r1 . Max . Assign ( r . Max ) return r1 }
1036	func SignalVal ( s * os . Signal ) os . Signal { if s == nil { return ( os . Signal ) ( nil ) } return * s }
1281	func ( m * MockCgroupFactory ) Load ( arg0 cgroups . Hierarchy , arg1 cgroups . Path ) ( cgroups . Cgroup , error ) { ret := m . ctrl . Call ( m , "Load" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( cgroups . Cgroup ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6180	func BalanceClosingHash ( clientAddr , pscAddr common . Address , block uint32 , offeringHash common . Hash , balance uint64 ) [ ] byte { blockBytes := data . Uint32ToBytes ( block ) balanceBytes := data . Uint64ToBytes ( balance ) return crypto . Keccak256 ( [ ] byte ( "\x19Ethereum Signed Message:\n32" ) , \x19 , ) }
5867	func ( a * API ) FetchBroker ( cid CIDType ) ( * Broker , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid broker CID [none]" ) } brokerCID := string ( * cid ) matched , err := regexp . MatchString ( config . BrokerCIDRegex , brokerCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid broker CID [%s]" , brokerCID ) } result , err := a . Get ( brokerCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch broker, received JSON: %s" , string ( result ) ) } response := new ( Broker ) if err := json . Unmarshal ( result , & response ) ; err != nil { return nil , err } return response , nil }
3696	func ( w * Widget ) HasMustShowDistribution ( ) bool { if w != nil && w . MustShowDistribution != nil { return true } return false }
1864	func ( secret * SSMSecretResource ) retrieveSSMSecretValues ( region string , names [ ] string , iamCredentials credentials . IAMRoleCredentials , wg * sync . WaitGroup , errorEvents chan error ) { defer wg . Done ( ) ssmClient := secret . ssmClientCreator . NewSSMClient ( region , iamCredentials ) seelog . Infof ( "ssm secret resource: retrieving resource for secrets %v in region [%s] in task: [%s]" , names , region , secret . taskARN ) secValueMap , err := ssm . GetSecretsFromSSM ( names , ssmClient ) if err != nil { errorEvents <- fmt . Errorf ( "fetching secret data from SSM Parameter Store in %s: %v" , region , err ) return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for secretName , secretValue := range secValueMap { secretKey := secretName + "_" + region secret . secretData [ secretKey ] = secretValue } }
5240	func ValidLabel ( label string ) bool { return len ( label ) <= maxLabel && labelRegex . Match ( [ ] byte ( label ) ) }
5566	func ( o * FindVmsByStatesParams ) WithContext ( ctx context . Context ) * FindVmsByStatesParams { o . SetContext ( ctx ) return o }
610	func ( c * Compressor ) Handler ( ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { encoder , encoding , cleanup := c . selectEncoder ( r . Header , w ) cw := & compressResponseWriter { ResponseWriter : w , w : w , contentTypes : c . allowedTypes , encoding : encoding , } if encoder != nil { cw . w = encoder } defer cleanup ( ) defer cw . Close ( ) next . ServeHTTP ( cw , r ) } return http . HandlerFunc ( fn ) } }
6419	func ( list * LinkedList ) Swap ( x , y uint ) error { list . key . Lock ( ) defer list . key . Unlock ( ) var xNode , yNode * llNode if temp , ok := get ( list . first , x ) ; ok { xNode = temp } else { return fmt . Errorf ( "index out of bounds 'x', wanted less than %d got %d" , list . length , x ) } if temp , ok := get ( list . first , y ) ; ok { yNode = temp } else { return fmt . Errorf ( "index out of bounds 'y', wanted less than %d got %d" , list . length , y ) } temp := xNode . payload xNode . payload = yNode . payload yNode . payload = temp return nil }
721	func NewRfc2136Provider ( host string , port int , zoneName string , insecure bool , keyName string , secret string , secretAlg string , axfr bool , domainFilter DomainFilter , dryRun bool , actions rfc2136Actions ) ( Provider , error ) { secretAlgChecked , ok := tsigAlgs [ secretAlg ] if ! ok && ! insecure { return nil , errors . Errorf ( "%s is not supported TSIG algorithm" , secretAlg ) } r := & rfc2136Provider { nameserver : net . JoinHostPort ( host , strconv . Itoa ( port ) ) , zoneName : dns . Fqdn ( zoneName ) , insecure : insecure , domainFilter : domainFilter , dryRun : dryRun , axfr : axfr , } if actions != nil { r . actions = actions } else { r . actions = r } if ! insecure { r . tsigKeyName = dns . Fqdn ( keyName ) r . tsigSecret = secret r . tsigSecretAlg = secretAlgChecked } log . Infof ( "Configured RFC2136 with zone '%s' and nameserver '%s'" , r . zoneName , r . nameserver ) return r , nil }
2265	func ( v * Orientable ) native ( ) * C . GtkOrientable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkOrientable ( p ) }
6799	func Dir ( ) ( string , error ) { currentUser , err := user . Current ( ) if err != nil { return "" , err } if currentUser . HomeDir == "" { return "" , errors . New ( "cannot find user-specific home dir" ) } return currentUser . HomeDir , nil }
1642	func ( mr * MockBackoffMockRecorder ) Duration ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Duration" , reflect . TypeOf ( ( * MockBackoff ) ( nil ) . Duration ) ) }
2509	func ( c * disposeCommand ) Exec ( indexOffset int ) error { c . target . image . Dispose ( ) return nil }
5422	func NewGroup ( ) * Group { in := make ( chan Message ) close := make ( chan bool ) return & Group { in : in , close : close , clock : 0 } }
6086	func AddWithDataAndDelay ( q Queue , tx * reform . TX , jobType , relatedType , relatedID , creator string , jobData interface { } , delay time . Duration ) error { data2 , err := json . Marshal ( jobData ) if err != nil { return err } return q . Add ( tx , & data . Job { Type : jobType , RelatedType : relatedType , RelatedID : relatedID , CreatedBy : creator , Data : data2 , NotBefore : time . Now ( ) . Add ( delay ) , } ) }
6447	func logName ( logger , tag string , t time . Time ) ( name , link string ) { name = fmt . Sprintf ( "%s.%s.%s.log.%s.%s.%04d%02d%02d-%02d%02d%02d.%d" , program , host , userName , logger , tag , t . Year ( ) , t . Month ( ) , t . Day ( ) , t . Hour ( ) , t . Minute ( ) , t . Second ( ) , pid ) return name , program + "." + tag }
5334	func ( s * Shadow ) Add ( key [ ] byte ) ( err error ) { loadConfig ( ) shadow , err := LookupShadow ( s . Name ) if err != nil { if _ , ok := err . ( NoFoundError ) ; ! ok { return } } if shadow != nil { return ErrUserExist } if s . Name == "" { return RequiredError ( "Name" ) } if s . Max == 0 { return RequiredError ( "Max" ) } if s . Warn == 0 { return RequiredError ( "Warn" ) } if err = backup ( _SHADOW_FILE ) ; err != nil { return } db , err := openDBFile ( _SHADOW_FILE , os . O_WRONLY | os . O_APPEND ) if err != nil { return } defer func ( ) { e := db . close ( ) if e != nil && err == nil { err = e } } ( ) if key != nil { s . password , _ = config . crypter . Generate ( key , nil ) if s . changed == _ENABLE_AGING { s . setChange ( ) } } else { s . password = "*" } _ , err = db . file . WriteString ( s . String ( ) ) return }
4900	func ( s * Session ) FetchNext ( id uint64 , resultFieldSet * ResultFieldSet , fieldValues * FieldValues ) ( PartAttributes , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) s . resultsetID . id = & id if err := s . writeRequest ( mtFetchNext , false , s . resultsetID , fetchsize ( s . prm . FetchSize ( ) ) ) ; err != nil { return nil , err } f := func ( p replyPart ) { switch p := p . ( type ) { case * resultset : p . s = s p . resultFieldSet = resultFieldSet p . fieldValues = fieldValues } } if err := s . readReply ( f ) ; err != nil { return nil , err } return s . ph . partAttributes , nil }
6897	func NewWindow ( manager Windower ) * Window { wc := make ( chan * Window ) Queue ( func ( ) { w := & Window { id : lastWindowID , mgr : manager , x : maxX , y : maxY , focus : - 1 , backingStore : make ( [ ] Cell , maxX * maxY ) , widgets : make ( [ ] Widgeter , 0 , 16 ) , } lastWindowID ++ windows [ w . id ] = w windower2window [ manager ] = w manager . Init ( w ) wc <- w } ) return <- wc }
2695	func RelocateVM ( client * govmomi . Client , vm * object . VirtualMachine , spec types . VirtualMachineRelocateSpec , timeout int , pod * object . StoragePod , ) error { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return err } if ! sdrsEnabled { return fmt . Errorf ( "storage DRS is not enabled on datastore cluster %q" , pod . Name ( ) ) } log . Printf ( "[DEBUG] Relocating virtual machine %q to datastore cluster %q" , vm . InventoryPath , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Vm : types . NewReference ( vm . Reference ( ) ) , PodSelectionSpec : types . StorageDrsPodSelectionSpec { StoragePod : types . NewReference ( pod . Reference ( ) ) , } , Priority : types . VirtualMachineMovePriorityDefaultPriority , RelocateSpec : & spec , Type : string ( types . StoragePlacementSpecPlacementTypeRelocate ) , } _ , err = recommendAndApplySDRS ( client , sps , time . Minute * time . Duration ( timeout ) ) return err }
3650	func ( t * TriggeringValue ) GetFromTsOk ( ) ( int , bool ) { if t == nil || t . FromTs == nil { return 0 , false } return * t . FromTs , true }
2735	func tagTypeForObject ( obj object . Reference ) ( string , error ) { switch obj . ( type ) { case * object . VirtualMachine : return vSphereTagTypeVirtualMachine , nil case * object . Datastore : return vSphereTagTypeDatastore , nil case * object . Network : return vSphereTagTypeNetwork , nil case * object . Folder : return vSphereTagTypeFolder , nil case * object . VmwareDistributedVirtualSwitch : return vSphereTagTypeVmwareDistributedVirtualSwitch , nil case * object . DistributedVirtualSwitch : return vSphereTagTypeDistributedVirtualSwitch , nil case * object . DistributedVirtualPortgroup : return vSphereTagTypeDistributedVirtualPortgroup , nil case * object . Datacenter : return vSphereTagTypeDatacenter , nil case * object . ClusterComputeResource : return vSphereTagTypeClusterComputeResource , nil case * object . HostSystem : return vSphereTagTypeHostSystem , nil case * object . StoragePod : return vSphereTagTypeStoragePod , nil case * object . ResourcePool : return vSphereTagTypeResourcePool , nil case * object . VirtualApp : return vSphereTagTypeVirtualApp , nil } return "" , fmt . Errorf ( "unsupported type for tagging: %T" , obj ) }
5229	func NewPQLRowsQuery ( pql string , index * Index , err error ) * PQLRowsQuery { return & PQLRowsQuery { index : index , pql : pql , err : err , } }
5790	func ( a * API ) DeleteAnnotationByCID ( cid CIDType ) ( bool , error ) { if cid == nil || * cid == "" { return false , fmt . Errorf ( "Invalid annotation CID [none]" ) } annotationCID := string ( * cid ) matched , err := regexp . MatchString ( config . AnnotationCIDRegex , annotationCID ) if err != nil { return false , err } if ! matched { return false , fmt . Errorf ( "Invalid annotation CID [%s]" , annotationCID ) } _ , err = a . Delete ( annotationCID ) if err != nil { return false , err } return true , nil }
3557	func ( s * SyntheticsTest ) GetMonitorStatusOk ( ) ( string , bool ) { if s == nil || s . MonitorStatus == nil { return "" , false } return * s . MonitorStatus , true }
4014	func ( d * FileSelectDialog ) detectPath ( ) { p := d . currPath if p == "" { d . currPath , _ = os . Getwd ( ) return } p = filepath . Clean ( p ) for { _ , err := os . Stat ( p ) if err == nil { break } dirUp := filepath . Dir ( p ) if dirUp == p { p , _ = os . Getwd ( ) break } p = dirUp } d . currPath = p }
571	func ( mx * Mux ) MethodFunc ( method , pattern string , handlerFn http . HandlerFunc ) { mx . Method ( method , pattern , handlerFn ) }
1046	func NewKVGetQuery ( s string ) ( * KVGetQuery , error ) { if s != "" && ! KVGetQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "kv.get: invalid format: %q" , s ) } m := regexpMatch ( KVGetQueryRe , s ) return & KVGetQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ "dc" ] , key : m [ "key" ] , } , nil }
874	func ( r * BugsnagCrashReporter ) Send ( err CrashError ) error { if r . noReportFileExist ( ) || r . apiKey == noreportAPIKey { log . Debug ( "Opting out of crash reporting." ) return nil } if r . apiKey == "" { return errors . New ( "no api key has been set" ) } bugsnag . Configure ( bugsnag . Configuration { APIKey : r . apiKey , ReleaseStage : fmt . Sprintf ( "%s (%s)" , runtime . GOOS , runtime . GOARCH ) , ProjectPackages : [ ] string { "github.com/docker/machine/[^v]*" } , AppVersion : version . FullVersion ( ) , Synchronous : true , PanicHandler : func ( ) { } , Logger : new ( logger ) , } ) metaData := bugsnag . MetaData { } metaData . Add ( "app" , "compiler" , fmt . Sprintf ( "%s (%s)" , runtime . Compiler , runtime . Version ( ) ) ) metaData . Add ( "device" , "os" , runtime . GOOS ) metaData . Add ( "device" , "arch" , runtime . GOARCH ) detectRunningShell ( & metaData ) detectUname ( & metaData ) detectOSVersion ( & metaData ) addFile ( err . LogFilePath , & metaData ) var buffer bytes . Buffer for _ , message := range log . History ( ) { buffer . WriteString ( message + "\n" ) } \n metaData . Add ( "history" , "trace" , buffer . String ( ) ) }
1408	func ( mr * MockECSSubmitStateSDKMockRecorder ) SubmitContainerStateChange ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "SubmitContainerStateChange" , reflect . TypeOf ( ( * MockECSSubmitStateSDK ) ( nil ) . SubmitContainerStateChange ) , arg0 ) }
258	func ( n * Manager ) DroppedAlertmanagers ( ) [ ] * url . URL { n . mtx . RLock ( ) amSets := n . alertmanagers n . mtx . RUnlock ( ) var res [ ] * url . URL for _ , ams := range amSets { ams . mtx . RLock ( ) for _ , dam := range ams . droppedAms { res = append ( res , dam . url ( ) ) } ams . mtx . RUnlock ( ) } return res }
4963	func UInt32ToBytes ( value uint32 ) [ ] byte { result := make ( [ ] byte , 4 ) binary . BigEndian . PutUint32 ( result , value ) return result }
6217	func ( w * Worker ) ClientPreServiceTerminate ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientPreServiceTerminate" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientPreServiceTerminate ) if err != nil { return err } logger = logger . Add ( "channel" , ch ) if ch . ServiceStatus == data . ServiceActive { ch . ServiceStatus = data . ServiceTerminating } else { ch . ServiceStatus = data . ServiceTerminated } changedTime := time . Now ( ) ch . ServiceChangedTime = & changedTime err = w . saveRecord ( logger , w . db . Querier , ch ) if err != nil { return err } return nil }
5689	func mergeQualifiers ( q1 , q2 Qualifiers ) Qualifiers { m := make ( map [ string ] bool ) for _ , qual := range q1 { m [ qual ] = true } for _ , qual := range q2 { if ! m [ qual ] { q1 = append ( q1 , qual ) m [ qual ] = true } } return q1 }
493	func ( h * ResponseHeader ) ContentType ( ) [ ] byte { contentType := h . contentType if ! h . noDefaultContentType && len ( h . contentType ) == 0 { contentType = defaultContentType } return contentType }
4052	func ( l * ListBox ) Clear ( ) { l . items = make ( [ ] string , 0 ) l . currSelection = - 1 l . topLine = 0 }
4099	func ( l * TableView ) SetSelectedCol ( col int ) { oldSelection := l . selectedCol if col >= len ( l . columns ) { l . selectedCol = len ( l . columns ) - 1 } else if col < - 1 { l . selectedCol = - 1 } if l . selectedCol != oldSelection { l . EnsureColVisible ( ) l . emitSelectionChange ( ) } }
203	func NewManager ( o * ManagerOptions ) * Manager { if o . Metrics == nil { o . Metrics = NewGroupMetrics ( o . Registerer ) } m := & Manager { groups : map [ string ] * Group { } , opts : o , block : make ( chan struct { } ) , logger : o . Logger , } if o . Registerer != nil { o . Registerer . MustRegister ( m ) } o . Metrics . iterationsMissed . Inc ( ) return m }
6396	func ( iter Enumerator ) Where ( predicate Predicate ) Enumerator { retval := make ( chan interface { } ) go func ( ) { for item := range iter { if predicate ( item ) { retval <- item } } close ( retval ) } ( ) return retval }
5508	func ( f * FileLogger ) logWriter ( ) { defer func ( ) { if err := recover ( ) ; err != nil { log . Printf ( "FileLogger's LogWritter() catch panic: %v\n" , \n ) } } err ( ) printInterval := DEFAULT_PRINT_INTERVAL seqTimer := time . NewTicker ( time . Duration ( printInterval ) * time . Second ) }
2946	func resourceVSphereDatastoreClusterValidateEmptyCluster ( d structure . ResourceIDStringer , pod * object . StoragePod ) error { log . Printf ( "[DEBUG] %s: Checking to ensure that datastore cluster is empty" , resourceVSphereDatastoreClusterIDString ( d ) ) ne , err := storagepod . HasChildren ( pod ) if err != nil { return fmt . Errorf ( "error checking for datastore cluster contents: %s" , err ) } if ne { return fmt . Errorf ( "datastore cluster %q still has datastores. Please move or remove all datastores before deleting" , pod . InventoryPath , ) } return nil }
4853	func GenODBC ( u * URL ) ( string , error ) { q := u . Query ( ) host , port , dbname := hostname ( u . Host ) , hostport ( u . Host ) , strings . TrimPrefix ( u . Path , "/" ) if u . hostPortDB == nil { u . hostPortDB = [ ] string { host , port , dbname } } q . Set ( "Driver" , "{" + strings . Replace ( u . Proto , "+" , " " , - 1 ) + "}" ) q . Set ( "Server" , host ) if port == "" { proto := strings . ToLower ( u . Proto ) switch { case strings . Contains ( proto , "mysql" ) : q . Set ( "Port" , "3306" ) case strings . Contains ( proto , "postgres" ) : q . Set ( "Port" , "5432" ) case strings . Contains ( proto , "db2" ) || strings . Contains ( proto , "ibm" ) : q . Set ( "ServiceName" , "50000" ) default : q . Set ( "Port" , "1433" ) } } else { q . Set ( "Port" , port ) } q . Set ( "Database" , dbname ) if u . User != nil { q . Set ( "UID" , u . User . Username ( ) ) p , _ := u . User . Password ( ) q . Set ( "PWD" , p ) } return genOptionsODBC ( q , true ) , nil }
3444	func ( o * Options ) GetThresholdWindowsOk ( ) ( ThresholdWindows , bool ) { if o == nil || o . ThresholdWindows == nil { return ThresholdWindows { } , false } return * o . ThresholdWindows , true }
6742	func ( c * MConnection ) _recover ( ) { if r := recover ( ) ; r != nil { stack := debug . Stack ( ) err := cmn . StackError { r , stack } c . stopForError ( err ) } }
290	func ( s * ReadyStorage ) Set ( db * tsdb . DB , startTimeMargin int64 ) { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) s . a = & adapter { db : db , startTimeMargin : startTimeMargin } }
3390	func ( m * MetricMetadata ) GetShortNameOk ( ) ( string , bool ) { if m == nil || m . ShortName == nil { return "" , false } return * m . ShortName , true }
6887	func ( w * Window ) focusWidget ( ) { setCursor ( - 1 , - 1 ) if w . focus < 0 { for i , widget := range w . widgets { if widget . CanFocus ( ) { w . focus = i widget . Focus ( ) return } } return } if w . focus > len ( w . widgets ) { return } w . widgets [ w . focus ] . Focus ( ) }
4569	func ( c * Context ) Has ( key string ) bool { return c . Value ( key ) != nil }
1106	func explodeHelper ( m map [ string ] interface { } , k , v , p string ) error { if strings . Contains ( k , "/" ) { parts := strings . Split ( k , "/" ) top := parts [ 0 ] key := strings . Join ( parts [ 1 : ] , "/" ) if _ , ok := m [ top ] ; ! ok { m [ top ] = make ( map [ string ] interface { } ) } nest , ok := m [ top ] . ( map [ string ] interface { } ) if ! ok { return fmt . Errorf ( "not a map: %q: %q already has value %q" , p , top , m [ top ] ) } return explodeHelper ( nest , key , v , k ) } if k != "" { m [ k ] = v } return nil }
1279	func GetSecretFromASM ( secretID string , client secretsmanageriface . SecretsManagerAPI ) ( string , error ) { in := & secretsmanager . GetSecretValueInput { SecretId : aws . String ( secretID ) , } out , err := client . GetSecretValue ( in ) if err != nil { return "" , errors . Wrapf ( err , "secret %s" , secretID ) } return aws . StringValue ( out . SecretString ) , nil }
2146	func ( m * Matrix ) InitTranslate ( tx , ty float64 ) { C . cairo_matrix_init_translate ( m . native ( ) , C . double ( tx ) , C . double ( ty ) ) }
7148	func DefaultServiceConfig ( ) ServiceConfig { return ServiceConfig { BackoffFactory : func ( ) Backoff { return & backoff . StopBackOff { } } , RandFactory : rand . Int , RandReader : rand . Reader , Timeout : 1 * time . Second , } }
2388	func ( f * Field ) flushLine ( j int ) bool { for i := 0 ; i < fieldBlockNumX ; i ++ { if f . blocks [ i ] [ j ] == BlockTypeNone { return false } } for j2 := j ; 1 <= j2 ; j2 -- { for i := 0 ; i < fieldBlockNumX ; i ++ { f . blocks [ i ] [ j2 ] = f . blocks [ i ] [ j2 - 1 ] } } for i := 0 ; i < fieldBlockNumX ; i ++ { f . blocks [ i ] [ 0 ] = BlockTypeNone } return true }
813	func migrateStringToSlice ( value string , values [ ] string ) ( result [ ] string ) { if value != "" { result = append ( result , value ) } result = append ( result , values ... ) return }
6889	func ( w * Window ) keyHandler ( ev termbox . Event ) ( bool , Windower , Widgeter ) { if w . focus < 0 || w . focus > len ( w . widgets ) { return false , w . mgr , nil } return w . widgets [ w . focus ] . KeyHandler ( ev ) , w . mgr , w . widgets [ w . focus ] }
6499	func ( r rpc ) createRequest ( method string , endpoint string , params [ ] byte ) ( * http . Request , error ) { endpoint = r . auth . getBaseUrl ( ) + endpoint req , err := http . NewRequest ( method , endpoint , bytes . NewBuffer ( params ) ) if err != nil { return nil , err } r . auth . authenticate ( req , endpoint , params ) req . Header . Set ( "User-Agent" , "CoinbaseGo/v1" ) req . Header . Set ( "Content-Type" , "application/json" ) return req , nil }
3815	func ( s * Server ) Bootstrap ( ) ( ts TraversalStats , err error ) { initialAddrs , err := s . traversalStartingNodes ( ) if err != nil { return } var outstanding sync . WaitGroup triedAddrs := newBloomFilterForTraversal ( ) var onAddr func ( addr Addr ) onAddr = func ( addr Addr ) { if triedAddrs . Test ( [ ] byte ( addr . String ( ) ) ) { return } ts . NumAddrsTried ++ outstanding . Add ( 1 ) triedAddrs . AddString ( addr . String ( ) ) s . findNode ( addr , s . id , func ( m krpc . Msg , err error ) { defer outstanding . Done ( ) s . mu . Lock ( ) defer s . mu . Unlock ( ) if err != nil { return } ts . NumResponses ++ if r := m . R ; r != nil { r . ForAllNodes ( func ( ni krpc . NodeInfo ) { onAddr ( NewAddr ( ni . Addr . UDP ( ) ) ) } ) } } ) } s . mu . Lock ( ) for _ , addr := range initialAddrs { onAddr ( NewAddr ( addr . Addr . UDP ( ) ) ) } s . mu . Unlock ( ) outstanding . Wait ( ) return }
4648	func NewExpiringClusteringIndex ( expiration Minutes ) * ClusteringIndex { index := & ClusteringIndex { } index . streetLevel = NewExpiringPointsIndex ( Km ( 0.5 ) , expiration ) index . cityLevel = NewExpiringCountIndex ( Km ( 10 ) , expiration ) index . worldLevel = NewExpiringCountIndex ( Km ( 500 ) , expiration ) return index }
2214	func ( v * SimpleAction ) SetEnabled ( enabled bool ) { C . g_simple_action_set_enabled ( v . native ( ) , gbool ( enabled ) ) }
5111	func ( gfs * GridFS ) Remove ( name string ) ( err error ) { iter := gfs . Files . Find ( bson . M { "filename" : name } ) . Select ( bson . M { "_id" : 1 } ) . Iter ( ) var doc gfsDocId for iter . Next ( & doc ) { if e := gfs . RemoveId ( doc . Id ) ; e != nil { err = e } } if err == nil { err = iter . Close ( ) } return err }
4881	func ( e * hdbErrors ) IsFatal ( ) bool { return e . errors [ e . idx ] . errorLevel == errorLevelFatalError }
6802	func ( s * Session ) TimeElapsed ( ) time . Duration { s . mu . Lock ( ) defer s . mu . Unlock ( ) if v , ok := s . Decoded [ "time_elapsed" ] . ( string ) ; ok { if dur , err := time . ParseDuration ( v + "s" ) ; err == nil { return dur } } return time . Second * - 1 }
4372	func Base64Value ( v * strfmt . Base64 ) strfmt . Base64 { if v == nil { return nil } return * v }
6967	func ( c GConfig ) GetInt ( key string ) int { i , _ := strconv . Atoi ( c . getStringValue ( key ) ) return i }
1213	func ( dg * dockerGoClient ) APIVersion ( ) ( dockerclient . DockerVersion , error ) { client , err := dg . sdkDockerClient ( ) if err != nil { return "" , err } return dg . sdkClientFactory . FindClientAPIVersion ( client ) , nil }
2026	func ( err * ResourceInitError ) Error ( ) string { return fmt . Sprintf ( "resource cannot be initialized for task %s: %v" , err . taskARN , err . origErr ) }
6737	func ( p * Peer ) Send ( chID byte , msg interface { } ) bool { if ! p . IsRunning ( ) { return false } return p . mconn . Send ( chID , msg ) }
1354	func ( agent * ecsAgent ) constructVPCSubnetAttributes ( ) [ ] * ecs . Attribute { return [ ] * ecs . Attribute { { Name : aws . String ( vpcIDAttributeName ) , Value : aws . String ( agent . vpc ) , } , { Name : aws . String ( subnetIDAttributeName ) , Value : aws . String ( agent . subnet ) , } , } }
6459	func ( l * Log ) setVState ( verbosity Level , modules [ ] modulePat , filepaths [ ] filepathPat , setFilter bool ) { l . verbosity . set ( 0 ) atomic . StoreInt32 ( & l . filterLength , 0 ) nfilters := 0 if setFilter { if modules != nil { l . vmodule . filter = modules } if filepaths != nil { l . vfilepath . filter = filepaths } nfilters = len ( l . vmodule . filter ) + len ( l . vfilepath . filter ) l . vmap = make ( map [ uintptr ] Level ) } atomic . StoreInt32 ( & l . filterLength , int32 ( nfilters ) ) l . verbosity . set ( verbosity ) }
4615	func extractArgumentsType ( f * ast . FuncDecl ) ( [ ] string , bool ) { var fields [ ] * ast . Field if f . Recv != nil { if len ( f . Recv . List ) != 1 { panic ( "Expect only one receiver; please fix panicparse's code" ) } if _ , ok := f . Recv . List [ 0 ] . Type . ( * ast . StarExpr ) ; ok { fields = append ( fields , f . Recv . List [ 0 ] ) } } var types [ ] string extra := false for _ , arg := range append ( fields , f . Type . Params . List ... ) { var t string t , extra = fieldToType ( arg ) mult := len ( arg . Names ) if mult == 0 { mult = 1 } for i := 0 ; i < mult ; i ++ { types = append ( types , t ) } } return types , extra }
26	func ( d * Deduper ) Log ( keyvals ... interface { } ) error { line , err := encode ( keyvals ... ) if err != nil { return err } d . mtx . RLock ( ) last , ok := d . seen [ line ] d . mtx . RUnlock ( ) if ok && time . Since ( last ) < d . repeat { return nil } d . mtx . Lock ( ) if len ( d . seen ) < maxEntries { d . seen [ line ] = time . Now ( ) } d . mtx . Unlock ( ) return d . next . Log ( keyvals ... ) }
5969	func truncate ( in [ ] byte ) int64 { offset := int ( in [ len ( in ) - 1 ] & 0xF ) p := in [ offset : offset + 4 ] var binCode int32 binCode = int32 ( ( p [ 0 ] & 0x7f ) ) << 24 binCode += int32 ( ( p [ 1 ] & 0xff ) ) << 16 binCode += int32 ( ( p [ 2 ] & 0xff ) ) << 8 binCode += int32 ( ( p [ 3 ] & 0xff ) ) return int64 ( binCode ) & 0x7FFFFFFF }
5665	func ( ps * printState ) writeString ( s string ) { if len ( s ) > 0 { ps . last = s [ len ( s ) - 1 ] } ps . buf . WriteString ( s ) }
4562	func RunScript ( input string , ctx hctx . Context ) error { input = "<% " + input + "%>" ctx = ctx . New ( ) ctx . Set ( "print" , func ( i interface { } ) { fmt . Print ( i ) } ) ctx . Set ( "println" , func ( i interface { } ) { fmt . Println ( i ) } ) _ , err := Render ( input , ctx ) return err }
2311	func ( v * TextMark ) native ( ) * C . GtkTextMark { if v == nil { return nil } return ( * C . GtkTextMark ) ( v ) }
117	func ParseExpr ( input string ) ( Expr , error ) { p := newParser ( input ) expr , err := p . parseExpr ( ) if err != nil { return nil , err } err = p . typecheck ( expr ) return expr , err }
2726	func resourceVSphereVirtualDisk ( ) * schema . Resource { return & schema . Resource { Create : resourceVSphereVirtualDiskCreate , Read : resourceVSphereVirtualDiskRead , Delete : resourceVSphereVirtualDiskDelete , Schema : map [ string ] * schema . Schema { "size" : { Type : schema . TypeInt , Required : true , ForceNew : true , } , "vmdk_path" : { Type : schema . TypeString , Required : true , ForceNew : true , } , "datastore" : { Type : schema . TypeString , Required : true , ForceNew : true , } , "type" : { Type : schema . TypeString , Optional : true , ForceNew : true , Default : "eagerZeroedThick" , ValidateFunc : func ( v interface { } , k string ) ( ws [ ] string , errors [ ] error ) { value := v . ( string ) if value != "thin" && value != "eagerZeroedThick" && value != "lazy" { errors = append ( errors , fmt . Errorf ( "only 'thin', 'eagerZeroedThick', and 'lazy' are supported values for 'type'" ) ) } return } , } , "adapter_type" : { Type : schema . TypeString , Optional : true , ForceNew : true , Default : "lsiLogic" , Deprecated : "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead" , ValidateFunc : func ( v interface { } , k string ) ( ws [ ] string , errors [ ] error ) { value := v . ( string ) if value != "ide" && value != "busLogic" && value != "lsiLogic" { errors = append ( errors , fmt . Errorf ( "only 'ide', 'busLogic', and 'lsiLogic' are supported values for 'adapter_type'" ) ) } return } , } , "datacenter" : { Type : schema . TypeString , Optional : true , ForceNew : true , } , "create_directories" : { Type : schema . TypeBool , Optional : true , ForceNew : true , } , } , } }
3097	func getNextWildcard ( pattern string ) ( wildcard , _ string ) { pos := wildcardPattern . FindStringIndex ( pattern ) if pos == nil { return "" , pattern } wildcard = pattern [ pos [ 0 ] : pos [ 1 ] ] if len ( pattern ) == pos [ 1 ] { return wildcard , strings . Replace ( pattern , wildcard , `(.+)` , 1 ) } else if pattern [ pos [ 1 ] ] != '(' { switch { case isSpecialRegexp ( pattern , ":int" , pos ) : pattern = strings . Replace ( pattern , ":int" , "([0-9]+)" , 1 ) case isSpecialRegexp ( pattern , ":string" , pos ) : pattern = strings . Replace ( pattern , ":string" , "([\\w]+)" , \\ ) 1 } } default : return wildcard , strings . Replace ( pattern , wildcard , `(.+)` , 1 ) }
5900	func peekField ( buf [ ] byte , fieldName string , pos tokenPosition ) ( string , error ) { var err error ut := UnverifiedToken { } err = DecodeUnverifiedToken ( buf , & ut ) if err != nil { return "" , err } var typ string var b [ ] byte switch pos { case tokenPositionHeader : typ = "header" b = ut . Header case tokenPositionPayload : typ = "payload" b = ut . Payload default : return "" , fmt . Errorf ( "invalid field %d" , pos ) } dec , err := b64 . DecodeString ( string ( b ) ) if err != nil { return "" , fmt . Errorf ( "could not decode token %s" , typ ) } m := make ( map [ string ] interface { } ) err = json . Unmarshal ( dec , & m ) if err != nil { return "" , err } if val , ok := m [ fieldName ] ; ok { return fmt . Sprintf ( "%v" , val ) , nil } return "" , fmt . Errorf ( "token %s field %s not present or invalid" , typ , fieldName ) }
1304	func ( event * sendableEvent ) taskShouldBeSent ( ) bool { event . lock . RLock ( ) defer event . lock . RUnlock ( ) if event . isContainerEvent { return false } tevent := event . taskChange if event . taskSent { return false } if tevent . Task == nil { return false } if tevent . Task . GetSentStatus ( ) < tevent . Status { return true } for _ , containerStateChange := range tevent . Containers { container := containerStateChange . Container if container . GetSentStatus ( ) < container . GetKnownStatus ( ) { return true } } return false }
60	func NewQueryStats ( tg * QueryTimers ) * QueryStats { var qt queryTimings for s , timer := range tg . TimerGroup . timers { switch s { case EvalTotalTime : qt . EvalTotalTime = timer . Duration ( ) case ResultSortTime : qt . ResultSortTime = timer . Duration ( ) case QueryPreparationTime : qt . QueryPreparationTime = timer . Duration ( ) case InnerEvalTime : qt . InnerEvalTime = timer . Duration ( ) case ExecQueueTime : qt . ExecQueueTime = timer . Duration ( ) case ExecTotalTime : qt . ExecTotalTime = timer . Duration ( ) } } qs := QueryStats { Timings : qt } return & qs }
3668	func ( w * Widget ) GetHTMLOk ( ) ( string , bool ) { if w == nil || w . HTML == nil { return "" , false } return * w . HTML , true }
7169	func ( s * Stack ) PeakHeader ( ) ( header [ ] byte , err error ) { if s . depth == 0 { return nil , nil } s . guard . Lock ( ) defer s . guard . Unlock ( ) s . lastAccess = time . Now ( ) file , err := s . getFile ( ) if err != nil { return nil , err } header = make ( [ ] byte , s . currentBlock . HeaderSize ) _ , err = file . ReadAt ( header , int64 ( s . currentBlock . HeaderPoint ) ) if err != nil { return nil , err } return header , nil }
5976	func Unmarshal ( in [ ] byte ) ( otp * HOTP , err error ) { var asnHOTP struct { Key [ ] byte Counter * big . Int Digits int } _ , err = asn1 . Unmarshal ( in , & asnHOTP ) if err != nil { return } otp = & HOTP { Key : asnHOTP . Key [ : ] , Digits : asnHOTP . Digits , } otp . setCounter ( asnHOTP . Counter . Uint64 ( ) ) return }
449	func ( s * Server ) ListenAndServeTLSEmbed ( addr string , certData , keyData [ ] byte ) error { ln , err := net . Listen ( "tcp4" , addr ) if err != nil { return err } if s . TCPKeepalive { if tcpln , ok := ln . ( * net . TCPListener ) ; ok { return s . ServeTLSEmbed ( tcpKeepaliveListener { TCPListener : tcpln , keepalivePeriod : s . TCPKeepalivePeriod , } , certData , keyData ) } } return s . ServeTLSEmbed ( ln , certData , keyData ) }
4830	func ( g GitOS ) TimeSince ( t time . Time ) time . Duration { return time . Since ( t ) }
6619	func SupplierWithPrependedArgs ( s CmderSupplier , argsFunc func ( cmd Cmd ) [ ] string ) CmderSupplier { return func ( cmd Cmd ) ( Cmder , error ) { r , err := s ( cmd ) if err != nil { return nil , err } return CmderWithPrependedArgs ( r , argsFunc ( cmd ) ... ) , nil } }
4707	func ( l * line ) isPlainText ( ) bool { return len ( l . tokens ) > 0 && ( l . tokens [ 0 ] == pipe || l . tokens [ 0 ] == doublePipe ) }
2294	func ( v * ToggleButton ) native ( ) * C . GtkToggleButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToggleButton ( p ) }
2770	func expandVirtualMachineConfigSpec ( d * schema . ResourceData , client * govmomi . Client ) ( types . VirtualMachineConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Building config spec" , resourceVSphereVirtualMachineIDString ( d ) ) vappConfig , err := expandVAppConfig ( d , client ) if err != nil { return types . VirtualMachineConfigSpec { } , err } obj := types . VirtualMachineConfigSpec { Name : d . Get ( "name" ) . ( string ) , GuestId : getWithRestart ( d , "guest_id" ) . ( string ) , AlternateGuestName : getWithRestart ( d , "alternate_guest_name" ) . ( string ) , Annotation : d . Get ( "annotation" ) . ( string ) , Tools : expandToolsConfigInfo ( d ) , Flags : expandVirtualMachineFlagInfo ( d ) , NumCPUs : expandCPUCountConfig ( d ) , NumCoresPerSocket : int32 ( getWithRestart ( d , "num_cores_per_socket" ) . ( int ) ) , MemoryMB : expandMemorySizeConfig ( d ) , MemoryHotAddEnabled : getBoolWithRestart ( d , "memory_hot_add_enabled" ) , CpuHotAddEnabled : getBoolWithRestart ( d , "cpu_hot_add_enabled" ) , CpuHotRemoveEnabled : getBoolWithRestart ( d , "cpu_hot_remove_enabled" ) , CpuAllocation : expandVirtualMachineResourceAllocation ( d , "cpu" ) , MemoryAllocation : expandVirtualMachineResourceAllocation ( d , "memory" ) , MemoryReservationLockedToMax : getMemoryReservationLockedToMax ( d ) , ExtraConfig : expandExtraConfig ( d ) , SwapPlacement : getWithRestart ( d , "swap_placement_policy" ) . ( string ) , BootOptions : expandVirtualMachineBootOptions ( d , client ) , VAppConfig : vappConfig , Firmware : getWithRestart ( d , "firmware" ) . ( string ) , NestedHVEnabled : getBoolWithRestart ( d , "nested_hv_enabled" ) , VPMCEnabled : getBoolWithRestart ( d , "cpu_performance_counters_enabled" ) , LatencySensitivity : expandLatencySensitivity ( d ) , } return obj , nil }
4163	func ( c * Client ) Disconnect ( ) error { if ! c . connActive . get ( ) { return ErrConnectionIsNotOpen } c . userDisconnect . Close ( ) return nil }
3334	func ( g * GroupData ) GetLastResolvedTs ( ) int { if g == nil || g . LastResolvedTs == nil { return 0 } return * g . LastResolvedTs }
2646	func resourceVSphereComputeClusterApplyCustomAttributes ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { client := meta . ( * VSphereClient ) . vimClient attrsProcessor , err := customattribute . GetDiffProcessorIfAttributesDefined ( client , d ) if err != nil { return err } if attrsProcessor == nil { log . Printf ( "[DEBUG] %s: Custom attributes unsupported on this connection, skipping" , resourceVSphereComputeClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying any pending custom attributes" , resourceVSphereComputeClusterIDString ( d ) ) return attrsProcessor . ProcessDiff ( cluster ) }
3621	func ( t * ToggleStatus ) HasNewStatus ( ) bool { if t != nil && t . NewStatus != nil { return true } return false }
2861	func RenameObject ( client * govmomi . Client , ref types . ManagedObjectReference , new string ) error { req := types . Rename_Task { This : ref , NewName : new , } rctx , rcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer rcancel ( ) res , err := methods . Rename_Task ( rctx , client . Client , & req ) if err != nil { return err } t := object . NewTask ( client . Client , res . Returnval ) tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) return t . Wait ( tctx ) }
3208	func ( client * Client ) DeleteUser ( handle string ) error { uri := "/v1/user/" + handle return client . doJsonRequest ( "DELETE" , uri , nil , nil ) }
80	func newHypervisorDiscovery ( provider * gophercloud . ProviderClient , opts * gophercloud . AuthOptions , port int , region string , l log . Logger ) * HypervisorDiscovery { return & HypervisorDiscovery { provider : provider , authOpts : opts , region : region , port : port , logger : l } }
2773	func getMemoryReservationLockedToMax ( d * schema . ResourceData ) * bool { if d . Get ( "memory_reservation" ) . ( int ) != d . Get ( "memory" ) . ( int ) { return structure . BoolPtr ( false ) } return nil }
5257	func ( c * Client ) statusToNodeShardsForIndex ( status Status , indexName string ) ( map [ uint64 ] * URI , error ) { result := make ( map [ uint64 ] * URI ) if maxShard , ok := status . indexMaxShard [ indexName ] ; ok { for shard := 0 ; shard <= int ( maxShard ) ; shard ++ { fragmentNodes , err := c . fetchFragmentNodes ( indexName , uint64 ( shard ) ) if err != nil { return nil , err } if len ( fragmentNodes ) == 0 { return nil , ErrNoFragmentNodes } node := fragmentNodes [ 0 ] uri := & URI { host : node . Host , port : node . Port , scheme : node . Scheme , } result [ uint64 ( shard ) ] = uri } } else { return nil , ErrNoShard } return result , nil }
6930	func NewRateScale ( d time . Duration ) * Rate { return & Rate { time : time . Now ( ) . UnixNano ( ) , unit : d . Seconds ( ) , } }
6775	func ( r * PEXReactor ) IncrementMsgCountForPeer ( addr string ) { var count uint16 countI := r . msgCountByPeer . Get ( addr ) if countI != nil { count = countI . ( uint16 ) } count ++ r . msgCountByPeer . Set ( addr , count ) }
5708	func ( s * Sentinel ) close ( ) { if s . pools != nil { for _ , pool := range s . pools { pool . Close ( ) } } s . pools = nil }
298	func NewRegexp ( s string ) ( Regexp , error ) { regex , err := regexp . Compile ( "^(?:" + s + ")$" ) return Regexp { Regexp : regex , original : s , } , err }
2126	func ( v * Variant ) IsType ( t * VariantType ) bool { return gobool ( C . g_variant_is_of_type ( v . native ( ) , t . native ( ) ) ) }
5680	func ( st * state ) fail ( err string ) { panic ( demangleErr { err : err , off : st . off } ) }
2128	func ( v * FrameTimings ) native ( ) * C . GdkFrameTimings { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkFrameTimings ( p ) }
4403	func ( b * Base64 ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { enc := base64 . StdEncoding dbuf := make ( [ ] byte , enc . DecodedLen ( len ( data ) ) ) n , err := enc . Decode ( dbuf , [ ] byte ( data ) ) if err != nil { in . AddError ( err ) return } * b = dbuf [ : n ] } }
4793	func ( g * gitCmd ) Exec ( dir string ) error { g . Lock ( ) g . dir = dir g . Unlock ( ) if g . background { return g . execBackground ( dir ) } return g . exec ( dir ) }
482	func ( req * Request ) CopyTo ( dst * Request ) { req . copyToSkipBody ( dst ) if req . body != nil { dst . bodyBuffer ( ) . Set ( req . body . B ) } else if dst . body != nil { dst . body . Reset ( ) } }
94	func ( t * Target ) offset ( interval time . Duration , jitterSeed uint64 ) time . Duration { now := time . Now ( ) . UnixNano ( ) var ( base = int64 ( interval ) - now % int64 ( interval ) offset = ( t . hash ( ) ^ jitterSeed ) % uint64 ( interval ) next = base + int64 ( offset ) ) if next > int64 ( interval ) { next -= int64 ( interval ) } return time . Duration ( next ) }
1793	func ( healthStatus * ContainerHealthStatus ) UnmarshalJSON ( b [ ] byte ) error { * healthStatus = ContainerHealthUnknown if strings . ToLower ( string ( b ) ) == "null" { return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { return errors . New ( "container health status unmarshal: status must be a string or null; Got " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) switch strStatus { case "UNKNOWN" : case "HEALTHY" : * healthStatus = ContainerHealthy case "UNHEALTHY" : * healthStatus = ContainerUnhealthy default : return errors . New ( "container health status unmarshal: unrecognized status: " + string ( b ) ) } return nil }
5918	func ( it * Iterator ) Value ( ) [ ] byte { valOffset , valSize := decodeValue ( it . value ) return it . arena . GetBytes ( valOffset , uint32 ( valSize ) ) }
430	func ( ctx * RequestCtx ) TLSConnectionState ( ) * tls . ConnectionState { tlsConn , ok := ctx . c . ( connTLSer ) if ! ok { return nil } state := tlsConn . ConnectionState ( ) return & state }
4594	func ( c * Call ) updateLocations ( goroot , localgoroot string , gopaths map [ string ] string ) { if c . SrcPath != "" { if strings . HasPrefix ( c . SrcPath , goroot ) { c . LocalSrcPath = filepath . Join ( localgoroot , c . SrcPath [ len ( goroot ) : ] ) } else { c . LocalSrcPath = c . SrcPath for prefix , dest := range gopaths { if strings . HasPrefix ( c . SrcPath , prefix ) { c . LocalSrcPath = filepath . Join ( dest , c . SrcPath [ len ( prefix ) : ] ) break } } } } c . IsStdlib = ( goroot != "" && strings . HasPrefix ( c . SrcPath , goroot ) ) || c . PkgSrc ( ) == testMainSrc }
6196	func ( h * Handler ) GetTotalIncome ( tkn string ) ( * uint , error ) { logger := h . logger . Add ( "method" , "GetTotalIncome" ) return h . uintFromQuery ( logger , tkn , `SELECT SUM(channels.receipt_balance) FROM channels` ) }
6903	func ( w * Window ) AddList ( x , y , width , height int ) * List { l , _ := w . AddWidget ( WidgetList , x , y ) list := l . ( * List ) list . width = width list . height = height list . Resize ( ) list . SetAttributes ( defaultAttributes ( ) ) list . content = make ( [ ] string , 0 , 1000 ) return list }
5297	func ( r * Regexp ) MatchString ( s string ) bool { return r . compiled . MatchString ( s ) }
2539	func expandCustomizationGlobalIPSettings ( d * schema . ResourceData ) types . CustomizationGlobalIPSettings { obj := types . CustomizationGlobalIPSettings { DnsSuffixList : structure . SliceInterfacesToStrings ( d . Get ( cKeyPrefix + "." + "dns_suffix_list" ) . ( [ ] interface { } ) ) , DnsServerList : structure . SliceInterfacesToStrings ( d . Get ( cKeyPrefix + "." + "dns_server_list" ) . ( [ ] interface { } ) ) , } return obj }
2138	func ( v * Context ) native ( ) * C . cairo_t { if v == nil { return nil } return v . context }
2518	func flattenHostNicTeamingPolicy ( d * schema . ResourceData , obj * types . HostNicTeamingPolicy ) error { if obj . RollingOrder != nil { v := * obj . RollingOrder d . Set ( "failback" , ! v ) } if obj . NotifySwitches != nil { d . Set ( "notify_switches" , obj . NotifySwitches ) } d . Set ( "teaming_policy" , obj . Policy ) if err := flattenHostNicFailureCriteria ( d , obj . FailureCriteria ) ; err != nil { return err } if err := flattenHostNicOrderPolicy ( d , obj . NicOrder ) ; err != nil { return err } return nil }
1989	func ( resolver * DockerContainerMetadataResolver ) ResolveTask ( dockerID string ) ( * apitask . Task , error ) { if resolver . dockerTaskEngine == nil { return nil , fmt . Errorf ( "Docker task engine uninitialized" ) } task , found := resolver . dockerTaskEngine . State ( ) . TaskByID ( dockerID ) if ! found { return nil , fmt . Errorf ( "Could not map docker id to task: %s" , dockerID ) } return task , nil }
1349	func ( agent * ecsAgent ) start ( ) int { sighandlers . StartDebugHandler ( ) containerChangeEventStream := eventstream . NewEventStream ( containerChangeEventStreamName , agent . ctx ) credentialsManager := credentials . NewManager ( ) state := dockerstate . NewTaskEngineState ( ) imageManager := engine . NewImageManager ( agent . cfg , agent . dockerClient , state ) client := ecsclient . NewECSClient ( agent . credentialProvider , agent . cfg , agent . ec2MetadataClient ) agent . initializeResourceFields ( credentialsManager ) return agent . doStart ( containerChangeEventStream , credentialsManager , state , imageManager , client ) }
2471	func ( a * arrayBufferLayout ) disable ( context * context , program program ) { for i := range a . parts { context . disableVertexAttribArray ( program , i ) } }
4139	func ( n Network ) Masked ( ones int ) Network { mask := net . CIDRMask ( ones , len ( n . Number ) * BitsPerUint32 ) return NewNetwork ( net . IPNet { IP : n . IP . Mask ( mask ) , Mask : mask , } ) }
4651	func ( queue * queue ) Push ( element interface { } ) { if queue . size == queue . cap { queue . resize ( queue . cap * 2 ) } queue . elements [ queue . end % int64 ( queue . cap ) ] = element queue . end ++ queue . size ++ }
5128	func ( h * windowsAnsiEventHandler ) scrollLine ( columns int , position COORD , info * CONSOLE_SCREEN_BUFFER_INFO ) error { scrollRect := SMALL_RECT { Top : position . Y , Bottom : position . Y , Left : position . X , Right : info . Size . X - 1 , } destOrigin := COORD { X : position . X - int16 ( columns ) , Y : position . Y , } char := CHAR_INFO { UnicodeChar : ' ' , Attributes : h . attributes , } if err := ScrollConsoleScreenBuffer ( h . fd , scrollRect , scrollRect , destOrigin , char ) ; err != nil { return err } return nil }
1372	func ( handler * TaskHandler ) getTaskEventsUnsafe ( event * sendableEvent ) * taskSendableEvents { taskARN := event . taskArn ( ) taskEvents , ok := handler . tasksToEvents [ taskARN ] if ! ok { taskEvents = & taskSendableEvents { events : list . New ( ) , sending : false , createdAt : time . Now ( ) , taskARN : taskARN , } handler . tasksToEvents [ taskARN ] = taskEvents seelog . Debugf ( "TaskHandler: collecting events for new task; event: %s; events: %s " , event . toString ( ) , taskEvents . toStringUnsafe ( ) ) } return taskEvents }
4933	func ( w * Writer ) WriteCesu8 ( p [ ] byte ) int { if w . err != nil { return 0 } w . tr . Reset ( ) cnt := 0 i := 0 for i < len ( p ) { m , n , err := w . tr . Transform ( w . b , p [ i : ] , true ) if err != nil && err != transform . ErrShortDst { w . err = err return cnt } if m == 0 { w . err = transform . ErrShortDst return cnt } o , _ := w . wr . Write ( w . b [ : m ] ) cnt += o i += n } return cnt }
2842	func ( r * CdromSubresource ) Create ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Running create" , r ) var spec [ ] types . BaseVirtualDeviceConfigSpec var ctlr types . BaseVirtualController ctlr , err := r . ControllerForCreateUpdate ( l , SubresourceControllerTypeIDE , 0 ) if err != nil { return nil , err } device , err := l . CreateCdrom ( ctlr . ( * types . VirtualIDEController ) ) if err != nil { return nil , err } r . mapCdrom ( device , l ) if err := r . SaveDevIDs ( device , ctlr ) ; err != nil { return nil , err } dspec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } spec = append ( spec , dspec ... ) log . Printf ( "[DEBUG] %s: Device config operations from create: %s" , r , DeviceChangeString ( spec ) ) log . Printf ( "[DEBUG] %s: Create finished" , r ) return spec , nil }
1184	func NewContainerResponse ( containerID string , state dockerstate . TaskEngineState ) ( * ContainerResponse , error ) { dockerContainer , ok := state . ContainerByID ( containerID ) if ! ok { return nil , errors . Errorf ( "v2 container response: unable to find container '%s'" , containerID ) } task , ok := state . TaskByID ( containerID ) if ! ok { return nil , errors . Errorf ( "v2 container response: unable to find task for container '%s'" , containerID ) } resp := newContainerResponse ( dockerContainer , task . GetTaskENI ( ) , state ) return & resp , nil }
1414	func ( m * MockStateManager ) NewStateManager ( arg0 * config . Config , arg1 ... statemanager . Option ) ( statemanager . StateManager , error ) { varargs := [ ] interface { } { arg0 } for _ , a := range arg1 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "NewStateManager" , varargs ... ) ret0 , _ := ret [ 0 ] . ( statemanager . StateManager ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
717	func getETCDConfig ( ) ( * etcdcv3 . Config , error ) { etcdURLsStr := os . Getenv ( "ETCD_URLS" ) if etcdURLsStr == "" { etcdURLsStr = "http://localhost:2379" } etcdURLs := strings . Split ( etcdURLsStr , "," ) firstURL := strings . ToLower ( etcdURLs [ 0 ] ) if strings . HasPrefix ( firstURL , "http://" ) { return & etcdcv3 . Config { Endpoints : etcdURLs } , nil } else if strings . HasPrefix ( firstURL , "https://" ) { caFile := os . Getenv ( "ETCD_CA_FILE" ) certFile := os . Getenv ( "ETCD_CERT_FILE" ) keyFile := os . Getenv ( "ETCD_KEY_FILE" ) serverName := os . Getenv ( "ETCD_TLS_SERVER_NAME" ) isInsecureStr := strings . ToLower ( os . Getenv ( "ETCD_TLS_INSECURE" ) ) isInsecure := isInsecureStr == "true" || isInsecureStr == "yes" || isInsecureStr == "1" tlsConfig , err := newTLSConfig ( certFile , keyFile , caFile , serverName , isInsecure ) if err != nil { return nil , err } return & etcdcv3 . Config { Endpoints : etcdURLs , TLS : tlsConfig , } , nil } else { return nil , errors . New ( "etcd URLs must start with either http:// or https://" ) } }
7065	func Echo ( ctx * neptulon . ReqCtx ) error { if err := ctx . Params ( & ctx . Res ) ; err != nil { return err } return ctx . Next ( ) }
3363	func ( i * IntegrationGCPCreateRequest ) GetClientID ( ) string { if i == nil || i . ClientID == nil { return "" } return * i . ClientID }
5069	func ( r * Render ) Create ( ) * Render { r . Validate ( ) layout := r . TemplatesDir + r . Layout + r . Ext tplRoot , err := filepath . Glob ( r . TemplatesDir + "*" + r . Ext ) if err != nil { panic ( err . Error ( ) ) } tplSub , err := filepath . Glob ( r . TemplatesDir + "**/*" + r . Ext ) if err != nil { panic ( err . Error ( ) ) } for _ , tpl := range append ( tplRoot , tplSub ... ) { name := r . getTemplateName ( tpl ) if name == r . Layout { continue } r . AddFromFiles ( name , layout , tpl ) } return r }
3503	func ( s * Series ) HasScope ( ) bool { if s != nil && s . Scope != nil { return true } return false }
1777	func ( m * MockStateManager ) ForceSave ( ) error { ret := m . ctrl . Call ( m , "ForceSave" ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
154	func ( t * QueueManager ) Start ( ) { name := t . client . Name ( ) t . highestSentTimestampMetric = & maxGauge { Gauge : queueHighestSentTimestamp . WithLabelValues ( name ) , } t . pendingSamplesMetric = queuePendingSamples . WithLabelValues ( name ) t . enqueueRetriesMetric = enqueueRetriesTotal . WithLabelValues ( name ) t . droppedSamplesTotal = droppedSamplesTotal . WithLabelValues ( name ) t . numShardsMetric = numShards . WithLabelValues ( name ) t . failedSamplesTotal = failedSamplesTotal . WithLabelValues ( name ) t . sentBatchDuration = sentBatchDuration . WithLabelValues ( name ) t . succeededSamplesTotal = succeededSamplesTotal . WithLabelValues ( name ) t . retriedSamplesTotal = retriedSamplesTotal . WithLabelValues ( name ) t . shardCapacity = shardCapacity . WithLabelValues ( name ) t . shardCapacity . Set ( float64 ( t . cfg . Capacity ) ) t . pendingSamplesMetric . Set ( 0 ) t . shards . start ( t . numShards ) t . watcher . Start ( ) t . wg . Add ( 2 ) go t . updateShardsLoop ( ) go t . reshardLoop ( ) }
5063	func ( server * mongoServer ) AbendSocket ( socket * mongoSocket ) { server . Lock ( ) server . abended = true if server . closed { server . Unlock ( ) return } server . liveSockets = removeSocket ( server . liveSockets , socket ) server . unusedSockets = removeSocket ( server . unusedSockets , socket ) server . Unlock ( ) select { case server . sync <- true : default : } }
3135	func ( rcv * Kafka ) Stat ( send helper . StatCallback ) { metricsReceived := atomic . LoadUint64 ( & rcv . metricsReceived ) send ( "metricsReceived" , float64 ( metricsReceived ) ) errors := atomic . LoadUint64 ( & rcv . errors ) send ( "errors" , float64 ( errors ) ) if ! rcv . statsAsCounters { atomic . AddUint64 ( & rcv . metricsReceived , - metricsReceived ) atomic . AddUint64 ( & rcv . errors , - errors ) } }
1001	func Must ( s string ) * Config { c , err := Parse ( s ) if err != nil { log . Fatal ( err ) } return c }
548	func AcquireTimer ( timeout time . Duration ) * time . Timer { v := timerPool . Get ( ) if v == nil { return time . NewTimer ( timeout ) } t := v . ( * time . Timer ) initTimer ( t , timeout ) return t }
689	func ( p * dnsimpleProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } for _ , zone := range zones { page := 1 listOptions := & dnsimple . ZoneRecordListOptions { } for { listOptions . Page = page records , err := p . client . ListRecords ( p . accountID , zone . Name , listOptions ) if err != nil { return nil , err } for _ , record := range records . Data { switch record . Type { case "A" , "CNAME" , "TXT" : break default : continue } endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( record . Name + "." + record . ZoneID , record . Type , endpoint . TTL ( record . TTL ) , record . Content ) ) } page ++ if page > records . Pagination . TotalPages { break } } } return endpoints , nil }
753	func endpointToRecord ( ep * endpoint . Endpoint ) * dynect . DataBlock { result := dynect . DataBlock { } if ep . RecordType == endpoint . RecordTypeA { result . Address = ep . Targets [ 0 ] } else if ep . RecordType == endpoint . RecordTypeCNAME { result . CName = ep . Targets [ 0 ] } else if ep . RecordType == endpoint . RecordTypeTXT { result . TxtData = ep . Targets [ 0 ] } return & result }
6641	func ( r Rectangle ) Overlaps ( s Rectangle ) bool { return ! r . Empty ( ) && ! s . Empty ( ) && r . Min [ 0 ] < s . Max [ 0 ] && s . Min [ 0 ] < r . Max [ 0 ] && r . Min [ 1 ] < s . Max [ 1 ] && s . Min [ 1 ] < r . Max [ 1 ] && r . Min [ 2 ] < s . Max [ 2 ] && s . Min [ 2 ] < r . Max [ 2 ] }
3240	func ( b * BoardWidget ) HasLayout ( ) bool { if b != nil && b . Layout != nil { return true } return false }
2800	func Create ( f * object . Folder , name string , spec types . ClusterConfigSpecEx ) ( * object . ClusterComputeResource , error ) { log . Printf ( "[DEBUG] Creating compute cluster %q" , fmt . Sprintf ( "%s/%s" , f . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) cluster , err := f . CreateCluster ( ctx , name , spec ) if err != nil { return nil , err } return cluster , nil }
1916	func ( m * MockFactory ) GetDefaultClient ( ) ( sdkclient . Client , error ) { ret := m . ctrl . Call ( m , "GetDefaultClient" ) ret0 , _ := ret [ 0 ] . ( sdkclient . Client ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5300	func ( r * Regexp ) RevertValid ( values url . Values ) ( string , error ) { reverse , err := r . Revert ( values ) if err != nil { return "" , err } if ! r . compiled . MatchString ( reverse ) { return "" , fmt . Errorf ( "Resulting string doesn't match the regexp: %q" , reverse ) } return reverse , nil }
2440	func ( i * Image ) internalSize ( ) ( int , int ) { if i . w2 == 0 || i . h2 == 0 { w , h := i . image . Size ( ) i . w2 = graphics . InternalImageSize ( w ) i . h2 = graphics . InternalImageSize ( h ) } return i . w2 , i . h2 }
1249	func ( cs * clientServer ) publishMetricsOnce ( ) error { requests , err := cs . metricsToPublishMetricRequests ( ) if err != nil { return err } for _ , request := range requests { err = cs . MakeRequest ( request ) if err != nil { return err } } return nil }
5631	func ComputePrivateKey ( mprivHex string , chainHex string , path string , index int32 ) string { privKeyBytes := DerivePrivateKeyForPath ( HexDecode ( mprivHex ) , HexDecode ( chainHex ) , fmt . Sprintf ( "%v/%v" , path , index ) , ) return HexEncode ( privKeyBytes ) }
2297	func ( v * ToggleToolButton ) native ( ) * C . GtkToggleToolButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToggleToolButton ( p ) }
6186	func ( h * Handler ) UpdateProduct ( tkn string , product data . Product ) error { logger := h . logger . Add ( "method" , "UpdateProduct" , "product" , product ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } oldProduct := & data . Product { } if err := h . findByPrimaryKey ( logger , ErrProductNotFound , oldProduct , product . ID ) ; err != nil { return err } if product . Salt == 0 { product . Salt = oldProduct . Salt } if product . Password == "" { product . Password = oldProduct . Password } if product . ServiceEndpointAddress != nil && ! isValidSEAddress ( * product . ServiceEndpointAddress ) { return ErrBadServiceEndpointAddress } if err := update ( logger , h . db . Querier , & product ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil }
3450	func ( p * Period ) GetSecondsOk ( ) ( json . Number , bool ) { if p == nil || p . Seconds == nil { return "" , false } return * p . Seconds , true }
1680	func ( auth * ASMAuthResource ) UnmarshalJSON ( b [ ] byte ) error { temp := asmAuthResourceJSON { } if err := json . Unmarshal ( b , & temp ) ; err != nil { return err } if temp . DesiredStatus != nil { auth . SetDesiredStatus ( resourcestatus . ResourceStatus ( * temp . DesiredStatus ) ) } if temp . KnownStatus != nil { auth . SetKnownStatus ( resourcestatus . ResourceStatus ( * temp . KnownStatus ) ) } if temp . CreatedAt != nil && ! temp . CreatedAt . IsZero ( ) { auth . SetCreatedAt ( * temp . CreatedAt ) } if temp . RequiredASMResources != nil { auth . requiredASMResources = temp . RequiredASMResources } auth . taskARN = temp . TaskARN auth . executionCredentialsID = temp . ExecutionCredentialsID return nil }
1905	func ( engine * DockerTaskEngine ) cleanupPauseContainerNetwork ( task * apitask . Task , container * apicontainer . Container ) error { seelog . Infof ( "Task engine [%s]: cleaning up the network namespace" , task . Arn ) cniConfig , err := engine . buildCNIConfigFromTaskContainer ( task , container ) if err != nil { return errors . Wrapf ( err , "engine: failed cleanup task network namespace, task: %s" , task . String ( ) ) } return engine . cniClient . CleanupNS ( engine . ctx , cniConfig , cniCleanupTimeout ) }
216	func ( w * WALWatcher ) readCheckpoint ( checkpointDir string ) error { level . Debug ( w . logger ) . Log ( "msg" , "reading checkpoint" , "dir" , checkpointDir ) index , err := checkpointNum ( checkpointDir ) if err != nil { return errors . Wrap ( err , "checkpointNum" ) } segs , err := w . segments ( checkpointDir ) if err != nil { return errors . Wrap ( err , "Unable to get segments checkpoint dir" ) } for _ , seg := range segs { size , err := getSegmentSize ( checkpointDir , seg ) if err != nil { return errors . Wrap ( err , "getSegmentSize" ) } sr , err := wal . OpenReadSegment ( wal . SegmentName ( checkpointDir , seg ) ) if err != nil { return errors . Wrap ( err , "unable to open segment" ) } defer sr . Close ( ) r := wal . NewLiveReader ( w . logger , sr ) if err := w . readSegment ( r , index , false ) ; err != io . EOF && err != nil { return errors . Wrap ( err , "readSegment" ) } if r . Offset ( ) != size { return fmt . Errorf ( "readCheckpoint wasn't able to read all data from the checkpoint %s/%08d, size: %d, totalRead: %d" , checkpointDir , seg , size , r . Offset ( ) ) } } level . Debug ( w . logger ) . Log ( "msg" , "read series references from checkpoint" , "checkpoint" , checkpointDir ) return nil }
1874	func JsonKeys ( b [ ] byte ) ( [ ] string , error ) { var keyMap map [ string ] interface { } err := json . Unmarshal ( b , & keyMap ) if err != nil { return [ ] string { } , err } keys := make ( [ ] string , len ( keyMap ) ) ndx := 0 for k := range keyMap { keys [ ndx ] = k ndx ++ } return keys , nil }
1300	func ( mr * MockAuditLoggerMockRecorder ) Log ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Log" , reflect . TypeOf ( ( * MockAuditLogger ) ( nil ) . Log ) , arg0 , arg1 , arg2 ) }
6078	func ( h * Handler ) GetObjectByHash ( tkn , objectType , hash string ) ( json . RawMessage , error ) { logger := h . logger . Add ( "method" , "GetObjectByHash" , "type" , objectType , "hash" , hash ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } table , ok := objectWithHashTypes [ objectType ] if ! ok { logger . Warn ( ErrBadObjectType . Error ( ) ) return nil , ErrBadObjectType } obj , err := h . db . FindOneFrom ( table , "hash" , hash ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrObjectNotFound } raw , err := json . Marshal ( obj ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrInternal } return raw , nil }
1882	func ( mr * MockDockerStateResolverMockRecorder ) State ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "State" , reflect . TypeOf ( ( * MockDockerStateResolver ) ( nil ) . State ) ) }
572	func ( mx * Mux ) Connect ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mCONNECT , pattern , handlerFn ) }
2576	func ( r * NetworkInterfaceSubresource ) Read ( l object . VirtualDeviceList ) error { log . Printf ( "[DEBUG] %s: Reading state" , r ) vd , err := r . FindVirtualDevice ( l ) if err != nil { return fmt . Errorf ( "cannot find network device: %s" , err ) } device , err := baseVirtualDeviceToBaseVirtualEthernetCard ( vd ) if err != nil { return err } r . Set ( "adapter_type" , virtualEthernetCardString ( device ) ) card := device . GetVirtualEthernetCard ( ) var netID string switch backing := card . Backing . ( type ) { case * types . VirtualEthernetCardNetworkBackingInfo : if backing . Network == nil { return fmt . Errorf ( "could not determine network information from NIC backing" ) } netID = backing . Network . Value case * types . VirtualEthernetCardOpaqueNetworkBackingInfo : onet , err := nsx . OpaqueNetworkFromNetworkID ( r . client , backing . OpaqueNetworkId ) if err != nil { return err } netID = onet . Reference ( ) . Value case * types . VirtualEthernetCardDistributedVirtualPortBackingInfo : pg , err := dvportgroup . FromKey ( r . client , backing . Port . SwitchUuid , backing . Port . PortgroupKey ) if err != nil { return err } netID = pg . Reference ( ) . Value default : return fmt . Errorf ( "unknown network interface backing %T" , card . Backing ) } r . Set ( "network_id" , netID ) r . Set ( "use_static_mac" , card . AddressType == string ( types . VirtualEthernetCardMacTypeManual ) ) r . Set ( "mac_address" , card . MacAddress ) version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if card . ResourceAllocation != nil { r . Set ( "bandwidth_limit" , card . ResourceAllocation . Limit ) r . Set ( "bandwidth_reservation" , card . ResourceAllocation . Reservation ) r . Set ( "bandwidth_share_count" , card . ResourceAllocation . Share . Shares ) r . Set ( "bandwidth_share_level" , card . ResourceAllocation . Share . Level ) } } ctlr , err := findControllerForDevice ( l , vd ) if err != nil { return err } if err := r . SaveDevIDs ( vd , ctlr ) ; err != nil { return err } log . Printf ( "[DEBUG] %s: Read finished (key and device address may have changed)" , r ) return nil }
7097	func ( b * RefCountBox ) Alloc ( ) ( DB , error ) { b . Lock ( ) defer b . Unlock ( ) if b . db . DB == nil { if b . DataPath == nil { return DB { } , errorsp . WithStacks ( ErrBoxDataPathNotSpecified ) } var db DB var err error if b . OpenFunc == nil { db , err = Open ( b . DataPath ( ) , 0644 , nil ) } else { db , err = b . OpenFunc ( b . DataPath ( ) ) } if err != nil { return DB { } , errorsp . WithStacks ( err ) } b . db , b . count = db , 0 } b . count ++ return b . db , nil }
1687	func ( key * cacheKey ) String ( ) string { return fmt . Sprintf ( "%s-%s-%s-%s" , key . roleARN , key . region , key . registryID , key . endpointOverride ) }
4704	func newPlainText ( ln * line , rslt * result , src * source , parent element , opts * Options ) * plainText { return & plainText { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , insertBr : ln . tokens [ 0 ] == doublePipe , } }
6092	func ( h * Handler ) TopUpChannel ( tkn , channel string , deposit , gasPrice uint64 ) error { logger := h . logger . Add ( "method" , "TopUpChannel" , "channel" , channel , "deposit" , deposit , "gasPrice" , gasPrice ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } ch := & data . Channel { } if err := h . findByPrimaryKey ( logger , ErrChannelNotFound , ch , channel ) ; err != nil { return err } jobData , err := h . topUpChannelJobData ( logger , deposit , gasPrice ) if err != nil { return err } return job . AddWithData ( h . queue , nil , data . JobClientPreChannelTopUp , data . JobChannel , ch . ID , data . JobUser , jobData ) }
6764	func NewNetAddressStrings ( addrs [ ] string ) ( [ ] * NetAddress , error ) { netAddrs := make ( [ ] * NetAddress , len ( addrs ) ) for i , addr := range addrs { netAddr , err := NewNetAddressString ( addr ) if err != nil { return nil , errors . New ( cmn . Fmt ( "Error in address %s: %v" , addr , err ) ) } netAddrs [ i ] = netAddr } return netAddrs , nil }
508	func ( h * RequestHeader ) HasAcceptEncodingBytes ( acceptEncoding [ ] byte ) bool { ae := h . peek ( strAcceptEncoding ) n := bytes . Index ( ae , acceptEncoding ) if n < 0 { return false } b := ae [ n + len ( acceptEncoding ) : ] if len ( b ) > 0 && b [ 0 ] != ',' { return false } if n == 0 { return true } return ae [ n - 1 ] == ' ' }
3676	func ( w * Widget ) GetManageStatusShowTitle ( ) bool { if w == nil || w . ManageStatusShowTitle == nil { return false } return * w . ManageStatusShowTitle }
1934	func ( m * MockTaskEngineState ) AddTaskIPAddress ( arg0 , arg1 string ) { m . ctrl . Call ( m , "AddTaskIPAddress" , arg0 , arg1 ) }
1664	func ( cnferror ContainerNotFound ) Error ( ) string { return fmt . Sprintf ( "Could not find container '%s' in task '%s'" , cnferror . ContainerName , cnferror . TaskArn ) }
7194	func ( r * Route ) HandleMethod ( pat , method string , f ... HandlerFunc ) { entry := r . addPattern ( pat ) batch := batchRoute ( f ) if err := entry . SetMethodHandler ( method , batch ) ; err != nil { panic ( err ) } }
4179	func ( c * UpdateSpaceQuotasCommand ) Execute ( [ ] string ) error { var cfMgmt * CFMgmt var err error if cfMgmt , err = InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { err = cfMgmt . QuotaManager . CreateSpaceQuotas ( ) } return err }
5793	func ( a * API ) UpdateOutlierReport ( cfg * OutlierReport ) ( * OutlierReport , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid outlier report config [nil]" ) } reportCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . OutlierReportCIDRegex , reportCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid outlier report CID [%s]" , reportCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update outlier report, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( reportCID , jsonCfg ) if err != nil { return nil , err } report := & OutlierReport { } if err := json . Unmarshal ( result , report ) ; err != nil { return nil , err } return report , nil }
5966	func NewHOTP ( key [ ] byte , counter uint64 , digits int ) * HOTP { otp := & HOTP { Key : key , Digits : digits , } otp . counter = new ( [ ctrSize ] byte ) binary . BigEndian . PutUint64 ( otp . counter [ : ] , counter ) return otp }
3254	func ( c * Check ) GetTimestampOk ( ) ( string , bool ) { if c == nil || c . Timestamp == nil { return "" , false } return * c . Timestamp , true }
5046	func ( q * Query ) Limit ( n int ) * Query { q . m . Lock ( ) switch { case n == 1 : q . limit = 1 q . op . limit = - 1 case n == math . MinInt32 : q . limit = math . MaxInt32 q . op . limit = math . MinInt32 + 1 case n < 0 : q . limit = int32 ( - n ) q . op . limit = int32 ( n ) default : q . limit = int32 ( n ) q . op . limit = int32 ( n ) } q . m . Unlock ( ) return q }
2054	func TaskContainerStatsHandler ( state dockerstate . TaskEngineState , statsEngine stats . Engine ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { errResponseJSON , _ := json . Marshal ( fmt . Sprintf ( "Unable to get task arn from request: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskStats ) return } if containerID , ok := utils . GetMuxValueFromRequest ( r , statsContainerIDMuxName ) ; ok { seelog . Infof ( "V2 task/container stats handler: writing response for container '%s'" , containerID ) WriteContainerStatsResponse ( w , taskARN , containerID , statsEngine ) return } seelog . Infof ( "V2 task/container stats handler: writing response for task '%s'" , taskARN ) WriteTaskStatsResponse ( w , taskARN , state , statsEngine ) } }
2751	func flattenDVSNameArrayUplinkPortPolicy ( d * schema . ResourceData , obj * types . DVSNameArrayUplinkPortPolicy ) error { if err := d . Set ( "uplinks" , obj . UplinkPortName ) ; err != nil { return err } return nil }
4289	func CreateBridge ( name string , setMacAddr bool ) error { if len ( name ) >= IFNAMSIZ { return fmt . Errorf ( "Interface name %s too long" , name ) } s , err := getIfSocket ( ) if err != nil { return err } defer syscall . Close ( s ) nameBytePtr , err := syscall . BytePtrFromString ( name ) if err != nil { return err } if _ , _ , err := syscall . Syscall ( syscall . SYS_IOCTL , uintptr ( s ) , SIOC_BRADDBR , uintptr ( unsafe . Pointer ( nameBytePtr ) ) ) ; err != 0 { return err } if setMacAddr { return SetMacAddress ( name , randMacAddr ( ) ) } return nil }
3759	func ( t * templateData ) addIdent ( x * ast . Ident , receiverType , fieldName string ) { var zeroValue string switch x . String ( ) { case "int" : zeroValue = "0" case "string" : zeroValue = `""` case "bool" : zeroValue = "false" case "float64" : zeroValue = "0" case "Status" : zeroValue = "0" case "PrecisionT" : zeroValue = `""` default : zeroValue = fmt . Sprintf ( "%s{}" , x . String ( ) ) } t . Accessors = append ( t . Accessors , newAccessor ( receiverType , fieldName , x . String ( ) , zeroValue ) ) }
877	func ( d * SerialDriver ) GetCreateFlags ( ) [ ] mcnflag . Flag { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetCreateFlags ( ) }
7259	func NewStdFormatter ( delim , tmpl string , entry Entry , values map [ string ] interface { } , timeformat string ) ( Formatter , error ) { if delim == "" { return nil , e . New ( "invalid delimitator" ) } if tmpl == "" { return nil , e . New ( "invalid template" ) } if entry == nil { return nil , e . New ( "invalid entry" ) } if values == nil { return nil , e . New ( "invalid values" ) } if timeformat == "" { timeformat = TimeDateFormat } return & StdFormatter { Delim : [ ] byte ( delim ) , Tmpl : [ ] byte ( tmpl ) , E : entry , Map : values , Idx : mkindex ( entry ) , TimeFormat : timeformat , } , nil }
2824	func flattenVMwareUplinkLacpPolicy ( d * schema . ResourceData , obj * types . VMwareUplinkLacpPolicy ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , "lacp_enabled" , obj . Enable ) structure . SetStringPolicy ( d , "lacp_mode" , obj . Mode ) return nil }
5316	func openDBFile ( filename string , flag int ) ( * dbfile , error ) { f , err := os . OpenFile ( filename , flag , 0 ) if err != nil { return nil , err } db := & dbfile { file : f , rd : bufio . NewReader ( f ) } db . Lock ( ) return db , nil }
6610	func ( m * OuiDb ) Lookup ( address HardwareAddr ) * AddressBlock { for _ , block := range m . Blocks { if block . Contains ( address ) { return & block } } return nil }
5620	func ( privKey PrivKeyEd25519 ) Equals ( other PrivKey ) bool { if otherEd , ok := other . ( PrivKeyEd25519 ) ; ok { return subtle . ConstantTimeCompare ( privKey [ : ] , otherEd [ : ] ) == 1 } else { return false } }
7268	func ( r * Reader ) Push ( reader io . Reader ) { r . readers = append ( r . readers , reader ) }
1314	func NewMockFile ( ctrl * gomock . Controller ) * MockFile { mock := & MockFile { ctrl : ctrl } mock . recorder = & MockFileMockRecorder { mock } return mock }
5602	func ( o * AddVMParams ) WithContext ( ctx context . Context ) * AddVMParams { o . SetContext ( ctx ) return o }
5676	func ToString ( name string , options ... Option ) ( string , error ) { a , err := ToAST ( name , options ... ) if err != nil { return "" , err } return ASTToString ( a , options ... ) , nil }
520	func ( h * ResponseHeader ) Cookie ( cookie * Cookie ) bool { v := peekArgBytes ( h . cookies , cookie . Key ( ) ) if v == nil { return false } cookie . ParseBytes ( v ) return true }
5279	func NewIterator ( reader io . Reader , unmarshaller RecordUnmarshaller ) * Iterator { return & Iterator { reader : reader , line : 0 , scanner : bufio . NewScanner ( reader ) , unmarshaller : unmarshaller , } }
2645	func resourceVSphereComputeClusterReadTags ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( "[DEBUG] %s: Reading tags" , resourceVSphereComputeClusterIDString ( d ) ) if err := readTagsForResource ( tagsClient , cluster , d ) ; err != nil { return err } } else { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping tag read" , resourceVSphereComputeClusterIDString ( d ) ) } return nil }
710	func ( p * RcodeZeroProvider ) NewRcodezeroChange ( action string , endpoint * endpoint . Endpoint ) * rc0 . RRSetChange { change := & rc0 . RRSetChange { Type : endpoint . RecordType , ChangeType : action , Name : endpoint . DNSName , Records : [ ] * rc0 . Record { { Disabled : false , Content : endpoint . Targets [ 0 ] , } } , } if p . TXTEncrypt && ( p . Key != nil ) && strings . EqualFold ( endpoint . RecordType , "TXT" ) { p . Client . RRSet . EncryptTXT ( p . Key , change ) } return change }
2203	func SimpleActionGroupNew ( ) * SimpleActionGroup { c := C . g_simple_action_group_new ( ) if c == nil { return nil } return wrapSimpleActionGroup ( wrapObject ( unsafe . Pointer ( c ) ) ) }
4378	func CIDRValue ( v * strfmt . CIDR ) strfmt . CIDR { if v == nil { return strfmt . CIDR ( "" ) } return * v }
5481	func ( o * OutgoingCallerIDService ) Delete ( ctx context . Context , sid string ) error { return o . client . DeleteResource ( ctx , callerIDPathPart , sid ) }
5849	func ( a * API ) DeleteRuleSetByCID ( cid CIDType ) ( bool , error ) { if cid == nil || * cid == "" { return false , fmt . Errorf ( "Invalid rule set CID [none]" ) } rulesetCID := string ( * cid ) matched , err := regexp . MatchString ( config . RuleSetCIDRegex , rulesetCID ) if err != nil { return false , err } if ! matched { return false , fmt . Errorf ( "Invalid rule set CID [%s]" , rulesetCID ) } _ , err = a . Delete ( rulesetCID ) if err != nil { return false , err } return true , nil }
6512	func ( c Client ) CompleteRequest ( id string ) ( * transactionConfirmation , error ) { return c . transactionRequest ( "PUT" , id + "/complete_request" , nil ) }
3723	func ( w * Widget ) HasTick ( ) bool { if w != nil && w . Tick != nil { return true } return false }
6679	func ( s * Server ) respCode ( r * http . Request ) int { if r . URL . Path == "/opengdpr_requests" && r . Method == "POST" { return http . StatusCreated } return http . StatusOK }
3867	func ( p * Package ) Func ( name string ) ( f * Function ) { f , _ = p . Members [ name ] . ( * Function ) return }
2473	func areSameFloat32Array ( a , b [ ] float32 ) bool { if len ( a ) != len ( b ) { return false } for i := 0 ; i < len ( a ) ; i ++ { if a [ i ] != b [ i ] { return false } } return true }
4184	func ( m * yamlManager ) AddOrgToConfig ( orgConfig * OrgConfig , spaces * Spaces ) error { orgList , err := m . Orgs ( ) if err != nil { return err } orgName := orgConfig . Org if orgName == "" { return errors . New ( "cannot have an empty org name" ) } if orgList . Contains ( orgName ) { return fmt . Errorf ( "org [%s] already added to config -> %v" , orgName , orgList . Orgs ) } lo . G . Infof ( "Adding org: %s " , orgName ) orgList . Orgs = append ( orgList . Orgs , orgName ) if err = m . SaveOrgs ( orgList ) ; err != nil { return err } m . SaveOrgConfig ( orgConfig ) return m . SaveOrgSpaces ( spaces ) }
6060	func ( h * Handler ) Endpoint ( key data . Base64String ) ( * data . Base64String , error ) { logger := h . logger . Add ( "type" , "agent/tor-somc.Handler" ) channelsStructs , err := h . db . SelectAllFrom ( data . ChannelTable , "" ) if err != nil { h . logger . Error ( err . Error ( ) ) return nil , ErrInternal } for _ , chanStruct := range channelsStructs { channel := chanStruct . ( * data . Channel ) channelKey , err := h . channelKey ( logger , channel ) if err != nil { h . logger . Error ( err . Error ( ) ) return nil , ErrInternal } if channelKey == key { endpoint , err := h . endpointByChannelID ( logger , channel . ID ) if err != nil { return nil , err } return & endpoint . RawMsg , nil } } return nil , ErrChannelNotFound }
848	func parseTags ( d * Driver ) [ ] string { tags := [ ] string { firewallTargetTag } if d . Tags != "" { tags = append ( tags , strings . Split ( d . Tags , "," ) ... ) } return tags }
2640	func queryVmfsDatastoreExtendOptions ( ctx context . Context , s * object . HostDatastoreSystem , ds * object . Datastore , devicePath string , suppressExpandCandidates bool ) ( [ ] types . VmfsDatastoreOption , error ) { req := types . QueryVmfsDatastoreExtendOptions { This : s . Reference ( ) , Datastore : ds . Reference ( ) , DevicePath : devicePath , SuppressExpandCandidates : & suppressExpandCandidates , } res , err := methods . QueryVmfsDatastoreExtendOptions ( ctx , s . Client ( ) , & req ) if err != nil { return nil , err } return res . Returnval , nil }
6798	func roundIndex ( start , max int ) [ ] int { if start < 0 { start = 0 } result := make ( [ ] int , max ) for i := 0 ; i < max ; i ++ { if start + i < max { result [ i ] = start + i } else { result [ i ] = int ( math . Abs ( float64 ( max - ( start + i ) ) ) ) } } return result }
649	func NewCRDSource ( crdClient rest . Interface , namespace , kind string , scheme * runtime . Scheme ) ( Source , error ) { return & crdSource { crdResource : strings . ToLower ( kind ) + "s" , namespace : namespace , crdClient : crdClient , codec : runtime . NewParameterCodec ( scheme ) , } , nil }
7000	func NewRemoteMysqlDump ( username , password string , sshCfg command . SshConfig ) ( * MysqlDump , error ) { return NewRemoteMysqlDumpWithPath ( username , password , sshCfg , "" ) }
5728	func OnClosingContext ( p goprocess . Process ) context . Context { return & procContext { done : p . Closing ( ) , which : closing , } }
3997	func ( e LintStatus ) MarshalJSON ( ) ( [ ] byte , error ) { s := e . String ( ) return json . Marshal ( s ) }
2330	func ( v * Context ) Translate ( tx , ty float64 ) { C . cairo_translate ( v . native ( ) , C . double ( tx ) , C . double ( ty ) ) }
3185	func ( client * Client ) EditComment ( id int , handle , message string ) error { comment := Comment { Message : String ( message ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } return client . doJsonRequest ( "PUT" , fmt . Sprintf ( "/v1/comments/%d" , id ) , & comment , nil ) }
7296	func ( tx Tx ) ForEach ( folders [ ] [ ] byte , f func ( Bucket , bytesp . Slice , bytesp . Slice ) error ) error { return tx . Bucket ( folders , func ( b Bucket ) error { return errorsp . WithStacks ( b . Bucket . ForEach ( func ( k , v [ ] byte ) error { return errorsp . WithStacks ( f ( b , bytesp . Slice ( k ) , bytesp . Slice ( v ) ) ) } ) ) } ) }
4282	func GetAdditionalGroupsPath ( additionalGroups [ ] string , groupPath string ) ( [ ] int , error ) { groupReader , err := os . Open ( groupPath ) if err != nil { return nil , fmt . Errorf ( "Failed to open group file: %v" , err ) } defer groupReader . Close ( ) groups , err := ParseGroupFilter ( groupReader , func ( g Group ) bool { for _ , ag := range additionalGroups { if g . Name == ag || strconv . Itoa ( g . Gid ) == ag { return true } } return false } ) if err != nil { return nil , fmt . Errorf ( "Unable to find additional groups %v: %v" , additionalGroups , err ) } gidMap := make ( map [ int ] struct { } ) for _ , ag := range additionalGroups { var found bool for _ , g := range groups { if g . Name == ag || strconv . Itoa ( g . Gid ) == ag { if _ , ok := gidMap [ g . Gid ] ; ! ok { gidMap [ g . Gid ] = struct { } { } found = true break } } } if ! found { gid , err := strconv . Atoi ( ag ) if err != nil { return nil , fmt . Errorf ( "Unable to find group %s" , ag ) } if gid < minId || gid > maxId { return nil , ErrRange } gidMap [ gid ] = struct { } { } } } gids := [ ] int { } for gid := range gidMap { gids = append ( gids , gid ) } return gids , nil }
3912	func yaml_mapping_start_event_initialize ( event * yaml_event_t , anchor , tag [ ] byte , implicit bool , style yaml_mapping_style_t ) { * event = yaml_event_t { typ : yaml_MAPPING_START_EVENT , anchor : anchor , tag : tag , implicit : implicit , style : yaml_style_t ( style ) , } }
7257	func ( f * formatifier ) urlEncodeSpaces ( ) { rp := regexp . MustCompile ( `\s` ) f . theString = rp . ReplaceAllString ( f . theString , "%20" ) }
6865	func ( dl * DefaultLogger ) Critical ( message string , params ... interface { } ) { dl . logger . Criticalf ( fmt . Sprintf ( "%s %s" , caller ( ) , message ) , params ... ) }
1419	func NewECSClient ( credentialProvider * credentials . Credentials , config * config . Config , ec2MetadataClient ec2 . EC2MetadataClient ) api . ECSClient { var ecsConfig aws . Config ecsConfig . Credentials = credentialProvider ecsConfig . Region = & config . AWSRegion ecsConfig . HTTPClient = httpclient . New ( roundtripTimeout , config . AcceptInsecureCert ) if config . APIEndpoint != "" { ecsConfig . Endpoint = & config . APIEndpoint } standardClient := ecs . New ( session . New ( & ecsConfig ) ) submitStateChangeClient := newSubmitStateChangeClient ( & ecsConfig ) pollEndpoinCache := async . NewLRUCache ( pollEndpointCacheSize , pollEndpointCacheTTL ) return & APIECSClient { credentialProvider : credentialProvider , config : config , standardClient : standardClient , submitStateChangeClient : submitStateChangeClient , ec2metadata : ec2MetadataClient , pollEndpoinCache : pollEndpoinCache , } }
4233	func ( s * Spinner ) UpdateCharSet ( cs [ ] string ) { s . lock . Lock ( ) defer s . lock . Unlock ( ) s . chars = cs }
1410	func ( mr * MockECSClientMockRecorder ) DiscoverPollEndpoint ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "DiscoverPollEndpoint" , reflect . TypeOf ( ( * MockECSClient ) ( nil ) . DiscoverPollEndpoint ) , arg0 ) }
500	func ( h * RequestHeader ) SetUserAgentBytes ( userAgent [ ] byte ) { h . parseRawHeaders ( ) h . userAgent = append ( h . userAgent [ : 0 ] , userAgent ... ) }
6659	func NewSigner ( opts * KeyOptions ) ( Signer , error ) { privateKey := opts . KeyBytes if opts . KeyPath != "" { raw , err := ioutil . ReadFile ( opts . KeyPath ) if err != nil { return nil , err } privateKey = raw } block , _ := pem . Decode ( privateKey ) blockBytes := block . Bytes if x509 . IsEncryptedPEMBlock ( block ) { b , err := x509 . DecryptPEMBlock ( block , opts . Password ) if err != nil { return nil , err } blockBytes = b } parsed , err := x509 . ParsePKCS8PrivateKey ( blockBytes ) if err != nil { return nil , err } privKey , ok := parsed . ( * rsa . PrivateKey ) if ! ok { return nil , fmt . Errorf ( "unsupported private key" ) } return & rsaSigner { privKey : privKey } , nil }
6874	func ( e * execStreamerBuilder ) Writers ( writers io . Writer ) ExecStreamerBuilder { e . d . StdoutWriter = writers e . d . StderrWriter = writers return e }
2503	func ( q * commandQueue ) Enqueue ( command command ) { q . commands = append ( q . commands , command ) }
4550	func ( c DiffCmd ) formatDiff ( diffs [ ] diffmatchpatch . Diff , color bool ) string { var buff bytes . Buffer for _ , diff := range diffs { text := diff . Text switch diff . Type { case diffmatchpatch . DiffInsert : if color { _ , _ = buff . WriteString ( "\x1b[32m" ) } \x1b _ , _ = buff . WriteString ( DiffLineStart . ReplaceAllString ( text , "$1+ $2" ) ) if color { _ , _ = buff . WriteString ( "\x1b[0m" ) } \x1b } } case diffmatchpatch . DiffDelete : if color { _ , _ = buff . WriteString ( "\x1b[31m" ) } \x1b _ , _ = buff . WriteString ( DiffLineStart . ReplaceAllString ( text , "$1- $2" ) ) }
4698	func ( e * htmlTag ) IsBlockElement ( ) bool { if inline , found := inlineElements [ e . tagName ] ; found { return ! inline } else { return true } }
6882	func ( w * Window ) AddLabel ( x , y int , format string , args ... interface { } ) * Label { l , _ := w . AddWidget ( WidgetLabel , x , y ) label := l . ( * Label ) label . Resize ( ) label . SetAttributes ( defaultAttributes ( ) ) label . SetText ( format , args ... ) return label }
1059	func ( c * EnvConfig ) Env ( ) [ ] string { if BoolVal ( c . Pristine ) { if len ( c . Custom ) > 0 { return c . Custom } return [ ] string { } } environ := os . Environ ( ) keys := make ( [ ] string , len ( environ ) ) env := make ( map [ string ] string , len ( environ ) ) for i , v := range environ { list := strings . SplitN ( v , "=" , 2 ) keys [ i ] = list [ 0 ] env [ list [ 0 ] ] = list [ 1 ] } anyGlobMatch := func ( s string , patterns [ ] string ) bool { for _ , pattern := range patterns { if matched , _ := filepath . Match ( pattern , s ) ; matched { return true } } return false } if len ( c . Whitelist ) > 0 { newKeys := make ( [ ] string , 0 , len ( keys ) ) for _ , k := range keys { if anyGlobMatch ( k , c . Whitelist ) { newKeys = append ( newKeys , k ) } } keys = newKeys } if len ( c . Blacklist ) > 0 { newKeys := make ( [ ] string , 0 , len ( keys ) ) for _ , k := range keys { if ! anyGlobMatch ( k , c . Blacklist ) { newKeys = append ( newKeys , k ) } } keys = newKeys } finalEnv := make ( [ ] string , 0 , len ( keys ) + len ( c . Custom ) ) for _ , k := range keys { finalEnv = append ( finalEnv , k + "=" + env [ k ] ) } finalEnv = append ( finalEnv , c . Custom ... ) return finalEnv }
7198	func ( r * Route ) Put ( pat string , f ... HandlerFunc ) { r . HandleMethod ( pat , "PUT" , f ... ) }
6013	func ( t Typed ) FloatMust ( key string ) float64 { f , exists := t . FloatIf ( key ) if exists == false { panic ( "expected float value for " + key ) } return f }
4892	func NewSession ( ctx context . Context , prm sessionPrm ) ( * Session , error ) { if trace { outLogger . Printf ( "%s" , prm ) } conn , err := newSessionConn ( ctx , prm . Host ( ) , prm . Timeout ( ) , prm . TLSConfig ( ) ) if err != nil { return nil , err } rd := bufio . NewReader ( conn ) wr := bufio . NewWriter ( conn ) s := & Session { prm : prm , conn : conn , rd : rd , wr : wr , mh : new ( messageHeader ) , sh : new ( segmentHeader ) , ph : new ( partHeader ) , scramsha256InitialRequest : new ( scramsha256InitialRequest ) , scramsha256InitialReply : new ( scramsha256InitialReply ) , scramsha256FinalRequest : new ( scramsha256FinalRequest ) , scramsha256FinalReply : new ( scramsha256FinalReply ) , topologyInformation : newTopologyInformation ( ) , connectOptions : newConnectOptions ( ) , rowsAffected : new ( rowsAffected ) , statementID : new ( statementID ) , resultMetadata : new ( resultMetadata ) , resultsetID : new ( resultsetID ) , resultset : new ( resultset ) , parameterMetadata : new ( parameterMetadata ) , outputParameters : new ( outputParameters ) , writeLobRequest : new ( writeLobRequest ) , readLobRequest : new ( readLobRequest ) , writeLobReply : new ( writeLobReply ) , readLobReply : new ( readLobReply ) , stmtCtx : newStatementContext ( ) , txFlags : newTransactionFlags ( ) , lastError : new ( hdbErrors ) , } if err = s . init ( ) ; err != nil { return nil , err } return s , nil }
1540	func ( td * TransitionDependenciesMap ) UnmarshalJSON ( b [ ] byte ) error { depMap := make ( map [ apicontainerstatus . ContainerStatus ] TransitionDependencySet ) err := json . Unmarshal ( b , & depMap ) if err == nil { * td = depMap return nil } seelog . Debugf ( "Unmarshal 'TransitionDependencySet': %s, not a map: %v" , string ( b ) , err ) tdSet := TransitionDependencySet { } if err := json . Unmarshal ( b , & tdSet ) ; err != nil { return errors . Wrapf ( err , "Unmarshal 'TransitionDependencySet': does not comply with any of the dependency types" ) } for _ , dep := range tdSet . ContainerDependencies { dependentStatus := dep . DependentStatus dep . DependentStatus = 0 if _ , ok := depMap [ dependentStatus ] ; ! ok { depMap [ dependentStatus ] = TransitionDependencySet { } } deps := depMap [ dependentStatus ] deps . ContainerDependencies = append ( deps . ContainerDependencies , dep ) depMap [ dependentStatus ] = deps } * td = depMap return nil }
6785	func RegisterDriver ( d Driver , knownNames ... string ) { for _ , k := range knownNames { drivers [ strings . ToLower ( k ) ] = d } log . Info ( "registered pubsub driver: %v" , knownNames ) }
2301	func TreePathFromList ( list * glib . List ) * TreePath { if list == nil { return nil } return & TreePath { ( * C . GtkTreePath ) ( list . Data ( ) . ( unsafe . Pointer ) ) } }
4287	func Relabel ( path string , fileLabel string , relabel string ) error { exclude_path := [ ] string { "/" , "/usr" , "/etc" } if fileLabel == "" { return nil } if ! strings . ContainsAny ( relabel , "zZ" ) { return nil } for _ , p := range exclude_path { if path == p { return fmt . Errorf ( "Relabeling of %s is not allowed" , path ) } } if strings . Contains ( relabel , "z" ) && strings . Contains ( relabel , "Z" ) { return fmt . Errorf ( "Bad SELinux option z and Z can not be used together" ) } if strings . Contains ( relabel , "z" ) { c := selinux . NewContext ( fileLabel ) c [ "level" ] = "s0" fileLabel = c . Get ( ) } return selinux . Chcon ( path , fileLabel , true ) }
5851	func ( m * CirconusMetrics ) Set ( metric string , val uint64 ) { m . cm . Lock ( ) defer m . cm . Unlock ( ) m . counters [ metric ] = val }
1422	func ( cs * ClientServerImpl ) Connect ( ) error { seelog . Infof ( "Establishing a Websocket connection to %s" , cs . URL ) parsedURL , err := url . Parse ( cs . URL ) if err != nil { return err } wsScheme , err := websocketScheme ( parsedURL . Scheme ) if err != nil { return err } parsedURL . Scheme = wsScheme request , _ := http . NewRequest ( "GET" , parsedURL . String ( ) , nil ) err = utils . SignHTTPRequest ( request , cs . AgentConfig . AWSRegion , ServiceName , cs . CredentialProvider , nil ) if err != nil { return err } timeoutDialer := & net . Dialer { Timeout : wsConnectTimeout } tlsConfig := & tls . Config { ServerName : parsedURL . Host , InsecureSkipVerify : cs . AgentConfig . AcceptInsecureCert } cipher . WithSupportedCipherSuites ( tlsConfig ) noProxy := os . Getenv ( "NO_PROXY" ) if noProxy == "" { dockerHost , err := url . Parse ( cs . AgentConfig . DockerEndpoint ) if err == nil { dockerHost . Scheme = "" os . Setenv ( "NO_PROXY" , fmt . Sprintf ( "%s,%s" , defaultNoProxyIP , dockerHost . String ( ) ) ) seelog . Info ( "NO_PROXY set:" , os . Getenv ( "NO_PROXY" ) ) } else { seelog . Errorf ( "NO_PROXY unable to be set: the configured Docker endpoint is invalid." ) } } dialer := websocket . Dialer { ReadBufferSize : readBufSize , WriteBufferSize : writeBufSize , TLSClientConfig : tlsConfig , Proxy : http . ProxyFromEnvironment , NetDial : timeoutDialer . Dial , HandshakeTimeout : wsHandshakeTimeout , } websocketConn , httpResponse , err := dialer . Dial ( parsedURL . String ( ) , request . Header ) if httpResponse != nil { defer httpResponse . Body . Close ( ) } if err != nil { var resp [ ] byte if httpResponse != nil { var readErr error resp , readErr = ioutil . ReadAll ( httpResponse . Body ) if readErr != nil { return fmt . Errorf ( "Unable to read websocket connection: " + readErr . Error ( ) + ", " + err . Error ( ) ) } possibleError , _ , decodeErr := DecodeData ( resp , cs . TypeDecoder ) if decodeErr == nil { return cs . NewError ( possibleError ) } } seelog . Warnf ( "Error creating a websocket client: %v" , err ) return errors . Wrapf ( err , "websocket client: unable to dial %s response: %s" , parsedURL . Host , string ( resp ) ) } cs . writeLock . Lock ( ) defer cs . writeLock . Unlock ( ) cs . conn = websocketConn seelog . Debugf ( "Established a Websocket connection to %s" , cs . URL ) return nil }
2285	func ( v * SeparatorToolItem ) native ( ) * C . GtkSeparatorToolItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSeparatorToolItem ( p ) }
5049	func ( db * Database ) CollectionNames ( ) ( names [ ] string , err error ) { session := db . Session cloned := session . Clone ( ) cloned . SetMode ( Monotonic , false ) defer cloned . Close ( ) batchSize := int ( cloned . queryConfig . op . limit ) var result struct { Collections [ ] bson . Raw Cursor struct { FirstBatch [ ] bson . Raw "firstBatch" NS string Id int64 } } err = db . With ( cloned ) . Run ( bson . D { { "listCollections" , 1 } , { "cursor" , bson . D { { "batchSize" , batchSize } } } } , & result ) if err == nil { firstBatch := result . Collections if firstBatch == nil { firstBatch = result . Cursor . FirstBatch } var iter * Iter ns := strings . SplitN ( result . Cursor . NS , "." , 2 ) if len ( ns ) < 2 { iter = db . With ( cloned ) . C ( "" ) . NewIter ( nil , firstBatch , result . Cursor . Id , nil ) } else { iter = cloned . DB ( ns [ 0 ] ) . C ( ns [ 1 ] ) . NewIter ( nil , firstBatch , result . Cursor . Id , nil ) } var coll struct { Name string } for iter . Next ( & coll ) { names = append ( names , coll . Name ) } if err := iter . Close ( ) ; err != nil { return nil , err } sort . Strings ( names ) return names , err } if err != nil && ! isNoCmd ( err ) { return nil , err } nameIndex := len ( db . Name ) + 1 iter := db . C ( "system.namespaces" ) . Find ( nil ) . Iter ( ) var coll struct { Name string } for iter . Next ( & coll ) { if strings . Index ( coll . Name , "$" ) < 0 || strings . Index ( coll . Name , ".oplog.$" ) >= 0 { names = append ( names , coll . Name [ nameIndex : ] ) } } if err := iter . Close ( ) ; err != nil { return nil , err } sort . Strings ( names ) return names , nil }
174	func NewMergeQuerier ( primaryQuerier Querier , queriers [ ] Querier ) Querier { filtered := make ( [ ] Querier , 0 , len ( queriers ) ) for _ , querier := range queriers { if querier != NoopQuerier ( ) { filtered = append ( filtered , querier ) } } setQuerierMap := make ( map [ SeriesSet ] Querier ) failedQueriers := make ( map [ Querier ] struct { } ) switch len ( filtered ) { case 0 : return NoopQuerier ( ) case 1 : return filtered [ 0 ] default : return & mergeQuerier { primaryQuerier : primaryQuerier , queriers : filtered , failedQueriers : failedQueriers , setQuerierMap : setQuerierMap , } } }
6340	func ( m * Monitor ) MonitorReflectedFunc ( section string , reflectedFunc reflect . Value , args [ ] reflect . Value ) [ ] reflect . Value { m . Start ( section ) defer m . StopAndLog ( section ) return reflectedFunc . Call ( args ) }
6376	func First ( subject Enumerable ) ( retval interface { } , err error ) { done := make ( chan struct { } ) err = errNoElements var isOpen bool if retval , isOpen = <- subject . Enumerate ( done ) ; isOpen { err = nil } close ( done ) return }
262	func alertmanagerFromGroup ( tg * targetgroup . Group , cfg * config . AlertmanagerConfig ) ( [ ] alertmanager , [ ] alertmanager , error ) { var res [ ] alertmanager var droppedAlertManagers [ ] alertmanager for _ , tlset := range tg . Targets { lbls := make ( [ ] labels . Label , 0 , len ( tlset ) + 2 + len ( tg . Labels ) ) for ln , lv := range tlset { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } lbls = append ( lbls , labels . Label { Name : model . SchemeLabel , Value : cfg . Scheme } ) lbls = append ( lbls , labels . Label { Name : pathLabel , Value : postPath ( cfg . PathPrefix ) } ) for ln , lv := range tg . Labels { if _ , ok := tlset [ ln ] ; ! ok { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } } lset := relabel . Process ( labels . New ( lbls ... ) , cfg . RelabelConfigs ... ) if lset == nil { droppedAlertManagers = append ( droppedAlertManagers , alertmanagerLabels { lbls } ) continue } lb := labels . NewBuilder ( lset ) addPort := func ( s string ) bool { if _ , _ , err := net . SplitHostPort ( s ) ; err == nil { return false } _ , _ , err := net . SplitHostPort ( s + ":1234" ) return err == nil } addr := lset . Get ( model . AddressLabel ) if addPort ( addr ) { switch lset . Get ( model . SchemeLabel ) { case "http" , "" : addr = addr + ":80" case "https" : addr = addr + ":443" default : return nil , nil , errors . Errorf ( "invalid scheme: %q" , cfg . Scheme ) } lb . Set ( model . AddressLabel , addr ) } if err := config . CheckTargetAddress ( model . LabelValue ( addr ) ) ; err != nil { return nil , nil , err } for _ , l := range lset { if strings . HasPrefix ( l . Name , model . MetaLabelPrefix ) { lb . Del ( l . Name ) } } res = append ( res , alertmanagerLabels { lset } ) } return res , droppedAlertManagers , nil }
5664	func ( ps * printState ) writeByte ( b byte ) { ps . last = b ps . buf . WriteByte ( b ) }
3367	func ( i * IntegrationGCPCreateRequest ) GetClientX509CertURLOk ( ) ( string , bool ) { if i == nil || i . ClientX509CertURL == nil { return "" , false } return * i . ClientX509CertURL , true }
5823	func ( cm * CheckManager ) GetSubmissionURL ( ) ( * Trap , error ) { if cm . trapURL == "" { return nil , errors . Errorf ( "get submission url - submission url unavailable" ) } trap := & Trap { } u , err := url . Parse ( string ( cm . trapURL ) ) if err != nil { return nil , errors . Wrap ( err , "get submission url" ) } trap . URL = u if u . Scheme == "http+unix" { service := "circonus-agent" sockPath := "" metricID := "" subNames := cm . sockRx . SubexpNames ( ) matches := cm . sockRx . FindAllStringSubmatch ( string ( cm . trapURL ) , - 1 ) for _ , match := range matches { for idx , val := range match { switch subNames [ idx ] { case "sockfile" : sockPath = val case "id" : metricID = val } } } if sockPath == "" || metricID == "" { return nil , errors . Errorf ( "get submission url - invalid socket url (%s)" , cm . trapURL ) } u , err = url . Parse ( fmt . Sprintf ( "http+unix://%s/write/%s" , service , metricID ) ) if err != nil { return nil , errors . Wrap ( err , "get submission url" ) } trap . URL = u trap . SockTransport = & httpunix . Transport { DialTimeout : 100 * time . Millisecond , RequestTimeout : 1 * time . Second , ResponseHeaderTimeout : 1 * time . Second , } trap . SockTransport . RegisterLocation ( service , sockPath ) trap . IsSocket = true } if u . Scheme == "https" { if cm . brokerTLS != nil { trap . TLS = cm . brokerTLS return trap , nil } if trap . URL . Hostname ( ) == "api.circonus.com" { return trap , nil } if cm . certPool == nil { if err := cm . loadCACert ( ) ; err != nil { return nil , errors . Wrap ( err , "get submission url" ) } } t := & tls . Config { RootCAs : cm . certPool , } if cm . trapCN != "" { t . ServerName = string ( cm . trapCN ) } trap . TLS = t } return trap , nil }
7319	func PublisherContext ( ctx context . Context ) Publisher { pub , ok := ctx . Value ( KeyPublisher ) . ( Publisher ) if ! ok { return nil } return pub }
2541	func expandCustomizationGuiRunOnce ( d * schema . ResourceData ) * types . CustomizationGuiRunOnce { obj := & types . CustomizationGuiRunOnce { CommandList : structure . SliceInterfacesToStrings ( d . Get ( cWindowsKeyPrefix + "." + "run_once_command_list" ) . ( [ ] interface { } ) ) , } if len ( obj . CommandList ) < 1 { return nil } return obj }
6099	func ReadBoolSetting ( db * reform . Querier , key string ) ( bool , error ) { val , err := ReadSetting ( db , key ) if err != nil { return false , err } val2 , err := strconv . ParseBool ( val ) if err != nil { return false , newSettingParseError ( key , err ) } return bool ( val2 ) , nil }
935	func GenerateRandomID ( ) string { for { id := make ( [ ] byte , 32 ) if _ , err := io . ReadFull ( rand . Reader , id ) ; err != nil { panic ( err ) } value := hex . EncodeToString ( id ) if _ , err := strconv . ParseInt ( TruncateID ( value ) , 10 , 64 ) ; err == nil { continue } return value } }
6987	func ( s * S3Bucket ) Delete ( path string ) error { return s . bucket . Delete ( path ) }
6191	func ( n * npmp ) AddMapping ( protocol string , extPort , intPort int , name string , lifetime time . Duration ) error { if lifetime <= 0 { return ErrTooShortLifetime } _ , err := n . c . AddPortMapping ( strings . ToLower ( protocol ) , intPort , extPort , int ( lifetime / time . Second ) ) return err }
3293	func ( d * Downtime ) GetRecurrenceOk ( ) ( Recurrence , bool ) { if d == nil || d . Recurrence == nil { return Recurrence { } , false } return * d . Recurrence , true }
5979	func ( pool * WriterPool ) Len ( ) int { pool . mu . Lock ( ) l := len ( pool . givenOut ) pool . mu . Unlock ( ) return l }
2949	func expandStorageDrsPodConfigSpec ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . StorageDrsPodConfigSpec { obj := & types . StorageDrsPodConfigSpec { DefaultIntraVmAffinity : structure . GetBool ( d , "sdrs_default_intra_vm_affinity" ) , DefaultVmBehavior : d . Get ( "sdrs_automation_level" ) . ( string ) , Enabled : structure . GetBool ( d , "sdrs_enabled" ) , IoLoadBalanceConfig : expandStorageDrsIoLoadBalanceConfig ( d , version ) , IoLoadBalanceEnabled : structure . GetBool ( d , "sdrs_io_load_balance_enabled" ) , LoadBalanceInterval : int32 ( d . Get ( "sdrs_load_balance_interval" ) . ( int ) ) , SpaceLoadBalanceConfig : expandStorageDrsSpaceLoadBalanceConfig ( d , version ) , Option : expandStorageDrsOptionSpec ( d ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . AutomationOverrides = expandStorageDrsAutomationConfig ( d ) } return obj }
5856	func ( a * API ) FetchWorksheet ( cid CIDType ) ( * Worksheet , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid worksheet CID [none]" ) } worksheetCID := string ( * cid ) matched , err := regexp . MatchString ( config . WorksheetCIDRegex , worksheetCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid worksheet CID [%s]" , worksheetCID ) } result , err := a . Get ( string ( * cid ) ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch worksheet, received JSON: %s" , string ( result ) ) } worksheet := new ( Worksheet ) if err := json . Unmarshal ( result , worksheet ) ; err != nil { return nil , err } return worksheet , nil }
6310	func ( handler ControllerHandler ) getResponse ( r * http . Request ) Response { controller := handler . factory ( ) controller . SetRequest ( r ) controller . Init ( ) rController := reflect . ValueOf ( controller ) method := rController . MethodByName ( handler . methodName ) var args [ ] reflect . Value for _ , val := range mux . Vars ( r ) { args = append ( args , reflect . ValueOf ( val ) ) } expected := len ( args ) actual := method . Type ( ) . NumIn ( ) if expected != actual { panic ( fmt . Sprintf ( "Method '%s' has %d args, expected %d" , handler . methodName , actual , expected ) ) } out := method . Call ( args ) if out [ 0 ] . IsNil ( ) { panic ( "Response from controller was nil" ) } resp := out [ 0 ] . Interface ( ) . ( Response ) if resp == nil { panic ( "Response from controller was not Response interface" ) } controller . Session ( ) . WriteToResponse ( resp ) return resp }
5200	func OptIndexKeys ( keys bool ) IndexOption { return func ( options * IndexOptions ) { options . keys = keys options . keysSet = true } }
3395	func ( m * Monitor ) GetOverallState ( ) string { if m == nil || m . OverallState == nil { return "" } return * m . OverallState }
1445	func ( state * DockerTaskEngineState ) taskToIPUnsafe ( arn string ) ( string , bool ) { for ip , taskARN := range state . ipToTask { if arn == taskARN { return ip , true } } return "" , false }
1458	func ( c * Container ) SetKnownStatus ( status apicontainerstatus . ContainerStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . KnownStatusUnsafe = status c . updateAppliedStatusUnsafe ( status ) }
2515	func expandHostNicOrderPolicy ( d * schema . ResourceData ) * types . HostNicOrderPolicy { obj := & types . HostNicOrderPolicy { } activeNics , activeOk := d . GetOkExists ( "active_nics" ) standbyNics , standbyOk := d . GetOkExists ( "standby_nics" ) if ! activeOk && ! standbyOk { return nil } obj . ActiveNic = structure . SliceInterfacesToStrings ( activeNics . ( [ ] interface { } ) ) obj . StandbyNic = structure . SliceInterfacesToStrings ( standbyNics . ( [ ] interface { } ) ) return obj }
3733	func ( w * WidgetApmOrLogQuery ) GetCompute ( ) ApmOrLogQueryCompute { if w == nil || w . Compute == nil { return ApmOrLogQueryCompute { } } return * w . Compute }
6440	func ( l * List ) Set ( pos uint , val interface { } ) bool { l . key . Lock ( ) defer l . key . Unlock ( ) var retval bool count := uint ( len ( l . underlyer ) ) if pos > count { retval = false } else { l . underlyer [ pos ] = val retval = true } return retval }
309	func EncodeReadResponse ( resp * prompb . ReadResponse , w http . ResponseWriter ) error { data , err := proto . Marshal ( resp ) if err != nil { return err } w . Header ( ) . Set ( "Content-Type" , "application/x-protobuf" ) w . Header ( ) . Set ( "Content-Encoding" , "snappy" ) compressed := snappy . Encode ( nil , data ) _ , err = w . Write ( compressed ) return err }
464	func ( resp * Response ) SendFile ( path string ) error { f , err := os . Open ( path ) if err != nil { return err } fileInfo , err := f . Stat ( ) if err != nil { f . Close ( ) return err } size64 := fileInfo . Size ( ) size := int ( size64 ) if int64 ( size ) != size64 { size = - 1 } resp . Header . SetLastModified ( fileInfo . ModTime ( ) ) resp . SetBodyStream ( f , size ) return nil }
3959	func ( z * Writer ) Close ( ) error { if ! z . Header . done { if err := z . writeHeader ( ) ; err != nil { return err } } if err := z . Flush ( ) ; err != nil { return err } if debugFlag { debug ( "writing last empty block" ) } if err := z . writeUint32 ( 0 ) ; err != nil { return err } if ! z . NoChecksum { checksum := z . checksum . Sum32 ( ) if debugFlag { debug ( "stream checksum %x" , checksum ) } if err := z . writeUint32 ( checksum ) ; err != nil { return err } } return nil }
3326	func ( g * GraphDefinitionRequest ) GetStackedOk ( ) ( bool , bool ) { if g == nil || g . Stacked == nil { return false , false } return * g . Stacked , true }
5165	func NewRequestTx ( name string , url string ) * tx { t := NewTx ( name ) t . url = url return t }
3981	func ( p GTLDPeriod ) Valid ( when time . Time ) error { notBefore , _ := time . Parse ( GTLDPeriodDateFormat , p . DelegationDate ) if when . Before ( notBefore ) { return fmt . Errorf ( `gTLD ".%s" is not valid until %s` , p . GTLD , p . DelegationDate ) } if p . RemovalDate != "" { notAfter , _ := time . Parse ( GTLDPeriodDateFormat , p . RemovalDate ) if when . After ( notAfter ) { return fmt . Errorf ( `gTLD ".%s" is not valid after %s` , p . GTLD , p . RemovalDate ) } } return nil }
2684	func expandClusterProactiveDrsConfigInfo ( d * schema . ResourceData ) * types . ClusterProactiveDrsConfigInfo { obj := & types . ClusterProactiveDrsConfigInfo { Enabled : structure . GetBool ( d , "drs_enable_predictive_drs" ) , } return obj }
5124	func ( h * windowsAnsiEventHandler ) simulateLF ( includeCR bool ) ( bool , error ) { if h . wrapNext { if err := h . Flush ( ) ; err != nil { return false , err } h . clearWrap ( ) } pos , info , err := h . getCurrentInfo ( ) if err != nil { return false , err } sr := h . effectiveSr ( info . Window ) if pos . Y == sr . bottom { if sr . top == info . Window . Top && sr . bottom == info . Window . Bottom { if includeCR { pos . X = 0 h . updatePos ( pos ) } return false , nil } if err := h . Flush ( ) ; err != nil { return false , err } h . logf ( "Simulating LF inside scroll region" ) if err := h . scrollUp ( 1 ) ; err != nil { return false , err } if includeCR { pos . X = 0 if err := SetConsoleCursorPosition ( h . fd , pos ) ; err != nil { return false , err } } return true , nil } else if pos . Y < info . Window . Bottom { pos . Y ++ if includeCR { pos . X = 0 } h . updatePos ( pos ) return false , nil } else { h . logf ( "Simulating LF outside scroll region" ) if includeCR { if err := h . Flush ( ) ; err != nil { return false , err } pos . X = 0 if err := SetConsoleCursorPosition ( h . fd , pos ) ; err != nil { return false , err } } return true , nil } }
7271	func validateTournamentInfo ( info Info ) error { if info . Scheduled . IsZero ( ) { return errors . New ( "Tournament needs scheduled date" ) } if info . Stake == 0 { return errors . New ( "Tournament needs a stake" ) } if info . Season == 0 { return errors . New ( "Tournament needs a season" ) } return nil }
3253	func ( c * Check ) GetTimestamp ( ) string { if c == nil || c . Timestamp == nil { return "" } return * c . Timestamp }
1817	func ( m * MockCache ) Get ( arg0 string ) ( async . Value , bool ) { ret := m . ctrl . Call ( m , "Get" , arg0 ) ret0 , _ := ret [ 0 ] . ( async . Value ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 }
1296	func NewMockAuditLogger ( ctrl * gomock . Controller ) * MockAuditLogger { mock := & MockAuditLogger { ctrl : ctrl } mock . recorder = & MockAuditLoggerMockRecorder { mock } return mock }
1463	func ( c * Container ) SetKnownExitCode ( i * int ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . KnownExitCodeUnsafe = i }
3661	func ( w * Widget ) GetBgcolor ( ) string { if w == nil || w . Bgcolor == nil { return "" } return * w . Bgcolor }
4054	func ( l * ListBox ) SelectItem ( id int ) bool { if len ( l . items ) <= id || id < 0 { return false } l . currSelection = id l . EnsureVisible ( ) return true }
2080	func ( m * MockGPUManager ) SetGPUIDs ( arg0 [ ] string ) { m . ctrl . Call ( m , "SetGPUIDs" , arg0 ) }
1491	func ( c * Container ) updateAppliedStatusUnsafe ( knownStatus apicontainerstatus . ContainerStatus ) { if c . AppliedStatus == apicontainerstatus . ContainerStatusNone { return } if c . AppliedStatus <= knownStatus { c . AppliedStatus = apicontainerstatus . ContainerStatusNone } }
6773	func ( r * PEXReactor ) RequestPEX ( p * Peer ) { p . Send ( PexChannel , struct { PexMessage } { & pexRequestMessage { } } ) }
1747	func ( task * Task ) GetAppMesh ( ) * apiappmesh . AppMesh { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . AppMesh }
4005	func TypeInName ( name * pkix . Name , oid asn1 . ObjectIdentifier ) bool { for _ , v := range name . Names { if oid . Equal ( v . Type ) { return true } } return false }
6692	func ( c * Client ) DestroyServer ( identifier string ) error { _ , err := c . MakeApiRequest ( "DELETE" , "/1.0/servers/" + identifier , nil , nil ) if err != nil { return err } return nil }
3273	func ( d * DashboardConditionalFormat ) HasInverted ( ) bool { if d != nil && d . Inverted != nil { return true } return false }
2597	func ( r MOIDForUUIDResults ) MOIDs ( ) [ ] string { var moids [ ] string for _ , result := range r { moids = append ( moids , result . MOID ) } return moids }
3204	func ( self * Client ) CreateUser ( handle , name * string ) ( * User , error ) { in := struct { Handle * string `json:"handle"` Name * string `json:"name"` } { Handle : handle , Name : name , } out := struct { * User `json:"user"` } { } if err := self . doJsonRequest ( "POST" , "/v1/user" , in , & out ) ; err != nil { return nil , err } return out . User , nil }
3386	func ( m * MetricMetadata ) GetPerUnit ( ) string { if m == nil || m . PerUnit == nil { return "" } return * m . PerUnit }
1917	func NewMockFileSystem ( ctrl * gomock . Controller ) * MockFileSystem { mock := & MockFileSystem { ctrl : ctrl } mock . recorder = & MockFileSystemMockRecorder { mock } return mock }
3265	func ( c * CreatedBy ) GetIcon ( ) string { if c == nil || c . Icon == nil { return "" } return * c . Icon }
192	func ( a * Adapter ) Run ( ) { go a . manager . Run ( ) a . manager . StartCustomProvider ( a . ctx , a . name , a . disc ) go a . runCustomSD ( a . ctx ) }
6384	func ( iter Enumerator ) SelectMany ( lister Unfolder ) Enumerator { retval := make ( chan interface { } ) go func ( ) { for parent := range iter { for child := range lister ( parent ) { retval <- child } } close ( retval ) } ( ) return retval }
2408	func IsGamepadButtonJustPressed ( id int , button ebiten . GamepadButton ) bool { return GamepadButtonPressDuration ( id , button ) == 1 }
3841	func ( s * ScreenBuf ) Clear ( ) error { for i := 0 ; i < s . height ; i ++ { _ , err := s . buf . Write ( moveUp ) if err != nil { return err } _ , err = s . buf . Write ( clearLine ) if err != nil { return err } } s . cursor = 0 s . height = 0 s . reset = false return nil }
5407	func ( g * Group ) Add ( ) ( gid int , err error ) { loadConfig ( ) group , err := LookupGroup ( g . Name ) if err != nil { if _ , ok := err . ( NoFoundError ) ; ! ok { return 0 , err } } if group != nil { return 0 , ErrGroupExist } if g . Name == "" { return 0 , RequiredError ( "Name" ) } var db * dbfile if g . GID < 0 { db , gid , err = nextGUID ( g . addSystemGroup ) if err != nil { db . close ( ) return 0 , err } g . GID = gid } else { db , err = openDBFile ( _GROUP_FILE , os . O_WRONLY | os . O_APPEND ) if err != nil { return } _ , err = LookupGID ( g . GID ) if err == nil { return 0 , IdUsedError ( g . GID ) } else if _ , ok := err . ( NoFoundError ) ; ! ok { return 0 , err } } g . password = "x" _ , err = db . file . WriteString ( g . String ( ) ) err2 := db . close ( ) if err2 != nil && err == nil { err = err2 } return }
6448	func Monotonic ( ) time . Duration { sec , nsec := monotime ( ) return time . Duration ( sec * 1000000000 + int64 ( nsec ) ) }
4797	func Init ( ) error { initMutex . Lock ( ) defer initMutex . Unlock ( ) if gitBinary != "" { return nil } var err error if gitBinary , err = gos . LookPath ( "git" ) ; err != nil { return fmt . Errorf ( "git middleware requires git installed. Cannot find git binary in PATH" ) } shell = "bash" if _ , err = gos . LookPath ( "bash" ) ; err != nil { shell = "sh" if _ , err = gos . LookPath ( "sh" ) ; err != nil { return fmt . Errorf ( "git middleware requires either bash or sh" ) } } return nil }
1599	func ( m * MockSecretsManagerAPI ) ListSecrets ( arg0 * secretsmanager . ListSecretsInput ) ( * secretsmanager . ListSecretsOutput , error ) { ret := m . ctrl . Call ( m , "ListSecrets" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . ListSecretsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1345	func dependenciesCanBeResolved ( target * apicontainer . Container , by [ ] * apicontainer . Container ) bool { nameMap := make ( map [ string ] * apicontainer . Container ) for _ , cont := range by { nameMap [ cont . Name ] = cont } if _ , err := verifyContainerOrderingStatusResolvable ( target , nameMap , containerOrderingDependenciesCanResolve ) ; err != nil { return false } return verifyStatusResolvable ( target , nameMap , target . SteadyStateDependencies , onSteadyStateCanResolve ) }
1892	func ( engine * DockerTaskEngine ) filterTasksToStartUnsafe ( tasks [ ] * apitask . Task ) [ ] * apitask . Task { var tasksToStart [ ] * apitask . Task for _ , task := range tasks { conts , ok := engine . state . ContainerMapByArn ( task . Arn ) if ! ok { tasksToStart = append ( tasksToStart , task ) continue } for _ , cont := range conts { engine . synchronizeContainerStatus ( cont , task ) } tasksToStart = append ( tasksToStart , task ) if task . GetDesiredStatus ( ) . Terminal ( ) && task . GetStopSequenceNumber ( ) != 0 { engine . taskStopGroup . Add ( task . GetStopSequenceNumber ( ) , 1 ) } } return tasksToStart }
3915	func ( c * Checker ) processCompositeLiteral ( pkg * lint . Pkg , node ast . Node ) { if node , ok := node . ( * ast . CompositeLit ) ; ok { typ := pkg . TypesInfo . TypeOf ( node ) if _ , ok := typ . ( * types . Named ) ; ok { typ = typ . Underlying ( ) } if _ , ok := typ . ( * types . Struct ) ; ! ok { return } if isBasicStruct ( node . Elts ) { c . markFields ( typ ) } } }
4834	func ( h WebHook ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) ( int , error ) { for _ , repo := range h . Repos { if r . URL . Path == repo . Hook . URL { if handler , ok := handlers [ repo . Hook . Type ] ; ok { if ! handler . DoesHandle ( r . Header ) { return http . StatusBadRequest , errors . New ( http . StatusText ( http . StatusBadRequest ) ) } status , err := handler . Handle ( w , r , repo ) if hookIgnored ( err ) { Logger ( ) . Println ( err ) err = nil } return status , err } for _ , h := range defaultHandlers { if handlers [ h ] . DoesHandle ( r . Header ) { status , err := handlers [ h ] . Handle ( w , r , repo ) if hookIgnored ( err ) { Logger ( ) . Println ( err ) err = nil } return status , err } } Logger ( ) . Println ( "No compatible handler found. Consider enabling generic handler with 'hook_type generic'." ) } } return h . Next . ServeHTTP ( w , r ) }
5741	func ( c * CustomerIO ) Delete ( customerID string ) error { status , responseBody , err := c . request ( "DELETE" , c . customerURL ( customerID ) , [ ] byte { } ) if err != nil { return err } else if status != 200 { return & CustomerIOError { status , c . customerURL ( customerID ) , responseBody } } return nil }
7167	func ( s * Stack ) Pop ( ) ( header , data [ ] byte , err error ) { if s . depth == 0 { return nil , nil , nil } s . guard . Lock ( ) defer s . guard . Unlock ( ) s . lastAccess = time . Now ( ) file , err := s . getFile ( ) if err != nil { return nil , nil , err } data = make ( [ ] byte , s . currentBlock . DataSize ) header = make ( [ ] byte , s . currentBlock . HeaderSize ) _ , err = file . ReadAt ( header , int64 ( s . currentBlock . HeaderPoint ) ) if err != nil { return nil , nil , err } _ , err = file . ReadAt ( data , int64 ( s . currentBlock . DataPoint ) ) if err != nil { return nil , nil , err } var newBlock fileBlock if s . currentBlockPos != 0 { newBlock , err = readBlockAt ( file , int64 ( s . currentBlock . PrevBlock ) ) if err != nil { return nil , nil , err } } err = file . Truncate ( int64 ( s . currentBlockPos ) ) if err != nil { return nil , nil , err } s . depth -- s . currentBlockPos = int64 ( s . currentBlock . PrevBlock ) s . currentBlock = newBlock return header , data , nil }
2254	func ( v * Layout ) SetSize ( width , height uint ) { C . gtk_layout_set_size ( v . native ( ) , C . guint ( width ) , C . guint ( height ) ) }
372	func ( a * Args ) AddBytesKV ( key , value [ ] byte ) { a . args = appendArg ( a . args , b2s ( key ) , b2s ( value ) , argsHasValue ) }
736	func ( p * AWSSDProvider ) targetToInstanceID ( target string ) string { if len ( target ) > 64 { hash := sha256 . Sum256 ( [ ] byte ( strings . ToLower ( target ) ) ) return hex . EncodeToString ( hash [ : ] ) } return strings . ToLower ( target ) }
5738	func ( c * CustomerIO ) Identify ( customerID string , attributes map [ string ] interface { } ) error { j , err := json . Marshal ( attributes ) if err != nil { return err } status , responseBody , err := c . request ( "PUT" , c . customerURL ( customerID ) , j ) if err != nil { return err } else if status != 200 { return & CustomerIOError { status , c . customerURL ( customerID ) , responseBody } } return nil }
4121	func ( b * SparkChart ) SetTop ( top float64 ) { b . mtx . Lock ( ) defer b . mtx . Unlock ( ) b . topValue = top }
621	func isAWSLoadBalancer ( ep * endpoint . Endpoint ) bool { if ep . RecordType == endpoint . RecordTypeCNAME { return canonicalHostedZone ( ep . Targets [ 0 ] ) != "" } return false }
3562	func ( t * TemplateVariable ) GetDefault ( ) string { if t == nil || t . Default == nil { return "" } return * t . Default }
3100	func NewRouteMap ( ) * routeMap { rm := & routeMap { routes : make ( map [ string ] map [ string ] * Leaf ) , } for m := range _HTTP_METHODS { rm . routes [ m ] = make ( map [ string ] * Leaf ) } return rm }
5147	func ( ui * PrefixUI ) Error ( message string ) { if ui . ErrorPrefix == " " { message = ui . ErrorPrefix + message } else if ui . ErrorPrefix != "" { message = ui . ErrorPrefix + " " + message } ui . UI . Error ( message ) }
1693	func NewTaskStateChangeEvent ( task * apitask . Task , reason string ) ( TaskStateChange , error ) { var event TaskStateChange taskKnownStatus := task . GetKnownStatus ( ) if ! taskKnownStatus . BackendRecognized ( ) { return event , errors . Errorf ( "create task state change event api: status not recognized by ECS: %v" , taskKnownStatus ) } if task . GetSentStatus ( ) >= taskKnownStatus { return event , errors . Errorf ( "create task state change event api: status [%s] already sent" , taskKnownStatus . String ( ) ) } event = TaskStateChange { TaskARN : task . Arn , Status : taskKnownStatus , Reason : reason , Task : task , } event . SetTaskTimestamps ( ) return event , nil }
2071	func ( mr * MockECRFactoryMockRecorder ) GetClient ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "GetClient" , reflect . TypeOf ( ( * MockECRFactory ) ( nil ) . GetClient ) , arg0 ) }
6288	func ( t * BTTracer ) SetOutputPath ( path string , perm os . FileMode ) error { if perm == 0 { perm = 0755 } if err := os . MkdirAll ( path , perm ) ; err != nil { t . Logf ( LogError , "Failed to create output directory: %v\n" , \n ) err } return err t . m . Lock ( ) defer t . m . Unlock ( ) t . outputDir = path }
4981	func ( c * Consumer ) StreamWithoutReconnect ( appGuid string , authToken string ) ( <- chan * events . Envelope , <- chan error ) { return c . runStream ( appGuid , authToken , false ) }
3639	func ( t * TraceServiceDefinition ) HasShowLatency ( ) bool { if t != nil && t . ShowLatency != nil { return true } return false }
4515	func ( s * SortFilter ) Num ( n int ) * SortFilter { s . add ( func ( a , b string ) int { a1 , a2 := column ( a , n ) b1 , b2 := column ( b , n ) switch { case a1 < b1 : return - 1 case a1 > b1 : return + 1 } a3 , a4 := strconv . ParseFloat ( a2 , 64 ) b3 , b4 := strconv . ParseFloat ( b2 , 64 ) if a4 != b4 { if a4 != nil { return + 1 } return - 1 } switch { case a3 < b3 : return - 1 case a3 > b3 : return + 1 } return 0 } ) return s }
6245	func Uint32ToBytes ( x uint32 ) [ 4 ] byte { var xBytes [ 4 ] byte binary . BigEndian . PutUint32 ( xBytes [ : ] , x ) return xBytes }
5942	func ( r * BasicReporter ) PostEZCountTime ( statName , ezkey string , count int , timestamp int64 ) error { x := newEZStatCount ( statName , ezkey , count ) x . Timestamp = timestamp r . add ( x ) return nil }
2227	func ( v * Clipboard ) native ( ) * C . GtkClipboard { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkClipboard ( p ) }
1298	func ( mr * MockAuditLoggerMockRecorder ) GetContainerInstanceArn ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "GetContainerInstanceArn" , reflect . TypeOf ( ( * MockAuditLogger ) ( nil ) . GetContainerInstanceArn ) ) }
1201	func NewMockTimer ( ctrl * gomock . Controller ) * MockTimer { mock := & MockTimer { ctrl : ctrl } mock . recorder = & MockTimerMockRecorder { mock } return mock }
550	func ( ln * InmemoryListener ) Close ( ) error { var err error ln . lock . Lock ( ) if ! ln . closed { close ( ln . conns ) ln . closed = true } else { err = fmt . Errorf ( "InmemoryListener is already closed" ) } ln . lock . Unlock ( ) return err }
814	func DockerClient ( dockerHost DockerHost ) ( * dockerclient . DockerClient , error ) { url , err := dockerHost . URL ( ) if err != nil { return nil , err } tlsConfig , err := cert . ReadTLSConfig ( url , dockerHost . AuthOptions ( ) ) if err != nil { return nil , fmt . Errorf ( "Unable to read TLS config: %s" , err ) } return dockerclient . NewDockerClient ( url , tlsConfig ) }
6983	func ( s * Server ) wsConnHandler ( ws * websocket . Conn ) { c , err := NewConn ( ) if err != nil { log . Printf ( "server: error while accepting connection: %v" , err ) return } defer recoverAndLog ( c , & s . wg ) c . MiddlewareFunc ( s . middleware ... ) log . Printf ( "server: client connected %v: %v" , c . ID , ws . RemoteAddr ( ) ) s . conns . Set ( c . ID , c ) connsCounter . Add ( 1 ) c . setConn ( ws ) c . startReceive ( ) s . conns . Delete ( c . ID ) connsCounter . Add ( - 1 ) s . disconnHandler ( c ) }
6457	func ( l * Log ) SetLogToStderr ( f bool ) { l . mu . Lock ( ) defer l . mu . Unlock ( ) l . toStderr = f }
1822	func ( mtask * managedTask ) emitCurrentStatus ( ) { for _ , container := range mtask . Containers { mtask . emitContainerEvent ( mtask . Task , container , "" ) } mtask . emitTaskEvent ( mtask . Task , "" ) }
5981	func ( pool * ReaderPool ) Get ( r io . Reader ) ( reader io . Reader , release func ( ) ) { rd := ThrottledReader ( r , 0 , pool . maxBurst ) pool . mu . Lock ( ) pool . givenOut [ rd ] = struct { } { } pool . setSharedRates ( ) pool . mu . Unlock ( ) return rd , func ( ) { pool . mu . Lock ( ) delete ( pool . givenOut , rd ) pool . setSharedRates ( ) pool . mu . Unlock ( ) } }
5817	func ( cm * CheckManager ) checkBundleSearch ( criteria string , filter map [ string ] [ ] string ) ( * api . CheckBundle , error ) { search := api . SearchQueryType ( criteria ) checkBundles , err := cm . apih . SearchCheckBundles ( & search , & filter ) if err != nil { return nil , err } if len ( * checkBundles ) == 0 { return nil , nil } numActive := 0 checkID := - 1 for idx , check := range * checkBundles { if check . Status == statusActive { numActive ++ checkID = idx } } if numActive > 1 { return nil , fmt . Errorf ( "[ERROR] multiple check bundles match criteria %s" , criteria ) } bundle := ( * checkBundles ) [ checkID ] return & bundle , nil }
1244	func ( udevWatcher * UdevWatcher ) buildState ( links [ ] netlink . Link ) map [ string ] string { state := make ( map [ string ] string ) for _ , link := range links { if link . Type ( ) != linkTypeDevice { continue } if link . Attrs ( ) . EncapType == encapTypeLoopback { continue } macAddress := link . Attrs ( ) . HardwareAddr . String ( ) if macAddress != "" && macAddress != udevWatcher . primaryMAC { state [ macAddress ] = link . Attrs ( ) . Name } } return state }
4332	func ( c * Client ) Timing ( bucket string , value interface { } ) { if c . skip ( ) { return } c . conn . metric ( c . prefix , bucket , value , "ms" , c . rate , c . tags ) }
768	func canonicalizeDomainNames ( domains [ ] string ) [ ] string { var cDomains [ ] string for _ , d := range domains { if ! strings . HasSuffix ( d , "." ) { d += "." cDomains = append ( cDomains , strings . ToLower ( d ) ) } } return cDomains }
3007	func migrateVSphereVirtualMachineStateV3 ( is * terraform . InstanceState , meta interface { } ) error { client := meta . ( * VSphereClient ) . vimClient id := is . ID log . Printf ( "[DEBUG] Migrate state for VM at UUID %q" , id ) vm , err := virtualmachine . FromUUID ( client , id ) if err != nil { return fmt . Errorf ( "error fetching virtual machine: %s" , err ) } props , err := virtualmachine . Properties ( vm ) if err != nil { return fmt . Errorf ( "error fetching virtual machine properties: %s" , err ) } diskCnt , _ := strconv . Atoi ( is . Attributes [ "disk.#" ] ) l := object . VirtualDeviceList ( props . Config . Hardware . Device ) for i := 0 ; i < diskCnt ; i ++ { v , ok := is . Attributes [ fmt . Sprintf ( "disk.%d.key" , i ) ] if ! ok { return fmt . Errorf ( "corrupt state: key disk.%d.key not found" , i ) } key , err := strconv . Atoi ( v ) if err != nil { return fmt . Errorf ( "corrupt state: strconv.Atoi error on disk.%d.key: %s" , i , err ) } if key < 1 { continue } device := l . FindByKey ( int32 ( key ) ) if device == nil { continue } disk , ok := device . ( * types . VirtualDisk ) if ! ok { continue } backing , ok := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) if ! ok { return fmt . Errorf ( "disk device %s is not a VMDK-backed virtual disk and state import cannot continue" , l . Name ( disk ) ) } is . Attributes [ fmt . Sprintf ( "disk.%d.uuid" , i ) ] = backing . Uuid } d := resourceVSphereVirtualMachine ( ) . Data ( & terraform . InstanceState { } ) log . Printf ( "[DEBUG] %s: Migration to V3 complete" , resourceVSphereVirtualMachineIDString ( d ) ) return nil }
1872	func NewMockDockerMetadataClient ( ctrl * gomock . Controller ) * MockDockerMetadataClient { mock := & MockDockerMetadataClient { ctrl : ctrl } mock . recorder = & MockDockerMetadataClientMockRecorder { mock } return mock }
1547	func ( m * MockCgroup ) MoveTo ( arg0 cgroups . Cgroup ) error { ret := m . ctrl . Call ( m , "MoveTo" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
2421	func playNote ( freq float64 ) { f := int ( freq ) p , _ := audio . NewPlayerFromBytes ( audioContext , pianoNoteSamples [ f ] ) p . Play ( ) }
6845	func ( c * Client ) Subscription ( tag string ) ( * Subscription , error ) { subs , err := c . Subscriptions ( ) if err != nil { return nil , err } for i := range subs { if subs [ i ] . Channel . Tag == tag { subs [ i ] . Client = c return subs [ i ] , nil } } return nil , ErrDeviceNotFound }
4831	func ( t TravisHook ) handleSignature ( r * http . Request , secret string ) error { signature := r . Header . Get ( "Authorization" ) if signature == "" { return errors . New ( "request sent no authorization signature" ) } if secret == "" { Logger ( ) . Print ( "Unable to verify request signature. Secret not set in caddyfile!\n" ) \n } return nil content := r . Header . Get ( "Travis-Repo-Slug" ) + secret hash := sha256 . Sum256 ( [ ] byte ( content ) ) expectedMac := hex . EncodeToString ( hash [ : ] ) if signature != expectedMac { fmt . Println ( signature , expectedMac ) return errors . New ( "Invalid authorization header" ) } }
1317	func ( m * MockFile ) Write ( arg0 [ ] byte ) ( int , error ) { ret := m . ctrl . Call ( m , "Write" , arg0 ) ret0 , _ := ret [ 0 ] . ( int ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
173	func ( f * fanout ) Close ( ) error { if err := f . primary . Close ( ) ; err != nil { return err } var lastErr error for _ , storage := range f . secondaries { if err := storage . Close ( ) ; err != nil { lastErr = err } } return lastErr }
6694	func ( c * Client ) UnlockServer ( identifier string ) error { return c . UnLockResource ( Server { Id : identifier } ) }
4701	func extractID ( s string , ln * line ) ( string , error ) { tokens := strings . Split ( s , sharp ) l := len ( tokens ) if l < 2 { return "" , nil } if l > 2 { return "" , fmt . Errorf ( "multiple IDs are specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } return strings . Split ( tokens [ 1 ] , dot ) [ 0 ] , nil }
7289	func ( formatter * JSONFormatter ) Format ( record * Record ) string { data , _ := json . Marshal ( record ) return string ( data ) }
4068	func AlignText ( str string , width int , align Align ) ( shift int , out string ) { length := xs . Len ( str ) if length >= width { return 0 , CutText ( str , width ) } if align == AlignRight { return width - length , str } else if align == AlignCenter { return ( width - length ) / 2 , str } return 0 , str }
2855	func taskFault ( err error ) ( types . BaseMethodFault , bool ) { if te , ok := err . ( task . Error ) ; ok { return te . Fault ( ) , true } return nil , false }
5636	func DerivePublicKeyForPath ( pubKeyBytes [ ] byte , chainCode [ ] byte , path string ) [ ] byte { data := pubKeyBytes parts := strings . Split ( path , "/" ) for _ , part := range parts { prime := part [ len ( part ) - 1 : ] == "'" if prime { panic ( errors . New ( "cannot do a prime derivation from public key" ) ) } i , err := strconv . Atoi ( part ) if err != nil { panic ( err ) } if i < 0 { panic ( errors . New ( "index too large." ) ) } data , chainCode = DerivePublicKey ( data , chainCode , uint32 ( i ) ) } return data }
4455	func ( r * RGBColor ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { * r = RGBColor ( data ) } }
1205	func ( mr * MockTimerMockRecorder ) Stop ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Stop" , reflect . TypeOf ( ( * MockTimer ) ( nil ) . Stop ) ) }
4353	func Omnimatch ( password string , userInputs [ ] string , filters ... func ( match . Matcher ) bool ) ( matches [ ] match . Match ) { if dictionaryMatchers == nil || adjacencyGraphs == nil { loadFrequencyList ( ) } if userInputs != nil { userInputMatcher := buildDictMatcher ( "user_inputs" , buildRankedDict ( userInputs ) ) matches = userInputMatcher ( password ) } for _ , matcher := range matchers { shouldBeFiltered := false for i := range filters { if filters [ i ] ( matcher ) { shouldBeFiltered = true break } } if ! shouldBeFiltered { matches = append ( matches , matcher . MatchingFunc ( password ) ... ) } } sort . Sort ( match . Matches ( matches ) ) return matches }
4822	func ( g GitOS ) Mkdir ( name string , perm os . FileMode ) error { return os . Mkdir ( name , perm ) }
518	func ( h * RequestHeader ) Cookie ( key string ) [ ] byte { h . parseRawHeaders ( ) h . collectCookies ( ) return peekArgStr ( h . cookies , key ) }
2593	func UUIDForMOID ( client * govmomi . Client , moid string ) ( MOIDForUUIDResult , error ) { vm , err := FromMOID ( client , moid ) if err != nil { return MOIDForUUIDResult { } , err } props , err := Properties ( vm ) if err != nil { return MOIDForUUIDResult { } , err } return MOIDForUUIDResult { UUID : props . Config . Uuid , MOID : vm . Reference ( ) . Value , } , nil }
1025	func ( d * DedupManager ) IsLeader ( tmpl * template . Template ) bool { d . leaderLock . RLock ( ) defer d . leaderLock . RUnlock ( ) lockCh , ok := d . leader [ tmpl ] if ! ok { return false } select { case <- lockCh : return false default : return true } }
6437	func ( l * List ) IsEmpty ( ) bool { l . key . RLock ( ) defer l . key . RUnlock ( ) return 0 == len ( l . underlyer ) }
2577	func ( r * NetworkInterfaceSubresource ) Delete ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] %s: Beginning delete" , r ) vd , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( "cannot find network device: %s" , err ) } device , err := baseVirtualDeviceToBaseVirtualEthernetCard ( vd ) if err != nil { return nil , err } if r . rdd . Get ( "vmware_tools_status" ) . ( string ) != string ( types . VirtualMachineToolsRunningStatusGuestToolsRunning ) { r . SetRestart ( "<device delete>" ) } bvd := baseVirtualEthernetCardToBaseVirtualDevice ( device ) spec , err := object . VirtualDeviceList { bvd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } log . Printf ( "[DEBUG] %s: Device config operations from update: %s" , r , DeviceChangeString ( spec ) ) log . Printf ( "[DEBUG] %s: Delete completed" , r ) return spec , nil }
3186	func ( client * Client ) CreateMonitor ( monitor * Monitor ) ( * Monitor , error ) { var out Monitor if err := client . doJsonRequest ( "POST" , "/v1/monitor" , monitor , & out ) ; err != nil { return nil , err } return & out , nil }
2263	func ( v * Notebook ) native ( ) * C . GtkNotebook { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkNotebook ( p ) }
4453	func ( r RGBColor ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( r ) ) }
55	func ( d * Discovery ) watchService ( ctx context . Context , ch chan <- [ ] * targetgroup . Group , name string ) { srv := & consulService { discovery : d , client : d . client , name : name , tags : d . watchedTags , labels : model . LabelSet { serviceLabel : model . LabelValue ( name ) , datacenterLabel : model . LabelValue ( d . clientDatacenter ) , } , tagSeparator : d . tagSeparator , logger : d . logger , } go func ( ) { ticker := time . NewTicker ( d . refreshInterval ) var lastIndex uint64 catalog := srv . client . Catalog ( ) for { select { case <- ctx . Done ( ) : ticker . Stop ( ) return default : srv . watch ( ctx , ch , catalog , & lastIndex ) <- ticker . C } } } ( ) }
4204	func ( c * DeleteSpaceConfigurationCommand ) Execute ( [ ] string ) error { if err := config . NewManager ( c . ConfigDirectory ) . DeleteSpaceConfig ( c . OrgName , c . SpaceName ) ; err != nil { return err } fmt . Printf ( "The org/space %s/%s was successfully deleted" , c . OrgName , c . SpaceName ) return nil }
1986	func ( m * MockClient ) VolumeCreate ( arg0 context . Context , arg1 volume . VolumeCreateBody ) ( types . Volume , error ) { ret := m . ctrl . Call ( m , "VolumeCreate" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Volume ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5404	func GetgroupsName ( ) [ ] string { user := GetUsername ( ) list := make ( [ ] string , 0 ) if _ , err := LookupGroup ( user ) ; err == nil { list = append ( list , user ) } groups , err := LookupInGroup ( G_MEMBER , user , - 1 ) if err != nil { if _ , ok := err . ( NoFoundError ) ; ! ok { panic ( err ) } } for _ , v := range groups { list = append ( list , v . Name ) } return list }
5791	func ( a * API ) FetchOutlierReport ( cid CIDType ) ( * OutlierReport , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid outlier report CID [none]" ) } reportCID := string ( * cid ) matched , err := regexp . MatchString ( config . OutlierReportCIDRegex , reportCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid outlier report CID [%s]" , reportCID ) } result , err := a . Get ( reportCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch outlier report, received JSON: %s" , string ( result ) ) } report := & OutlierReport { } if err := json . Unmarshal ( result , report ) ; err != nil { return nil , err } return report , nil }
2799	func Properties ( cluster * object . ClusterComputeResource ) ( * mo . ClusterComputeResource , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . ClusterComputeResource if err := cluster . Properties ( ctx , cluster . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
6531	func ( d * SerialDispatcher ) DispatchOptional ( cmd interface { } ) ( err error ) { d . mutex . RLock ( ) defer d . mutex . RUnlock ( ) err = d . Dispatch ( cmd ) switch err . ( type ) { case * NoHandlerFoundError : return nil default : return err } }
5185	func DefaultCluster ( ) * Cluster { return & Cluster { hosts : make ( [ ] * URI , 0 ) , okList : make ( [ ] bool , 0 ) , mutex : & sync . RWMutex { } , } }
3132	func ( p * Protocol ) UnmarshalText ( text [ ] byte ) error { protocolName := string ( text ) switch strings . ToLower ( protocolName ) { case "plain" : * p = ProtocolPlain case "protobuf" : * p = ProtocolProtobuf case "pickle" : * p = ProtocolPickle default : return fmt . Errorf ( "Unsupported protocol type %v, supported: %v" , protocolName , supportedProtocols ) } return nil }
5749	func ( a * API ) Get ( reqPath string ) ( [ ] byte , error ) { return a . apiRequest ( "GET" , reqPath , nil ) }
1739	func ( task * Task ) GetExecutionCredentialsID ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ExecutionCredentialsID }
107	func ( c * Client ) Store ( ctx context . Context , req [ ] byte ) error { httpReq , err := http . NewRequest ( "POST" , c . url . String ( ) , bytes . NewReader ( req ) ) if err != nil { return err } httpReq . Header . Add ( "Content-Encoding" , "snappy" ) httpReq . Header . Set ( "Content-Type" , "application/x-protobuf" ) httpReq . Header . Set ( "User-Agent" , userAgent ) httpReq . Header . Set ( "X-Prometheus-Remote-Write-Version" , "0.1.0" ) httpReq = httpReq . WithContext ( ctx ) ctx , cancel := context . WithTimeout ( context . Background ( ) , c . timeout ) defer cancel ( ) httpResp , err := c . client . Do ( httpReq . WithContext ( ctx ) ) if err != nil { return recoverableError { err } } defer func ( ) { io . Copy ( ioutil . Discard , httpResp . Body ) httpResp . Body . Close ( ) } ( ) if httpResp . StatusCode / 100 != 2 { scanner := bufio . NewScanner ( io . LimitReader ( httpResp . Body , maxErrMsgLen ) ) line := "" if scanner . Scan ( ) { line = scanner . Text ( ) } err = errors . Errorf ( "server returned HTTP status %s: %s" , httpResp . Status , line ) } if httpResp . StatusCode / 100 == 5 { return recoverableError { err } } return err }
2407	func IsGamepadJustDisconnected ( id int ) bool { theInputState . m . RLock ( ) _ , prev := theInputState . prevGamepadIDs [ id ] _ , current := theInputState . gamepadIDs [ id ] theInputState . m . RUnlock ( ) return prev && ! current }
7253	func ( l * logger ) Facilities ( ) ( enabled , disabled [ ] string ) { l . mut . Lock ( ) for facility , isEnabled := range l . debug { if isEnabled { enabled = append ( enabled , facility ) } else { disabled = append ( disabled , facility ) } } l . mut . Unlock ( ) return }
3260	func ( c * ConditionalFormat ) GetImageURLOk ( ) ( string , bool ) { if c == nil || c . ImageURL == nil { return "" , false } return * c . ImageURL , true }
6195	func ( h * Handler ) GetProductIncome ( tkn , productID string ) ( * uint , error ) { logger := h . logger . Add ( "method" , "GetProductIncome" , "productID" , productID ) return h . uintFromQuery ( logger , tkn , `SELECT SUM(channels.receipt_balance) FROM offerings JOIN channels ON channels.offering=offerings.id AND offerings.product=$1` , productID ) }
3894	func ( b * builder ) forStmt ( fn * Function , s * ast . ForStmt , label * lblock ) { if s . Init != nil { b . stmt ( fn , s . Init ) } body := fn . newBasicBlock ( "for.body" ) done := fn . newBasicBlock ( "for.done" ) loop := body if s . Cond != nil { loop = fn . newBasicBlock ( "for.loop" ) } cont := loop if s . Post != nil { cont = fn . newBasicBlock ( "for.post" ) } if label != nil { label . _break = done label . _continue = cont } emitJump ( fn , loop ) fn . currentBlock = loop if loop != body { b . cond ( fn , s . Cond , body , done ) fn . currentBlock = body } fn . targets = & targets { tail : fn . targets , _break : done , _continue : cont , } b . stmt ( fn , s . Body ) fn . targets = fn . targets . tail emitJump ( fn , cont ) if s . Post != nil { fn . currentBlock = cont b . stmt ( fn , s . Post ) emitJump ( fn , loop ) } fn . currentBlock = done }
5428	func ( m * Member ) Send ( val interface { } ) { m . group . in <- Message { sender : m , payload : val } }
4758	func ( pool * DeflatePool ) GetWriter ( dst io . Writer ) ( writer * flate . Writer ) { if w := pool . pool . Get ( ) ; w != nil { writer = w . ( * flate . Writer ) writer . Reset ( dst ) } else { writer , _ = flate . NewWriter ( dst , flate . BestCompression ) } return writer }
5581	func ( o * FindVmsByDeploymentParams ) WithDeployment ( deployment [ ] string ) * FindVmsByDeploymentParams { o . SetDeployment ( deployment ) return o }
1108	func indent ( spaces int , s string ) ( string , error ) { if spaces < 0 { return "" , fmt . Errorf ( "indent value must be a positive integer" ) } var output , prefix [ ] byte var sp bool var size int prefix = [ ] byte ( strings . Repeat ( " " , spaces ) ) sp = true for _ , c := range [ ] byte ( s ) { if sp && c != '\n' { output = append ( output , prefix ... ) size += spaces } output = append ( output , c ) sp = c == '\n' size ++ } return string ( output [ : size ] ) , nil }
4960	func Concat ( arrays ... [ ] byte ) [ ] byte { var result [ ] byte = arrays [ 0 ] for _ , arr := range arrays [ 1 : ] { result = append ( result , arr ... ) } return result }
4487	func ( d Date ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( time . Time ( d ) . Format ( RFC3339FullDate ) ) }
7232	func ( e * Entry ) SetMethodHandler ( method string , h * Route ) error { if e . GetHandler ( method ) != nil { return errors . New ( "Duplicate Route registration" ) } e . handlers [ method ] = h return nil }
4279	func GetThisCgroupDir ( subsystem string ) ( string , error ) { f , err := os . Open ( "/proc/self/cgroup" ) if err != nil { return "" , err } defer f . Close ( ) return ParseCgroupFile ( subsystem , f ) }
5403	func Getgroups ( ) [ ] int { user := GetUsername ( ) list := make ( [ ] int , 0 ) if g , err := LookupGroup ( user ) ; err == nil { list = append ( list , g . GID ) } groups , err := LookupInGroup ( G_MEMBER , user , - 1 ) if err != nil { if _ , ok := err . ( NoFoundError ) ; ! ok { panic ( err ) } } for _ , v := range groups { list = append ( list , v . GID ) } return list }
2019	func AppMeshFromACS ( proxyConfig * ecsacs . ProxyConfiguration ) ( * AppMesh , error ) { if * proxyConfig . Type != appMesh { return nil , fmt . Errorf ( "agent does not support proxy type other than app mesh" ) } return & AppMesh { ContainerName : aws . StringValue ( proxyConfig . ContainerName ) , IgnoredUID : aws . StringValue ( proxyConfig . Properties [ ignoredUID ] ) , IgnoredGID : aws . StringValue ( proxyConfig . Properties [ ignoredGID ] ) , ProxyIngressPort : aws . StringValue ( proxyConfig . Properties [ proxyIngressPort ] ) , ProxyEgressPort : aws . StringValue ( proxyConfig . Properties [ proxyEgressPort ] ) , AppPorts : buildAppPorts ( proxyConfig ) , EgressIgnoredIPs : buildEgressIgnoredIPs ( proxyConfig ) , EgressIgnoredPorts : buildEgressIgnoredPorts ( proxyConfig ) , } , nil }
5887	func PeekHeaderField ( buf [ ] byte , field string ) ( string , error ) { return peekField ( buf , field , tokenPositionHeader ) }
3194	func GetIntOk ( v * int ) ( int , bool ) { if v != nil { return * v , true } return 0 , false }
757	func ( d * dynProviderState ) commit ( client * dynect . Client ) error { errs := [ ] error { } for _ , zone := range d . zones ( client ) { if log . GetLevel ( ) >= log . DebugLevel { response := ZoneChangesResponse { } err := client . Do ( "GET" , fmt . Sprintf ( "ZoneChanges/%s/" , zone ) , nil , & response ) log . Debugf ( "Pending changes for zone %s: %+v" , zone , errorOrValue ( err , & response ) ) } h , err := os . Hostname ( ) if err != nil { h = "unknown-host" } notes := fmt . Sprintf ( "Change by external-dns@%s, DynAPI@%s, %s on %s" , d . AppVersion , d . DynVersion , time . Now ( ) . Format ( time . RFC3339 ) , h , ) zonePublish := ZonePublishRequest { Publish : true , Notes : notes , } response := ZonePublishResponse { } err = apiRetryLoop ( func ( ) error { return client . Do ( "PUT" , fmt . Sprintf ( "Zone/%s/" , zone ) , & zonePublish , & response ) } ) log . Infof ( "Committing changes for zone %s: %+v" , zone , errorOrValue ( err , & response ) ) } switch len ( errs ) { case 0 : return nil case 1 : return errs [ 0 ] default : return fmt . Errorf ( "Multiple errors committing: %+v" , errs ) } }
7033	func ( s * RemoteOperations ) GetRemoteFile ( ) ( rfile io . WriteCloser , err error ) { var sftpclient SFTPClient sftpclient , err = s . getClient ( ) if err == nil { rfile , err = SafeCreateSSH ( sftpclient , s . remotePath ) } return }
4308	func ( c * Client ) Me ( ) ( * User , error ) { user := & User { } err := c . request ( "GET" , "me" , user , nil , nil ) if err != nil { return nil , err } return user , nil }
6323	func ( r * Request ) FormValueOrDefault ( key string , def string ) string { val := r . FormValue ( key ) if val == "" { val = def } return val }
6555	func ( d * Data ) Close ( ) error { if d . dh == nil { return nil } if d . cbc > 0 { callbackDelete ( d . cbc ) } _ , err := C . gpgme_data_release ( d . dh ) d . dh = nil return err }
2692	func CreateVM ( client * govmomi . Client , fo * object . Folder , spec types . VirtualMachineConfigSpec , pool * object . ResourcePool , host * object . HostSystem , pod * object . StoragePod , ) ( * object . VirtualMachine , error ) { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return nil , err } if ! sdrsEnabled { return nil , fmt . Errorf ( "storage DRS is not enabled on datastore cluster %q" , pod . Name ( ) ) } log . Printf ( "[DEBUG] Creating virtual machine %q on datastore cluster %q" , fmt . Sprintf ( "%s/%s" , fo . InventoryPath , spec . Name ) , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Type : string ( types . StoragePlacementSpecPlacementTypeCreate ) , ResourcePool : types . NewReference ( pool . Reference ( ) ) , PodSelectionSpec : types . StorageDrsPodSelectionSpec { StoragePod : types . NewReference ( pod . Reference ( ) ) , InitialVmConfig : expandVMPodConfigForPlacement ( spec . DeviceChange , pod ) , } , ConfigSpec : & spec , Folder : types . NewReference ( fo . Reference ( ) ) , } if host != nil { sps . Host = types . NewReference ( host . Reference ( ) ) } placement , err := recommendSDRS ( client , sps , provider . DefaultAPITimeout ) if err != nil { return nil , err } if sps . ResourcePool != nil { vc , err := vappcontainer . FromID ( client , sps . ResourcePool . Reference ( ) . Value ) switch { case viapi . IsManagedObjectNotFoundError ( err ) : case err == nil : return createVAppVMFromSPS ( client , placement , spec , sps , vc ) default : return nil , err } } return applySDRS ( client , placement , provider . DefaultAPITimeout ) }
6424	func ( q * Queue ) IsEmpty ( ) bool { q . key . RLock ( ) defer q . key . RUnlock ( ) return q . underlyer == nil || q . underlyer . IsEmpty ( ) }
1568	func ( auth * ASMAuthData ) SetDockerAuthConfig ( dac types . AuthConfig ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . dockerAuthConfig = dac }
2271	func ( v * Range ) native ( ) * C . GtkRange { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRange ( p ) }
2856	func IsManagedObjectNotFoundError ( err error ) bool { if f , ok := vimSoapFault ( err ) ; ok { if _ , ok := f . ( types . ManagedObjectNotFound ) ; ok { return true } } return false }
5278	func ColumnUnmarshallerWithTimestamp ( format Format , timestampFormat string ) RecordUnmarshaller { return func ( text string ) ( pilosa . Record , error ) { var err error column := pilosa . Column { } parts := strings . Split ( text , "," ) if len ( parts ) < 2 { return nil , errors . New ( "Invalid CSV line" ) } hasRowKey := format == RowKeyColumnID || format == RowKeyColumnKey hasColumnKey := format == RowIDColumnKey || format == RowKeyColumnKey if hasRowKey { column . RowKey = parts [ 0 ] } else { column . RowID , err = strconv . ParseUint ( parts [ 0 ] , 10 , 64 ) if err != nil { return nil , errors . New ( "Invalid row ID" ) } } if hasColumnKey { column . ColumnKey = parts [ 1 ] } else { column . ColumnID , err = strconv . ParseUint ( parts [ 1 ] , 10 , 64 ) if err != nil { return nil , errors . New ( "Invalid column ID" ) } } timestamp := 0 if len ( parts ) == 3 { if timestampFormat == "" { timestamp , err = strconv . Atoi ( parts [ 2 ] ) if err != nil { return nil , err } } else { t , err := time . Parse ( timestampFormat , parts [ 2 ] ) if err != nil { return nil , err } timestamp = int ( t . Unix ( ) ) } } column . Timestamp = int64 ( timestamp ) return column , nil } }
7226	func ( logger * Logger ) Errorf ( format string , a ... interface { } ) { logger . log ( ERROR , format , a ... ) }
2110	func ackPublishMetricHandler ( timer * time . Timer ) func ( * ecstcs . AckPublishMetric ) { return func ( * ecstcs . AckPublishMetric ) { seelog . Debug ( "Received AckPublishMetric from tcs" ) timer . Reset ( retry . AddJitter ( defaultHeartbeatTimeout , defaultHeartbeatJitter ) ) } }
1523	func NewConfig ( ec2client ec2 . EC2MetadataClient ) ( * Config , error ) { var errs [ ] error envConfig , err := environmentConfig ( ) if err != nil { errs = append ( errs , err ) } config := & envConfig if config . complete ( ) { return config , nil } fcfg , err := fileConfig ( ) if err != nil { errs = append ( errs , err ) } config . Merge ( fcfg ) config . Merge ( userDataConfig ( ec2client ) ) if config . AWSRegion == "" { if config . NoIID { awsRegion , err := ec2client . Region ( ) if err != nil { errs = append ( errs , err ) } config . AWSRegion = awsRegion } else { config . Merge ( ec2MetadataConfig ( ec2client ) ) } } return config , config . mergeDefaultConfig ( errs ) }
3509	func ( s * SyntheticsAssertion ) GetOperatorOk ( ) ( string , bool ) { if s == nil || s . Operator == nil { return "" , false } return * s . Operator , true }
5137	func ( ui * ColorUI ) Error ( message string ) { ct . ChangeColor ( ui . ErrorFGColor . Code , ui . ErrorFGColor . Bright , ui . ErrorBGColor . Code , ui . ErrorBGColor . Bright ) ui . UI . Error ( message ) ct . ResetColor ( ) }
3966	func ( client * Client ) Subscribe ( topic string , fn interface { } , serverAddr , serverPath string ) { client . doSubscribe ( topic , fn , serverAddr , serverPath , Subscribe ) }
655	func ( sc * serviceSource ) endpoints ( svc * v1 . Service , nodeTargets endpoint . Targets ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint if ! sc . ignoreHostnameAnnotation { providerSpecific := getProviderSpecificAnnotations ( svc . Annotations ) hostnameList := getHostnamesFromAnnotations ( svc . Annotations ) for _ , hostname := range hostnameList { endpoints = append ( endpoints , sc . generateEndpoints ( svc , hostname , nodeTargets , providerSpecific ) ... ) } } return endpoints }
2642	func resourceVSphereComputeClusterImportSetDefaults ( d * schema . ResourceData ) error { s := resourceVSphereComputeCluster ( ) . Schema return structure . SetBatch ( d , map [ string ] interface { } { "ha_admission_control_performance_tolerance" : s [ "ha_admission_control_performance_tolerance" ] . Default , "ha_admission_control_resource_percentage_cpu" : s [ "ha_admission_control_resource_percentage_cpu" ] . Default , "ha_admission_control_resource_percentage_memory" : s [ "ha_admission_control_resource_percentage_memory" ] . Default , "ha_admission_control_slot_policy_explicit_cpu" : s [ "ha_admission_control_slot_policy_explicit_cpu" ] . Default , "ha_admission_control_slot_policy_explicit_memory" : s [ "ha_admission_control_slot_policy_explicit_memory" ] . Default , "host_cluster_exit_timeout" : s [ "host_cluster_exit_timeout" ] . Default , } ) }
1135	func ( c * cache ) ItemCount ( ) int { c . mu . RLock ( ) n := len ( c . items ) c . mu . RUnlock ( ) return n }
5837	func ( a * API ) DeleteDashboardByCID ( cid CIDType ) ( bool , error ) { if cid == nil || * cid == "" { return false , fmt . Errorf ( "Invalid dashboard CID [none]" ) } dashboardCID := string ( * cid ) matched , err := regexp . MatchString ( config . DashboardCIDRegex , dashboardCID ) if err != nil { return false , err } if ! matched { return false , fmt . Errorf ( "Invalid dashboard CID [%s]" , dashboardCID ) } _ , err = a . Delete ( dashboardCID ) if err != nil { return false , err } return true , nil }
1239	func New ( ctx context . Context , primaryMAC string , udevwrap udevwrapper . Udev , state dockerstate . TaskEngineState , stateChangeEvents chan <- statechange . Event ) * UdevWatcher { return newWatcher ( ctx , primaryMAC , netlinkwrapper . New ( ) , udevwrap , state , stateChangeEvents ) }
4598	func ( s * Stack ) less ( r * Stack ) bool { lStdlib := 0 lPrivate := 0 for _ , c := range s . Calls { if c . IsStdlib { lStdlib ++ } else { lPrivate ++ } } rStdlib := 0 rPrivate := 0 for _ , s := range r . Calls { if s . IsStdlib { rStdlib ++ } else { rPrivate ++ } } if lPrivate > rPrivate { return true } if lPrivate < rPrivate { return false } if lStdlib > rStdlib { return false } if lStdlib < rStdlib { return true } for x := range s . Calls { if s . Calls [ x ] . Func . Raw < r . Calls [ x ] . Func . Raw { return true } if s . Calls [ x ] . Func . Raw > r . Calls [ x ] . Func . Raw { return true } if s . Calls [ x ] . PkgSrc ( ) < r . Calls [ x ] . PkgSrc ( ) { return true } if s . Calls [ x ] . PkgSrc ( ) > r . Calls [ x ] . PkgSrc ( ) { return true } if s . Calls [ x ] . Line < r . Calls [ x ] . Line { return true } if s . Calls [ x ] . Line > r . Calls [ x ] . Line { return true } } return false }
5586	func ( as AgentSettings ) ConfigureNetworks ( networksSettings NetworksSettings ) AgentSettings { as . Networks = networksSettings return as }
2439	func NewScreenFramebufferImage ( width , height int ) * Image { i := & Image { image : graphicscommand . NewScreenFramebufferImage ( width , height ) , screen : true , } i . clear ( ) theImages . add ( i ) return i }
7078	func ( m * MACMaskArg ) MarshalBinary ( ) ( [ ] byte , error ) { if int ( m . DirCount ) != len ( m . Directives ) { return nil , ErrorBadArgumentParameter } b := make ( [ ] byte , macMaskArgLen + ( directiveLen * m . DirCount ) ) b [ 1 ] = uint8 ( m . Command ) b [ 2 ] = uint8 ( m . Error ) b [ 3 ] = m . DirCount n := 4 for _ , d := range m . Directives { db , err := d . MarshalBinary ( ) if err != nil { return nil , err } copy ( b [ n : n + directiveLen ] , db ) n += directiveLen } return b , nil }
6657	func ( r Ray ) IntersectRect ( b Rectangle ) bool { t1 := ( b . Min . X - r . o . X ) * r . invv . X t2 := ( b . Max . X - r . o . X ) * r . invv . X tmin := math . Min ( t1 , t2 ) tmax := math . Max ( t1 , t2 ) t1 = ( b . Min . X - r . o . X ) * r . invv . X t2 = ( b . Max . X - r . o . X ) * r . invv . X tmin = math . Max ( tmin , math . Min ( t1 , t2 ) ) tmax = math . Min ( tmax , math . Max ( t1 , t2 ) ) t1 = ( b . Min . Y - r . o . Y ) * r . invv . Y t2 = ( b . Max . Y - r . o . Y ) * r . invv . Y tmin = math . Max ( tmin , math . Min ( t1 , t2 ) ) tmax = math . Min ( tmax , math . Max ( t1 , t2 ) ) return tmax >= math . Max ( tmin , 0.0 ) }
2298	func ( v * ToolItem ) native ( ) * C . GtkToolItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToolItem ( p ) }
2873	func resourceVSphereComputeClusterVMGroupFetchObjects ( meta interface { } , clusterID string , name string , ) ( * object . ClusterComputeResource , string , error ) { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return nil , "" , err } cluster , err := clustercomputeresource . FromID ( client , clusterID ) if err != nil { return nil , "" , fmt . Errorf ( "cannot locate cluster: %s" , err ) } return cluster , name , nil }
488	func ( resp * Response ) WriteTo ( w io . Writer ) ( int64 , error ) { return writeBufio ( resp , w ) }
2747	func expandVMwareIpfixConfig ( d * schema . ResourceData ) * types . VMwareIpfixConfig { obj := & types . VMwareIpfixConfig { ActiveFlowTimeout : int32 ( d . Get ( "netflow_active_flow_timeout" ) . ( int ) ) , CollectorIpAddress : d . Get ( "netflow_collector_ip_address" ) . ( string ) , CollectorPort : int32 ( d . Get ( "netflow_collector_port" ) . ( int ) ) , IdleFlowTimeout : int32 ( d . Get ( "netflow_idle_flow_timeout" ) . ( int ) ) , InternalFlowsOnly : d . Get ( "netflow_internal_flows_only" ) . ( bool ) , ObservationDomainId : int64 ( d . Get ( "netflow_observation_domain_id" ) . ( int ) ) , SamplingRate : int32 ( d . Get ( "netflow_sampling_rate" ) . ( int ) ) , } return obj }
5122	func collectAnsiIntoWindowsAttributes ( windowsMode uint16 , inverted bool , baseMode uint16 , ansiMode int16 ) ( uint16 , bool ) { switch ansiMode { case ansiterm . ANSI_SGR_BOLD : windowsMode = windowsMode | FOREGROUND_INTENSITY case ansiterm . ANSI_SGR_DIM , ansiterm . ANSI_SGR_BOLD_DIM_OFF : windowsMode &^= FOREGROUND_INTENSITY case ansiterm . ANSI_SGR_UNDERLINE : windowsMode = windowsMode | COMMON_LVB_UNDERSCORE case ansiterm . ANSI_SGR_REVERSE : inverted = true case ansiterm . ANSI_SGR_REVERSE_OFF : inverted = false case ansiterm . ANSI_SGR_UNDERLINE_OFF : windowsMode &^= COMMON_LVB_UNDERSCORE case ansiterm . ANSI_SGR_FOREGROUND_DEFAULT : windowsMode = ( windowsMode &^ FOREGROUND_MASK ) | ( baseMode & FOREGROUND_MASK ) case ansiterm . ANSI_SGR_FOREGROUND_BLACK : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) case ansiterm . ANSI_SGR_FOREGROUND_RED : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_RED case ansiterm . ANSI_SGR_FOREGROUND_GREEN : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_GREEN case ansiterm . ANSI_SGR_FOREGROUND_YELLOW : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_RED | FOREGROUND_GREEN case ansiterm . ANSI_SGR_FOREGROUND_BLUE : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_BLUE case ansiterm . ANSI_SGR_FOREGROUND_MAGENTA : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_RED | FOREGROUND_BLUE case ansiterm . ANSI_SGR_FOREGROUND_CYAN : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_GREEN | FOREGROUND_BLUE case ansiterm . ANSI_SGR_FOREGROUND_WHITE : windowsMode = ( windowsMode &^ FOREGROUND_COLOR_MASK ) | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE case ansiterm . ANSI_SGR_BACKGROUND_DEFAULT : windowsMode = ( windowsMode &^ BACKGROUND_MASK ) | ( baseMode & BACKGROUND_MASK ) case ansiterm . ANSI_SGR_BACKGROUND_BLACK : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) case ansiterm . ANSI_SGR_BACKGROUND_RED : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_RED case ansiterm . ANSI_SGR_BACKGROUND_GREEN : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_GREEN case ansiterm . ANSI_SGR_BACKGROUND_YELLOW : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_RED | BACKGROUND_GREEN case ansiterm . ANSI_SGR_BACKGROUND_BLUE : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_BLUE case ansiterm . ANSI_SGR_BACKGROUND_MAGENTA : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_RED | BACKGROUND_BLUE case ansiterm . ANSI_SGR_BACKGROUND_CYAN : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_GREEN | BACKGROUND_BLUE case ansiterm . ANSI_SGR_BACKGROUND_WHITE : windowsMode = ( windowsMode &^ BACKGROUND_COLOR_MASK ) | BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE } return windowsMode , inverted }
7193	func ( r * Route ) UseHandler ( h Handler ) { if r . f == nil { r . f = h return } route := r . getLeaf ( ) route . next = & Route { f : h } }
49	func NewDiscovery ( conf * SDConfig , logger log . Logger ) ( * Discovery , error ) { if logger == nil { logger = log . NewNopLogger ( ) } tls , err := config_util . NewTLSConfig ( & conf . TLSConfig ) if err != nil { return nil , err } transport := & http . Transport { IdleConnTimeout : 5 * time . Duration ( conf . RefreshInterval ) , TLSClientConfig : tls , DialContext : conntrack . NewDialContextFunc ( conntrack . DialWithTracing ( ) , conntrack . DialWithName ( "consul_sd" ) , ) , } wrapper := & http . Client { Transport : transport , Timeout : 35 * time . Second , } clientConf := & consul . Config { Address : conf . Server , Scheme : conf . Scheme , Datacenter : conf . Datacenter , Token : string ( conf . Token ) , HttpAuth : & consul . HttpBasicAuth { Username : conf . Username , Password : string ( conf . Password ) , } , HttpClient : wrapper , } client , err := consul . NewClient ( clientConf ) if err != nil { return nil , err } cd := & Discovery { client : client , tagSeparator : conf . TagSeparator , watchedServices : conf . Services , watchedTags : conf . ServiceTags , watchedNodeMeta : conf . NodeMeta , allowStale : conf . AllowStale , refreshInterval : time . Duration ( conf . RefreshInterval ) , clientDatacenter : conf . Datacenter , finalizer : transport . CloseIdleConnections , logger : logger , } return cd , nil }
3014	func ( p RootPathParticle ) SplitDatacenter ( inventoryPath string ) ( string , error ) { s := strings . SplitN ( inventoryPath , p . Delimiter ( ) , 2 ) if len ( s ) != 2 { return inventoryPath , fmt . Errorf ( "could not split path %q on %q" , inventoryPath , p . Delimiter ( ) ) } return s [ 0 ] , nil }
6608	func ( address HardwareAddr ) Mask ( mask [ ] byte ) [ ] byte { n := len ( address ) if n != len ( mask ) { return nil } out := make ( [ ] byte , n ) for i := 0 ; i < n ; i ++ { out [ i ] = address [ i ] & mask [ i ] } return out }
2983	func ( r * Subresource ) findControllerInfo ( l object . VirtualDeviceList , disk * types . VirtualDisk ) ( int , types . BaseVirtualController , error ) { ctlr := l . FindByKey ( disk . ControllerKey ) if ctlr == nil { return - 1 , nil , fmt . Errorf ( "could not find disk controller with key %d for disk key %d" , disk . ControllerKey , disk . Key ) } if disk . UnitNumber == nil { return - 1 , nil , fmt . Errorf ( "unit number on disk key %d is unset" , disk . Key ) } sc , ok := ctlr . ( types . BaseVirtualSCSIController ) if ! ok { return - 1 , nil , fmt . Errorf ( "controller at key %d is not a SCSI controller (actual: %T)" , ctlr . GetVirtualDevice ( ) . Key , ctlr ) } unit := * disk . UnitNumber if unit > sc . GetVirtualSCSIController ( ) . ScsiCtlrUnitNumber { unit -- } unit = unit + 15 * sc . GetVirtualSCSIController ( ) . BusNumber return int ( unit ) , ctlr . ( types . BaseVirtualController ) , nil }
2237	func ( v * Container ) native ( ) * C . GtkContainer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkContainer ( p ) }
7105	func ToSSN ( theString , delimiter string ) ( string , error ) { f := New ( theString ) f . removeNonDigits ( ) if f . length != 9 { return "" , errors . New ( "string needs to be 9 digits for Social Security Numbers" ) } var buffer bytes . Buffer count := 0 for _ , i := range f . theString { count ++ buffer . WriteString ( string ( i ) ) if count == 3 || count == 5 { buffer . WriteString ( delimiter ) } } return buffer . String ( ) , nil }
4188	func ( c * RenameSpaceConfigurationCommand ) Execute ( args [ ] string ) error { c . initConfig ( ) spaceConfig , err := c . ConfigManager . GetSpaceConfig ( c . OrgName , c . SpaceName ) if err != nil { return err } spaces , err := c . ConfigManager . OrgSpaces ( c . OrgName ) if err != nil { return err } spaceConfig . Space = c . NewSpaceName spaceConfig . OriginalSpace = c . SpaceName err = c . ConfigManager . RenameSpaceConfig ( spaceConfig ) if err != nil { return err } spaces . Replace ( c . SpaceName , c . NewSpaceName ) err = c . ConfigManager . SaveOrgSpaces ( spaces ) if err != nil { return err } fmt . Println ( fmt . Sprintf ( "The org/space [%s/%s] has been renamed to [%s/%s]" , c . OrgName , c . SpaceName , c . OrgName , c . NewSpaceName ) ) return nil }
2077	func ( mr * MockGPUManagerMockRecorder ) SetDevices ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "SetDevices" , reflect . TypeOf ( ( * MockGPUManager ) ( nil ) . SetDevices ) ) }
7238	func ( e * Entry ) execPrefix ( method , urlStr string ) ( * Route , [ ] string ) { if ! strings . HasPrefix ( urlStr , e . pattern ) { return nil , nil } if len ( urlStr ) == len ( e . pattern ) { return e . GetHandler ( method ) , nil } return e . traverse ( method , urlStr [ len ( e . pattern ) : ] ) }
4736	func StringJoinFormat ( format string , values interface { } , sep string ) string { v := reflect . ValueOf ( values ) if v . Kind ( ) != reflect . Slice { panic ( "values is not a slice" ) } var buffer bytes . Buffer for i := 0 ; i < v . Len ( ) ; i ++ { if i > 0 { buffer . WriteString ( sep ) } buffer . WriteString ( fmt . Sprintf ( format , v . Index ( i ) . Interface ( ) ) ) } return buffer . String ( ) }
6128	func ( b * backendInstance ) EstimateGas ( ctx context . Context , call ethereum . CallMsg ) ( gas uint64 , err error ) { ctx2 , cancel := b . addTimeout ( ctx ) defer cancel ( ) gas , err = b . conn . ethClient ( ) . EstimateGas ( ctx2 , call ) if err != nil { return 0 , fmt . Errorf ( "failed to estimated gas: %s" , err ) } return gas , err }
4522	func GrepNot ( r string ) Filter { re , err := regexp . Compile ( r ) if err != nil { return FilterFunc ( func ( Arg ) error { return err } ) } return If ( func ( s string ) bool { return ! re . MatchString ( s ) } ) }
5925	func WriteIndented ( w io . Writer , b [ ] byte ) error { return WriteIndentedN ( w , b , 4 ) }
6181	func Run ( ctx context . Context , conf * Config , logger log . Logger , ports [ ] uint16 ) { if conf . Mechanism == "" { logger . Debug ( "traversal NAT is not needed." ) return } service , err := Parse ( conf ) if err != nil { logger . Error ( err . Error ( ) ) return } for k := range ports { service . DeleteMapping ( "tcp" , int ( ports [ k ] ) , int ( ports [ k ] ) ) name := fmt . Sprintf ( "service-%d" , k ) if err := Map ( ctx , conf , logger , service , "tcp" , int ( ports [ k ] ) , int ( ports [ k ] ) , name ) ; err != nil { msg := fmt . Sprintf ( "failed to add port" + " mapping to %d port" , ports [ k ] ) logger . Warn ( msg ) return } } extIP , err := ipify . GetIp ( ) if err != nil { logger . Warn ( "failed to determine" + " a external ip address, error: " + err . Error ( ) ) return } logger = logger . Add ( "externalIP" , extIP ) timeout := time . Duration ( conf . CheckTimeout ) * time . Millisecond checkSrv := func ( port uint16 ) { if util . CheckConnection ( "tcp" , extIP , int ( port ) , timeout ) { logger . Info ( fmt . Sprintf ( "port %d is available" + " on the Internet" , port ) ) return } logger . Warn ( fmt . Sprintf ( "port %d is not available" + " on the Internet" , port ) ) } for k := range ports { checkSrv ( ports [ k ] ) } }
546	func ( c * Cookie ) ParseBytes ( src [ ] byte ) error { c . Reset ( ) var s cookieScanner s . b = src kv := & c . bufKV if ! s . next ( kv ) { return errNoCookies } c . key = append ( c . key [ : 0 ] , kv . key ... ) c . value = append ( c . value [ : 0 ] , kv . value ... ) for s . next ( kv ) { if len ( kv . key ) != 0 { switch kv . key [ 0 ] | 0x20 { case 'm' : if caseInsensitiveCompare ( strCookieMaxAge , kv . key ) { maxAge , err := ParseUint ( kv . value ) if err != nil { return err } c . maxAge = maxAge } case 'e' : if caseInsensitiveCompare ( strCookieExpires , kv . key ) { v := b2s ( kv . value ) exptime , err := time . ParseInLocation ( time . RFC1123 , v , time . UTC ) if err != nil { exptime , err = time . Parse ( "Mon, 02-Jan-2006 15:04:05 MST" , v ) if err != nil { return err } } c . expire = exptime } case 'd' : if caseInsensitiveCompare ( strCookieDomain , kv . key ) { c . domain = append ( c . domain [ : 0 ] , kv . value ... ) } case 'p' : if caseInsensitiveCompare ( strCookiePath , kv . key ) { c . path = append ( c . path [ : 0 ] , kv . value ... ) } case 's' : if caseInsensitiveCompare ( strCookieSameSite , kv . key ) { switch kv . value [ 0 ] | 0x20 { case 'l' : if caseInsensitiveCompare ( strCookieSameSiteLax , kv . value ) { c . sameSite = CookieSameSiteLaxMode } case 's' : if caseInsensitiveCompare ( strCookieSameSiteStrict , kv . value ) { c . sameSite = CookieSameSiteStrictMode } } } } } else if len ( kv . value ) != 0 { switch kv . value [ 0 ] | 0x20 { case 'h' : if caseInsensitiveCompare ( strCookieHTTPOnly , kv . value ) { c . httpOnly = true } case 's' : if caseInsensitiveCompare ( strCookieSecure , kv . value ) { c . secure = true } else if caseInsensitiveCompare ( strCookieSameSite , kv . value ) { c . sameSite = CookieSameSiteDefaultMode } } } } return nil }
587	func ( mx * Mux ) routeHTTP ( w http . ResponseWriter , r * http . Request ) { rctx := r . Context ( ) . Value ( RouteCtxKey ) . ( * Context ) routePath := rctx . RoutePath if routePath == "" { if r . URL . RawPath != "" { routePath = r . URL . RawPath } else { routePath = r . URL . Path } } if rctx . RouteMethod == "" { rctx . RouteMethod = r . Method } method , ok := methodMap [ rctx . RouteMethod ] if ! ok { mx . MethodNotAllowedHandler ( ) . ServeHTTP ( w , r ) return } if _ , _ , h := mx . tree . FindRoute ( rctx , method , routePath ) ; h != nil { h . ServeHTTP ( w , r ) return } if rctx . methodNotAllowed { mx . MethodNotAllowedHandler ( ) . ServeHTTP ( w , r ) } else { mx . NotFoundHandler ( ) . ServeHTTP ( w , r ) } }
5364	func NewUser ( name string , gid int ) * User { loadConfig ( ) return & User { Name : name , Dir : path . Join ( config . useradd . HOME , name ) , Shell : config . useradd . SHELL , UID : - 1 , GID : gid , } }
2213	func SimpleActionNewStateful ( name string , parameterType * VariantType , state * Variant ) * SimpleAction { c := C . g_simple_action_new_stateful ( ( * C . gchar ) ( C . CString ( name ) ) , parameterType . native ( ) , state . native ( ) ) if c == nil { return nil } return wrapSimpleAction ( wrapObject ( unsafe . Pointer ( c ) ) ) }
5569	func ( o * OrderVMByFilterParams ) WithTimeout ( timeout time . Duration ) * OrderVMByFilterParams { o . SetTimeout ( timeout ) return o }
1823	func ( mtask * managedTask ) waitForHostResources ( ) { if mtask . StartSequenceNumber == 0 { return } if mtask . GetDesiredStatus ( ) . Terminal ( ) { return } seelog . Infof ( "Managed task [%s]: waiting for any previous stops to complete. Sequence number: %d" , mtask . Arn , mtask . StartSequenceNumber ) othersStoppedCtx , cancel := context . WithCancel ( mtask . ctx ) defer cancel ( ) go func ( ) { mtask . taskStopWG . Wait ( mtask . StartSequenceNumber ) cancel ( ) } ( ) for ! mtask . waitEvent ( othersStoppedCtx . Done ( ) ) { if mtask . GetDesiredStatus ( ) . Terminal ( ) { break } } seelog . Infof ( "Managed task [%s]: wait over; ready to move towards status: %s" , mtask . Arn , mtask . GetDesiredStatus ( ) . String ( ) ) }
6302	func ( di * dependencyInjector ) MustRegister ( constructorFunc interface { } ) { err := di . Register ( constructorFunc ) if err != nil { panic ( err ) } }
6449	func ( s * Severity ) set ( val Severity ) { atomic . StoreInt32 ( ( * int32 ) ( s ) , int32 ( val ) ) }
1854	func SetLevel ( logLevel string ) { parsedLevel , ok := levels [ strings . ToLower ( logLevel ) ] if ok { levelLock . Lock ( ) defer levelLock . Unlock ( ) level = parsedLevel reloadConfig ( ) } }
3000	func UpdateLabel ( ctx context . Context , m * license . Manager , licenseKey string , key string , val string ) error { req := types . UpdateLicenseLabel { This : m . Reference ( ) , LicenseKey : licenseKey , LabelKey : key , LabelValue : val , } _ , err := methods . UpdateLicenseLabel ( ctx , m . Client ( ) , & req ) return err }
4517	func ( s * SortFilter ) By ( less func ( a , b string ) bool ) * SortFilter { s . add ( func ( a , b string ) int { if less ( a , b ) { return - 1 } if less ( b , a ) { return + 1 } return 0 } ) return s }
6788	func Unmarshal ( data [ ] byte ) ( interface { } , error ) { var msg map [ string ] interface { } err := json . Unmarshal ( data , & msg ) if err != nil { log . Errorf ( "json.Unmarshal failed: %+v" , err ) return nil , err } return msg , nil }
6016	func ( t Typed ) StringMust ( key string ) string { s , exists := t . StringIf ( key ) if exists == false { panic ( "expected string value for " + key ) } return s }
4285	func SetFileLabel ( path string , fileLabel string ) error { if selinux . SelinuxEnabled ( ) && fileLabel != "" { return selinux . Setfilecon ( path , fileLabel ) } return nil }
583	func ( mx * Mux ) With ( middlewares ... func ( http . Handler ) http . Handler ) Router { if ! mx . inline && mx . handler == nil { mx . buildRouteHandler ( ) } var mws Middlewares if mx . inline { mws = make ( Middlewares , len ( mx . middlewares ) ) copy ( mws , mx . middlewares ) } mws = append ( mws , middlewares ... ) im := & Mux { pool : mx . pool , inline : true , parent : mx , tree : mx . tree , middlewares : mws } return im }
6710	func ( r GetAuthResult ) Extract ( ) ( * AuthResult , error ) { var s * AuthResult err := r . ExtractInto ( & s ) return s , err }
5627	func ( pk PrivKeyLedgerSecp256k1 ) Equals ( other PrivKey ) bool { if ledger , ok := other . ( * PrivKeyLedgerSecp256k1 ) ; ok { return pk . CachedPubKey . Equals ( ledger . CachedPubKey ) } return false }
4247	func NeighborsIntWithPrecision ( hash uint64 , bits uint ) [ ] uint64 { box := BoundingBoxIntWithPrecision ( hash , bits ) lat , lng := box . Center ( ) latDelta := box . MaxLat - box . MinLat lngDelta := box . MaxLng - box . MinLng return [ ] uint64 { EncodeIntWithPrecision ( lat + latDelta , lng , bits ) , EncodeIntWithPrecision ( lat + latDelta , lng + lngDelta , bits ) , EncodeIntWithPrecision ( lat , lng + lngDelta , bits ) , EncodeIntWithPrecision ( lat - latDelta , lng + lngDelta , bits ) , EncodeIntWithPrecision ( lat - latDelta , lng , bits ) , EncodeIntWithPrecision ( lat - latDelta , lng - lngDelta , bits ) , EncodeIntWithPrecision ( lat , lng - lngDelta , bits ) , EncodeIntWithPrecision ( lat + latDelta , lng - lngDelta , bits ) , } }
4385	func ISBN10Value ( v * strfmt . ISBN10 ) strfmt . ISBN10 { if v == nil { return strfmt . ISBN10 ( "" ) } return * v }
1939	func ( m * MockTaskEngineState ) ENIByMac ( arg0 string ) ( * eni . ENIAttachment , bool ) { ret := m . ctrl . Call ( m , "ENIByMac" , arg0 ) ret0 , _ := ret [ 0 ] . ( * eni . ENIAttachment ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 }
355	func QueryInstant ( url , query string , p printer ) int { config := api . Config { Address : url , } c , err := api . NewClient ( config ) if err != nil { fmt . Fprintln ( os . Stderr , "error creating API client:" , err ) return 1 } api := v1 . NewAPI ( c ) ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Minute ) val , err := api . Query ( ctx , query , time . Now ( ) ) cancel ( ) if err != nil { fmt . Fprintln ( os . Stderr , "query error:" , err ) return 1 } p . printValue ( val ) return 0 }
1375	func ( taskEvents * taskSendableEvents ) submitFirstEvent ( handler * TaskHandler , backoff retry . Backoff ) ( bool , error ) { seelog . Debug ( "TaskHandler: Acquiring lock for sending event..." ) taskEvents . lock . Lock ( ) defer taskEvents . lock . Unlock ( ) seelog . Debugf ( "TaskHandler: Acquired lock, processing event list: : %s" , taskEvents . toStringUnsafe ( ) ) if taskEvents . events . Len ( ) == 0 { seelog . Debug ( "TaskHandler: No events left; not retrying more" ) taskEvents . sending = false return true , nil } eventToSubmit := taskEvents . events . Front ( ) event := eventToSubmit . Value . ( * sendableEvent ) if event . containerShouldBeSent ( ) { if err := event . send ( sendContainerStatusToECS , setContainerChangeSent , "container" , handler . client , eventToSubmit , handler . stateSaver , backoff , taskEvents ) ; err != nil { return false , err } } else if event . taskShouldBeSent ( ) { if err := event . send ( sendTaskStatusToECS , setTaskChangeSent , "task" , handler . client , eventToSubmit , handler . stateSaver , backoff , taskEvents ) ; err != nil { handleInvalidParamException ( err , taskEvents . events , eventToSubmit ) return false , err } } else if event . taskAttachmentShouldBeSent ( ) { if err := event . send ( sendTaskStatusToECS , setTaskAttachmentSent , "task attachment" , handler . client , eventToSubmit , handler . stateSaver , backoff , taskEvents ) ; err != nil { handleInvalidParamException ( err , taskEvents . events , eventToSubmit ) return false , err } } else { seelog . Infof ( "TaskHandler: Not submitting redundant event; just removing: %s" , event . toString ( ) ) taskEvents . events . Remove ( eventToSubmit ) } if taskEvents . events . Len ( ) == 0 { seelog . Debug ( "TaskHandler: Removed the last element, no longer sending" ) taskEvents . sending = false return true , nil } return false , nil }
2248	func ( v * FileChooserWidget ) native ( ) * C . GtkFileChooserWidget { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooserWidget ( p ) }
2871	func flattenClusterVMGroup ( d * schema . ResourceData , meta interface { } , obj * types . ClusterVmGroup ) error { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return err } results , err := virtualmachine . UUIDsForManagedObjectReferences ( client , obj . Vm , ) if err != nil { return err } return structure . SetBatch ( d , map [ string ] interface { } { "virtual_machine_ids" : results . UUIDs ( ) , } ) }
846	func ( c * ComputeUtil ) addFirewallTag ( instance * raw . Instance ) error { log . Infof ( "Adding tag for the firewall rule" ) tags := instance . Tags for _ , tag := range tags . Items { if tag == firewallTargetTag { return nil } } tags . Items = append ( tags . Items , firewallTargetTag ) op , err := c . service . Instances . SetTags ( c . project , c . zone , instance . Name , tags ) . Do ( ) if err != nil { return err } return c . waitForRegionalOp ( op . Name ) }
2895	func enableDVSNetworkResourceManagement ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , enabled bool ) error { req := & types . EnableNetworkResourceManagement { This : dvs . Reference ( ) , Enable : enabled , } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) _ , err := methods . EnableNetworkResourceManagement ( ctx , client , req ) if err != nil { return err } return nil }
5703	func SetMessage ( lang , filePath string , appendFiles ... string ) error { return SetMessageWithDesc ( lang , lang , filePath , appendFiles ... ) }
1922	func ( m * MockFileSystem ) ReadAll ( arg0 io . Reader ) ( [ ] byte , error ) { ret := m . ctrl . Call ( m , "ReadAll" , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] byte ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1605	func ( m * MockSecretsManagerAPI ) PutResourcePolicyWithContext ( arg0 aws . Context , arg1 * secretsmanager . PutResourcePolicyInput , arg2 ... request . Option ) ( * secretsmanager . PutResourcePolicyOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "PutResourcePolicyWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3968	func ( service * ClientService ) PushEvent ( arg * ClientArg , reply * bool ) error { service . client . eventBus . Publish ( arg . Topic , arg . Args ... ) * reply = true return nil }
6349	func RegexPath ( reg * regexp . Regexp , h http . Handler ) http . Handler { if reg == nil { return h } return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { matches := reg . FindStringSubmatch ( r . URL . Path ) if len ( matches ) > 1 { r . URL . Path = matches [ 1 ] h . ServeHTTP ( w , r ) } else { http . NotFound ( w , r ) } } ) }
234	func ( m * Manager ) setJitterSeed ( labels labels . Labels ) error { h := fnv . New64a ( ) hostname , err := getFqdn ( ) if err != nil { return err } if _ , err := fmt . Fprintf ( h , "%s%s" , hostname , labels . String ( ) ) ; err != nil { return err } m . jitterSeed = h . Sum64 ( ) return nil }
6388	func ( iter Enumerator ) splitN ( operation Transform , n uint ) [ ] Enumerator { results , cast := make ( [ ] chan interface { } , n , n ) , make ( [ ] Enumerator , n , n ) for i := uint ( 0 ) ; i < n ; i ++ { results [ i ] = make ( chan interface { } ) cast [ i ] = results [ i ] } go func ( ) { for i := uint ( 0 ) ; i < n ; i ++ { go func ( addr uint ) { defer close ( results [ addr ] ) for { read , ok := <- iter if ! ok { return } results [ addr ] <- operation ( read ) } } ( i ) } } ( ) return cast }
510	func ( h * ResponseHeader ) Reset ( ) { h . disableNormalizing = false h . noDefaultContentType = false h . resetSkipNormalize ( ) }
7258	func randomSelect ( a [ ] int ) int { var tmpIndex int length := len ( a ) randBytes := make ( [ ] byte , length ) if _ , err := rand . Read ( randBytes ) ; err == nil { tmpIndex = int ( randBytes [ 0 ] ) % length } return a [ tmpIndex ] }
3114	func NewTemplateFileSystem ( opt RenderOptions , omitData bool ) TplFileSystem { fs := TplFileSystem { } fs . files = make ( [ ] TemplateFile , 0 , 10 ) dirs := make ( [ ] string , 0 , len ( opt . AppendDirectories ) + 1 ) for i := len ( opt . AppendDirectories ) - 1 ; i >= 0 ; i -- { dirs = append ( dirs , opt . AppendDirectories [ i ] ) } dirs = append ( dirs , opt . Directory ) var err error for i := range dirs { if ! com . IsExist ( dirs [ i ] ) { continue } dirs [ i ] , err = filepath . EvalSymlinks ( dirs [ i ] ) if err != nil { panic ( "EvalSymlinks(" + dirs [ i ] + "): " + err . Error ( ) ) } } lastDir := dirs [ len ( dirs ) - 1 ] if err = filepath . Walk ( lastDir , func ( path string , info os . FileInfo , err error ) error { r , err := filepath . Rel ( lastDir , path ) if err != nil { return err } ext := GetExt ( r ) for _ , extension := range opt . Extensions { if ext != extension { continue } var data [ ] byte if ! omitData { for i := range dirs { path = filepath . Join ( dirs [ i ] , r ) if ! com . IsFile ( path ) { continue } data , err = ioutil . ReadFile ( path ) if err != nil { return err } break } } name := filepath . ToSlash ( ( r [ 0 : len ( r ) - len ( ext ) ] ) ) fs . files = append ( fs . files , NewTplFile ( name , data , ext ) ) } return nil } ) ; err != nil { panic ( "NewTemplateFileSystem: " + err . Error ( ) ) } return fs }
5763	func ( m * CirconusMetrics ) Gauge ( metric string , val interface { } ) { m . SetGauge ( metric , val ) }
2678	func flattenClusterDrsConfigInfo ( d * schema . ResourceData , obj types . ClusterDrsConfigInfo ) error { err := structure . SetBatch ( d , map [ string ] interface { } { "drs_automation_level" : obj . DefaultVmBehavior , "drs_enabled" : obj . Enabled , "drs_enable_vm_overrides" : obj . EnableVmBehaviorOverrides , "drs_migration_threshold" : obj . VmotionRate , } ) if err != nil { return err } return flattenResourceVSphereComputeClusterDrsAdvancedOptions ( d , obj . Option ) }
1366	func NewTaskHandler ( ctx context . Context , stateManager statemanager . Saver , state dockerstate . TaskEngineState , client api . ECSClient ) * TaskHandler { taskHandler := & TaskHandler { ctx : ctx , tasksToEvents : make ( map [ string ] * taskSendableEvents ) , submitSemaphore : utils . NewSemaphore ( concurrentEventCalls ) , tasksToContainerStates : make ( map [ string ] [ ] api . ContainerStateChange ) , stateSaver : stateManager , state : state , client : client , minDrainEventsFrequency : minDrainEventsFrequency , maxDrainEventsFrequency : maxDrainEventsFrequency , } go taskHandler . startDrainEventsTicker ( ) return taskHandler }
1017	func respWithMetadata ( i interface { } ) ( interface { } , * ResponseMetadata , error ) { return i , & ResponseMetadata { LastContact : 0 , LastIndex : uint64 ( time . Now ( ) . Unix ( ) ) , } , nil }
2858	func IsAnyNotFoundError ( err error ) bool { switch { case IsManagedObjectNotFoundError ( err ) : fallthrough case isNotFoundError ( err ) : return true } return false }
5640	func addScalars ( a [ ] byte , b [ ] byte ) [ ] byte { aInt := new ( big . Int ) . SetBytes ( a ) bInt := new ( big . Int ) . SetBytes ( b ) sInt := new ( big . Int ) . Add ( aInt , bInt ) x := sInt . Mod ( sInt , btcec . S256 ( ) . N ) . Bytes ( ) x2 := [ 32 ] byte { } copy ( x2 [ 32 - len ( x ) : ] , x ) return x2 [ : ] }
5858	func ( a * API ) UpdateWorksheet ( cfg * Worksheet ) ( * Worksheet , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid worksheet config [nil]" ) } worksheetCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . WorksheetCIDRegex , worksheetCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid worksheet CID [%s]" , worksheetCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update worksheet, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( worksheetCID , jsonCfg ) if err != nil { return nil , err } worksheet := & Worksheet { } if err := json . Unmarshal ( result , worksheet ) ; err != nil { return nil , err } return worksheet , nil }
6996	func ( r * Router ) Request ( route string , handler func ( ctx * neptulon . ReqCtx ) error ) { r . routes [ route ] = handler }
3139	func ( c * Cache ) Add ( p * points . Points ) { s := c . settings . Load ( ) . ( * cacheSettings ) if s . xlog != nil { p . WriteTo ( s . xlog ) return } if s . tagsEnabled { var err error p . Metric , err = tags . Normalize ( p . Metric ) if err != nil { atomic . AddUint32 ( & c . stat . tagsNormalizeErrors , 1 ) return } } count := len ( p . Data ) if s . maxSize > 0 && c . Size ( ) > s . maxSize { atomic . AddUint32 ( & c . stat . overflowCnt , uint32 ( count ) ) return } shard := c . GetShard ( p . Metric ) shard . Lock ( ) if values , exists := shard . items [ p . Metric ] ; exists { values . Data = append ( values . Data , p . Data ... ) } else { shard . items [ p . Metric ] = p } shard . Unlock ( ) atomic . AddInt32 ( & c . stat . size , int32 ( count ) ) }
975	func NewCatalogDatacentersQuery ( ignoreFailing bool ) ( * CatalogDatacentersQuery , error ) { return & CatalogDatacentersQuery { ignoreFailing : ignoreFailing , stopCh : make ( chan struct { } , 1 ) , } , nil }
5006	func msb64 ( n uint64 ) int { if n <= 0 { return - 1 } var r , v uint if n >= 1 << 32 { r += 32 v = uint ( n >> 32 ) } else { v = uint ( n ) } if v >= 1 << 16 { r += 16 v >>= 16 } if v >= 1 << 8 { r += 8 v >>= 8 } if v >= 1 << 4 { r += 4 v >>= 4 } if v >= 1 << 2 { r += 2 v >>= 2 } r += v >> 1 return int ( r ) }
7215	func ( logger * Logger ) WaitForUnprocessedRecords ( ) { runtime . Gosched ( ) var ( diff uint64 diffPrev uint64 i uint8 ) for { diff = atomic . LoadUint64 ( & logger . countIn ) - atomic . LoadUint64 ( & logger . countOut ) if diff == diffPrev { i ++ } if i >= 100 { return } if diff > 0 { diffPrev = diff time . Sleep ( 10 * time . Millisecond ) } else { return } } }
4495	func ( f * defaultFormats ) GetType ( name string ) ( reflect . Type , bool ) { f . Lock ( ) defer f . Unlock ( ) nme := f . normalizeName ( name ) for _ , v := range f . data { if v . Name == nme { return v . Type , true } } return nil , false }
5987	func ( m * MeasuredReader ) BytesPer ( perPeriod time . Duration ) uint64 { return uint64 ( m . rate . Rate ( perPeriod ) ) }
436	func ( ctx * RequestCtx ) RemoteAddr ( ) net . Addr { if ctx . c == nil { return zeroTCPAddr } addr := ctx . c . RemoteAddr ( ) if addr == nil { return zeroTCPAddr } return addr }
1865	func ( secret * SSMSecretResource ) clearSSMSecretValue ( ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for key := range secret . secretData { delete ( secret . secretData , key ) } }
993	func ( s * Scratch ) mapSet ( k , mk string , v interface { } , o bool ) ( string , error ) { if _ , ok := s . values [ k ] ; ! ok { s . values [ k ] = make ( map [ string ] interface { } ) } typed , ok := s . values [ k ] . ( map [ string ] interface { } ) if ! ok { return "" , fmt . Errorf ( "%q is not a map" , k ) } if _ , ok := typed [ mk ] ; o || ! ok { typed [ mk ] = v } return "" , nil }
3829	func ParseBytes ( b [ ] byte ) ( UUID , error ) { var uuid UUID switch len ( b ) { case 36 : case 36 + 9 : if ! bytes . Equal ( bytes . ToLower ( b [ : 9 ] ) , [ ] byte ( "urn:uuid:" ) ) { return uuid , fmt . Errorf ( "invalid urn prefix: %q" , b [ : 9 ] ) } b = b [ 9 : ] case 36 + 2 : b = b [ 1 : ] case 32 : var ok bool for i := 0 ; i < 32 ; i += 2 { uuid [ i / 2 ] , ok = xtob ( b [ i ] , b [ i + 1 ] ) if ! ok { return uuid , errors . New ( "invalid UUID format" ) } } return uuid , nil default : return uuid , fmt . Errorf ( "invalid UUID length: %d" , len ( b ) ) } if b [ 8 ] != '-' || b [ 13 ] != '-' || b [ 18 ] != '-' || b [ 23 ] != '-' { return uuid , errors . New ( "invalid UUID format" ) } for i , x := range [ 16 ] int { 0 , 2 , 4 , 6 , 9 , 11 , 14 , 16 , 19 , 21 , 24 , 26 , 28 , 30 , 32 , 34 } { v , ok := xtob ( b [ x ] , b [ x + 1 ] ) if ! ok { return uuid , errors . New ( "invalid UUID format" ) } uuid [ i ] = v } return uuid , nil }
7320	func PublishNamedEvent ( pub Publisher , eventBody interface { } ) { name := reflect . TypeOf ( eventBody ) . Name ( ) pub . Publish ( name , eventBody ) }
1640	func NewMockBackoff ( ctrl * gomock . Controller ) * MockBackoff { mock := & MockBackoff { ctrl : ctrl } mock . recorder = & MockBackoffMockRecorder { mock } return mock }
3832	func Must ( uuid UUID , err error ) UUID { if err != nil { panic ( err ) } return uuid }
1701	func ValidateTaskENI ( acsenis [ ] * ecsacs . ElasticNetworkInterface ) error { if len ( acsenis ) != 1 { return errors . Errorf ( "eni message validation: more than one ENIs in the message(%d)" , len ( acsenis ) ) } else if len ( acsenis [ 0 ] . Ipv4Addresses ) != 1 { return errors . Errorf ( "eni message validation: more than one ipv4 addresses in the message(%d)" , len ( acsenis [ 0 ] . Ipv4Addresses ) ) } else if len ( acsenis [ 0 ] . Ipv6Addresses ) > 1 { return errors . Errorf ( "eni message validation: more than one ipv6 addresses in the message(%d)" , len ( acsenis [ 0 ] . Ipv6Addresses ) ) } if acsenis [ 0 ] . MacAddress == nil { return errors . Errorf ( "eni message validation: empty eni mac address in the message" ) } if acsenis [ 0 ] . Ec2Id == nil { return errors . Errorf ( "eni message validation: empty eni id in the message" ) } return nil }
5370	func LookupUser ( name string ) ( * User , error ) { entries , err := LookupInUser ( U_NAME , name , 1 ) if err != nil { return nil , err } return entries [ 0 ] , err }
2740	func processTagDiff ( client * tags . RestClient , d * schema . ResourceData , obj object . Reference ) error { log . Printf ( "[DEBUG] Processing tags for object %q" , obj . Reference ( ) . Value ) old , new := d . GetChange ( vSphereTagAttributeKey ) tdp := & tagDiffProcessor { client : client , subject : obj , oldTagIDs : structure . SliceInterfacesToStrings ( old . ( * schema . Set ) . List ( ) ) , newTagIDs : structure . SliceInterfacesToStrings ( new . ( * schema . Set ) . List ( ) ) , } if err := tdp . processDetachOperations ( ) ; err != nil { return fmt . Errorf ( "error detaching tags to object ID %q: %s" , obj . Reference ( ) . Value , err ) } if err := tdp . processAttachOperations ( ) ; err != nil { return fmt . Errorf ( "error attaching tags to object ID %q: %s" , obj . Reference ( ) . Value , err ) } return nil }
5967	func ( otp * HOTP ) URL ( label string ) string { secret := base32 . StdEncoding . EncodeToString ( otp . Key ) u := url . URL { } v := url . Values { } u . Scheme = "otpauth" u . Host = "hotp" u . Path = label v . Add ( "secret" , secret ) v . Add ( "counter" , fmt . Sprintf ( "%d" , otp . Counter ( ) ) ) u . RawQuery = v . Encode ( ) return u . String ( ) }
4029	func ( c * RadioGroup ) AddItem ( r * Radio ) { c . items = append ( c . items , r ) r . SetGroup ( c ) }
1164	func validRoleType ( roleType string ) bool { switch roleType { case credentials . ApplicationRoleType : return true case credentials . ExecutionRoleType : return true default : return false } }
2578	func ( r * NetworkInterfaceSubresource ) ValidateDiff ( ) error { log . Printf ( "[DEBUG] %s: Beginning diff validation" , r ) version := viapi . ParseVersionFromClient ( r . client ) if version . Older ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := r . restrictResourceAllocationSettings ( ) ; err != nil { return err } } log . Printf ( "[DEBUG] %s: Diff validation complete" , r ) return nil }
5890	func NewEllipticSigner ( alg Algorithm , curve elliptic . Curve ) func ( Store , crypto . Hash ) ( Signer , error ) { curveBitSize := curve . Params ( ) . BitSize keyLen := curveBitSize / 8 if curveBitSize % 8 > 0 { keyLen ++ } return func ( store Store , hash crypto . Hash ) ( Signer , error ) { var ok bool var privRaw , pubRaw interface { } var priv * ecdsa . PrivateKey var pub * ecdsa . PublicKey if privRaw , ok = store . PrivateKey ( ) ; ok { if priv , ok = privRaw . ( * ecdsa . PrivateKey ) ; ! ok { return nil , ErrInvalidPrivateKey } if curveBitSize != priv . Curve . Params ( ) . BitSize { return nil , ErrInvalidPrivateKeySize } } if pubRaw , ok = store . PublicKey ( ) ; ok { if pub , ok = pubRaw . ( * ecdsa . PublicKey ) ; ! ok { return nil , ErrInvalidPublicKey } } if priv == nil && pub == nil { return nil , ErrMissingPrivateOrPublicKey } return & EccSigner { alg : alg , curve : curve , hash : hash , priv : priv , pub : pub , keyLen : keyLen , } , nil } }
4693	func newHelperMethodCSS ( ln * line , rslt * result , src * source , parent element , opts * Options ) * helperMethodCSS { return & helperMethodCSS { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , } }
778	func ( in * DNSEndpointSpec ) DeepCopy ( ) * DNSEndpointSpec { if in == nil { return nil } out := new ( DNSEndpointSpec ) in . DeepCopyInto ( out ) return out }
760	func remapEnv ( mapping map [ string ] string ) { for k , v := range mapping { currentVal := os . Getenv ( k ) newVal := os . Getenv ( v ) if currentVal == "" && newVal != "" { os . Setenv ( k , newVal ) } } }
1749	func ( task * Task ) SetStopSequenceNumber ( seqnum int64 ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . StopSequenceNumber = seqnum }
5258	func ( c * Client ) ExperimentalReplayImport ( r io . Reader , concurrency int ) error { span := c . tracer . StartSpan ( "Client.ExperimentalReplayImport" ) defer span . Finish ( ) work := make ( chan * importLog , concurrency * 2 ) eg := & errgroup . Group { } for i := 0 ; i < concurrency ; i ++ { eg . Go ( func ( ) error { for log := range work { nodes , err := c . fetchFragmentNodes ( log . Index , log . Shard ) if err != nil { return errors . Wrap ( err , "fetching fragment nodes" ) } if ! log . IsRoaring { for _ , node := range nodes { resp , err := c . doRequest ( node . URI ( ) , "POST" , log . Path , defaultProtobufHeaders ( ) , bytes . NewReader ( log . Data ) ) if err = anyError ( resp , err ) ; err != nil { return errors . Wrap ( err , "doing import" ) } resp . Body . Close ( ) } } else { resp , err := c . doRequest ( nodes [ 0 ] . URI ( ) , "POST" , log . Path , defaultProtobufHeaders ( ) , bytes . NewReader ( log . Data ) ) if err = anyError ( resp , err ) ; err != nil { return errors . Wrap ( err , "doing import" ) } resp . Body . Close ( ) } } return nil } ) } waitErrCh := make ( chan error ) go func ( ) { waitErrCh <- eg . Wait ( ) close ( waitErrCh ) } ( ) dec := newImportLogDecoder ( r ) var err error for { log := importLog { } err = dec . Decode ( & log ) if err != nil { err = errors . Wrap ( err , "decoding" ) break } select { case work <- & log : continue case err = <- waitErrCh : err = errors . Wrap ( err , "waiting" ) } break } close ( work ) <- waitErrCh if errors . Cause ( err ) == io . EOF { return nil } return err }
4260	func finalizeNamespace ( config * initConfig ) error { if err := utils . CloseExecFrom ( config . PassedFilesCount + 3 ) ; err != nil { return err } capabilities := config . Config . Capabilities if config . Capabilities != nil { capabilities = config . Capabilities } w , err := newCapWhitelist ( capabilities ) if err != nil { return err } if err := w . dropBoundingSet ( ) ; err != nil { return err } if err := system . SetKeepCaps ( ) ; err != nil { return err } if err := setupUser ( config ) ; err != nil { return err } if err := system . ClearKeepCaps ( ) ; err != nil { return err } if err := w . drop ( ) ; err != nil { return err } if config . Cwd != "" { if err := syscall . Chdir ( config . Cwd ) ; err != nil { return err } } return nil }
4784	func LoadWithEnvBytes ( conf interface { } , src [ ] byte ) error { return loadConfigBytes ( conf , src , envReplacer , yaml . Unmarshal ) }
1188	func RemoveFromTaskArray ( arr [ ] * Task , ndx int ) [ ] * Task { if ndx < 0 || ndx >= len ( arr ) { return arr } return append ( arr [ 0 : ndx ] , arr [ ndx + 1 : ] ... ) }
1489	func ( c * Container ) GetHealthStatus ( ) HealthStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) copyHealth := c . Health if c . Health . Since != nil { copyHealth . Since = aws . Time ( aws . TimeValue ( c . Health . Since ) ) } return copyHealth }
959	func ( c * TemplateConfig ) Display ( ) string { if c == nil { return "" } source := c . Source if StringPresent ( c . Contents ) { source = String ( "(dynamic)" ) } return fmt . Sprintf ( "%q => %q" , StringVal ( source ) , StringVal ( c . Destination ) , ) }
2355	func NewBoard ( size int ) ( * Board , error ) { b := & Board { size : size , tiles : map [ * Tile ] struct { } { } , } for i := 0 ; i < 2 ; i ++ { if err := addRandomTile ( b . tiles , b . size ) ; err != nil { return nil , err } } return b , nil }
90	func ( te Expander ) ExpandHTML ( templateFiles [ ] string ) ( result string , resultErr error ) { defer func ( ) { if r := recover ( ) ; r != nil { var ok bool resultErr , ok = r . ( error ) if ! ok { resultErr = errors . Errorf ( "panic expanding template %s: %v" , te . name , r ) } } } ( ) tmpl := html_template . New ( te . name ) . Funcs ( html_template . FuncMap ( te . funcMap ) ) tmpl . Option ( "missingkey=zero" ) tmpl . Funcs ( html_template . FuncMap { "tmpl" : func ( name string , data interface { } ) ( html_template . HTML , error ) { var buffer bytes . Buffer err := tmpl . ExecuteTemplate ( & buffer , name , data ) return html_template . HTML ( buffer . String ( ) ) , err } , } ) tmpl , err := tmpl . Parse ( te . text ) if err != nil { return "" , errors . Wrapf ( err , "error parsing template %v" , te . name ) } if len ( templateFiles ) > 0 { _ , err = tmpl . ParseFiles ( templateFiles ... ) if err != nil { return "" , errors . Wrapf ( err , "error parsing template files for %v" , te . name ) } } var buffer bytes . Buffer err = tmpl . Execute ( & buffer , te . data ) if err != nil { return "" , errors . Wrapf ( err , "error executing template %v" , te . name ) } return buffer . String ( ) , nil }
2563	func virtualSwitchIDsFromResourceID ( d * schema . ResourceData ) ( string , string , error ) { return splitHostVirtualSwitchID ( d . Id ( ) ) }
1287	func ( cgroup * CgroupResource ) MarshalJSON ( ) ( [ ] byte , error ) { if cgroup == nil { return nil , errors . New ( "cgroup resource is nil" ) } return json . Marshal ( cgroupResourceJSON { cgroup . cgroupRoot , cgroup . cgroupMountPath , cgroup . GetCreatedAt ( ) , func ( ) * CgroupStatus { desiredState := cgroup . GetDesiredStatus ( ) status := CgroupStatus ( desiredState ) return & status } ( ) , func ( ) * CgroupStatus { knownState := cgroup . GetKnownStatus ( ) status := CgroupStatus ( knownState ) return & status } ( ) , cgroup . resourceSpec , } ) }
6281	func ( s * Server ) ParseRequest ( logger log . Logger , w http . ResponseWriter , r * http . Request , args interface { } ) bool { var req Request if err := json . NewDecoder ( r . Body ) . Decode ( & req ) ; err != nil { logger . Warn ( "failed to parse request: " + err . Error ( ) ) s . RespondError ( logger , w , ErrFailedToParseRequest ) return false } r . Body . Close ( ) if err := json . Unmarshal ( req . Args , args ) ; err != nil { logger . Add ( "arguments" , req . Args ) . Warn ( "failed to parse request arguments: " + err . Error ( ) ) s . RespondError ( logger , w , ErrFailedToParseRequest ) return false } return true }
5759	func ( a * API ) FetchCheckBundles ( ) ( * [ ] CheckBundle , error ) { result , err := a . Get ( config . CheckBundlePrefix ) if err != nil { return nil , err } var checkBundles [ ] CheckBundle if err := json . Unmarshal ( result , & checkBundles ) ; err != nil { return nil , err } return & checkBundles , nil }
1421	func ( client * APIECSClient ) RegisterContainerInstance ( containerInstanceArn string , attributes [ ] * ecs . Attribute , tags [ ] * ecs . Tag , registrationToken string , platformDevices [ ] * ecs . PlatformDevice ) ( string , string , error ) { clusterRef := client . config . Cluster if clusterRef == "" { clusterRef = config . DefaultClusterName defer func ( ) { client . config . Cluster = clusterRef } ( ) containerInstanceArn , availabilityzone , err := client . registerContainerInstance ( clusterRef , containerInstanceArn , attributes , tags , registrationToken , platformDevices ) if err == nil { return containerInstanceArn , availabilityzone , nil } if apierrors . IsClusterNotFoundError ( err ) { clusterRef , err = client . CreateCluster ( clusterRef ) if err != nil { return "" , "" , err } } } return client . registerContainerInstance ( clusterRef , containerInstanceArn , attributes , tags , registrationToken , platformDevices ) }
446	func ( s * Server ) ListenAndServe ( addr string ) error { ln , err := net . Listen ( "tcp4" , addr ) if err != nil { return err } if s . TCPKeepalive { if tcpln , ok := ln . ( * net . TCPListener ) ; ok { return s . Serve ( tcpKeepaliveListener { TCPListener : tcpln , keepalivePeriod : s . TCPKeepalivePeriod , } ) } } return s . Serve ( ln ) }
2266	func ( v * Overlay ) native ( ) * C . GtkOverlay { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkOverlay ( p ) }
5491	func ( ipn * IncomingNumberService ) Get ( ctx context . Context , sid string ) ( * IncomingPhoneNumber , error ) { number := new ( IncomingPhoneNumber ) err := ipn . client . GetResource ( ctx , numbersPathPart , sid , number ) return number , err }
1231	func ( client * cniClient ) add ( runtimeConfig libcni . RuntimeConf , cfg * Config , pluginConfigFunc func ( * Config ) ( string , * libcni . NetworkConfig , error ) ) ( cnitypes . Result , error ) { deviceName , networkConfig , err := pluginConfigFunc ( cfg ) if err != nil { return nil , err } runtimeConfig . IfName = deviceName return client . libcni . AddNetwork ( networkConfig , & runtimeConfig ) }
1444	func ( state * DockerTaskEngineState ) RemoveTask ( task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) task , ok := state . tasks [ task . Arn ] if ! ok { seelog . Warnf ( "Failed to locate task %s for removal from state" , task . Arn ) return } delete ( state . tasks , task . Arn ) if ip , ok := state . taskToIPUnsafe ( task . Arn ) ; ok { delete ( state . ipToTask , ip ) } containerMap , ok := state . taskToID [ task . Arn ] if ! ok { seelog . Warnf ( "Failed to locate containerMap for task %s for removal from state" , task . Arn ) return } delete ( state . taskToID , task . Arn ) for _ , dockerContainer := range containerMap { state . removeIDToContainerTaskUnsafe ( dockerContainer ) state . removeV3EndpointIDToTaskContainerUnsafe ( dockerContainer . Container . V3EndpointID ) } }
4690	func findIncludes ( data [ ] byte , opts * Options , includes * [ ] * File , targetFile * File ) error { includePaths , err := findIncludePaths ( data , opts , targetFile ) if err != nil { return err } for _ , includePath := range includePaths { if ! hasFile ( * includes , includePath ) { f , err := readFile ( includePath , opts ) if err != nil { return err } * includes = append ( * includes , f ) if err := findIncludes ( f . data , opts , includes , f ) ; err != nil { return err } } } return nil }
6395	func Where ( original Enumerable , p Predicate ) Enumerable { return wherer { original : original , filter : p , } }
5467	func ( m * MessageService ) SendMessage ( from string , to string , body string , mediaURLs [ ] * url . URL ) ( * Message , error ) { v := url . Values { "Body" : [ ] string { body } , "From" : [ ] string { from } , "To" : [ ] string { to } , } if mediaURLs != nil { for _ , mediaURL := range mediaURLs { v . Add ( "MediaUrl" , mediaURL . String ( ) ) } } return m . Create ( context . Background ( ) , v ) }
5002	func ( d * Dataset ) Rollback ( destroyMoreRecent bool ) error { if d . Type != DatasetSnapshot { return errors . New ( "can only rollback snapshots" ) } args := make ( [ ] string , 1 , 3 ) args [ 0 ] = "rollback" if destroyMoreRecent { args = append ( args , "-r" ) } args = append ( args , d . Name ) _ , err := zfs ( args ... ) return err }
6033	func ( h * Handler ) ObjectChange ( ctx context . Context , tkn , objectType string , objectIDs [ ] string ) ( * rpc . Subscription , error ) { logger := h . logger . Add ( "method" , "ObjectChange" , "objectType" , objectType , "objectIDs" , objectIDs ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } table , ok := objectChangeTables [ objectType ] if ! ok { logger . Warn ( ErrBadObjectType . Error ( ) ) return nil , ErrBadObjectType } ntf , ok := rpc . NotifierFromContext ( ctx ) if ! ok { logger . Error ( "no notifier found in context" ) return nil , ErrInternal } sub := ntf . CreateSubscription ( ) cb := func ( job * data . Job , result error ) { obj , err := h . db . FindByPrimaryKeyFrom ( table , job . RelatedID ) if err != nil { logger . Error ( err . Error ( ) ) } var odata json . RawMessage if obj != nil { odata , err = json . Marshal ( obj ) if err != nil { logger . Error ( err . Error ( ) ) } } err = ntf . Notify ( sub . ID , & ObjectChangeResult { odata , job , rpcsrv . ToError ( result ) } ) if err != nil { logger . Warn ( err . Error ( ) ) } } sid := string ( sub . ID ) err := h . queue . Subscribe ( objectIDs , sid , cb ) if err != nil { logger . Error ( err . Error ( ) ) return nil , ErrInternal } go func ( ) { for err , ok := <- sub . Err ( ) ; ok ; { if err != nil { logger . Warn ( err . Error ( ) ) } } err := h . queue . Unsubscribe ( objectIDs , sid ) if err != nil { logger . Error ( err . Error ( ) ) } } ( ) return sub , nil }
2790	func saveHostPortGroupID ( d * schema . ResourceData , hsID , name string ) { d . SetId ( fmt . Sprintf ( "%s:%s:%s" , hostPortGroupIDPrefix , hsID , name ) ) }
2329	func ( v * Source ) native ( ) * C . GSource { if v == nil { return nil } return ( * C . GSource ) ( v ) }
286	func ( p * PromParser ) Type ( ) ( [ ] byte , MetricType ) { return p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] , p . mtype }
4002	func failResult ( format string , args ... interface { } ) * LintResult { return & LintResult { Status : Error , Details : fmt . Sprintf ( format , args ... ) , } }
6851	func ( c * cachedLoader ) Get ( key string ) ( [ ] byte , error ) { c . cacheLock . RLock ( ) defer c . cacheLock . RUnlock ( ) compiledKey := c . namespace + divider + key if ret , ok := c . cache [ compiledKey ] ; ok { return ret , nil } return nil , fmt . Errorf ( "Could not find value for key: %s" , compiledKey ) }
5249	func ( c * Client ) DeleteField ( field * Field ) error { span := c . tracer . StartSpan ( "Client.DeleteField" ) defer span . Finish ( ) path := fmt . Sprintf ( "/index/%s/field/%s" , field . index . name , field . name ) _ , _ , err := c . httpRequest ( "DELETE" , path , nil , nil , false ) return err }
47	func ( c * GlobalConfig ) isZero ( ) bool { return c . ExternalLabels == nil && c . ScrapeInterval == 0 && c . ScrapeTimeout == 0 && c . EvaluationInterval == 0 }
6715	func ( c * Client ) Image ( identifier string ) ( * Image , error ) { image := new ( Image ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/images/" + identifier , nil , image ) if err != nil { return nil , err } return image , err }
4859	func GenSnowflake ( u * URL ) ( string , error ) { host , port , dbname := hostname ( u . Host ) , hostport ( u . Host ) , strings . TrimPrefix ( u . Path , "/" ) if host == "" { return "" , ErrMissingHost } if dbname == "" { return "" , ErrMissingPath } if port != "" { port = ":" + port } var user string if u . User != nil { user = u . User . Username ( ) if pass , _ := u . User . Password ( ) ; pass != "" { user += ":" + pass } user += "@" } return user + host + port + "/" + dbname + genQueryOptions ( u . Query ( ) ) , nil }
4128	func MustSet ( key string , value string ) error { gil . Lock ( ) defer gil . Unlock ( ) err := os . Setenv ( key , value ) if err != nil { return err } env [ key ] = value return nil }
1147	func NewMockImageManager ( ctrl * gomock . Controller ) * MockImageManager { mock := & MockImageManager { ctrl : ctrl } mock . recorder = & MockImageManagerMockRecorder { mock } return mock }
3595	func ( t * TileDefRequest ) GetQueryType ( ) string { if t == nil || t . QueryType == nil { return "" } return * t . QueryType }
3391	func ( m * MetricMetadata ) HasShortName ( ) bool { if m != nil && m . ShortName != nil { return true } return false }
5386	func ( i * info ) OwnerHas ( p ... perm ) bool { mode := i . fi . Mode ( ) for _ , v := range p { switch v { case R : if mode & modeROwner == 0 { return false } case W : if mode & modeWOwner == 0 { return false } case X : if mode & modeXOwner == 0 { return false } } } return true }
5953	func ( s Scan ) SetHosts ( hosts ... string ) Scan { s . configHosts = hosts return s }
6236	func ( s * Service ) EndpointMessage ( channelID string ) ( * Message , error ) { c := make ( chan * result ) done := make ( chan bool ) req := & req { channelID : channelID , callback : c , done : done } go s . processing ( req ) select { case result := <- c : return result . msg , result . err case <- time . After ( s . timeout ) : close ( done ) return nil , ErrTimeOut } }
4757	func HTTPUnmarshalRequestBodyJSON ( request * http . Request , result interface { } ) error { defer request . Body . Close ( ) body , err := ioutil . ReadAll ( request . Body ) if err != nil { return err } return json . Unmarshal ( body , result ) }
699	func NewGoogleProvider ( project string , domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , dryRun bool ) ( * GoogleProvider , error ) { gcloud , err := google . DefaultClient ( context . TODO ( ) , dns . NdevClouddnsReadwriteScope ) if err != nil { return nil , err } gcloud = instrumented_http . NewClient ( gcloud , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , "/" ) return parts [ len ( parts ) - 1 ] } , } ) dnsClient , err := dns . New ( gcloud ) if err != nil { return nil , err } if project == "" { mProject , mErr := metadata . ProjectID ( ) if mErr == nil { log . Infof ( "Google project auto-detected: %s" , mProject ) project = mProject } } provider := & GoogleProvider { project : project , dryRun : dryRun , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , resourceRecordSetsClient : resourceRecordSetsService { dnsClient . ResourceRecordSets } , managedZonesClient : managedZonesService { dnsClient . ManagedZones } , changesClient : changesService { dnsClient . Changes } , } return provider , nil }
3012	func ( p RootPathParticle ) RootFromDatacenter ( dc * object . Datacenter ) string { return dc . InventoryPath + "/" + string ( p ) }
6740	func FuzzConnAfter ( conn net . Conn , d time . Duration ) net . Conn { return FuzzConnAfterFromConfig ( conn , d , DefaultFuzzConnConfig ( ) ) }
3184	func ( client * Client ) CreateRelatedComment ( handle , message string , relid int ) ( * Comment , error ) { var out reqComment comment := Comment { Message : String ( message ) , RelatedId : Int ( relid ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } if err := client . doJsonRequest ( "POST" , "/v1/comments" , & comment , & out ) ; err != nil { return nil , err } return out . Comment , nil }
6914	func ( s * Session ) CreateChild ( parent Identifiable , child Identifiable ) * Error { url , berr := s . getURLForChildrenIdentity ( parent , child . Identity ( ) ) if berr != nil { return berr } buffer := & bytes . Buffer { } if err := json . NewEncoder ( buffer ) . Encode ( child ) ; err != nil { return NewBambouError ( "JSON error" , err . Error ( ) ) } request , err := http . NewRequest ( "POST" , url , buffer ) if err != nil { return NewBambouError ( "HTTP transaction error" , err . Error ( ) ) } response , berr := s . send ( request , nil ) if berr != nil { return berr } defer response . Body . Close ( ) body , _ := ioutil . ReadAll ( response . Body ) log . Debugf ( "Response Body: %s" , string ( body ) ) dest := IdentifiablesList { child } if err := json . Unmarshal ( body , & dest ) ; err != nil { return NewBambouError ( "JSON Unmarshaling error" , err . Error ( ) ) } return nil }
5032	func ( s * Session ) SetSyncTimeout ( d time . Duration ) { s . m . Lock ( ) s . syncTimeout = d s . m . Unlock ( ) }
4591	func ( c * Call ) similar ( r * Call , similar Similarity ) bool { return c . SrcPath == r . SrcPath && c . Line == r . Line && c . Func == r . Func && c . Args . similar ( & r . Args , similar ) }
793	func NewOCIProvider ( cfg OCIConfig , domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , dryRun bool ) ( * OCIProvider , error ) { var client ociDNSClient client , err := dns . NewDnsClientWithConfigurationProvider ( common . NewRawConfigurationProvider ( cfg . Auth . TenancyID , cfg . Auth . UserID , cfg . Auth . Region , cfg . Auth . Fingerprint , cfg . Auth . PrivateKey , & cfg . Auth . Passphrase , ) ) if err != nil { return nil , errors . Wrap ( err , "initialising OCI DNS API client" ) } return & OCIProvider { client : client , cfg : cfg , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , dryRun : dryRun , } , nil }
116	func RegisterAdminHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterAdminHandlerClient ( ctx , mux , NewAdminClient ( conn ) ) }
2978	func ( r * DiskSubresource ) Relocate ( l object . VirtualDeviceList , clone bool ) ( types . VirtualMachineRelocateSpecDiskLocator , error ) { log . Printf ( "[DEBUG] %s: Starting relocate generation" , r ) disk , err := r . findVirtualDisk ( l , clone ) var relocate types . VirtualMachineRelocateSpecDiskLocator if err != nil { return relocate , fmt . Errorf ( "cannot find disk device: %s" , err ) } if err := r . expandDiskSettings ( disk ) ; err != nil { return relocate , err } relocate . DiskId = disk . Key dsID := r . Get ( "datastore_id" ) . ( string ) if dsID == "" { dsID = r . rdd . Get ( "datastore_id" ) . ( string ) } ds , err := datastore . FromID ( r . client , dsID ) if err != nil { return relocate , err } dsref := ds . Reference ( ) relocate . Datastore = dsref if r . rdd . Id ( ) == "" { log . Printf ( "[DEBUG] %s: Adding additional options to relocator for cloning" , r ) backing := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) backing . FileName = ds . Path ( "" ) backing . Datastore = & dsref relocate . DiskBackingInfo = backing } log . Printf ( "[DEBUG] %s: Generated disk locator: %s" , r , diskRelocateString ( relocate ) ) log . Printf ( "[DEBUG] %s: Relocate generation complete" , r ) return relocate , nil }
5718	func ( c * Client ) Close ( ) error { c . mu . Lock ( ) defer c . mu . Unlock ( ) c . closeIdleConns ( ) c . freeconn = nil c . maxIdlePerAddr = 0 return nil }
4342	func BuildQwerty ( ) Graph { data , err := data . Asset ( "data/Qwerty.json" ) if err != nil { panic ( "Can't find asset" ) } return getAdjancencyGraphFromFile ( data , "qwerty" ) }
2957	func expandStorageDrsOptionSpec ( d * schema . ResourceData ) [ ] types . StorageDrsOptionSpec { var opts [ ] types . StorageDrsOptionSpec m := d . Get ( "sdrs_advanced_options" ) . ( map [ string ] interface { } ) for k , v := range m { opts = append ( opts , types . StorageDrsOptionSpec { Option : & types . OptionValue { Key : k , Value : types . AnyType ( v ) , } , } ) } return opts }
183	func ( r * AlertingRule ) Health ( ) RuleHealth { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . health }
4159	func ( c * Client ) Say ( channel , text string ) { channel = strings . ToLower ( channel ) c . send ( fmt . Sprintf ( "PRIVMSG #%s :%s" , channel , text ) ) }
3361	func ( i * IntegrationGCPCreateRequest ) GetAuthURIOk ( ) ( string , bool ) { if i == nil || i . AuthURI == nil { return "" , false } return * i . AuthURI , true }
3382	func ( i * integrationPD ) GetSubdomainOk ( ) ( string , bool ) { if i == nil || i . Subdomain == nil { return "" , false } return * i . Subdomain , true }
625	func ( im * TXTRegistry ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { if im . recordsCache != nil && time . Since ( im . recordsCacheRefreshTime ) < im . cacheInterval { log . Debug ( "Using cached records." ) return im . recordsCache , nil } records , err := im . provider . Records ( ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } labelMap := map [ string ] endpoint . Labels { } for _ , record := range records { if record . RecordType != endpoint . RecordTypeTXT { endpoints = append ( endpoints , record ) continue } labels , err := endpoint . NewLabelsFromString ( record . Targets [ 0 ] ) if err == endpoint . ErrInvalidHeritage { endpoints = append ( endpoints , record ) continue } if err != nil { return nil , err } endpointDNSName := im . mapper . toEndpointName ( record . DNSName ) labelMap [ endpointDNSName ] = labels } for _ , ep := range endpoints { ep . Labels = endpoint . NewLabels ( ) if labels , ok := labelMap [ ep . DNSName ] ; ok { for k , v := range labels { ep . Labels [ k ] = v } } } if im . cacheInterval > 0 { im . recordsCache = endpoints im . recordsCacheRefreshTime = time . Now ( ) } return endpoints , nil }
236	func ( m * Manager ) ApplyConfig ( cfg * config . Config ) error { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) c := make ( map [ string ] * config . ScrapeConfig ) for _ , scfg := range cfg . ScrapeConfigs { c [ scfg . JobName ] = scfg } m . scrapeConfigs = c if err := m . setJitterSeed ( cfg . GlobalConfig . ExternalLabels ) ; err != nil { return err } var failed bool for name , sp := range m . scrapePools { if cfg , ok := m . scrapeConfigs [ name ] ; ! ok { sp . stop ( ) delete ( m . scrapePools , name ) } else if ! reflect . DeepEqual ( sp . config , cfg ) { err := sp . reload ( cfg ) if err != nil { level . Error ( m . logger ) . Log ( "msg" , "error reloading scrape pool" , "err" , err , "scrape_pool" , name ) failed = true } } } if failed { return errors . New ( "failed to apply the new configuration" ) } return nil }
3161	func ( client * Client ) CreateIntegrationSlack ( slackIntegration * IntegrationSlackRequest ) error { return client . doJsonRequest ( "POST" , "/v1/integration/slack" , slackIntegration , nil ) }
5060	func ( cluster * mongoCluster ) syncServersLoop ( ) { for { debugf ( "SYNC Cluster %p is starting a sync loop iteration." , cluster ) cluster . Lock ( ) if cluster . references == 0 { cluster . Unlock ( ) break } cluster . references ++ direct := cluster . direct cluster . Unlock ( ) cluster . syncServersIteration ( direct ) select { case <- cluster . sync : default : } cluster . Release ( ) if ! cluster . failFast { time . Sleep ( syncShortDelay ) } cluster . Lock ( ) if cluster . references == 0 { cluster . Unlock ( ) break } cluster . syncCount ++ cluster . serverSynced . Broadcast ( ) restart := ! direct && cluster . masters . Empty ( ) || cluster . servers . Empty ( ) cluster . Unlock ( ) if restart { log ( "SYNC No masters found. Will synchronize again." ) time . Sleep ( syncShortDelay ) continue } debugf ( "SYNC Cluster %p waiting for next requested or scheduled sync." , cluster ) select { case <- cluster . sync : case <- time . After ( syncServersDelay ) : } } debugf ( "SYNC Cluster %p is stopping its sync loop." , cluster ) }
1915	func ( m * MockFactory ) FindKnownAPIVersions ( ) [ ] dockerclient . DockerVersion { ret := m . ctrl . Call ( m , "FindKnownAPIVersions" ) ret0 , _ := ret [ 0 ] . ( [ ] dockerclient . DockerVersion ) return ret0 }
936	func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { EnvVar : "OS_USERNAME" , Name : "rackspace-username" , Usage : "Rackspace account username" , Value : "" , } , mcnflag . StringFlag { EnvVar : "OS_API_KEY" , Name : "rackspace-api-key" , Usage : "Rackspace API key" , Value : "" , } , mcnflag . StringFlag { EnvVar : "OS_REGION_NAME" , Name : "rackspace-region" , Usage : "Rackspace region name" , Value : defaultRegionName , } , mcnflag . StringFlag { EnvVar : "OS_ENDPOINT_TYPE" , Name : "rackspace-endpoint-type" , Usage : "Rackspace endpoint type (adminURL, internalURL or the default publicURL)" , Value : defaultEndpointType , } , mcnflag . StringFlag { EnvVar : "OS_IMAGE_ID" , Name : "rackspace-image-id" , Usage : "Rackspace image ID. Default: Ubuntu 16.04 LTS (Xenial Xerus) (PVHVM)" , } , mcnflag . StringFlag { EnvVar : "OS_FLAVOR_ID" , Name : "rackspace-flavor-id" , Usage : "Rackspace flavor ID. Default: General Purpose 1GB" , Value : defaultFlavorID , } , mcnflag . StringFlag { EnvVar : "OS_SSH_USER" , Name : "rackspace-ssh-user" , Usage : "SSH user for the newly booted machine. Set to root by default" , Value : defaultSSHUser , } , mcnflag . IntFlag { EnvVar : "OS_SSH_PORT" , Name : "rackspace-ssh-port" , Usage : "SSH port for the newly booted machine. Set to 22 by default" , Value : defaultSSHPort , } , mcnflag . StringFlag { Name : "rackspace-docker-install" , Usage : "Set if docker have to be installed on the machine" , Value : defaultDockerInstall , } , mcnflag . IntFlag { EnvVar : "OS_ACTIVE_TIMEOUT" , Name : "rackspace-active-timeout" , Usage : "Rackspace active timeout" , Value : defaultActiveTimeout , } , } }
2916	func swapSCSIDevice ( l object . VirtualDeviceList , device types . BaseVirtualSCSIController , ct string , st string ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( "[DEBUG] swapSCSIDevice: Swapping SCSI device for one of controller type %s: %s" , ct , l . Name ( device . ( types . BaseVirtualDevice ) ) ) var spec [ ] types . BaseVirtualDeviceConfigSpec bvd := device . ( types . BaseVirtualDevice ) cspec , err := object . VirtualDeviceList { bvd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } spec = append ( spec , cspec ... ) nsd , err := l . CreateSCSIController ( ct ) if err != nil { return nil , err } nsd . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus = types . VirtualSCSISharing ( st ) nsd . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . BusNumber = device . GetVirtualSCSIController ( ) . BusNumber cspec , err = object . VirtualDeviceList { nsd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } spec = append ( spec , cspec ... ) ockey := device . GetVirtualSCSIController ( ) . Key nckey := nsd . GetVirtualDevice ( ) . Key for _ , vd := range l { if vd . GetVirtualDevice ( ) . ControllerKey == ockey { vd . GetVirtualDevice ( ) . ControllerKey = nckey cspec , err := object . VirtualDeviceList { vd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } if len ( cspec ) != 1 { return nil , fmt . Errorf ( "incorrect number of config spec items returned - expected 1, got %d" , len ( cspec ) ) } cspec [ 0 ] . GetVirtualDeviceConfigSpec ( ) . FileOperation = "" spec = append ( spec , cspec ... ) } } log . Printf ( "[DEBUG] swapSCSIDevice: Outgoing device config spec: %s" , DeviceChangeString ( spec ) ) return spec , nil }
2956	func flattenStorageDrsSpaceLoadBalanceConfig ( d * schema . ResourceData , obj * types . StorageDrsSpaceLoadBalanceConfig , version viapi . VSphereVersion , ) error { attrs := map [ string ] interface { } { "sdrs_free_space_utilization_difference" : obj . MinSpaceUtilizationDifference , "sdrs_free_space_threshold_mode" : obj . SpaceThresholdMode , } freeSpaceSupported := version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) if freeSpaceSupported && obj . SpaceThresholdMode == string ( types . StorageDrsSpaceLoadBalanceConfigSpaceThresholdModeFreeSpace ) { attrs [ "sdrs_free_space_threshold" ] = obj . FreeSpaceThresholdGB } else { attrs [ "sdrs_space_utilization_threshold" ] = obj . SpaceUtilizationThreshold } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( "error setting attribute %q: %s" , k , err ) } } return nil }
2759	func flattenVirtualMachineBootOptions ( d * schema . ResourceData , obj * types . VirtualMachineBootOptions ) error { d . Set ( "boot_delay" , obj . BootDelay ) structure . SetBoolPtr ( d , "efi_secure_boot_enabled" , obj . EfiSecureBootEnabled ) structure . SetBoolPtr ( d , "boot_retry_enabled" , obj . BootRetryEnabled ) d . Set ( "boot_retry_delay" , obj . BootRetryDelay ) return nil }
2955	func expandStorageDrsSpaceLoadBalanceConfig ( d * schema . ResourceData , version viapi . VSphereVersion , ) * types . StorageDrsSpaceLoadBalanceConfig { obj := & types . StorageDrsSpaceLoadBalanceConfig { MinSpaceUtilizationDifference : int32 ( d . Get ( "sdrs_free_space_utilization_difference" ) . ( int ) ) , SpaceUtilizationThreshold : int32 ( d . Get ( "sdrs_space_utilization_threshold" ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . FreeSpaceThresholdGB = int32 ( d . Get ( "sdrs_free_space_threshold" ) . ( int ) ) obj . SpaceThresholdMode = d . Get ( "sdrs_free_space_threshold_mode" ) . ( string ) } return obj }
3424	func ( o * Options ) HasLocked ( ) bool { if o != nil && o . Locked != nil { return true } return false }
7029	func ( p Param ) UInt32 ( ) ( uint32 , error ) { i , err := strconv . ParseUint ( string ( p ) , 10 , 32 ) return uint32 ( i ) , err }
190	func ( a * Adapter ) refreshTargetGroups ( allTargetGroups map [ string ] [ ] * targetgroup . Group ) { tempGroups := generateTargetGroups ( allTargetGroups ) if ! reflect . DeepEqual ( a . groups , tempGroups ) { a . groups = tempGroups err := a . writeOutput ( ) if err != nil { level . Error ( log . With ( a . logger , "component" , "sd-adapter" ) ) . Log ( "err" , err ) } } }
5142	func ( ui * BasicUI ) Error ( message string ) { if ui . ErrorWriter != nil { fmt . Fprint ( ui . ErrorWriter , message ) fmt . Fprint ( ui . ErrorWriter , "\n" ) } else \n }
7307	func ( b Bucket ) PutGob ( k [ ] [ ] byte , v interface { } ) error { var bs bytesp . Slice if err := gob . NewEncoder ( & bs ) . Encode ( & v ) ; err != nil { return errorsp . WithStacksAndMessage ( err , "encoding %+v failed" , v ) } return b . Put ( k , bs ) }
2534	func flattenClusterHostGroup ( d * schema . ResourceData , obj * types . ClusterHostGroup ) error { var hostIDs [ ] string for _ , v := range obj . Host { hostIDs = append ( hostIDs , v . Value ) } return structure . SetBatch ( d , map [ string ] interface { } { "host_system_ids" : hostIDs , } ) }
5387	func ( i * info ) GroupHas ( p ... perm ) bool { mode := i . fi . Mode ( ) for _ , v := range p { switch v { case R : if mode & modeRGroup == 0 { return false } case W : if mode & modeWGroup == 0 { return false } case X : if mode & modeXGroup == 0 { return false } } } return true }
6468	func ( l * Log ) flushDaemon ( ) { for _ = range time . NewTicker ( flushInterval ) . C { l . lockAndFlushAll ( ) } }
4346	func BuildLeet ( ) Graph { data , err := data . Asset ( "data/L33t.json" ) if err != nil { panic ( "Can't find asset" ) } return getAdjancencyGraphFromFile ( data , "keypad" ) }
4761	func ( pool * GzipPool ) ReturnWriter ( writer * gzip . Writer ) { writer . Close ( ) pool . pool . Put ( writer ) }
6818	func ( c * Client ) SetRules ( rules * Rules , params map [ string ] string ) error { body , err := json . Marshal ( rules ) if err != nil { log . Printf ( "%v\n" , \n ) err } return err _ , err = c . api . Call ( "PUT" , c . Url + "/.settings/rules" , c . Auth , body , params ) }
6953	func ( e EnvVar ) String ( ) string { b := bytes . NewBuffer ( nil ) for _ , env := range e { if len ( strings . SplitN ( env , "=" , 2 ) ) < 2 { continue } fmt . Fprintln ( b , env ) } return b . String ( ) }
3483	func ( r * reqGetTags ) GetTagsOk ( ) ( TagMap , bool ) { if r == nil || r . Tags == nil { return TagMap { } , false } return * r . Tags , true }
1867	func ( secret * SSMSecretResource ) SetCachedSecretValue ( secretKey string , secretValue string ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . secretData == nil { secret . secretData = make ( map [ string ] string ) } secret . secretData [ secretKey ] = secretValue }
1162	func ( refreshHandler * refreshCredentialsHandler ) handleMessages ( ) { for { select { case message := <- refreshHandler . messageBuffer : refreshHandler . handleSingleMessage ( message ) case <- refreshHandler . ctx . Done ( ) : return } } }
5287	func elementsFromLine ( config * Config , line string ) [ ] interface { } { separated := strings . Split ( line , config . Delim ) elements := make ( [ ] interface { } , len ( separated ) ) for i , field := range separated { value := field if ! config . NoTrim { value = strings . TrimSpace ( field ) } if value == "" && config . Empty != "" { value = config . Empty } elements [ i ] = value } return elements }
1897	func ( engine * DockerTaskEngine ) startTask ( task * apitask . Task ) { thisTask := engine . newManagedTask ( task ) thisTask . _time = engine . time ( ) go thisTask . overseeTask ( ) }
1469	func ( c * Container ) IsMetadataFileUpdated ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . MetadataFileUpdated }
5639	func addPoints ( a [ ] byte , b [ ] byte ) [ ] byte { ap , err := btcec . ParsePubKey ( a , btcec . S256 ( ) ) if err != nil { panic ( err ) } bp , err := btcec . ParsePubKey ( b , btcec . S256 ( ) ) if err != nil { panic ( err ) } sumX , sumY := btcec . S256 ( ) . Add ( ap . X , ap . Y , bp . X , bp . Y ) sum := & btcec . PublicKey { Curve : btcec . S256 ( ) , X : sumX , Y : sumY , } return sum . SerializeCompressed ( ) }
1675	func ( auth * ASMAuthResource ) GetRequiredASMResources ( ) [ ] * apicontainer . ASMAuthData { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . requiredASMResources }
5005	func msb32 ( x uint32 ) int { pos := 32 temp := x >> 16 if temp != 0 { pos -= 16 x = temp } temp = x >> 8 if temp != 0 { pos -= 8 x = temp } temp = x >> 4 if temp != 0 { pos -= 4 x = temp } temp = x >> 2 if temp != 0 { pos -= 2 x = temp } temp = x >> 1 if temp != 0 { return pos - 2 } return int ( uint32 ( pos ) - x ) }
3120	func ( g * Graph ) Populate ( ) error { for _ , o := range g . named { if o . Complete { continue } if err := g . populateExplicit ( o ) ; err != nil { return err } } i := 0 for { if i == len ( g . unnamed ) { break } o := g . unnamed [ i ] i ++ if o . Complete { continue } if err := g . populateExplicit ( o ) ; err != nil { return err } } for _ , o := range g . unnamed { if o . Complete { continue } if err := g . populateUnnamedInterface ( o ) ; err != nil { return err } } for _ , o := range g . named { if o . Complete { continue } if err := g . populateUnnamedInterface ( o ) ; err != nil { return err } } return nil }
1610	func ( m * MockSecretsManagerAPI ) RestoreSecretRequest ( arg0 * secretsmanager . RestoreSecretInput ) ( * request . Request , * secretsmanager . RestoreSecretOutput ) { ret := m . ctrl . Call ( m , "RestoreSecretRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . RestoreSecretOutput ) return ret0 , ret1 }
444	func ( ctx * RequestCtx ) Logger ( ) Logger { if ctx . logger . ctx == nil { ctx . logger . ctx = ctx } if ctx . logger . logger == nil { ctx . logger . logger = ctx . s . logger ( ) } return & ctx . logger }
2832	func resourceVSphereDRSVMOverrideFindEntry ( cluster * object . ClusterComputeResource , vm * object . VirtualMachine , ) ( * types . ClusterDrsVmConfigInfo , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( "error fetching cluster properties: %s" , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . DrsVmConfig { if info . Key == vm . Reference ( ) { log . Printf ( "[DEBUG] Found DRS config info for VM %q in cluster %q" , vm . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( "[DEBUG] No DRS config info found for VM %q in cluster %q" , vm . Name ( ) , cluster . Name ( ) ) return nil , nil }
2361	func CreateProgram ( ) uint32 { ret , _ , _ := syscall . Syscall ( gpCreateProgram , 0 , 0 , 0 , 0 ) return ( uint32 ) ( ret ) }
4165	func ( c * Client ) Userlist ( channel string ) ( [ ] string , error ) { c . channelUserlistMutex . RLock ( ) defer c . channelUserlistMutex . RUnlock ( ) usermap , ok := c . channelUserlist [ channel ] if ! ok || usermap == nil { return nil , fmt . Errorf ( "Could not find userlist for channel '%s' in client" , channel ) } userlist := make ( [ ] string , len ( usermap ) ) i := 0 for key := range usermap { userlist [ i ] = key i ++ } return userlist , nil }
6731	func ( totp * TOTP ) ForPeriod ( period int64 ) int32 { data := int_to_bytestring ( period ) hmacHash := hmac . New ( sha1 . New , totp . key ) hmacHash . Write ( data ) digest := hmacHash . Sum ( nil ) offset := int ( digest [ 19 ] & 0xf ) code := int32 ( digest [ offset ] & 0x7f ) << 24 | int32 ( digest [ offset + 1 ] & 0xff ) << 16 | int32 ( digest [ offset + 2 ] & 0xff ) << 8 | int32 ( digest [ offset + 3 ] & 0xff ) code = int32 ( int64 ( code ) % int64 ( math . Pow10 ( totp . Digits ) ) ) return code }
5510	func ( f * FileLogger ) Print ( v ... interface { } ) { _ , file , line , _ := runtime . Caller ( 1 ) f . logChan <- fmt . Sprintf ( "[%v:%v]" , shortFileName ( file ) , line ) + fmt . Sprint ( v ... ) }
6430	func unquote ( input [ ] byte , buf [ ] byte ) ( unquoted [ ] byte , remainder [ ] byte ) { var ( errorIndicator = [ ] byte ( "???" ) ) if len ( input ) < 2 { return errorIndicator , buf } quote := input [ 0 ] input = input [ 1 : ] if input [ len ( input ) - 1 ] == quote { input = input [ : len ( input ) - 1 ] } index := bytes . IndexRune ( input , '\\' ) if index < 0 { remainder = buf unquoted = input return unquoted , remainder } if len ( buf ) > 0 { unquoted = buf [ : 0 ] } strinput := toString ( input ) for len ( strinput ) > 0 { r , mb , tail , err := strconv . UnquoteChar ( strinput , quote ) if err != nil { return errorIndicator , buf } strinput = tail if mb { runeLen := utf8 . RuneLen ( r ) unquotedLen := len ( unquoted ) for i := 0 ; i < runeLen ; i ++ { unquoted = append ( unquoted , 0 ) } utf8 . EncodeRune ( unquoted [ unquotedLen : ] , r ) } else { unquoted = append ( unquoted , byte ( r ) ) } } if len ( buf ) < len ( unquoted ) { remainder = nil } else { remainder = buf [ len ( unquoted ) : ] } return unquoted , remainder }
2229	func ( v * Clipboard ) WaitForText ( ) ( string , error ) { c := C . gtk_clipboard_wait_for_text ( v . native ( ) ) if c == nil { return "" , nilPtrErr } defer C . g_free ( C . gpointer ( c ) ) return goString ( c ) , nil }
3368	func ( i * IntegrationGCPCreateRequest ) HasClientX509CertURL ( ) bool { if i != nil && i . ClientX509CertURL != nil { return true } return false }
6025	func ( t Typed ) BoolsOr ( key string , d [ ] bool ) [ ] bool { n , ok := t . BoolsIf ( key ) if ok { return n } return d }
2962	func datacenterFromID ( client * govmomi . Client , id string ) ( * object . Datacenter , error ) { finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : "Datacenter" , Value : id , } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) ds , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , fmt . Errorf ( "could not find datacenter with id: %s: %s" , id , err ) } return ds . ( * object . Datacenter ) , nil }
294	func ( s * ReadyStorage ) Close ( ) error { if x := s . Get ( ) ; x != nil { return x . Close ( ) } return nil }
742	func NewDigitalOceanProvider ( domainFilter DomainFilter , dryRun bool ) ( * DigitalOceanProvider , error ) { token , ok := os . LookupEnv ( "DO_TOKEN" ) if ! ok { return nil , fmt . Errorf ( "No token found" ) } oauthClient := oauth2 . NewClient ( oauth2 . NoContext , oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token , } ) ) client := godo . NewClient ( oauthClient ) provider := & DigitalOceanProvider { Client : client . Domains , domainFilter : domainFilter , DryRun : dryRun , } return provider , nil }
5562	func FindPerformancePrice ( productPackage datatypes . Product_Package , priceCategory string ) ( datatypes . Product_Item_Price , error ) { for _ , item := range productPackage . Items { for _ , price := range item . Prices { if price . LocationGroupId != nil { continue } if ! hasCategory ( price . Categories , priceCategory ) { continue } return price , nil } } return datatypes . Product_Item_Price { } , bosherr . Error ( "Unable to find price for performance storage" ) }
5075	func ( r * Runner ) Resume ( id bson . ObjectId ) ( err error ) { t , err := r . load ( id ) if err != nil { return err } if ! t . done ( ) { debugf ( "Resuming %s from %q" , t , t . State ) if err := flush ( r , t ) ; err != nil { return err } } if t . State == taborted { return ErrAborted } else if t . State != tapplied { panic ( fmt . Errorf ( "invalid state for %s after flush: %q" , t , t . State ) ) } return nil }
6058	func NewDB ( conf * DBConfig ) ( * reform . DB , error ) { conn , err := dbConnect ( conf . ConnStr ( ) ) if err != nil { return nil , err } conn . SetMaxOpenConns ( conf . MaxOpen ) conn . SetMaxIdleConns ( conf . MaxIddle ) return newReform ( conn ) , nil }
6708	func ( c * Client ) FirewallPolicy ( identifier string ) ( * FirewallPolicy , error ) { policy := new ( FirewallPolicy ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/firewall_policies/" + identifier , nil , policy ) if err != nil { return nil , err } return policy , err }
5068	func New ( ) Render { return Render { Templates : make ( map [ string ] * template . Template ) , Files : make ( map [ string ] [ ] string ) , TemplatesDir : TemplatesDir , Layout : Layout , Ext : Ext , Debug : Debug , } }
5241	func ValidKey ( key string ) bool { return len ( key ) <= maxKey && keyRegex . Match ( [ ] byte ( key ) ) }
6921	func ( p * PushCenter ) HasHandlerForIdentity ( identity Identity ) bool { if identity . Name == AllIdentity . Name { return p . defaultHander != nil } _ , exists := p . handlers [ identity . Name ] return exists }
2783	func resourceVSphereHAVMOverrideFlattenID ( cluster * object . ClusterComputeResource , vm * object . VirtualMachine ) ( string , error ) { clusterID := cluster . Reference ( ) . Value props , err := virtualmachine . Properties ( vm ) if err != nil { return "" , fmt . Errorf ( "cannot compute ID off of properties of virtual machine: %s" , err ) } vmID := props . Config . Uuid return strings . Join ( [ ] string { clusterID , vmID } , ":" ) , nil }
4186	func ( m * yamlManager ) CreateConfigIfNotExists ( uaaOrigin string ) error { if FileOrDirectoryExists ( m . ConfigDir ) { lo . G . Infof ( "Config directory %s already exists, skipping creation" , m . ConfigDir ) return nil } if err := os . MkdirAll ( m . ConfigDir , 0755 ) ; err != nil { lo . G . Errorf ( "Error creating config directory %s. Error : %s" , m . ConfigDir , err ) return fmt . Errorf ( "cannot create directory %s: %v" , m . ConfigDir , err ) } lo . G . Infof ( "Config directory %s created" , m . ConfigDir ) asgDir := path . Join ( m . ConfigDir , "asgs" ) if err := os . MkdirAll ( asgDir , 0755 ) ; err != nil { lo . G . Errorf ( "Error creating config directory %s. Error : %s" , asgDir , err ) return fmt . Errorf ( "cannot create directory %s: %v" , asgDir , err ) } lo . G . Infof ( "ASG directory %s created" , asgDir ) asgDir = path . Join ( m . ConfigDir , "default_asgs" ) if err := os . MkdirAll ( asgDir , 0755 ) ; err != nil { lo . G . Errorf ( "Error creating config directory %s. Error : %s" , asgDir , err ) return fmt . Errorf ( "cannot create directory %s: %v" , asgDir , err ) } lo . G . Infof ( "ASG directory %s created" , asgDir ) orgQuotasDir := path . Join ( m . ConfigDir , "org_quotas" ) if err := os . MkdirAll ( orgQuotasDir , 0755 ) ; err != nil { lo . G . Errorf ( "Error creating config directory %s. Error : %s" , orgQuotasDir , err ) return fmt . Errorf ( "cannot create directory %s: %v" , orgQuotasDir , err ) } lo . G . Infof ( "OrgQuotas directory %s created" , orgQuotasDir ) if err := m . SaveGlobalConfig ( & GlobalConfig { } ) ; err != nil { return err } if err := WriteFile ( fmt . Sprintf ( "%s/ldap.yml" , m . ConfigDir ) , & LdapConfig { TLS : false , Origin : uaaOrigin } ) ; err != nil { return err } if err := WriteFile ( fmt . Sprintf ( "%s/orgs.yml" , m . ConfigDir ) , & Orgs { EnableDeleteOrgs : true , ProtectedOrgs : DefaultProtectedOrgs , } ) ; err != nil { return err } if err := WriteFile ( fmt . Sprintf ( "%s/spaceDefaults.yml" , m . ConfigDir ) , struct { Developer UserMgmt `yaml:"space-developer"` Manager UserMgmt `yaml:"space-manager"` Auditor UserMgmt `yaml:"space-auditor"` } { } ) ; err != nil { return err } return nil }
3154	func ( q * Queue ) delete ( key [ ] byte ) { err := q . db . Delete ( [ ] byte ( key ) , nil ) atomic . AddUint32 ( & q . stat . deleteCount , 1 ) if err != nil { atomic . AddUint32 ( & q . stat . deleteErrors , 1 ) q . logger . Error ( "delete from queue database failed" , zap . Error ( err ) ) } }
3147	func ( p * Points ) Eq ( other * Points ) bool { if other == nil { return false } if p . Metric != other . Metric { return false } if p . Data == nil && other . Data == nil { return true } if ( p . Data == nil || other . Data == nil ) && ( p . Data != nil || other . Data != nil ) { return false } if len ( p . Data ) != len ( other . Data ) { return false } for i := 0 ; i < len ( p . Data ) ; i ++ { if p . Data [ i ] . Value != other . Data [ i ] . Value { return false } if p . Data [ i ] . Timestamp != other . Data [ i ] . Timestamp { return false } } return true }
3857	func format ( a [ ] rune , c * Cursor ) string { i := c . Position var b [ ] rune out := make ( [ ] rune , 0 ) if i < len ( a ) { b = c . Cursor ( [ ] rune ( a [ i : i + 1 ] ) ) out = append ( out , a [ : i ] ... ) out = append ( out , b ... ) out = append ( out , a [ i + 1 : ] ... ) } else { b = c . Cursor ( [ ] rune { } ) out = append ( out , a ... ) out = append ( out , b ... ) } return string ( out ) }
3051	func tagIDFromName ( ctx context . Context , client * tags . RestClient , name , category string ) ( string , error ) { logger . Printf ( "[DEBUG] Fetching tag ID for tag name %q and category %q" , name , category ) categoryID , err := tagCategoryByName ( ctx , client , category ) if err != nil { return "" , err } return tagByName ( ctx , client , name , categoryID ) }
901	func ( d * Driver ) Create ( ) error { c , err := d . newAzureClient ( ) if err != nil { return err } var customData string if d . CustomDataFile != "" { buf , err := ioutil . ReadFile ( d . CustomDataFile ) if err != nil { return err } customData = base64 . StdEncoding . EncodeToString ( buf ) } if err := c . CreateResourceGroup ( d . ResourceGroup , d . Location ) ; err != nil { return err } if err := c . CreateAvailabilitySetIfNotExists ( d . ctx , d . ResourceGroup , d . AvailabilitySet , d . Location ) ; err != nil { return err } if err := c . CreateNetworkSecurityGroup ( d . ctx , d . ResourceGroup , d . naming ( ) . NSG ( ) , d . Location , d . ctx . FirewallRules ) ; err != nil { return err } vnetResourceGroup , vNetName := parseVirtualNetwork ( d . VirtualNetwork , d . ResourceGroup ) if err := c . CreateVirtualNetworkIfNotExists ( vnetResourceGroup , vNetName , d . Location ) ; err != nil { return err } if err := c . CreateSubnet ( d . ctx , vnetResourceGroup , vNetName , d . SubnetName , d . SubnetPrefix ) ; err != nil { return err } if d . NoPublicIP { log . Info ( "Not creating a public IP address." ) } else { if err := c . CreatePublicIPAddress ( d . ctx , d . ResourceGroup , d . naming ( ) . IP ( ) , d . Location , d . StaticPublicIP , d . DNSLabel ) ; err != nil { return err } } if err := c . CreateNetworkInterface ( d . ctx , d . ResourceGroup , d . naming ( ) . NIC ( ) , d . Location , d . ctx . PublicIPAddressID , d . ctx . SubnetID , d . ctx . NetworkSecurityGroupID , d . PrivateIPAddr ) ; err != nil { return err } if err := c . CreateStorageAccount ( d . ctx , d . ResourceGroup , d . Location , storage . SkuName ( d . StorageType ) ) ; err != nil { return err } if err := d . generateSSHKey ( d . ctx ) ; err != nil { return err } err = c . CreateVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) , d . Location , d . Size , d . ctx . AvailabilitySetID , d . ctx . NetworkInterfaceID , d . BaseDriver . SSHUser , d . ctx . SSHPublicKey , d . Image , customData , d . ctx . StorageAccount ) return err }
2467	func repeatingKeyPressed ( key ebiten . Key ) bool { const ( delay = 30 interval = 3 ) d := inpututil . KeyPressDuration ( key ) if d == 1 { return true } if d >= delay && ( d - delay ) % interval == 0 { return true } return false }
4751	func ( list ErrorList ) Error ( ) string { if len ( list ) == 0 { return "Empty ErrorList" } var b strings . Builder for _ , err := range list { fmt . Fprintln ( & b , err ) } return b . String ( ) }
3512	func ( s * SyntheticsAssertion ) GetPropertyOk ( ) ( string , bool ) { if s == nil || s . Property == nil { return "" , false } return * s . Property , true }
4675	func newComment ( ln * line , rslt * result , src * source , parent element , opts * Options ) * comment { return & comment { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , } }
1177	func ( mr * MockProviderMockRecorder ) IsExpired ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "IsExpired" , reflect . TypeOf ( ( * MockProvider ) ( nil ) . IsExpired ) ) }
3590	func ( t * ThresholdWindows ) GetRecoveryWindowOk ( ) ( string , bool ) { if t == nil || t . RecoveryWindow == nil { return "" , false } return * t . RecoveryWindow , true }
4229	func ( s * Spinner ) Stop ( ) { s . lock . Lock ( ) defer s . lock . Unlock ( ) if s . active { s . active = false if s . HideCursor && runtime . GOOS != "windows" { fmt . Print ( "\033[?25h" ) } \033 s . erase ( ) if s . FinalMSG != "" { fmt . Fprintf ( s . Writer , s . FinalMSG ) } } }
3920	func ( c * Checker ) CheckUnexportedReturn ( j * lint . Job ) { for _ , fn := range j . Program . InitialFunctions { if fn . Synthetic != "" || fn . Parent ( ) != nil { continue } if ! ast . IsExported ( fn . Name ( ) ) || IsInMain ( j , fn ) || IsInTest ( j , fn ) { continue } sig := fn . Type ( ) . ( * types . Signature ) if sig . Recv ( ) != nil && ! ast . IsExported ( Dereference ( sig . Recv ( ) . Type ( ) ) . ( * types . Named ) . Obj ( ) . Name ( ) ) { continue } res := sig . Results ( ) for i := 0 ; i < res . Len ( ) ; i ++ { if named , ok := DereferenceR ( res . At ( i ) . Type ( ) ) . ( * types . Named ) ; ok && ! ast . IsExported ( named . Obj ( ) . Name ( ) ) && named != types . Universe . Lookup ( "error" ) . Type ( ) { j . Errorf ( fn , "should not return unexported type" ) } } } }
1490	func ( c * Container ) BuildContainerDependency ( contName string , satisfiedStatus apicontainerstatus . ContainerStatus , dependentStatus apicontainerstatus . ContainerStatus ) { contDep := ContainerDependency { ContainerName : contName , SatisfiedStatus : satisfiedStatus , } if _ , ok := c . TransitionDependenciesMap [ dependentStatus ] ; ! ok { c . TransitionDependenciesMap [ dependentStatus ] = TransitionDependencySet { } } deps := c . TransitionDependenciesMap [ dependentStatus ] deps . ContainerDependencies = append ( deps . ContainerDependencies , contDep ) c . TransitionDependenciesMap [ dependentStatus ] = deps }
3687	func ( w * Widget ) HasManageStatusTitleText ( ) bool { if w != nil && w . ManageStatusTitleText != nil { return true } return false }
5993	func ( ds * DNSServer ) qualifySrvHosts ( srvs [ ] SRVRecord ) [ ] SRVRecord { newsrvs := [ ] SRVRecord { } for _ , srv := range srvs { newsrvs = append ( newsrvs , SRVRecord { Host : ds . qualifyHost ( srv . Host ) , Port : srv . Port , } ) } return newsrvs }
5567	func ( o * FindVmsByStatesParams ) WithStates ( states [ ] string ) * FindVmsByStatesParams { o . SetStates ( states ) return o }
5705	func ( c * Client ) IdleWithFallback ( stop <- chan struct { } , pollInterval time . Duration ) error { if ok , err := c . SupportIdle ( ) ; err != nil { return err } else if ok { return c . Idle ( stop ) } if pollInterval == 0 { pollInterval = defaultPollInterval } t := time . NewTicker ( pollInterval ) defer t . Stop ( ) for { select { case <- t . C : if err := c . c . Noop ( ) ; err != nil { return err } case <- stop : return nil case <- c . c . LoggedOut ( ) : return errors . New ( "disconnected while idling" ) } } }
189	func ( r * AlertingRule ) currentAlerts ( ) [ ] * Alert { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) alerts := make ( [ ] * Alert , 0 , len ( r . active ) ) for _ , a := range r . active { anew := * a alerts = append ( alerts , & anew ) } return alerts }
414	func NewPipeConns ( ) * PipeConns { ch1 := make ( chan * byteBuffer , 4 ) ch2 := make ( chan * byteBuffer , 4 ) pc := & PipeConns { stopCh : make ( chan struct { } ) , } pc . c1 . rCh = ch1 pc . c1 . wCh = ch2 pc . c2 . rCh = ch2 pc . c2 . wCh = ch1 pc . c1 . pc = pc pc . c2 . pc = pc return pc }
7196	func ( r * Route ) Get ( pat string , f ... HandlerFunc ) { r . HandleMethod ( pat , "GET" , f ... ) r . HandleMethod ( pat , "HEAD" , f ... ) }
4666	func newHelperMethodYield ( ln * line , rslt * result , src * source , parent element , opts * Options ) ( * helperMethodYield , error ) { if len ( ln . tokens ) < 3 { return nil , fmt . Errorf ( "no template name is specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } e := & helperMethodYield { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , templateName : ln . tokens [ 2 ] , } return e , nil }
563	func ( mws Middlewares ) HandlerFunc ( h http . HandlerFunc ) http . Handler { return & ChainHandler { mws , h , chain ( mws , h ) } }
6079	func ToError ( err error ) * Error { if err == nil { return nil } if err , ok := err . ( rpc . Error ) ; ok { return & Error { Code : err . ErrorCode ( ) , Message : err . Error ( ) } } return & Error { Message : err . Error ( ) } }
7280	func ( s * Image ) Exists ( ) bool { out , err := s . docker . Run ( "images" , "--no-trunc" ) if err != nil { return false } return strings . Contains ( out , s . name ) }
2307	func ( v * TreeRowReference ) Valid ( ) bool { c := C . gtk_tree_row_reference_valid ( v . native ( ) ) return gobool ( c ) }
5052	func ( q * Query ) Count ( ) ( n int , err error ) { q . m . Lock ( ) session := q . session op := q . op limit := q . limit q . m . Unlock ( ) c := strings . Index ( op . collection , "." ) if c < 0 { return 0 , errors . New ( "Bad collection name: " + op . collection ) } dbname := op . collection [ : c ] cname := op . collection [ c + 1 : ] query := op . query if query == nil { query = bson . D { } } result := struct { N int } { } err = session . DB ( dbname ) . Run ( countCmd { cname , query , limit , op . skip } , & result ) return result . N , err }
1299	func ( m * MockAuditLogger ) Log ( arg0 request . LogRequest , arg1 int , arg2 string ) { m . ctrl . Call ( m , "Log" , arg0 , arg1 , arg2 ) }
3030	func client ( path string ) ( * http . Client , error ) { if path == "" { return google . DefaultClient ( oauth2 . NoContext , compute . ComputeScope ) } key , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } jwtConfig , err := google . JWTConfigFromJSON ( key , compute . ComputeScope ) if err != nil { return nil , err } return jwtConfig . Client ( oauth2 . NoContext ) , nil }
361	func StatusMessage ( statusCode int ) string { s := statusMessages [ statusCode ] if s == "" { s = "Unknown Status Code" } return s }
4977	func New ( trafficControllerUrl string , tlsConfig * tls . Config , proxy func ( * http . Request ) ( * url . URL , error ) ) * Consumer { if proxy == nil { proxy = http . ProxyFromEnvironment } return & Consumer { trafficControllerUrl : trafficControllerUrl , debugPrinter : nullDebugPrinter { } , client : & http . Client { Transport : & http . Transport { Proxy : proxy , TLSClientConfig : tlsConfig , TLSHandshakeTimeout : internal . Timeout , DisableKeepAlives : true , } , Timeout : internal . Timeout , } , minRetryDelay : int64 ( DefaultMinRetryDelay ) , maxRetryDelay : int64 ( DefaultMaxRetryDelay ) , maxRetryCount : int64 ( DefaultMaxRetryCount ) , dialer : websocket . Dialer { HandshakeTimeout : internal . Timeout , Proxy : proxy , TLSClientConfig : tlsConfig , } , recentPathBuilder : defaultRecentPathBuilder , streamPathBuilder : defaultStreamPathBuilder , } }
145	func New ( minSize , maxSize int , factor float64 , makeFunc func ( int ) interface { } ) * Pool { if minSize < 1 { panic ( "invalid minimum pool size" ) } if maxSize < 1 { panic ( "invalid maximum pool size" ) } if factor < 1 { panic ( "invalid factor" ) } var sizes [ ] int for s := minSize ; s <= maxSize ; s = int ( float64 ( s ) * factor ) { sizes = append ( sizes , s ) } p := & Pool { buckets : make ( [ ] sync . Pool , len ( sizes ) ) , sizes : sizes , make : makeFunc , } return p }
7103	func ToPhone ( theString , delimiter string ) ( string , error ) { f := New ( theString ) f . removeNonDigits ( ) if f . length < 10 { return "" , errors . New ( lengthError ) } var buffer bytes . Buffer count := 0 switch f . length { case 10 : buffer . WriteString ( "(" ) for _ , i := range f . theString { count ++ buffer . WriteString ( string ( i ) ) switch count { case 3 : buffer . WriteString ( ") " ) case 6 : buffer . WriteString ( fmt . Sprintf ( "%s" , delimiter ) ) } } case 11 : for _ , i := range f . theString { count ++ buffer . WriteString ( string ( i ) ) switch count { case 1 : buffer . WriteString ( " (" ) case 4 : buffer . WriteString ( ") " ) case 7 : buffer . WriteString ( fmt . Sprintf ( "%s" , delimiter ) ) } } default : return "" , errors . New ( "non US number given" ) } return buffer . String ( ) , nil }
5034	func ( s * Session ) SetCursorTimeout ( d time . Duration ) { s . m . Lock ( ) if d == 0 { s . queryConfig . op . flags |= flagNoCursorTimeout } else { panic ( "SetCursorTimeout: only 0 (disable timeout) supported for now" ) } s . m . Unlock ( ) }
4249	func spread ( x uint32 ) uint64 { X := uint64 ( x ) X = ( X | ( X << 16 ) ) & 0x0000ffff0000ffff X = ( X | ( X << 8 ) ) & 0x00ff00ff00ff00ff X = ( X | ( X << 4 ) ) & 0x0f0f0f0f0f0f0f0f X = ( X | ( X << 2 ) ) & 0x3333333333333333 X = ( X | ( X << 1 ) ) & 0x5555555555555555 return X }
3608	func ( t * TimeRange ) GetToOk ( ) ( json . Number , bool ) { if t == nil || t . To == nil { return "" , false } return * t . To , true }
2841	func ( r * CdromSubresource ) ValidateDiff ( ) error { log . Printf ( "[DEBUG] %s: Beginning CDROM configuration validation" , r ) dsID := r . Get ( "datastore_id" ) . ( string ) path := r . Get ( "path" ) . ( string ) clientDevice := r . Get ( "client_device" ) . ( bool ) switch { case clientDevice && ( dsID != "" || path != "" ) : return fmt . Errorf ( "Cannot have both client_device parameter and ISO file parameters (datastore_id, path) set" ) case ! clientDevice && ( dsID == "" || path == "" ) : return fmt . Errorf ( "Either client_device or datastore_id and path must be set" ) } log . Printf ( "[DEBUG] %s: Config validation complete" , r ) return nil }
5330	func NextGID ( ) ( int , error ) { db , gid , err := nextGUID ( false ) db . close ( ) return gid , err }
891	func ( d * Driver ) PreCreateCheck ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } log . Infof ( "Check that the project exists" ) if _ , err = c . service . Projects . Get ( d . Project ) . Do ( ) ; err != nil { return fmt . Errorf ( "Project with ID %q not found. %v" , d . Project , err ) } log . Infof ( "Check if the instance already exists" ) instance , _ := c . instance ( ) if d . UseExisting { if instance == nil { return fmt . Errorf ( "unable to find instance %q in zone %q" , d . MachineName , d . Zone ) } } else { if instance != nil { return fmt . Errorf ( "instance %q already exists in zone %q" , d . MachineName , d . Zone ) } } return nil }
603	func UpdateArticle ( w http . ResponseWriter , r * http . Request ) { article := r . Context ( ) . Value ( "article" ) . ( * Article ) data := & ArticleRequest { Article : article } if err := render . Bind ( r , data ) ; err != nil { render . Render ( w , r , ErrInvalidRequest ( err ) ) return } article = data . Article dbUpdateArticle ( article . ID , article ) render . Render ( w , r , NewArticleResponse ( article ) ) }
590	func RequestLogger ( f LogFormatter ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { entry := f . NewLogEntry ( r ) ww := NewWrapResponseWriter ( w , r . ProtoMajor ) t1 := time . Now ( ) defer func ( ) { entry . Write ( ww . Status ( ) , ww . BytesWritten ( ) , time . Since ( t1 ) ) } ( ) next . ServeHTTP ( ww , WithLogEntry ( r , entry ) ) } return http . HandlerFunc ( fn ) } }
1637	func NewMockLicenseProvider ( ctrl * gomock . Controller ) * MockLicenseProvider { mock := & MockLicenseProvider { ctrl : ctrl } mock . recorder = & MockLicenseProviderMockRecorder { mock } return mock }
270	func ( l * lexer ) emit ( t ItemType ) { l . items <- item { t , l . start , l . input [ l . start : l . pos ] } l . start = l . pos }
1128	func ( c * cache ) SetDefault ( k string , x interface { } ) { c . Set ( k , x , DefaultExpiration ) }
5847	func ( a * API ) CreateRuleSet ( cfg * RuleSet ) ( * RuleSet , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid rule set config [nil]" ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] create rule set, sending JSON: %s" , string ( jsonCfg ) ) } resp , err := a . Post ( config . RuleSetPrefix , jsonCfg ) if err != nil { return nil , err } ruleset := & RuleSet { } if err := json . Unmarshal ( resp , ruleset ) ; err != nil { return nil , err } return ruleset , nil }
3907	func yaml_reader_read_handler ( parser * yaml_parser_t , buffer [ ] byte ) ( n int , err error ) { return parser . input_reader . Read ( buffer ) }
5578	func ( m * VmsResponse ) Validate ( formats strfmt . Registry ) error { var res [ ] error if err := m . validateVms ( formats ) ; err != nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . CompositeValidationError ( res ... ) } return nil }
1929	func ( gm * GenericMetrics ) IncrementCallCount ( callName string ) { defer func ( ) { if r := recover ( ) ; r != nil { seelog . Errorf ( "IncrementCallCount for %s panicked. Recovering quietly: %s" , callName , r ) } } ( ) gm . lock . Lock ( ) defer gm . lock . Unlock ( ) gm . counterVec . WithLabelValues ( callName ) . Inc ( ) }
276	func digitVal ( ch rune ) int { switch { case '0' <= ch && ch <= '9' : return int ( ch - '0' ) case 'a' <= ch && ch <= 'f' : return int ( ch - 'a' + 10 ) case 'A' <= ch && ch <= 'F' : return int ( ch - 'A' + 10 ) } return 16 }
4605	func CalcLengths ( buckets [ ] * stack . Bucket , fullPath bool ) ( int , int ) { srcLen := 0 pkgLen := 0 for _ , bucket := range buckets { for _ , line := range bucket . Signature . Stack . Calls { l := 0 if fullPath { l = len ( line . FullSrcLine ( ) ) } else { l = len ( line . SrcLine ( ) ) } if l > srcLen { srcLen = l } l = len ( line . Func . PkgName ( ) ) if l > pkgLen { pkgLen = l } } } return srcLen , pkgLen }
951	func setPortForwarding ( d * Driver , interfaceNum int , mapName , protocol string , guestPort , desiredHostPort int ) ( int , error ) { actualHostPort , err := getAvailableTCPPort ( desiredHostPort ) if err != nil { return - 1 , err } if desiredHostPort != actualHostPort && desiredHostPort != 0 { log . Debugf ( "NAT forwarding host port for guest port %d (%s) changed from %d to %d" , guestPort , mapName , desiredHostPort , actualHostPort ) } cmd := fmt . Sprintf ( "--natpf%d" , interfaceNum ) d . vbm ( "modifyvm" , d . MachineName , cmd , "delete" , mapName ) if err := d . vbm ( "modifyvm" , d . MachineName , cmd , fmt . Sprintf ( "%s,%s,127.0.0.1,%d,,%d" , mapName , protocol , actualHostPort , guestPort ) ) ; err != nil { return - 1 , err } return actualHostPort , nil }
6084	func NewConfig ( ) * Config { return & Config { CollectJobs : 100 , CollectPeriod : 1000 , WorkerBufLen : 10 , Workers : 0 , TypeConfig : TypeConfig { TryLimit : 3 , TryPeriod : 60000 , } , Types : make ( map [ string ] TypeConfig ) , } }
4841	func Register ( scheme Scheme ) { if scheme . Generator == nil { panic ( "must specify Generator when registering Scheme" ) } if scheme . Opaque && scheme . Proto & ProtoUnix != 0 { panic ( "scheme must support only Opaque or Unix protocols, not both" ) } if _ , ok := schemeMap [ scheme . Driver ] ; ok { panic ( fmt . Sprintf ( "scheme %s already registered" , scheme . Driver ) ) } sz := & Scheme { Driver : scheme . Driver , Generator : scheme . Generator , Proto : scheme . Proto , Opaque : scheme . Opaque , Override : scheme . Override , } schemeMap [ scheme . Driver ] = sz var hasShort bool for _ , alias := range scheme . Aliases { if len ( alias ) == 2 { hasShort = true } if scheme . Driver != alias { registerAlias ( scheme . Driver , alias , false ) } } if ! hasShort && len ( scheme . Driver ) > 2 { registerAlias ( scheme . Driver , scheme . Driver [ : 2 ] , false ) } if len ( sz . Aliases ) == 0 || len ( scheme . Driver ) == 2 { sz . Aliases = append ( sz . Aliases , scheme . Driver ) } sort . Sort ( ss ( sz . Aliases ) ) }
3410	func ( o * Options ) GetEnableLogsSample ( ) bool { if o == nil || o . EnableLogsSample == nil { return false } return * o . EnableLogsSample }
1578	func ( m * MockSecretsManagerAPI ) DeleteResourcePolicyRequest ( arg0 * secretsmanager . DeleteResourcePolicyInput ) ( * request . Request , * secretsmanager . DeleteResourcePolicyOutput ) { ret := m . ctrl . Call ( m , "DeleteResourcePolicyRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . DeleteResourcePolicyOutput ) return ret0 , ret1 }
3282	func ( d * Downtime ) HasActive ( ) bool { if d != nil && d . Active != nil { return true } return false }
3317	func ( g * GraphDefinition ) GetIncludeUngroupedHostsOk ( ) ( bool , bool ) { if g == nil || g . IncludeUngroupedHosts == nil { return false , false } return * g . IncludeUngroupedHosts , true }
2767	func flattenLatencySensitivity ( d * schema . ResourceData , obj * types . LatencySensitivity ) error { if obj == nil { log . Printf ( "[WARN] Unable to read LatencySensitivity, skipping" ) return nil } return d . Set ( "latency_sensitivity" , obj . Level ) }
3555	func ( s * SyntheticsTest ) HasModifiedBy ( ) bool { if s != nil && s . ModifiedBy != nil { return true } return false }
2185	func ( v * Allocation ) native ( ) * C . GtkAllocation { return ( * C . GtkAllocation ) ( unsafe . Pointer ( & v . GdkRectangle ) ) }
91	func NewTarget ( labels , discoveredLabels labels . Labels , params url . Values ) * Target { return & Target { labels : labels , discoveredLabels : discoveredLabels , params : params , health : HealthUnknown , } }
6021	func ( t Typed ) InterfaceOr ( key string , d interface { } ) interface { } { if value , exists := t . InterfaceIf ( key ) ; exists { return value } return d }
6284	func ParseRate ( resp * http . Response ) * RateLimit { limit := resp . Header . Get ( headerRateLimit ) path := resp . Header . Get ( headerRatePath ) remain := resp . Header . Get ( headerRateRemaining ) l , _ := strconv . Atoi ( limit ) r , _ := strconv . Atoi ( remain ) return & RateLimit { Limit : l , Path : path , Remaining : r , } }
5725	func ( c * Client ) Increment ( key string , delta uint64 ) ( newValue uint64 , err error ) { return c . incrDecr ( cmdIncr , key , delta ) }
3225	func ( a * APIKey ) GetKey ( ) string { if a == nil || a . Key == nil { return "" } return * a . Key }
6883	func ( w * Window ) printf ( x , y int , a Attributes , format string , args ... interface { } ) { out := fmt . Sprintf ( format , args ... ) xx := 0 c := Cell { } c . Fg = a . Fg c . Bg = a . Bg mx := w . x - x var rw int for i := 0 ; i < len ( out ) ; i += rw { if x + xx + 1 > mx { break } v , width := utf8 . DecodeRuneInString ( out [ i : ] ) if v == '\x1b' { cc , skip , err := DecodeColor ( out [ i : ] ) if err == nil { c . Fg = cc . Fg c . Bg = cc . Bg rw = skip continue } } rw = width c . Ch = v w . setCell ( x + xx , y , c ) xx ++ } }
4318	func ( c * Client ) ParameterizedBuild ( account , repo , branch string , buildParameters map [ string ] string ) ( * Build , error ) { opts := map [ string ] interface { } { "build_parameters" : buildParameters } return c . BuildOpts ( account , repo , branch , opts ) }
365	func ( a * Args ) QueryString ( ) [ ] byte { a . buf = a . AppendBytes ( a . buf [ : 0 ] ) return a . buf }
4989	func ( z * Zpool ) Destroy ( ) error { _ , err := zpool ( "destroy" , z . Name ) return err }
5872	func ( cm * CheckManager ) inventoryMetrics ( ) { availableMetrics := make ( map [ string ] bool ) for _ , metric := range cm . checkBundle . Metrics { availableMetrics [ metric . Name ] = metric . Status == "active" } cm . availableMetricsmu . Lock ( ) cm . availableMetrics = availableMetrics cm . availableMetricsmu . Unlock ( ) }
5509	func ( f * FileLogger ) Printf ( format string , v ... interface { } ) { _ , file , line , _ := runtime . Caller ( 1 ) f . logChan <- fmt . Sprintf ( "[%v:%v]" , shortFileName ( file ) , line ) + fmt . Sprintf ( format , v ... ) }
728	func ( p * AWSSDProvider ) ApplyChanges ( changes * plan . Changes ) error { if len ( changes . Create ) == 0 && len ( changes . Delete ) == 0 && len ( changes . UpdateNew ) == 0 { log . Info ( "All records are already up to date" ) return nil } creates , deletes := p . updatesToCreates ( changes ) changes . Delete = append ( changes . Delete , deletes ... ) changes . Create = append ( changes . Create , creates ... ) namespaces , err := p . ListNamespaces ( ) if err != nil { return err } err = p . submitDeletes ( namespaces , changes . Delete ) if err != nil { return err } err = p . submitCreates ( namespaces , changes . Create ) if err != nil { return err } return nil }
2843	func ( r * CdromSubresource ) Read ( l object . VirtualDeviceList ) error { log . Printf ( "[DEBUG] %s: Reading state" , r ) d , err := r . FindVirtualDevice ( l ) if err != nil { return fmt . Errorf ( "cannot find disk device: %s" , err ) } device , ok := d . ( * types . VirtualCdrom ) if ! ok { return fmt . Errorf ( "device at %q is not a virtual CDROM device" , l . Name ( d ) ) } switch backing := device . Backing . ( type ) { case * types . VirtualCdromRemoteAtapiBackingInfo : r . Set ( "client_device" , true ) case * types . VirtualCdromIsoBackingInfo : dp := & object . DatastorePath { } if ok := dp . FromString ( backing . FileName ) ; ! ok { return fmt . Errorf ( "could not read datastore path in backing %q" , backing . FileName ) } if backing . Datastore != nil { r . Set ( "datastore_id" , backing . Datastore . Value ) } r . Set ( "path" , dp . Path ) default : log . Printf ( "%s: [DEBUG] Unknown CDROM type %T, clearing all attributes" , r , backing ) r . Set ( "datastore_id" , "" ) r . Set ( "path" , "" ) r . Set ( "client_device" , false ) } ctlr , err := findControllerForDevice ( l , d ) if err != nil { return err } if err := r . SaveDevIDs ( d , ctlr ) ; err != nil { return err } log . Printf ( "[DEBUG] %s: Read finished (key and device address may have changed)" , r ) return nil }
4452	func ( h * HexColor ) DeepCopy ( ) * HexColor { if h == nil { return nil } out := new ( HexColor ) h . DeepCopyInto ( out ) return out }
2846	func ( r * CdromSubresource ) mapCdrom ( device * types . VirtualCdrom , l object . VirtualDeviceList ) error { dsID := r . Get ( "datastore_id" ) . ( string ) path := r . Get ( "path" ) . ( string ) clientDevice := r . Get ( "client_device" ) . ( bool ) switch { case dsID != "" && path != "" : ds , err := datastore . FromID ( r . client , dsID ) if err != nil { return fmt . Errorf ( "cannot find datastore: %s" , err ) } dsProps , err := datastore . Properties ( ds ) if err != nil { return fmt . Errorf ( "could not get properties for datastore: %s" , err ) } dsName := dsProps . Name dsPath := & object . DatastorePath { Datastore : dsName , Path : path , } device = l . InsertIso ( device , dsPath . String ( ) ) l . Connect ( device ) return nil case clientDevice == true : device . Backing = & types . VirtualCdromRemoteAtapiBackingInfo { VirtualDeviceRemoteDeviceBackingInfo : types . VirtualDeviceRemoteDeviceBackingInfo { } , } return nil } panic ( fmt . Sprintf ( "%s: no CDROM types specified" , r ) ) }
861	func ( a AzureClient ) GetPublicIPAddress ( resourceGroup , name string , useFqdn bool ) ( string , error ) { f := logutil . Fields { "name" : name } log . Debug ( "Querying public IP address." , f ) ip , err := a . publicIPAddressClient ( ) . Get ( resourceGroup , name , "" ) if err != nil { return "" , err } if ip . Properties == nil { log . Debug ( "publicIP.Properties is nil. Could not determine IP address" , f ) return "" , nil } if useFqdn { log . Debug ( "Will attempt to return FQDN." , f ) if ip . Properties . DNSSettings == nil || ip . Properties . DNSSettings . Fqdn == nil { return "" , errors . New ( "FQDN not found on public IP address" ) } return to . String ( ip . Properties . DNSSettings . Fqdn ) , nil } return to . String ( ip . Properties . IPAddress ) , nil }
356	func QueryRange ( url , query , start , end string , step time . Duration , p printer ) int { config := api . Config { Address : url , } c , err := api . NewClient ( config ) if err != nil { fmt . Fprintln ( os . Stderr , "error creating API client:" , err ) return 1 } var stime , etime time . Time if end == "" { etime = time . Now ( ) } else { etime , err = parseTime ( end ) if err != nil { fmt . Fprintln ( os . Stderr , "error parsing end time:" , err ) return 1 } } if start == "" { stime = etime . Add ( - 5 * time . Minute ) } else { stime , err = parseTime ( start ) if err != nil { fmt . Fprintln ( os . Stderr , "error parsing start time:" , err ) } } if ! stime . Before ( etime ) { fmt . Fprintln ( os . Stderr , "start time is not before end time" ) } if step == 0 { resolution := math . Max ( math . Floor ( etime . Sub ( stime ) . Seconds ( ) / 250 ) , 1 ) step = time . Duration ( resolution ) * time . Second } api := v1 . NewAPI ( c ) r := v1 . Range { Start : stime , End : etime , Step : step } ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Minute ) val , err := api . QueryRange ( ctx , query , r ) cancel ( ) if err != nil { fmt . Fprintln ( os . Stderr , "query error:" , err ) return 1 } p . printValue ( val ) return 0 }
6177	func ( m * Monitor ) VerifyChannelsForInactivity ( ) error { query := ` SELECT channels.id::text FROM channels LEFT JOIN sessions ses ON channels.id = ses.channel LEFT JOIN offerings offer ON channels.offering = offer.id INNER JOIN accounts acc ON channels.agent = acc.eth_addr WHERE channels.service_status IN ('pending', 'active', 'suspended') AND channels.channel_status NOT IN ('pending') AND acc.in_use GROUP BY channels.id, offer.max_inactive_time_sec HAVING GREATEST(MAX(ses.last_usage_time), channels.service_changed_time) + (offer.max_inactive_time_sec * INTERVAL '1 second') < now();` return m . processEachChannel ( query , m . terminateService ) }
4625	func newAlphabet ( s string ) alphabet { abc := dedupe ( strings . Split ( s , "" ) ) if len ( abc ) != 57 { panic ( "encoding alphabet is not 57-bytes long" ) } sort . Strings ( abc ) a := alphabet { len : int64 ( len ( abc ) ) , } copy ( a . chars [ : ] , abc ) return a }
5659	func GenerateFromPassword ( salt [ ] byte , password [ ] byte , cost int ) ( [ ] byte , error ) { if len ( salt ) != maxSaltSize { return nil , fmt . Errorf ( "Salt len must be %v" , maxSaltSize ) } p , err := newFromPassword ( salt , password , cost ) if err != nil { return nil , err } return p . Hash ( ) , nil }
4833	func hookName ( h hookHandler ) string { for name , handler := range handlers { if handler == h { return name } } return "" }
4406	func ( u URI ) MarshalJSON ( ) ( [ ] byte , error ) { var w jwriter . Writer u . MarshalEasyJSON ( & w ) return w . BuildBytes ( ) }
4137	func ( n NetworkNumber ) Previous ( ) NetworkNumber { newIP := make ( NetworkNumber , len ( n ) ) copy ( newIP , n ) for i := len ( newIP ) - 1 ; i >= 0 ; i -- { newIP [ i ] -- if newIP [ i ] < math . MaxUint32 { break } } return newIP }
3031	func lookupProject ( ) ( string , error ) { req , err := http . NewRequest ( "GET" , "http://metadata.google.internal/computeMetadata/v1/project/project-id" , nil ) if err != nil { return "" , err } req . Header . Add ( "Metadata-Flavor" , "Google" ) resp , err := http . DefaultClient . Do ( req ) if err != nil { return "" , err } defer resp . Body . Close ( ) if resp . StatusCode != 200 { return "" , fmt . Errorf ( "discover-gce: invalid status code %d when fetching project id" , resp . StatusCode ) } project , err := ioutil . ReadAll ( resp . Body ) if err != nil { return "" , err } return string ( project ) , nil }
2308	func ( v * TreeStore ) native ( ) * C . GtkTreeStore { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeStore ( p ) }
5507	func ( f * FileLogger ) Close ( ) error { close ( f . logChan ) f . lg = nil return f . logFile . Close ( ) }
6036	func ( t * LogTopics ) Scan ( src interface { } ) error { somcData , ok := src . ( [ ] byte ) if ! ok { return fmt . Errorf ( "type assertion .([]byte) failed, actual type is %T" , src , ) } return json . Unmarshal ( somcData , & t ) }
5073	func ( r * Runner ) Run ( ops [ ] Op , id bson . ObjectId , info interface { } ) ( err error ) { const efmt = "error in transaction op %d: %s" for i := range ops { op := & ops [ i ] if op . C == "" || op . Id == nil { return fmt . Errorf ( efmt , i , "C or Id missing" ) } changes := 0 if op . Insert != nil { changes ++ } if op . Update != nil { changes ++ } if op . Remove { changes ++ } if changes > 1 { return fmt . Errorf ( efmt , i , "more than one of Insert/Update/Remove set" ) } if changes == 0 && op . Assert == nil { return fmt . Errorf ( efmt , i , "none of Assert/Insert/Update/Remove set" ) } } if id == "" { id = bson . NewObjectId ( ) } t := transaction { Id : id , Ops : ops , State : tpreparing , Info : info , } if err = r . tc . Insert ( & t ) ; err != nil { return err } if err = flush ( r , & t ) ; err != nil { return err } if t . State == taborted { return ErrAborted } else if t . State != tapplied { panic ( fmt . Errorf ( "invalid state for %s after flush: %q" , & t , t . State ) ) } return nil }
3526	func ( s * SyntheticsOptions ) GetFollowRedirects ( ) bool { if s == nil || s . FollowRedirects == nil { return false } return * s . FollowRedirects }
243	func QueryableClient ( c * Client ) storage . Queryable { remoteReadQueries . WithLabelValues ( c . Name ( ) ) return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { return & querier { ctx : ctx , mint : mint , maxt : maxt , client : c , } , nil } ) }
1920	func ( m * MockFileSystem ) MkdirAll ( arg0 string , arg1 os . FileMode ) error { ret := m . ctrl . Call ( m , "MkdirAll" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
7121	func Convert ( val interface { } , targetType reflect . Type ) reflect . Value { value := reflect . ValueOf ( val ) if ! value . IsValid ( ) { return reflect . Zero ( targetType ) } valType := value . Type ( ) if valType . ConvertibleTo ( targetType ) { return value . Convert ( targetType ) } interfaceVal := value . Interface ( ) switch realVal := interfaceVal . ( type ) { case float64 : return reflect . ValueOf ( realVal ) . Convert ( targetType ) case [ ] interface { } : sliceSize := len ( realVal ) targetSlice := reflect . MakeSlice ( targetType , 0 , sliceSize ) elemType := targetType . Elem ( ) for i := 0 ; i < sliceSize ; i ++ { targetSlice = reflect . Append ( targetSlice , Convert ( value . Index ( i ) , elemType ) ) } return targetSlice } panic ( fmt . Errorf ( "convert from type %v to %v failed: %v" , valType , targetType , value ) ) }
1356	func ( agent * ecsAgent ) reregisterContainerInstance ( client api . ECSClient , capabilities [ ] * ecs . Attribute , tags [ ] * ecs . Tag , registrationToken string , platformDevices [ ] * ecs . PlatformDevice ) error { _ , availabilityZone , err := client . RegisterContainerInstance ( agent . containerInstanceARN , capabilities , tags , registrationToken , platformDevices ) agent . availabilityZone = availabilityZone if err == nil { return nil } seelog . Errorf ( "Error re-registering: %v" , err ) if apierrors . IsInstanceTypeChangedError ( err ) { seelog . Criticalf ( instanceTypeMismatchErrorFormat , err ) return err } if _ , ok := err . ( apierrors . AttributeError ) ; ok { seelog . Critical ( "Instance re-registration attempt with an invalid attribute" ) return err } return transientError { err } }
4931	func ( w * Writer ) WriteFloat64 ( f float64 ) { if w . err != nil { return } bits := math . Float64bits ( f ) binary . LittleEndian . PutUint64 ( w . b [ : 8 ] , bits ) w . wr . Write ( w . b [ : 8 ] ) }
3024	func MoveObjectTo ( ref types . ManagedObjectReference , folder * object . Folder ) error { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := folder . MoveInto ( ctx , [ ] types . ManagedObjectReference { ref } ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) return task . Wait ( tctx ) }
6121	func ReadFile ( name string ) ( [ ] byte , error ) { fs , err := fs . New ( ) if err != nil { return nil , ErrOpenFS } file , err := fs . Open ( name ) if err != nil { return nil , ErrOpenFile } defer file . Close ( ) data , err := ioutil . ReadAll ( file ) if err != nil { return nil , ErrReadFile } return data , nil }
4138	func NewNetwork ( ipNet net . IPNet ) Network { return Network { IPNet : ipNet , Number : NewNetworkNumber ( ipNet . IP ) , Mask : NetworkNumberMask ( NewNetworkNumber ( net . IP ( ipNet . Mask ) ) ) , } }
5038	func ( s * Session ) FsyncUnlock ( ) error { return s . DB ( "admin" ) . C ( "$cmd.sys.unlock" ) . Find ( nil ) . One ( nil ) }
4376	func IPv4Value ( v * strfmt . IPv4 ) strfmt . IPv4 { if v == nil { return strfmt . IPv4 ( "" ) } return * v }
6117	func Parse ( config * Config ) ( Interface , error ) { switch config . Mechanism { case "any" : return any ( config ) , nil case "upnp" : return uPnP ( config ) , nil case "pmp" : return pmp ( ) , nil default : return nil , ErrBadMechanism } }
1417	func ( m * MockSaveableOption ) AddSaveable ( arg0 string , arg1 statemanager . Saveable ) statemanager . Option { ret := m . ctrl . Call ( m , "AddSaveable" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( statemanager . Option ) return ret0 }
1622	func ( m * MockSecretsManagerAPI ) UpdateSecretVersionStage ( arg0 * secretsmanager . UpdateSecretVersionStageInput ) ( * secretsmanager . UpdateSecretVersionStageOutput , error ) { ret := m . ctrl . Call ( m , "UpdateSecretVersionStage" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UpdateSecretVersionStageOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2113	func formatURL ( endpoint string , cluster string , containerInstance string ) string { tcsURL := endpoint if ! strings . HasSuffix ( tcsURL , "/" ) { tcsURL += "/" } query := url . Values { } query . Set ( "cluster" , cluster ) query . Set ( "containerInstance" , containerInstance ) return tcsURL + "ws?" + query . Encode ( ) }
4141	func ( n Network ) Covers ( o Network ) bool { if len ( n . Number ) != len ( o . Number ) { return false } nMaskSize , _ := n . IPNet . Mask . Size ( ) oMaskSize , _ := o . IPNet . Mask . Size ( ) return n . Contains ( o . Number ) && nMaskSize <= oMaskSize }
5568	func ( o * UpdateVMWithStateOK ) WithPayload ( payload string ) * UpdateVMWithStateOK { o . Payload = payload return o }
6904	func ( l * List ) Append ( format string , args ... interface { } ) { s := fmt . Sprintf ( format , args ... ) l . content = append ( l . content , s ) if l . paging { return } l . at = len ( l . content ) - l . trueH if l . at < 0 { l . at = 0 } }
7300	func ( tx Tx ) Update ( k [ ] [ ] byte , f func ( bytesp . Slice ) ( bytesp . Slice , error ) ) error { b , err := tx . CreateBucketIfNotExists ( k [ : len ( k ) - 1 ] ) if err != nil { return err } v , err := f ( b . Bucket . Get ( k [ len ( k ) - 1 ] ) ) if err != nil { return errorsp . WithStacks ( err ) } if v == nil { return errorsp . WithStacks ( b . Bucket . Delete ( k [ len ( k ) - 1 ] ) ) } return errorsp . WithStacks ( b . Bucket . Put ( k [ len ( k ) - 1 ] , v ) ) }
1238	func ( client * cniClient ) Capabilities ( name string ) ( [ ] string , error ) { file := filepath . Join ( client . pluginsPath , name ) _ , err := os . Stat ( file ) if err != nil { return nil , errors . Wrapf ( err , "ecscni: unable to describe file info for '%s'" , file ) } cmd := exec . Command ( file , capabilitiesCommand ) capabilitiesInfo , err := cmd . Output ( ) if err != nil { return nil , errors . Wrapf ( err , "ecscni: failed invoking capabilities command for '%s'" , name ) } capabilities := & struct { Capabilities [ ] string `json:"capabilities"` } { } err = json . Unmarshal ( capabilitiesInfo , capabilities ) if err != nil { return nil , errors . Wrapf ( err , "ecscni: failed to unmarshal capabilities for '%s' from string: %s" , name , capabilitiesInfo ) } return capabilities . Capabilities , nil }
928	func ( b * B2dUtils ) DownloadISO ( dir , file , isoURL string ) error { log . Infof ( "Downloading %s from %s..." , b . path ( ) , isoURL ) return b . download ( dir , file , isoURL ) }
1938	func ( m * MockTaskEngineState ) ContainerByID ( arg0 string ) ( * container . DockerContainer , bool ) { ret := m . ctrl . Call ( m , "ContainerByID" , arg0 ) ret0 , _ := ret [ 0 ] . ( * container . DockerContainer ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 }
6098	func ReadUintSetting ( db * reform . Querier , key string ) ( uint , error ) { val , err := ReadSetting ( db , key ) if err != nil { return 0 , err } val2 , err := strconv . ParseUint ( val , 10 , 32 ) if err != nil { return 0 , newSettingParseError ( key , err ) } return uint ( val2 ) , nil }
5570	func ( o * OrderVMByFilterParams ) WithContext ( ctx context . Context ) * OrderVMByFilterParams { o . SetContext ( ctx ) return o }
6145	func ( b * backendInstance ) PSCAddress ( ) common . Address { return common . HexToAddress ( b . cfg . Contract . PSCAddrHex ) }
3663	func ( w * Widget ) HasBgcolor ( ) bool { if w != nil && w . Bgcolor != nil { return true } return false }
3205	func ( client * Client ) GetUsers ( ) ( users [ ] User , err error ) { var udata usersData uri := "/v1/user" err = client . doJsonRequest ( "GET" , uri , nil , & udata ) users = udata . Users return }
4710	func ( l * line ) isAction ( ) bool { str := strings . TrimSpace ( l . str ) return strings . HasPrefix ( str , l . opts . DelimLeft ) && strings . HasSuffix ( str , l . opts . DelimRight ) }
1223	func ( imageState * ImageState ) GetPullSucceeded ( ) bool { imageState . lock . RLock ( ) defer imageState . lock . RUnlock ( ) return imageState . PullSucceeded }
2633	func ( s MoRefSorter ) Less ( i , j int ) bool { return s [ i ] . Value < s [ j ] . Value }
252	func ( a * Alert ) ResolvedAt ( ts time . Time ) bool { if a . EndsAt . IsZero ( ) { return false } return ! a . EndsAt . After ( ts ) }
5140	func ( ui * BasicUI ) Log ( message string ) { timeString := time . Now ( ) . Format ( timeFormat ) message = timeString + ": " + message ui . Output ( message ) }
1105	func explode ( pairs [ ] * dep . KeyPair ) ( map [ string ] interface { } , error ) { m := make ( map [ string ] interface { } ) for _ , pair := range pairs { if err := explodeHelper ( m , pair . Key , pair . Value , pair . Key ) ; err != nil { return nil , errors . Wrap ( err , "explode" ) } } return m , nil }
540	func ( c * Cookie ) SetKeyBytes ( key [ ] byte ) { c . key = append ( c . key [ : 0 ] , key ... ) }
1535	func validateIPRules ( ) error { var iptable * iptables . IPTables var err error if iptable , err = iptables . NewWithProtocol ( iptables . ProtocolIPv4 ) ; err != nil { return err } str , _ := iptable . ListChains ( "nat" ) fmt . Printf ( "List Chains:%v" , str ) strs , _ := iptable . Stats ( "nat" , ingressChain ) for _ , str = range strs { fmt . Printf ( "Ingress chain stats:%v" , str ) } strs , _ = iptable . Stats ( "nat" , egressChain ) for _ , str = range strs { fmt . Printf ( "Egress chain stats:%v" , str ) } if exist , err := iptable . Exists ( "nat" , ingressChain , "-p" , "tcp" , "-m" , "multiport" , "--dports" , appPorts , "-j" , "REDIRECT" , "--to-port" , proxyIngressPort ) ; ! exist { return fmt . Errorf ( "failed to set rules to redirect app ports to proxy: %v\n" , \n ) } err if exist , err := iptable . Exists ( "nat" , "PREROUTING" , "-p" , "tcp" , "-m" , "addrtype" , "!" , "--src-type" , "LOCAL" , "-j" , ingressChain ) ; ! exist { return fmt . Errorf ( "failed to set rule to jump from PREROUTING to ingress chain: %v\n" , \n ) } err if exist , err := iptable . Exists ( "nat" , egressChain , "-m" , "owner" , "--gid-owner" , gid , "-j" , "RETURN" ) ; ! exist { return fmt . Errorf ( "failed to set ignoredGID: %v\n" , \n ) } err if exist , err := iptable . Exists ( "nat" , egressChain , "-p" , "tcp" , "-m" , "multiport" , "--dports" , egressIgnoredPorts , "-j" , "RETURN" ) ; ! exist { return fmt . Errorf ( "failed to set egressIgnoredPorts: %v\n" , \n ) } err }
5719	func ( c * Client ) Get ( key string ) ( * Item , error ) { cn , err := c . sendCommand ( key , cmdGet , nil , 0 , nil ) if err != nil { return nil , err } return c . parseItemResponse ( key , cn , true ) }
6471	func ( b * Bundle ) Add ( f func ( context . Context ) error ) { b . waitGroup . Add ( 1 ) go func ( ) { defer b . waitGroup . Done ( ) err := f ( b . context ) if err == nil { return } b . errorOnce . Do ( func ( ) { b . firstError = err b . cancel ( ) } ) } ( ) }
2636	func availableScsiDisk ( dss * object . HostDatastoreSystem , name string ) ( * types . HostScsiDisk , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) disks , err := dss . QueryAvailableDisksForVmfs ( ctx ) if err != nil { return nil , fmt . Errorf ( "cannot query available disks: %s" , err ) } var disk * types . HostScsiDisk for _ , d := range disks { if d . CanonicalName == name { disk = & d break } } if disk == nil { return nil , fmt . Errorf ( "%s does not seem to be a disk available for VMFS" , name ) } return disk , nil }
4812	func ( r * Repo ) pull ( ) error { if ! r . pulled { return r . clone ( ) } if r . Branch == latestTag { return r . checkoutLatestTag ( ) } params := append ( [ ] string { "pull" } , append ( r . PullArgs , "origin" , r . Branch ) ... ) var err error if err = r . gitCmd ( params , r . Path ) ; err == nil { r . pulled = true r . lastPull = time . Now ( ) Logger ( ) . Printf ( "%v pulled.\n" , \n ) r . URL } r . lastCommit , err = r . mostRecentCommit ( ) }
2506	func ( c * drawTrianglesCommand ) CanMerge ( dst , src * Image , color * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) bool { if c . dst != dst { return false } if c . src != src { return false } if ! c . color . Equals ( color ) { return false } if c . mode != mode { return false } if c . filter != filter { return false } if c . address != address { return false } return true }
3214	func ( c * Client ) SetKeys ( apiKey , appKey string ) { c . apiKey = apiKey c . appKey = appKey }
7026	func GetParam ( ctx context . Context , name string ) Param { n := paramName ( name ) if p , ok := ctx . Value ( n ) . ( Param ) ; ok { return p } return "" }
2264	func ( v * OffscreenWindow ) native ( ) * C . GtkOffscreenWindow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkOffscreenWindow ( p ) }
1172	func ( payloadHandler * payloadRequestHandler ) handleUnrecognizedTask ( task * ecsacs . Task , err error , payload * ecsacs . PayloadMessage ) { seelog . Warnf ( "Received unexpected acs message, messageID: %s, task: %v, err: %v" , aws . StringValue ( payload . MessageId ) , aws . StringValue ( task . Arn ) , err ) if aws . StringValue ( task . Arn ) == "" { seelog . Criticalf ( "Received task with no arn, messageId: %s" , aws . StringValue ( payload . MessageId ) ) return } taskEvent := api . TaskStateChange { TaskARN : * task . Arn , Status : apitaskstatus . TaskStopped , Reason : UnrecognizedTaskError { err } . Error ( ) , Task : & apitask . Task { } , } payloadHandler . taskHandler . AddStateChangeEvent ( taskEvent , payloadHandler . ecsClient ) }
3122	func newPubSub ( client * pubsub . Client , name string , options * Options , store func ( * points . Points ) ) ( * PubSub , error ) { logger := zapwriter . Logger ( name ) logger . Info ( "starting google pubsub receiver" , zap . String ( "project" , options . Project ) , zap . String ( "subscription" , options . Subscription ) , ) if options . Project == "" { return nil , fmt . Errorf ( "'project' must be specified" ) } ctx := context . Background ( ) if client == nil { c , err := pubsub . NewClient ( ctx , options . Project ) if err != nil { return nil , err } client = c } sub := client . Subscription ( options . Subscription ) exists , err := sub . Exists ( ctx ) if err != nil { return nil , err } if ! exists { return nil , fmt . Errorf ( "subscription %s in project %s does not exist" , options . Subscription , options . Project ) } if options . ReceiverGoRoutines != 0 { sub . ReceiveSettings . NumGoroutines = options . ReceiverGoRoutines } if options . ReceiverMaxBytes != 0 { sub . ReceiveSettings . MaxOutstandingBytes = options . ReceiverMaxBytes } if options . ReceiverMaxMessages != 0 { sub . ReceiveSettings . MaxOutstandingMessages = options . ReceiverMaxMessages } cctx , cancel := context . WithCancel ( ctx ) rcv := & PubSub { out : store , name : name , client : client , cancel : cancel , subscription : sub , logger : logger , closed : make ( chan struct { } ) , } go func ( ) { for { err := rcv . subscription . Receive ( cctx , func ( ctx context . Context , m * pubsub . Message ) { rcv . handleMessage ( m ) m . Ack ( ) } ) if err == context . Canceled { close ( rcv . closed ) rcv . Stop ( ) break } if err != nil { rcv . logger . Error ( err . Error ( ) ) } time . Sleep ( 1 * time . Second ) } } ( ) return rcv , nil }
5805	func ( a * API ) FetchAcknowledgements ( ) ( * [ ] Acknowledgement , error ) { result , err := a . Get ( config . AcknowledgementPrefix ) if err != nil { return nil , err } var acknowledgements [ ] Acknowledgement if err := json . Unmarshal ( result , & acknowledgements ) ; err != nil { return nil , err } return & acknowledgements , nil }
5050	func ( s * Session ) DatabaseNames ( ) ( names [ ] string , err error ) { var result dbNames err = s . Run ( "listDatabases" , & result ) if err != nil { return nil , err } for _ , db := range result . Databases { if ! db . Empty { names = append ( names , db . Name ) } } sort . Strings ( names ) return names , nil }
7011	func ( i * IrcText ) SetFg ( c int ) * IrcText { i . fgColor = c return i }
4807	func ( s * services ) add ( r * repoService ) { s . Lock ( ) defer s . Unlock ( ) s . services = append ( s . services , r ) }
5915	func NewArena ( size uint32 ) * Arena { out := & Arena { n : 1 , buf : make ( [ ] byte , size ) , } return out }
4720	func AddRelayTransport ( ctx context . Context , h host . Host , upgrader * tptu . Upgrader , opts ... RelayOpt ) error { n , ok := h . Network ( ) . ( tpt . Network ) if ! ok { return fmt . Errorf ( "%v is not a transport network" , h . Network ( ) ) } r , err := NewRelay ( ctx , h , upgrader , opts ... ) if err != nil { return err } if err := n . AddTransport ( r . Transport ( ) ) ; err != nil { log . Error ( "failed to add relay transport:" , err ) } else if err := n . Listen ( r . Listener ( ) . Multiaddr ( ) ) ; err != nil { log . Error ( "failed to listen on relay transport:" , err ) } return nil }
1474	func ( c * Container ) SetFinishedAt ( finishedAt time . Time ) { if finishedAt . IsZero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . finishedAt = finishedAt }
6325	func Contains ( s string , substrs [ ] string ) bool { for _ , substr := range substrs { if strings . Contains ( s , substr ) { return true } } return false }
1395	func ContainerAssociationHandler ( state dockerstate . TaskEngineState ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 container associations handler: unable to get task arn from request: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociation ) return } associationType , err := getAssociationTypeByRequest ( r ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 container associations handler: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociation ) return } associationName , err := getAssociationNameByRequest ( r ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( "V3 container associations handler: %s" , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociation ) return } seelog . Infof ( "V3 container association handler: writing response for association '%s' of type %s" , associationName , associationType ) writeContainerAssociationResponse ( w , taskARN , associationType , associationName , state ) } }
5095	func Delete ( c * gin . Context ) { db := c . MustGet ( "db" ) . ( * mgo . Database ) query := bson . M { "_id" : bson . ObjectIdHex ( c . Param ( "_id" ) ) } err := db . C ( models . CollectionArticle ) . Remove ( query ) if err != nil { c . Error ( err ) } c . Redirect ( http . StatusMovedPermanently , "/articles" ) }
2402	func IsKeyJustReleased ( key ebiten . Key ) bool { theInputState . m . RLock ( ) r := theInputState . keyDurations [ key ] == 0 && theInputState . prevKeyDurations [ key ] > 0 theInputState . m . RUnlock ( ) return r }
6069	func ( c * Client ) Ping ( ) error { _ , err := c . client . Head ( c . url ( ) ) return err }
3879	func lintName ( name string , initialisms map [ string ] bool ) ( should string ) { if name == "_" { return name } if strings . IndexFunc ( name , func ( r rune ) bool { return ! unicode . IsLower ( r ) } ) == - 1 { return name } runes := [ ] rune ( name ) w , i := 0 , 0 for i + 1 <= len ( runes ) { eow := false if i + 1 == len ( runes ) { eow = true } else if runes [ i + 1 ] == '_' && i + 1 != len ( runes ) - 1 { eow = true n := 1 for i + n + 1 < len ( runes ) && runes [ i + n + 1 ] == '_' { n ++ } if i + n + 1 < len ( runes ) && unicode . IsDigit ( runes [ i ] ) && unicode . IsDigit ( runes [ i + n + 1 ] ) { n -- } copy ( runes [ i + 1 : ] , runes [ i + n + 1 : ] ) runes = runes [ : len ( runes ) - n ] } else if unicode . IsLower ( runes [ i ] ) && ! unicode . IsLower ( runes [ i + 1 ] ) { eow = true } i ++ if ! eow { continue } word := string ( runes [ w : i ] ) if u := strings . ToUpper ( word ) ; initialisms [ u ] { if w == 0 && unicode . IsLower ( runes [ w ] ) { u = strings . ToLower ( u ) } copy ( runes [ w : ] , [ ] rune ( u ) ) } else if w > 0 && strings . ToLower ( word ) == word { runes [ w ] = unicode . ToUpper ( runes [ w ] ) } w = i } return string ( runes ) }
5228	func ( f * Field ) SetIntValue ( colIDOrKey interface { } , value int ) * PQLBaseQuery { colStr , err := formatIDKey ( colIDOrKey ) if err != nil { return NewPQLBaseQuery ( "" , f . index , err ) } q := fmt . Sprintf ( "Set(%s, %s=%d)" , colStr , f . name , value ) return NewPQLBaseQuery ( q , f . index , nil ) }
1974	func ( m * MockClient ) ContainerStart ( arg0 context . Context , arg1 string , arg2 types . ContainerStartOptions ) error { ret := m . ctrl . Call ( m , "ContainerStart" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
149	func ( r * Result ) Vector ( ) ( Vector , error ) { if r . Err != nil { return nil , r . Err } v , ok := r . Value . ( Vector ) if ! ok { return nil , errors . New ( "query result is not a Vector" ) } return v , nil }
6513	func ( c Client ) CreateButton ( params * Button ) ( * Button , error ) { finalParams := & struct { Button * Button `json:"button"` } { Button : params , } holder := buttonHolder { } if err := c . Post ( "buttons" , finalParams , & holder ) ; err != nil { return nil , err } if err := checkApiErrors ( holder . response , "CreateButton" ) ; err != nil { return nil , err } button := holder . Button button . EmbedHtml = "<div class=\"coinbase-button\" data-code=\"" + \" + \" \" }
2405	func MouseButtonPressDuration ( button ebiten . MouseButton ) int { theInputState . m . RLock ( ) s := theInputState . mouseButtonDurations [ button ] theInputState . m . RUnlock ( ) return s }
609	func NewCompressor ( level int , types ... string ) * Compressor { allowedTypes := make ( map [ string ] bool ) if len ( types ) > 0 { for _ , t := range types { allowedTypes [ t ] = true } } else { for _ , t := range defaultCompressibleContentTypes { allowedTypes [ t ] = true } } c := & Compressor { level : level , encoders : make ( map [ string ] EncoderFunc ) , pooledEncoders : make ( map [ string ] * sync . Pool ) , allowedTypes : allowedTypes , } c . SetEncoder ( "deflate" , encoderDeflate ) c . SetEncoder ( "gzip" , encoderGzip ) return c }
5045	func ( q * Query ) Skip ( n int ) * Query { q . m . Lock ( ) q . op . skip = int32 ( n ) q . m . Unlock ( ) return q }
3456	func ( q * QueryConfig ) GetQueryIsFailedOk ( ) ( bool , bool ) { if q == nil || q . QueryIsFailed == nil { return false , false } return * q . QueryIsFailed , true }
4595	func ( s * Stack ) equal ( r * Stack ) bool { if len ( s . Calls ) != len ( r . Calls ) || s . Elided != r . Elided { return false } for i := range s . Calls { if ! s . Calls [ i ] . equal ( & r . Calls [ i ] ) { return false } } return true }
3860	func ( c * Cursor ) Replace ( input string ) { c . input = [ ] rune ( input ) c . End ( ) }
6772	func ( r * PEXReactor ) Receive ( chID byte , src * Peer , msgBytes [ ] byte ) { srcAddr := src . Connection ( ) . RemoteAddress srcAddrStr := srcAddr . String ( ) r . IncrementMsgCountForPeer ( srcAddrStr ) if r . ReachedMaxMsgCountForPeer ( srcAddrStr ) { log . Warn ( "Maximum number of messages reached for peer" , "peer" , srcAddrStr ) return } _ , msg , err := DecodeMessage ( msgBytes ) if err != nil { log . Warn ( "Error decoding message" , "error" , err ) return } log . Notice ( "Received message" , "msg" , msg ) switch msg := msg . ( type ) { case * pexRequestMessage : r . SendAddrs ( src , r . book . GetSelection ( ) ) case * pexAddrsMessage : for _ , addr := range msg . Addrs { if addr != nil { r . book . AddAddress ( addr , srcAddr ) } } default : log . Warn ( fmt . Sprintf ( "Unknown message type %v" , reflect . TypeOf ( msg ) ) ) } }
2571	func ReadNetworkInterfaceTypes ( l object . VirtualDeviceList ) ( [ ] string , error ) { log . Printf ( "[DEBUG] ReadNetworkInterfaceTypes: Fetching interface types" ) devices := l . Select ( func ( device types . BaseVirtualDevice ) bool { if _ , ok := device . ( types . BaseVirtualEthernetCard ) ; ok { return true } return false } ) log . Printf ( "[DEBUG] ReadNetworkInterfaceTypes: Network devices located: %s" , DeviceListString ( devices ) ) devSort := virtualDeviceListSorter { Sort : devices , DeviceList : l , } sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( "[DEBUG] ReadNetworkInterfaceTypes: Network devices order after sort: %s" , DeviceListString ( devices ) ) var out [ ] string for _ , device := range devices { out = append ( out , virtualEthernetCardString ( device . ( types . BaseVirtualEthernetCard ) ) ) } log . Printf ( "[DEBUG] ReadNetworkInterfaceTypes: Network types returned: %+v" , out ) return out , nil }
5997	func ( ds * DNSServer ) SetSRV ( service , protocol string , srvs [ ] SRVRecord ) { ds . srvMutex . Lock ( ) ds . srvRecords [ ds . qualifySrv ( service , protocol ) ] = ds . qualifySrvHosts ( srvs ) ds . srvMutex . Unlock ( ) }
1095	func secretFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( * dep . Secret , error ) { return func ( s ... string ) ( * dep . Secret , error ) { var result * dep . Secret if len ( s ) == 0 { return result , nil } path , rest := s [ 0 ] , s [ 1 : ] data := make ( map [ string ] interface { } ) for _ , str := range rest { parts := strings . SplitN ( str , "=" , 2 ) if len ( parts ) != 2 { return result , fmt . Errorf ( "not k=v pair %q" , str ) } k , v := strings . TrimSpace ( parts [ 0 ] ) , strings . TrimSpace ( parts [ 1 ] ) data [ k ] = v } var d dep . Dependency var err error if len ( rest ) == 0 { d , err = dep . NewVaultReadQuery ( path ) } else { d , err = dep . NewVaultWriteQuery ( path , data ) } if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { result = value . ( * dep . Secret ) return result , nil } missing . Add ( d ) return result , nil } }
4475	func ( d Duration ) Value ( ) ( driver . Value , error ) { return driver . Value ( int64 ( d ) ) , nil }
724	func ( p * PDNSProvider ) mutateRecords ( endpoints [ ] * endpoint . Endpoint , changetype pdnsChangeType ) error { zonelist , err := p . ConvertEndpointsToZones ( endpoints , changetype ) if err != nil { return err } for _ , zone := range zonelist { jso , err := json . Marshal ( zone ) if err != nil { log . Errorf ( "JSON Marshal for zone struct failed!" ) } else { log . Debugf ( "Struct for PatchZone:\n%s" , \n ) } string ( jso ) resp , err := p . client . PatchZone ( zone . Id , zone ) } if err != nil { log . Debugf ( "PDNS API response: %s" , stringifyHTTPResponseBody ( resp ) ) return err } }
3657	func ( w * Widget ) HasAlertID ( ) bool { if w != nil && w . AlertID != nil { return true } return false }
6458	func ( l * Log ) SetAlsoLogToStderr ( f bool ) { l . mu . Lock ( ) defer l . mu . Unlock ( ) l . alsoToStderr = f }
6470	func ( l * Log ) flushAll ( ) { for s := FatalLog ; s >= InfoLog ; s -- { file := l . file [ s ] if file != nil { file . Flush ( ) file . Sync ( ) } } }
834	func deviceFlowAuth ( oauthCfg azure . OAuthConfig , clientID , resource string ) ( * azure . ServicePrincipalToken , error ) { cl := oauthClient ( ) deviceCode , err := azure . InitiateDeviceAuth ( & cl , oauthCfg , clientID , resource ) if err != nil { return nil , fmt . Errorf ( "Failed to start device auth: %v" , err ) } log . Debug ( "Retrieved device code." , logutil . Fields { "expires_in" : to . Int64 ( deviceCode . ExpiresIn ) , "interval" : to . Int64 ( deviceCode . Interval ) , } ) log . Infof ( "Microsoft Azure: %s" , to . String ( deviceCode . Message ) ) token , err := azure . WaitForUserCompletion ( & cl , deviceCode ) if err != nil { return nil , fmt . Errorf ( "Failed to complete device auth: %v" , err ) } spt , err := azure . NewServicePrincipalTokenFromManualToken ( oauthCfg , clientID , resource , * token ) if err != nil { return nil , fmt . Errorf ( "Error constructing service principal token: %v" , err ) } return spt , nil }
6587	func EnableSvcNotifications ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "ENABLE_SVC_NOTIFICATIONS" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
3155	func NewWhisper ( rootPath string , schemas WhisperSchemas , aggregation * WhisperAggregation , recv func ( chan bool ) string , pop func ( string ) ( * points . Points , bool ) , confirm func ( * points . Points ) ) * Whisper { return & Whisper { recv : recv , pop : pop , confirm : confirm , schemas : schemas , aggregation : aggregation , workersCount : 1 , rootPath : rootPath , maxUpdatesPerSecond : 0 , logger : zapwriter . Logger ( "persister" ) , createLogger : zapwriter . Logger ( "whisper:new" ) , } }
1691	func ( authProvider * ecrAuthProvider ) IsTokenValid ( authData * ecrapi . AuthorizationData ) bool { if authData == nil || authData . ExpiresAt == nil { return false } refreshTime := aws . TimeValue ( authData . ExpiresAt ) . Add ( - 1 * retry . AddJitter ( MinimumJitterDuration , MinimumJitterDuration ) ) return time . Now ( ) . Before ( refreshTime ) }
364	func ( a * Args ) ParseBytes ( b [ ] byte ) { a . Reset ( ) var s argsScanner s . b = b var kv * argsKV a . args , kv = allocArg ( a . args ) for s . next ( kv ) { if len ( kv . key ) > 0 || len ( kv . value ) > 0 { a . args , kv = allocArg ( a . args ) } } a . args = releaseArg ( a . args ) }
2587	func Create ( c * govmomi . Client , f * object . Folder , s types . VirtualMachineConfigSpec , p * object . ResourcePool , h * object . HostSystem ) ( * object . VirtualMachine , error ) { log . Printf ( "[DEBUG] Creating virtual machine %q" , fmt . Sprintf ( "%s/%s" , f . InventoryPath , s . Name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var task * object . Task vc , err := vappcontainer . FromID ( c , p . Reference ( ) . Value ) if err != nil { if ! viapi . IsManagedObjectNotFoundError ( err ) { return nil , err } task , err = f . CreateVM ( ctx , s , p , h ) } else { task , err = vc . CreateChildVM ( ctx , s , h ) } if err != nil { return nil , err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) result , err := task . WaitForResult ( tctx , nil ) if err != nil { return nil , err } log . Printf ( "[DEBUG] Virtual machine %q: creation complete (MOID: %q)" , fmt . Sprintf ( "%s/%s" , f . InventoryPath , s . Name ) , result . Result . ( types . ManagedObjectReference ) . Value ) return FromMOID ( c , result . Result . ( types . ManagedObjectReference ) . Value ) }
6056	func ( c DBConfig ) ConnStr ( ) string { comps := [ ] string { } for k , v := range c . Conn { comps = append ( comps , k + "=" + v ) } return strings . Join ( comps , " " ) }
821	func ( d * Driver ) Restart ( ) error { cs := d . client ( ) _ , err := cs . RequestWithContext ( context . TODO ( ) , & egoscale . RebootVirtualMachine { ID : d . ID , } ) return err }
1053	func ( c * Child ) Command ( ) string { list := append ( [ ] string { c . command } , c . args ... ) return strings . Join ( list , " " ) }
348	func ( r * ewmaRate ) rate ( ) float64 { r . mutex . Lock ( ) defer r . mutex . Unlock ( ) return r . lastRate }
5503	func ( f * FileLogger ) initLoggerBySize ( ) { f . mu . Lock ( ) defer f . mu . Unlock ( ) logFile := joinFilePath ( f . fileDir , f . fileName ) for i := 1 ; i <= f . fileCount ; i ++ { if ! isExist ( logFile + "." + strconv . Itoa ( i ) ) { break } f . suffix = i } if ! f . isMustSplit ( ) { if ! isExist ( f . fileDir ) { os . Mkdir ( f . fileDir , 0755 ) } f . logFile , _ = os . OpenFile ( logFile , os . O_RDWR | os . O_APPEND | os . O_CREATE , 0666 ) f . lg = log . New ( f . logFile , f . prefix , log . LstdFlags | log . Lmicroseconds ) } else { f . split ( ) } go f . logWriter ( ) go f . fileMonitor ( ) }
3104	func ( r * Router ) handle ( method , pattern string , handle Handle ) * Route { method = strings . ToUpper ( method ) var leaf * Leaf if leaf = r . getLeaf ( method , pattern ) ; leaf != nil { return & Route { r , leaf } } if ! _HTTP_METHODS [ method ] && method != "*" { panic ( "unknown HTTP method: " + method ) } methods := make ( map [ string ] bool ) if method == "*" { for m := range _HTTP_METHODS { methods [ m ] = true } } else { methods [ method ] = true } for m := range methods { if t , ok := r . routers [ m ] ; ok { leaf = t . Add ( pattern , handle ) } else { t := NewTree ( ) leaf = t . Add ( pattern , handle ) r . routers [ m ] = t } r . add ( m , pattern , leaf ) } return & Route { r , leaf } }
335	func ( d * Discovery ) stop ( ) { level . Debug ( d . logger ) . Log ( "msg" , "Stopping file discovery..." , "paths" , fmt . Sprintf ( "%v" , d . paths ) ) done := make ( chan struct { } ) defer close ( done ) fileSDTimeStamp . removeDiscoverer ( d ) go func ( ) { for { select { case <- d . watcher . Errors : case <- d . watcher . Events : case <- done : return } } } ( ) if err := d . watcher . Close ( ) ; err != nil { level . Error ( d . logger ) . Log ( "msg" , "Error closing file watcher" , "paths" , fmt . Sprintf ( "%v" , d . paths ) , "err" , err ) } level . Debug ( d . logger ) . Log ( "msg" , "File discovery stopped" ) }
3706	func ( w * Widget ) GetMustShowResourceList ( ) bool { if w == nil || w . MustShowResourceList == nil { return false } return * w . MustShowResourceList }
5166	func NewBackgroundTx ( name string , category string ) * tx { t := NewTx ( name ) t . txnType = OtherTransaction t . category = category return t }
403	func ( u * URI ) SetPath ( path string ) { u . pathOriginal = append ( u . pathOriginal [ : 0 ] , path ... ) u . path = normalizePath ( u . path , u . pathOriginal ) }
1853	func ( eventStream * EventStream ) StartListening ( ) { eventStream . statusLock . Lock ( ) defer eventStream . statusLock . Unlock ( ) eventStream . open = true go eventStream . listen ( ) }
5441	func ( bot * Bot ) AddTrigger ( h Handler ) { bot . handlers = append ( bot . handlers , h ) }
6859	func SetClockSequence ( seq int ) { if seq == - 1 { var b [ 2 ] byte randomBits ( b [ : ] ) seq = int ( b [ 0 ] ) << 8 | int ( b [ 1 ] ) } old_seq := clock_seq clock_seq = uint16 ( seq & 0x3fff ) | 0x8000 if old_seq != clock_seq { lasttime = 0 } }
5236	func ( u * URI ) SetScheme ( scheme string ) error { m := schemeRegexp . FindStringSubmatch ( scheme ) if m == nil { return errors . New ( "invalid scheme" ) } u . scheme = scheme return nil }
5884	func Proxy ( proxy string ) Option { return func ( gsa * GServiceAccount ) error { u , err := url . Parse ( proxy ) if err != nil { return err } return Transport ( & http . Transport { Proxy : http . ProxyURL ( u ) , } ) ( gsa ) } }
1379	func ( m * MockControl ) Exists ( arg0 string ) bool { ret := m . ctrl . Call ( m , "Exists" , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 }
2522	func flattenHostNetworkTrafficShapingPolicy ( d * schema . ResourceData , obj * types . HostNetworkTrafficShapingPolicy ) error { if obj . Enabled != nil { d . Set ( "shaping_enabled" , * obj . Enabled ) } d . Set ( "shaping_average_bandwidth" , obj . AverageBandwidth ) d . Set ( "shaping_burst_size" , obj . BurstSize ) d . Set ( "shaping_peak_bandwidth" , obj . PeakBandwidth ) return nil }
1736	func ( task * Task ) SetCredentialsID ( id string ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . credentialsID = id }
536	func ( c * Cookie ) Expire ( ) time . Time { expire := c . expire if expire . IsZero ( ) { expire = CookieExpireUnlimited } return expire }
4056	func ( l * ListBox ) FindItem ( text string , caseSensitive bool ) int { for idx , itm := range l . items { if itm == text || ( caseSensitive && strings . EqualFold ( itm , text ) ) { return idx } } return - 1 }
1885	func ( c * GlobalCgroupFactory ) New ( hierarchy cgroups . Hierarchy , path cgroups . Path , specs * specs . LinuxResources ) ( cgroups . Cgroup , error ) { return cgroups . New ( hierarchy , path , specs ) }
4095	func ( l * TableView ) SetColumnInfo ( id int , col Column ) { if id < len ( l . columns ) { l . columns [ id ] = col } }
3622	func ( t * TraceServiceDefinition ) GetService ( ) string { if t == nil || t . Service == nil { return "" } return * t . Service }
2860	func isConcurrentAccessError ( err error ) bool { var f types . AnyType var ok bool f , ok = vimSoapFault ( err ) if ! ok { f , ok = taskFault ( err ) } if ok { switch f . ( type ) { case types . ConcurrentAccess , * types . ConcurrentAccess : return true } } return false }
6403	func ( stack * Stack ) Peek ( ) ( interface { } , bool ) { stack . key . RLock ( ) defer stack . key . RUnlock ( ) return stack . underlyer . PeekFront ( ) }
3378	func ( i * IntegrationGCPCreateRequest ) HasTokenURI ( ) bool { if i != nil && i . TokenURI != nil { return true } return false }
5572	func ( c * FakeClient ) Delete ( instanceID string ) error { c . DeleteCalled = true return c . DeleteErr }
2687	func Create ( f * object . Folder , name string ) ( * object . StoragePod , error ) { log . Printf ( "[DEBUG] Creating datastore cluster %q" , fmt . Sprintf ( "%s/%s" , f . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) pod , err := f . CreateStoragePod ( ctx , name ) if err != nil { return nil , err } return pod , nil }
1075	func spawnChild ( i * spawnChildInput ) ( * child . Child , error ) { p := shellwords . NewParser ( ) p . ParseEnv = true p . ParseBacktick = true args , err := p . Parse ( i . Command ) if err != nil { return nil , errors . Wrap ( err , "failed parsing command" ) } child , err := child . New ( & child . NewInput { Stdin : i . Stdin , Stdout : i . Stdout , Stderr : i . Stderr , Command : args [ 0 ] , Args : args [ 1 : ] , Env : i . Env , Timeout : i . Timeout , ReloadSignal : i . ReloadSignal , KillSignal : i . KillSignal , KillTimeout : i . KillTimeout , Splay : i . Splay , } ) if err != nil { return nil , errors . Wrap ( err , "error creating child" ) } if err := child . Start ( ) ; err != nil { return nil , errors . Wrap ( err , "child" ) } return child , nil }
6807	func ( t * T ) Failed ( ) bool { t . mu . Lock ( ) defer t . mu . Unlock ( ) return t . failed }
7274	func ( s StringSlice ) IndexOfIgnoreCase ( str string ) int { str = strings . ToLower ( str ) for i , v := range s { if str == strings . ToLower ( v ) { return i } } return - 1 }
1253	func ( cs * clientServer ) createPublishHealthRequests ( ) ( [ ] * ecstcs . PublishHealthRequest , error ) { metadata , taskHealthMetrics , err := cs . statsEngine . GetTaskHealthMetrics ( ) if err != nil { return nil , err } if metadata == nil || taskHealthMetrics == nil { seelog . Debug ( "No container health metrics to report" ) return nil , nil } var requests [ ] * ecstcs . PublishHealthRequest var taskHealths [ ] * ecstcs . TaskHealth numOfTasks := len ( taskHealthMetrics ) for i , taskHealth := range taskHealthMetrics { taskHealths = append ( taskHealths , taskHealth ) if ( i + 1 ) % tasksInHealthMessage == 0 { requestMetadata := copyHealthMetadata ( metadata , ( i + 1 ) == numOfTasks ) requestTaskHealth := copyTaskHealthMetrics ( taskHealths ) request := ecstcs . NewPublishHealthMetricsRequest ( requestMetadata , requestTaskHealth ) requests = append ( requests , request ) taskHealths = taskHealths [ : 0 ] } } if len ( taskHealths ) != 0 { requestMetadata := copyHealthMetadata ( metadata , true ) requests = append ( requests , ecstcs . NewPublishHealthMetricsRequest ( requestMetadata , taskHealths ) ) } return requests , nil }
4084	func ControlInRect ( c Control , x int , y int , w int , h int ) bool { xx , yy := c . Pos ( ) ww , hh := c . Size ( ) return xx >= x && ww <= x + w && yy <= y + h && yy + hh <= y + h && yy >= y && yy + h >= y }
4681	func newHelperMethodInclude ( ln * line , rslt * result , src * source , parent element , opts * Options ) ( * helperMethodInclude , error ) { if len ( ln . tokens ) < 3 { return nil , fmt . Errorf ( "no template name is specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } var pipeline string if len ( ln . tokens ) > 3 { pipeline = strings . Join ( ln . tokens [ 3 : ] , space ) } e := & helperMethodInclude { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , templateName : ln . tokens [ 2 ] , pipeline : pipeline , } return e , nil }
1792	func ( cs * ContainerStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if cs == nil { return nil , nil } return [ ] byte ( `"` + cs . String ( ) + `"` ) , nil }
6716	func ( c * Client ) Accounts ( ) ( [ ] Account , error ) { var accounts [ ] Account _ , err := c . MakeApiRequest ( "GET" , "/1.0/accounts?nested=false" , nil , & accounts ) if err != nil { return nil , err } return accounts , err }
2033	func GetMACAddress ( ctx context . Context , timeout time . Duration , dev string , netlinkClient netlinkwrapper . NetLink ) ( string , error ) { retriever := & macAddressRetriever { dev : dev , netlinkClient : netlinkClient , ctx : ctx , timeout : timeout , } return retriever . retrieve ( ) }
7184	func ( c Client ) readMessage ( ) ( irc . Message , error ) { if err := c . conn . SetReadDeadline ( time . Now ( ) . Add ( c . readTimeout ) ) ; err != nil { return irc . Message { } , fmt . Errorf ( "unable to set deadline: %s" , err ) } line , err := c . rw . ReadString ( '\n' ) if err != nil { return irc . Message { } , err } log . Printf ( "client %s: read: %s" , c . nick , strings . TrimRight ( line , "\r\n" ) ) \r \n m , err := irc . ParseMessage ( line ) }
1107	func in ( l , v interface { } ) ( bool , error ) { lv := reflect . ValueOf ( l ) vv := reflect . ValueOf ( v ) switch lv . Kind ( ) { case reflect . Array , reflect . Slice : var interfaceSlice [ ] interface { } if reflect . TypeOf ( l ) . Elem ( ) . Kind ( ) == reflect . Interface { interfaceSlice = l . ( [ ] interface { } ) } for i := 0 ; i < lv . Len ( ) ; i ++ { var lvv reflect . Value if interfaceSlice != nil { lvv = reflect . ValueOf ( interfaceSlice [ i ] ) } else { lvv = lv . Index ( i ) } switch lvv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : switch vv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : if vv . Int ( ) == lvv . Int ( ) { return true , nil } } case reflect . Float32 , reflect . Float64 : switch vv . Kind ( ) { case reflect . Float32 , reflect . Float64 : if vv . Float ( ) == lvv . Float ( ) { return true , nil } } case reflect . String : if vv . Type ( ) == lvv . Type ( ) && vv . String ( ) == lvv . String ( ) { return true , nil } } } case reflect . String : if vv . Type ( ) == lv . Type ( ) && strings . Contains ( lv . String ( ) , vv . String ( ) ) { return true , nil } } return false , nil }
6005	func ( t Typed ) Bool ( key string ) bool { return t . BoolOr ( key , false ) }
2878	func resourceVSphereComputeClusterVMAffinityRuleFindEntry ( cluster * object . ClusterComputeResource , key int32 , ) ( * types . ClusterAffinityRuleSpec , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( "error fetching cluster properties: %s" , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . Rule { if info . GetClusterRuleInfo ( ) . Key == key { if vmAffinityRuleInfo , ok := info . ( * types . ClusterAffinityRuleSpec ) ; ok { log . Printf ( "[DEBUG] Found VM affinity rule key %d in cluster %q" , key , cluster . Name ( ) ) return vmAffinityRuleInfo , nil } return nil , fmt . Errorf ( "rule key %d in cluster %q is not a VM affinity rule" , key , cluster . Name ( ) ) } } log . Printf ( "[DEBUG] No VM affinity rule key %d found in cluster %q" , key , cluster . Name ( ) ) return nil , nil }
7049	func SafeCreateSSH ( client SFTPClient , name ... string ) ( file * sftp . File , err error ) { ssh := sshClientBucket { client : client , } fpath := path . Join ( name ... ) basepath := filepath . Dir ( fpath ) if err = ssh . remoteSafeMkdirAll ( basepath ) ; err == nil { file , err = client . Create ( fpath ) } return }
5607	func ( m * Error ) Validate ( formats strfmt . Registry ) error { var res [ ] error if err := m . validateType ( formats ) ; err != nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . CompositeValidationError ( res ... ) } return nil }
6827	func SetLogger ( out io . Writer , prefix string , flag int ) { Log = stdlog . New ( out , prefix , flag ) }
1254	func copyMetricsMetadata ( metadata * ecstcs . MetricsMetadata , fin bool ) * ecstcs . MetricsMetadata { return & ecstcs . MetricsMetadata { Cluster : aws . String ( * metadata . Cluster ) , ContainerInstance : aws . String ( * metadata . ContainerInstance ) , Idle : aws . Bool ( * metadata . Idle ) , MessageId : aws . String ( * metadata . MessageId ) , Fin : aws . Bool ( fin ) , } }
6857	func ( r * randomBalancer ) writeServiceToCache ( serviceName string ) ( [ ] * balancer . ServiceLocation , error ) { r . cacheLock . Lock ( ) defer r . cacheLock . Unlock ( ) if result , ok := r . cache [ serviceName ] ; ok { if time . Now ( ) . UTC ( ) . Before ( result . CachedAt . Add ( r . ttl ) ) { return result . Services , nil } } consulServices , _ , err := r . consulCatalog . Service ( serviceName , r . environment , true , nil ) if err != nil { return nil , fmt . Errorf ( "Error reaching consul for service lookup %v" , err ) } if len ( consulServices ) == 0 { return nil , fmt . Errorf ( "No services found for %s" , serviceName ) } var services [ ] * balancer . ServiceLocation for _ , v := range consulServices { s := & balancer . ServiceLocation { } s . URL = v . Service . Address s . Port = v . Service . Port services = append ( services , s ) } c := cachedServiceLocation { Services : services , CachedAt : time . Now ( ) . UTC ( ) } r . cache [ serviceName ] = c return services , nil }
3788	func ( client * Client ) GetEvents ( start , end int , priority , sources , tags string ) ( [ ] Event , error ) { vals := url . Values { } vals . Add ( "start" , strconv . Itoa ( start ) ) vals . Add ( "end" , strconv . Itoa ( end ) ) if priority != "" { vals . Add ( "priority" , priority ) } if sources != "" { vals . Add ( "sources" , sources ) } if tags != "" { vals . Add ( "tags" , tags ) } var out reqGetEvents if err := client . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/events?%s" , vals . Encode ( ) ) , nil , & out ) ; err != nil { return nil , err } return out . Events , nil }
3310	func ( g * Graph ) GetDefinition ( ) GraphDefinition { if g == nil || g . Definition == nil { return GraphDefinition { } } return * g . Definition }
182	func ( r * AlertingRule ) SetHealth ( health RuleHealth ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . health = health }
1426	func ( cs * ClientServerImpl ) WriteMessage ( send [ ] byte ) error { cs . writeLock . Lock ( ) defer cs . writeLock . Unlock ( ) if err := cs . conn . SetWriteDeadline ( time . Now ( ) . Add ( cs . RWTimeout ) ) ; err != nil { seelog . Warnf ( "Unable to set write deadline for websocket connection: %v for %s" , err , cs . URL ) } return cs . conn . WriteMessage ( websocket . TextMessage , send ) }
1393	func ( mr * MockCNIClientMockRecorder ) SetupNS ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "SetupNS" , reflect . TypeOf ( ( * MockCNIClient ) ( nil ) . SetupNS ) , arg0 , arg1 , arg2 ) }
1262	func ( vol * VolumeResource ) GetMountPoint ( ) string { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . VolumeConfig . Mountpoint }
5713	func ( s * Sentinel ) Slaves ( ) ( [ ] * Slave , error ) { res , err := s . doUntilSuccess ( func ( c redis . Conn ) ( interface { } , error ) { return queryForSlaves ( c , s . MasterName ) } ) if err != nil { return nil , err } return res . ( [ ] * Slave ) , nil }
949	func validateNoIPCollisions ( hif HostInterfaces , hostOnlyNet * net . IPNet , currHostOnlyNets map [ string ] * hostOnlyNetwork ) error { hostOnlyByCIDR := map [ string ] * hostOnlyNetwork { } for _ , n := range currHostOnlyNets { ipnet := net . IPNet { IP : n . IPv4 . IP , Mask : n . IPv4 . Mask } hostOnlyByCIDR [ ipnet . String ( ) ] = n } m , err := listHostInterfaces ( hif , hostOnlyByCIDR ) if err != nil { return err } collision , err := checkIPNetCollision ( hostOnlyNet , m ) if err != nil { return err } if collision { return ErrNetworkAddrCollision } return nil }
850	func ( c * ComputeUtil ) waitForOp ( opGetter func ( ) ( * raw . Operation , error ) ) error { for { op , err := opGetter ( ) if err != nil { return err } log . Debugf ( "Operation %q status: %s" , op . Name , op . Status ) if op . Status == "DONE" { if op . Error != nil { return fmt . Errorf ( "Operation error: %v" , * op . Error . Errors [ 0 ] ) } break } time . Sleep ( 1 * time . Second ) } return nil }
4190	func ( m * DefaultManager ) DeleteSpace ( space cfclient . Space , orgName string ) error { if m . Peek { lo . G . Infof ( "[dry-run]: delete space with %s from org %s" , space . Name , orgName ) return nil } lo . G . Infof ( "delete space with %s from org %s" , space . Name , orgName ) return m . Client . DeleteSpace ( space . Guid , true , false ) }
1727	func ( task * Task ) shouldOverrideNetworkMode ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer ) ( bool , string ) { if container . IsInternal ( ) { return true , networkModeNone } if task . GetTaskENI ( ) == nil { return false , "" } pauseContName := "" for _ , cont := range task . Containers { if cont . Type == apicontainer . ContainerCNIPause { pauseContName = cont . Name break } } if pauseContName == "" { seelog . Critical ( "Pause container required, but not found in the task: %s" , task . String ( ) ) return false , "" } pauseContainer , ok := dockerContainerMap [ pauseContName ] if ! ok || pauseContainer == nil { seelog . Criticalf ( "Pause container required, but not found in container map for container: [%s] in task: %s" , container . String ( ) , task . String ( ) ) return false , "" } return true , dockerMappingContainerPrefix + pauseContainer . DockerID }
7107	func ToPirateSpeak ( theString string ) ( string , error ) { f := New ( theString ) if f . length < 1 { return "" , errors . New ( lengthError ) } f . urlEncodeSpaces ( ) response , err := http . Get ( fmt . Sprintf ( pirateLink , f . theString ) ) if err != nil { return "" , errors . New ( "unable to convert" ) } defer response . Body . Close ( ) contents , err := ioutil . ReadAll ( response . Body ) if err != nil { return "" , err } return string ( contents ) , nil }
4189	func ( c * CreateSpacesCommand ) Execute ( [ ] string ) error { var cfMgmt * CFMgmt var err error if cfMgmt , err = InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { err = cfMgmt . SpaceManager . CreateSpaces ( ) } return err }
2480	func ( p * player ) RotateRight ( ) { p . angle ++ if maxAngle <= p . angle { p . angle -= maxAngle } p . lean ++ if maxLean < p . lean { p . lean = maxLean } }
2722	func expandClusterDpmHostConfigInfo ( d * schema . ResourceData , host * object . HostSystem ) ( * types . ClusterDpmHostConfigInfo , error ) { obj := & types . ClusterDpmHostConfigInfo { Behavior : types . DpmBehavior ( d . Get ( "dpm_automation_level" ) . ( string ) ) , Enabled : structure . GetBool ( d , "dpm_enabled" ) , Key : host . Reference ( ) , } return obj , nil }
5170	func ( t * tx ) StartDatastore ( table , operation , sql , rollupName string ) error { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) id , err := t . Tracer . BeginDatastoreSegment ( t . id , t . ss . Peek ( ) , table , operation , sql , rollupName ) if err != nil { return err } t . ss . Push ( id ) return nil }
2316	func ( v * Device ) native ( ) * C . GdkDevice { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDevice ( p ) }
5328	func NextSystemGID ( ) ( int , error ) { db , gid , err := nextGUID ( true ) db . close ( ) return gid , err }
3559	func ( s * SyntheticsTest ) GetPublicId ( ) string { if s == nil || s . PublicId == nil { return "" } return * s . PublicId }
337	func ( d * Discovery ) readFile ( filename string ) ( [ ] * targetgroup . Group , error ) { fd , err := os . Open ( filename ) if err != nil { return nil , err } defer fd . Close ( ) content , err := ioutil . ReadAll ( fd ) if err != nil { return nil , err } info , err := fd . Stat ( ) if err != nil { return nil , err } var targetGroups [ ] * targetgroup . Group switch ext := filepath . Ext ( filename ) ; strings . ToLower ( ext ) { case ".json" : if err := json . Unmarshal ( content , & targetGroups ) ; err != nil { return nil , err } case ".yml" , ".yaml" : if err := yaml . UnmarshalStrict ( content , & targetGroups ) ; err != nil { return nil , err } default : panic ( errors . Errorf ( "discovery.File.readFile: unhandled file extension %q" , ext ) ) } for i , tg := range targetGroups { if tg == nil { err = errors . New ( "nil target group item found" ) return nil , err } tg . Source = fileSource ( filename , i ) if tg . Labels == nil { tg . Labels = model . LabelSet { } } tg . Labels [ fileSDFilepathLabel ] = model . LabelValue ( filename ) } d . writeTimestamp ( filename , float64 ( info . ModTime ( ) . Unix ( ) ) ) return targetGroups , nil }
157	func processExternalLabels ( ls tsdbLabels . Labels , externalLabels labels . Labels ) labels . Labels { i , j , result := 0 , 0 , make ( labels . Labels , 0 , len ( ls ) + len ( externalLabels ) ) for i < len ( ls ) && j < len ( externalLabels ) { if ls [ i ] . Name < externalLabels [ j ] . Name { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) i ++ } else if ls [ i ] . Name > externalLabels [ j ] . Name { result = append ( result , externalLabels [ j ] ) j ++ } else { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) i ++ j ++ } } for ; i < len ( ls ) ; i ++ { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) } result = append ( result , externalLabels [ j : ] ... ) return result }
5209	func ( idx * Index ) Not ( row * PQLRowQuery ) * PQLRowQuery { return NewPQLRowQuery ( fmt . Sprintf ( "Not(%s)" , row . serialize ( ) ) , idx , row . Error ( ) ) }
1174	func v3HandlersSetup ( muxRouter * mux . Router , state dockerstate . TaskEngineState , ecsClient api . ECSClient , statsEngine stats . Engine , cluster string , availabilityZone string , containerInstanceArn string ) { muxRouter . HandleFunc ( v3 . ContainerMetadataPath , v3 . ContainerMetadataHandler ( state ) ) muxRouter . HandleFunc ( v3 . TaskMetadataPath , v3 . TaskMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , false ) ) muxRouter . HandleFunc ( v3 . TaskWithTagsMetadataPath , v3 . TaskMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , true ) ) muxRouter . HandleFunc ( v3 . ContainerStatsPath , v3 . ContainerStatsHandler ( state , statsEngine ) ) muxRouter . HandleFunc ( v3 . TaskStatsPath , v3 . TaskStatsHandler ( state , statsEngine ) ) muxRouter . HandleFunc ( v3 . ContainerAssociationsPath , v3 . ContainerAssociationsHandler ( state ) ) muxRouter . HandleFunc ( v3 . ContainerAssociationPathWithSlash , v3 . ContainerAssociationHandler ( state ) ) muxRouter . HandleFunc ( v3 . ContainerAssociationPath , v3 . ContainerAssociationHandler ( state ) ) }
5064	func ( servers * mongoServers ) BestFit ( serverTags [ ] bson . D ) * mongoServer { var best * mongoServer for _ , next := range servers . slice { if best == nil { best = next best . RLock ( ) if serverTags != nil && ! next . info . Mongos && ! best . hasTags ( serverTags ) { best . RUnlock ( ) best = nil } continue } next . RLock ( ) swap := false switch { case serverTags != nil && ! next . info . Mongos && ! next . hasTags ( serverTags ) : case next . info . Master != best . info . Master : swap = best . info . Master case absDuration ( next . pingValue - best . pingValue ) > 15 * time . Millisecond : swap = next . pingValue < best . pingValue case len ( next . liveSockets ) - len ( next . unusedSockets ) < len ( best . liveSockets ) - len ( best . unusedSockets ) : swap = true } if swap { best . RUnlock ( ) best = next } else { next . RUnlock ( ) } } if best != nil { best . RUnlock ( ) } return best }
5105	func ( b * Bulk ) Run ( ) ( * BulkResult , error ) { op := & insertOp { b . c . FullName , b . inserts , 0 } if ! b . ordered { op . flags = 1 } _ , err := b . c . writeQuery ( op ) if err != nil { return nil , & bulkError { err } } return & BulkResult { } , nil }
3614	func ( t * TimeseriesRequestStyle ) GetLineTypeOk ( ) ( string , bool ) { if t == nil || t . LineType == nil { return "" , false } return * t . LineType , true }
4880	func ( e * hdbErrors ) IsError ( ) bool { return e . errors [ e . idx ] . errorLevel == errorLevelError }
1551	func ( m * MockCgroup ) Subsystems ( ) [ ] cgroups . Subsystem { ret := m . ctrl . Call ( m , "Subsystems" ) ret0 , _ := ret [ 0 ] . ( [ ] cgroups . Subsystem ) return ret0 }
1774	func ( handler * attachENIHandler ) handleSingleMessage ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) error { receivedAt := time . Now ( ) if err := validateAttachTaskNetworkInterfacesMessage ( message ) ; err != nil { return errors . Wrapf ( err , "attach eni message handler: error validating AttachTaskNetworkInterface message received from ECS" ) } go func ( clusterArn * string , containerInstanceArn * string , messageID * string ) { if err := handler . acsClient . MakeRequest ( & ecsacs . AckRequest { Cluster : clusterArn , ContainerInstance : containerInstanceArn , MessageId : messageID , } ) ; err != nil { seelog . Warnf ( "Failed to ack request with messageId: %s, error: %v" , aws . StringValue ( messageID ) , err ) } } ( message . ClusterArn , message . ContainerInstanceArn , message . MessageId ) mac := aws . StringValue ( message . ElasticNetworkInterfaces [ 0 ] . MacAddress ) if eniAttachment , ok := handler . state . ENIByMac ( mac ) ; ok { seelog . Infof ( "Duplicate ENI attachment message for ENI with MAC address: %s" , mac ) eniAckTimeoutHandler := ackTimeoutHandler { mac : mac , state : handler . state } return eniAttachment . StartTimer ( eniAckTimeoutHandler . handle ) } if err := handler . addENIAttachmentToState ( message , receivedAt ) ; err != nil { return errors . Wrapf ( err , "attach eni message handler: unable to add eni attachment to engine state" ) } if err := handler . saver . Save ( ) ; err != nil { return errors . Wrapf ( err , "attach eni message handler: unable to save agent state" ) } return nil }
353	func CheckRules ( files ... string ) int { failed := false for _ , f := range files { if n , errs := checkRules ( f ) ; errs != nil { fmt . Fprintln ( os . Stderr , " FAILED:" ) for _ , e := range errs { fmt . Fprintln ( os . Stderr , e . Error ( ) ) } failed = true } else { fmt . Printf ( " SUCCESS: %d rules found\n" , \n ) } n } fmt . Println ( ) if failed { return 1 } }
4918	func ( r * Reader ) ReadCesu8 ( size int ) [ ] byte { if r . err != nil { return nil } p := make ( [ ] byte , size ) var n int n , r . err = io . ReadFull ( r . rd , p ) r . cnt += n if r . err != nil { return nil } r . tr . Reset ( ) if n , _ , r . err = r . tr . Transform ( p , p , true ) ; r . err != nil { return nil } return p [ : n ] }
4296	func Setfilecon ( path string , scon string ) error { return system . Lsetxattr ( path , xattrNameSelinux , [ ] byte ( scon ) , 0 ) }
5990	func ThrottledWriter ( w io . Writer , bytesPerSec int , maxBurst time . Duration ) ThrottlerWriter { return & throttledWriter { wrap : w , limiter : newRateLimiter ( bytesPerSec , maxBurst ) , } }
3454	func ( q * QueryConfig ) HasLogSet ( ) bool { if q != nil && q . LogSet != nil { return true } return false }
5760	func ( a * API ) UpdateCheckBundle ( cfg * CheckBundle ) ( * CheckBundle , error ) { if cfg == nil { return nil , fmt . Errorf ( "Invalid check bundle config [nil]" ) } bundleCID := string ( cfg . CID ) matched , err := regexp . MatchString ( config . CheckBundleCIDRegex , bundleCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid check bundle CID [%s]" , bundleCID ) } jsonCfg , err := json . Marshal ( cfg ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] update check bundle, sending JSON: %s" , string ( jsonCfg ) ) } result , err := a . Put ( bundleCID , jsonCfg ) if err != nil { return nil , err } checkBundle := & CheckBundle { } if err := json . Unmarshal ( result , checkBundle ) ; err != nil { return nil , err } return checkBundle , nil }
2173	func ( v * ListBoxRow ) native ( ) * C . GtkListBoxRow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkListBoxRow ( p ) }
3429	func ( o * Options ) GetNotifyAuditOk ( ) ( bool , bool ) { if o == nil || o . NotifyAudit == nil { return false , false } return * o . NotifyAudit , true }
5239	func ( u URI ) Equals ( other * URI ) bool { if other == nil { return false } return u . scheme == other . scheme && u . host == other . host && u . port == other . port }
6413	func ( list * LinkedList ) RemoveFront ( ) ( interface { } , bool ) { list . key . Lock ( ) defer list . key . Unlock ( ) if list . first == nil { return nil , false } retval := list . first . payload list . first = list . first . next list . length -- if 0 == list . length { list . last = nil } return retval , true }
3149	func ParseRetentionDefs ( retentionDefs string ) ( whisper . Retentions , error ) { retentions := make ( whisper . Retentions , 0 ) for _ , retentionDef := range strings . Split ( retentionDefs , "," ) { retentionDef = strings . TrimSpace ( retentionDef ) parts := strings . Split ( retentionDef , ":" ) if len ( parts ) != 2 { return nil , fmt . Errorf ( "bad retentions spec %q" , retentionDef ) } val1 , err1 := strconv . ParseInt ( parts [ 0 ] , 10 , 0 ) val2 , err2 := strconv . ParseInt ( parts [ 1 ] , 10 , 0 ) if err1 == nil && err2 == nil { retention := whisper . NewRetention ( int ( val1 ) , int ( val2 ) ) retentions = append ( retentions , & retention ) continue } retention , err := whisper . ParseRetentionDef ( retentionDef ) if err != nil { return nil , err } retentions = append ( retentions , retention ) } return retentions , nil }
1815	func NewMockCache ( ctrl * gomock . Controller ) * MockCache { mock := & MockCache { ctrl : ctrl } mock . recorder = & MockCacheMockRecorder { mock } return mock }
6964	func ( s * Set ) ItemsFunc ( f func ( value interface { } ) bool ) [ ] interface { } { s . RLock ( ) defer s . RUnlock ( ) items := [ ] interface { } { } for k := range s . m { if f ( k ) { items = append ( items , k ) } } return items }
5810	func ( m * CirconusMetrics ) Timing ( metric string , val float64 ) { m . SetHistogramValue ( metric , val ) }
4079	func ActiveControl ( parent Control ) Control { fnActive := func ( c Control ) bool { return c . Active ( ) } return FindFirstControl ( parent , fnActive ) }
2874	func resourceVSphereResourcePoolApplyTags ( d * schema . ResourceData , meta interface { } , rp * object . ResourcePool ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } if tagsClient == nil { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping" , resourceVSphereComputeClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying any pending tags" , resourceVSphereResourcePoolIDString ( d ) ) return processTagDiff ( tagsClient , d , rp ) }
4749	func LastError ( errs ... error ) error { for i := len ( errs ) - 1 ; i >= 0 ; i -- { err := errs [ i ] if err != nil { return err } } return nil }
3901	func ( p * parser ) expect ( e yaml_event_type_t ) { if p . event . typ == yaml_NO_EVENT { if ! yaml_parser_parse ( & p . parser , & p . event ) { p . fail ( ) } } if p . event . typ == yaml_STREAM_END_EVENT { failf ( "attempted to go past the end of stream; corrupted value?" ) } if p . event . typ != e { p . parser . problem = fmt . Sprintf ( "expected %s event but got %s" , e , p . event . typ ) p . fail ( ) } yaml_event_delete ( & p . event ) p . event . typ = yaml_NO_EVENT }
473	func ( resp * Response ) SetBodyRaw ( body [ ] byte ) { resp . ResetBody ( ) resp . bodyRaw = body }
5106	func hasLengthOf ( top interface { } , current interface { } , field interface { } , param string ) bool { st := reflect . ValueOf ( field ) switch st . Kind ( ) { case reflect . String : p := asInt ( param ) return int64 ( utf8 . RuneCountInString ( st . String ( ) ) ) == p case reflect . Slice , reflect . Map , reflect . Array : p := asInt ( param ) return int64 ( st . Len ( ) ) == p case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : p := asInt ( param ) return st . Int ( ) == p case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 , reflect . Uintptr : p := asUint ( param ) return st . Uint ( ) == p case reflect . Float32 , reflect . Float64 : p := asFloat ( param ) return st . Float ( ) == p } panic ( fmt . Sprintf ( "Bad field type %T" , field ) ) }
5225	func ( f * Field ) Store ( row * PQLRowQuery , rowIDOrKey interface { } ) * PQLBaseQuery { rowStr , err := formatIDKeyBool ( rowIDOrKey ) if err != nil { return NewPQLBaseQuery ( "" , f . index , err ) } return NewPQLBaseQuery ( fmt . Sprintf ( "Store(%s,%s=%s)" , row . serialize ( ) . String ( ) , f . name , rowStr ) , f . index , nil ) }
2334	func ( v * Context ) SetMatrix ( matrix * Matrix ) { C . cairo_set_matrix ( v . native ( ) , matrix . native ( ) ) }
2291	func ( v * TextTagTable ) native ( ) * C . GtkTextTagTable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTextTagTable ( p ) }
6023	func ( t Typed ) InterfaceIf ( key string ) ( interface { } , bool ) { value , exists := t [ key ] if exists == false { return nil , false } return value , true }
2716	func resourceVSphereVirtualMachineCreateBareWithSDRS ( d * schema . ResourceData , meta interface { } , fo * object . Folder , spec types . VirtualMachineConfigSpec , pool * object . ResourcePool , hs * object . HostSystem , ) ( * object . VirtualMachine , error ) { client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , fmt . Errorf ( "connection ineligible to use datastore_cluster_id: %s" , err ) } log . Printf ( "[DEBUG] %s: Creating virtual machine through Storage DRS API" , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( "datastore_cluster_id" ) . ( string ) ) if err != nil { return nil , fmt . Errorf ( "error getting datastore cluster: %s" , err ) } vm , err := storagepod . CreateVM ( client , fo , spec , pool , hs , pod ) if err != nil { return nil , fmt . Errorf ( "error creating virtual machine on datastore cluster %q: %s" , pod . Name ( ) , err ) } return vm , nil }
7008	func NewPgRemoteDump ( port int , database , username , password string , sshCfg command . SshConfig ) ( * PgDump , error ) { return NewPgRemoteDumpWithPath ( port , database , username , password , sshCfg , "" ) }
6546	func unsetenvGPGAgentInfo ( ) { v := C . CString ( "GPG_AGENT_INFO=" ) defer C . free ( unsafe . Pointer ( v ) ) C . putenv ( v ) }
4667	func newHelperMethodDoctype ( ln * line , rslt * result , src * source , parent element , opts * Options ) ( * helperMethodDoctype , error ) { if len ( ln . tokens ) < 3 { return nil , fmt . Errorf ( "doctype is not specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } doctype := ln . tokens [ 2 ] if _ , ok := doctypes [ doctype ] ; ! ok { return nil , fmt . Errorf ( "doctype is invalid [file: %s][line: %d][doctype: %s]" , ln . fileName ( ) , ln . no , doctype ) } e := & helperMethodDoctype { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , doctype : doctype , } return e , nil }
2569	func NewNetworkInterfaceSubresource ( client * govmomi . Client , rdd resourceDataDiff , d , old map [ string ] interface { } , idx int ) * NetworkInterfaceSubresource { sr := & NetworkInterfaceSubresource { Subresource : & Subresource { schema : NetworkInterfaceSubresourceSchema ( ) , client : client , srtype : subresourceTypeNetworkInterface , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr }
2738	func ( p * tagDiffProcessor ) processAttachOperations ( ) error { tagIDs := p . diffNewOld ( ) if len ( tagIDs ) < 1 { return nil } for _ , tagID := range tagIDs { objID := p . subject . Reference ( ) . Value objType , err := tagTypeForObject ( p . subject ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) log . Printf ( "[DEBUG] Attaching tag %q for object %q" , tagID , objID ) if err := p . client . AttachTagToObject ( ctx , tagID , objID , objType ) ; err != nil { return err } } return nil }
230	func FuzzParseExpr ( in [ ] byte ) int { _ , err := ParseExpr ( string ( in ) ) if err == nil { return fuzzInteresting } return fuzzMeh }
3653	func ( t * TriggeringValue ) GetToTsOk ( ) ( int , bool ) { if t == nil || t . ToTs == nil { return 0 , false } return * t . ToTs , true }
1937	func ( m * MockTaskEngineState ) AllTasks ( ) [ ] * task . Task { ret := m . ctrl . Call ( m , "AllTasks" ) ret0 , _ := ret [ 0 ] . ( [ ] * task . Task ) return ret0 }
5306	func postEOFCheck ( c * Cmp , r io . Reader , buf [ ] byte ) bool { tmpLR , isLR := r . ( * io . LimitedReader ) if isLR { if tmpLR . N > 0 { return true } r = tmpLR . R } else { c . debugf ( "compareReader: A type assertion of LimitedReader unexpectedly failed\n" ) } \n n , _ := readPartial ( c , r , buf , 0 , len ( buf ) ) }
6942	func ( r * Registry ) Size ( ) int { r . mutex . RLock ( ) size := len ( r . instruments ) r . mutex . RUnlock ( ) return size }
1306	func sendContainerStatusToECS ( client api . ECSClient , event * sendableEvent ) error { return client . SubmitContainerStateChange ( event . containerChange ) }
4155	func ( b * bruteRanger ) Remove ( network net . IPNet ) ( RangerEntry , error ) { networks , err := b . getEntriesByVersion ( network . IP ) if err != nil { return nil , err } key := network . String ( ) if networkToDelete , found := networks [ key ] ; found { delete ( networks , key ) return networkToDelete , nil } return nil , nil }
6201	func IsHostname ( s string ) bool { addrs , err := net . LookupHost ( s ) if err != nil || len ( addrs ) == 0 { return false } return true }
7323	func ( level Level ) String ( ) string { switch level { case EMERGENCY : return "EMERGENCY" case ALERT : return "ALERT" case CRITICAL : return "CRITICAL" case ERROR : return "ERROR" case WARNING : return "WARNING" case NOTICE : return "NOTICE" case INFO : return "INFO" default : return "DEBUG" } }
220	func NewManager ( ctx context . Context , logger log . Logger , options ... func ( * Manager ) ) * Manager { if logger == nil { logger = log . NewNopLogger ( ) } mgr := & Manager { logger : logger , syncCh : make ( chan map [ string ] [ ] * targetgroup . Group ) , targets : make ( map [ poolKey ] map [ string ] * targetgroup . Group ) , discoverCancel : [ ] context . CancelFunc { } , ctx : ctx , updatert : 5 * time . Second , triggerSend : make ( chan struct { } , 1 ) , } for _ , option := range options { option ( mgr ) } return mgr }
332	func NewDiscovery ( conf * SDConfig , logger log . Logger ) * Discovery { if logger == nil { logger = log . NewNopLogger ( ) } disc := & Discovery { paths : conf . Files , interval : time . Duration ( conf . RefreshInterval ) , timestamps : make ( map [ string ] float64 ) , logger : logger , } fileSDTimeStamp . addDiscoverer ( disc ) return disc }
3515	func ( s * SyntheticsConfig ) GetRequestOk ( ) ( SyntheticsRequest , bool ) { if s == nil || s . Request == nil { return SyntheticsRequest { } , false } return * s . Request , true }
2107	func StartMetricsSession ( params * TelemetrySessionParams ) { ok , err := params . isContainerHealthMetricsDisabled ( ) if err != nil { seelog . Warnf ( "Error starting metrics session: %v" , err ) return } if ok { seelog . Warnf ( "Metrics were disabled, not starting the telemetry session" ) return } err = params . StatsEngine . MustInit ( params . Ctx , params . TaskEngine , params . Cfg . Cluster , params . ContainerInstanceArn ) if err != nil { seelog . Warnf ( "Error initializing metrics engine: %v" , err ) return } err = StartSession ( params , params . StatsEngine ) if err != nil { seelog . Warnf ( "Error starting metrics session with backend: %v" , err ) } }
6650	func ( v Vec3 ) Copy ( dst Vec3 ) { dst [ 0 ] = v [ 0 ] dst [ 1 ] = v [ 1 ] dst [ 2 ] = v [ 2 ] }
2052	func ( mr * MockIOUtilMockRecorder ) WriteFile ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "WriteFile" , reflect . TypeOf ( ( * MockIOUtil ) ( nil ) . WriteFile ) , arg0 , arg1 , arg2 ) }
6000	func Must ( data [ ] byte ) Typed { var m map [ string ] interface { } if err := json . Unmarshal ( data , & m ) ; err != nil { panic ( err ) } return Typed ( m ) }
5307	func ( h * HAProxyClient ) Stats ( ) ( stats [ ] * Stat , err error ) { res , err := h . RunCommand ( "show stat" ) if err != nil { return nil , err } reader := csv . NewReader ( res ) reader . TrailingComma = true err = gocsv . UnmarshalCSV ( reader , & stats ) if err != nil { return nil , fmt . Errorf ( "error reading csv: %s" , err ) } return stats , nil }
2682	func expandClusterOrchestrationInfo ( d * schema . ResourceData ) * types . ClusterOrchestrationInfo { obj := & types . ClusterOrchestrationInfo { DefaultVmReadiness : & types . ClusterVmReadiness { PostReadyDelay : int32 ( d . Get ( "ha_vm_restart_additional_delay" ) . ( int ) ) , ReadyCondition : d . Get ( "ha_vm_dependency_restart_condition" ) . ( string ) , } , } return obj }
314	func ( c * concreteSeriesIterator ) Seek ( t int64 ) bool { c . cur = sort . Search ( len ( c . series . samples ) , func ( n int ) bool { return c . series . samples [ n ] . Timestamp >= t } ) return c . cur < len ( c . series . samples ) }
733	func ( p * AWSSDProvider ) UpdateService ( service * sd . Service , ep * endpoint . Endpoint ) error { log . Infof ( "Updating service \"%s\"" , \" ) \" * service . Name srvType := p . serviceTypeFromEndpoint ( ep ) ttl := int64 ( sdDefaultRecordTTL ) if ep . RecordTTL . IsConfigured ( ) { ttl = int64 ( ep . RecordTTL ) } }
6088	func AddSimple ( q Queue , tx * reform . TX , jobType , relatedType , relatedID , creator string ) error { return AddWithData ( q , tx , jobType , relatedType , relatedID , creator , & struct { } { } ) }
3535	func ( s * SyntheticsOptions ) GetTickEvery ( ) int { if s == nil || s . TickEvery == nil { return 0 } return * s . TickEvery }
5119	func ( file * GridFile ) Write ( data [ ] byte ) ( n int , err error ) { file . assertMode ( gfsWriting ) file . m . Lock ( ) debugf ( "GridFile %p: writing %d bytes" , file , len ( data ) ) defer file . m . Unlock ( ) if file . err != nil { return 0 , file . err } n = len ( data ) file . doc . Length += int64 ( n ) chunkSize := file . doc . ChunkSize if len ( file . wbuf ) + len ( data ) < chunkSize { file . wbuf = append ( file . wbuf , data ... ) return } if len ( file . wbuf ) > 0 { missing := chunkSize - len ( file . wbuf ) if missing > len ( data ) { missing = len ( data ) } file . wbuf = append ( file . wbuf , data [ : missing ] ... ) data = data [ missing : ] file . insertChunk ( file . wbuf ) file . wbuf = file . wbuf [ 0 : 0 ] } for len ( data ) > chunkSize { size := chunkSize if size > len ( data ) { size = len ( data ) } file . insertChunk ( data [ : size ] ) data = data [ size : ] } file . wbuf = append ( file . wbuf , data ... ) return n , file . err }
5808	func ( m * CirconusMetrics ) Reset ( ) { m . cm . Lock ( ) defer m . cm . Unlock ( ) m . cfm . Lock ( ) defer m . cfm . Unlock ( ) m . gm . Lock ( ) defer m . gm . Unlock ( ) m . gfm . Lock ( ) defer m . gfm . Unlock ( ) m . hm . Lock ( ) defer m . hm . Unlock ( ) m . tm . Lock ( ) defer m . tm . Unlock ( ) m . tfm . Lock ( ) defer m . tfm . Unlock ( ) m . counters = make ( map [ string ] uint64 ) m . counterFuncs = make ( map [ string ] func ( ) uint64 ) m . gauges = make ( map [ string ] interface { } ) m . gaugeFuncs = make ( map [ string ] func ( ) int64 ) m . histograms = make ( map [ string ] * Histogram ) m . text = make ( map [ string ] string ) m . textFuncs = make ( map [ string ] func ( ) string ) }
2586	func WaitForGuestNet ( client * govmomi . Client , vm * object . VirtualMachine , routable bool , timeout int , ignoredGuestIPs [ ] interface { } ) error { if timeout < 1 { log . Printf ( "[DEBUG] Skipping network waiter for VM %q" , vm . InventoryPath ) return nil } log . Printf ( "[DEBUG] Waiting for an available IP address on VM %q (routable= %t, timeout = %dm)" , vm . InventoryPath , routable , timeout , ) var v4gw , v6gw net . IP p := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) err := property . Wait ( ctx , p , vm . Reference ( ) , [ ] string { "guest.net" , "guest.ipStack" } , func ( pc [ ] types . PropertyChange ) bool { for _ , c := range pc { if c . Op != types . PropertyChangeOpAssign { continue } switch v := c . Val . ( type ) { case types . ArrayOfGuestStackInfo : for _ , s := range v . GuestStackInfo { if s . IpRouteConfig != nil { for _ , r := range s . IpRouteConfig . IpRoute { switch r . Network { case "0.0.0.0" : v4gw = net . ParseIP ( r . Gateway . IpAddress ) case "::" : v6gw = net . ParseIP ( r . Gateway . IpAddress ) } } } } case types . ArrayOfGuestNicInfo : for _ , n := range v . GuestNicInfo { if n . IpConfig != nil { for _ , addr := range n . IpConfig . IpAddress { ip := net . ParseIP ( addr . IpAddress ) if skipIPAddrForWaiter ( ip , ignoredGuestIPs ) { continue } if ! routable { return true } var mask net . IPMask if ip . To4 ( ) != nil { mask = net . CIDRMask ( int ( addr . PrefixLength ) , 32 ) } else { mask = net . CIDRMask ( int ( addr . PrefixLength ) , 128 ) } if ip . Mask ( mask ) . Equal ( v4gw . Mask ( mask ) ) || ip . Mask ( mask ) . Equal ( v6gw . Mask ( mask ) ) { return true } } } } } } return false } ) if err != nil { if ctx . Err ( ) == context . DeadlineExceeded { return errors . New ( "timeout waiting for an available IP address" ) } return err } log . Printf ( "[DEBUG] IP address(es) is/are now available for VM %q" , vm . InventoryPath ) return nil }
418	func AcquireResponse ( ) * Response { v := responsePool . Get ( ) if v == nil { return & Response { } } return v . ( * Response ) }
3571	func ( t * ThresholdCount ) GetCriticalRecovery ( ) json . Number { if t == nil || t . CriticalRecovery == nil { return "" } return * t . CriticalRecovery }
983	func funcMap ( i * funcMapInput ) template . FuncMap { var scratch Scratch return template . FuncMap { "datacenters" : datacentersFunc ( i . brain , i . used , i . missing ) , "file" : fileFunc ( i . brain , i . used , i . missing ) , "key" : keyFunc ( i . brain , i . used , i . missing ) , "keyExists" : keyExistsFunc ( i . brain , i . used , i . missing ) , "keyOrDefault" : keyWithDefaultFunc ( i . brain , i . used , i . missing ) , "ls" : lsFunc ( i . brain , i . used , i . missing ) , "node" : nodeFunc ( i . brain , i . used , i . missing ) , "nodes" : nodesFunc ( i . brain , i . used , i . missing ) , "secret" : secretFunc ( i . brain , i . used , i . missing ) , "secrets" : secretsFunc ( i . brain , i . used , i . missing ) , "service" : serviceFunc ( i . brain , i . used , i . missing ) , "services" : servicesFunc ( i . brain , i . used , i . missing ) , "tree" : treeFunc ( i . brain , i . used , i . missing ) , "scratch" : func ( ) * Scratch { return & scratch } , "base64Decode" : base64Decode , "base64Encode" : base64Encode , "base64URLDecode" : base64URLDecode , "base64URLEncode" : base64URLEncode , "byKey" : byKey , "byTag" : byTag , "contains" : contains , "containsAll" : containsSomeFunc ( true , true ) , "containsAny" : containsSomeFunc ( false , false ) , "containsNone" : containsSomeFunc ( true , false ) , "containsNotAll" : containsSomeFunc ( false , true ) , "env" : envFunc ( i . env ) , "executeTemplate" : executeTemplateFunc ( i . t ) , "explode" : explode , "in" : in , "indent" : indent , "loop" : loop , "join" : join , "trimSpace" : trimSpace , "parseBool" : parseBool , "parseFloat" : parseFloat , "parseInt" : parseInt , "parseJSON" : parseJSON , "parseUint" : parseUint , "plugin" : plugin , "regexReplaceAll" : regexReplaceAll , "regexMatch" : regexMatch , "replaceAll" : replaceAll , "timestamp" : timestamp , "toLower" : toLower , "toJSON" : toJSON , "toJSONPretty" : toJSONPretty , "toTitle" : toTitle , "toTOML" : toTOML , "toUpper" : toUpper , "toYAML" : toYAML , "split" : split , "add" : add , "subtract" : subtract , "multiply" : multiply , "divide" : divide , "modulo" : modulo , } }
6638	func RectFromSphere ( c Vec3 , r float32 ) Rectangle { return RectWHD ( c [ 0 ] - r , c [ 1 ] - r , c [ 2 ] - r , 2 * r , 2 * r , 2 * r ) }
6763	func ( sw * Switch ) DialSeeds ( addrBook * AddrBook , seeds [ ] string ) error { netAddrs , err := NewNetAddressStrings ( seeds ) if err != nil { return err } if addrBook != nil { ourAddrS := sw . nodeInfo . ListenAddr ourAddr , _ := NewNetAddressString ( ourAddrS ) for _ , netAddr := range netAddrs { if netAddr . Equals ( ourAddr ) { continue } addrBook . AddAddress ( netAddr , ourAddr ) } addrBook . Save ( ) } perm := rand . Perm ( len ( netAddrs ) ) for i := 0 ; i < len ( perm ) ; i ++ { go func ( i int ) { time . Sleep ( time . Duration ( rand . Int63n ( 3000 ) ) * time . Millisecond ) j := perm [ i ] sw . dialSeed ( netAddrs [ j ] ) } ( i ) } return nil }
6370	func ( d Directory ) Enumerate ( cancel <- chan struct { } ) Enumerator { results := make ( chan interface { } ) go func ( ) { defer close ( results ) filepath . Walk ( d . Location , func ( currentLocation string , info os . FileInfo , openErr error ) ( err error ) { if openErr != nil { err = openErr return } if d . Location == currentLocation { return } if info . IsDir ( ) && 0 == d . Options & DirectoryOptionsRecursive { err = filepath . SkipDir } if d . applyOptions ( currentLocation , info ) { select { case results <- currentLocation : case <- cancel : err = errors . New ( "directory enumeration cancelled" ) } } return } ) } ( ) return results }
3125	func ( app * App ) configure ( ) error { var err error cfg , err := ReadConfig ( app . ConfigFilename ) if err != nil { return err } if hostname , err := os . Hostname ( ) ; err == nil { hostname = strings . Replace ( hostname , "." , "_" , - 1 ) cfg . Common . GraphPrefix = strings . Replace ( cfg . Common . GraphPrefix , "{host}" , hostname , - 1 ) } else { cfg . Common . GraphPrefix = strings . Replace ( cfg . Common . GraphPrefix , "{host}" , "localhost" , - 1 ) } if cfg . Whisper . Enabled { cfg . Whisper . Schemas , err = persister . ReadWhisperSchemas ( cfg . Whisper . SchemasFilename ) if err != nil { return err } if cfg . Whisper . AggregationFilename != "" { cfg . Whisper . Aggregation , err = persister . ReadWhisperAggregation ( cfg . Whisper . AggregationFilename ) if err != nil { return err } } else { cfg . Whisper . Aggregation = persister . NewWhisperAggregation ( ) } } if ! ( cfg . Cache . WriteStrategy == "max" || cfg . Cache . WriteStrategy == "sorted" || cfg . Cache . WriteStrategy == "noop" ) { return fmt . Errorf ( "go-carbon support only \"max\", \"sorted\" or \"noop\" write-strategy" ) } \" \" \" \" }
607	func paginate ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { next . ServeHTTP ( w , r ) } ) }
3529	func ( s * SyntheticsOptions ) GetMinFailureDuration ( ) int { if s == nil || s . MinFailureDuration == nil { return 0 } return * s . MinFailureDuration }
7188	func JsonRead ( body io . ReadCloser , obj interface { } , w http . ResponseWriter ) bool { content , err := ioutil . ReadAll ( io . LimitReader ( body , HTTP_BODY_MAX_LENGTH ) ) if err != nil { jerr := NewJsonErrorFromError ( http . StatusInternalServerError , err ) JsonWrite ( w , jerr . Status , jerr ) return false } if err := body . Close ( ) ; err != nil { jerr := NewJsonErrorFromError ( http . StatusInternalServerError , err ) JsonWrite ( w , jerr . Status , jerr ) return false } if err := json . Unmarshal ( content , obj ) ; err != nil { jerr := NewJsonErrorFromError ( StatusUnprocessableEntity , err ) JsonWrite ( w , jerr . Status , jerr ) return false } return true }
1606	func ( m * MockSecretsManagerAPI ) PutSecretValue ( arg0 * secretsmanager . PutSecretValueInput ) ( * secretsmanager . PutSecretValueOutput , error ) { ret := m . ctrl . Call ( m , "PutSecretValue" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1246	func ( cs * clientServer ) Close ( ) error { if cs . publishTicker != nil { cs . publishTicker . Stop ( ) } if cs . publishHealthTicker != nil { cs . publishHealthTicker . Stop ( ) } cs . cancel ( ) return cs . Disconnect ( ) }
6727	func ( d PingScanner ) Scan ( ) ( aliveIPs [ ] string , err error ) { var hostsInCidr [ ] string if hostsInCidr , err = expandCidrIntoIPs ( d . CIDR ) ; err != nil { return nil , err } pingChan := make ( chan string , d . NumOfConcurrency ) pongChan := make ( chan pong , len ( hostsInCidr ) ) doneChan := make ( chan [ ] pong ) for i := 0 ; i < d . NumOfConcurrency ; i ++ { go ping ( pingChan , pongChan , d . PingOptions ... ) } go receivePong ( len ( hostsInCidr ) , pongChan , doneChan ) for _ , ip := range hostsInCidr { pingChan <- ip } alives := <- doneChan for _ , a := range alives { aliveIPs = append ( aliveIPs , a . IP ) } sort . Strings ( aliveIPs ) return }
3850	func ( l * List ) SetCursor ( i int ) { max := len ( l . scope ) - 1 if i >= max { i = max } if i < 0 { i = 0 } l . cursor = i if l . start > l . cursor { l . start = l . cursor } else if l . start + l . size <= l . cursor { l . start = l . cursor - l . size + 1 } }
1202	func ( m * MockTimer ) Reset ( arg0 time . Duration ) bool { ret := m . ctrl . Call ( m , "Reset" , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 }
692	func ( p * dnsimpleProvider ) submitChanges ( changes [ ] * dnsimpleChange ) error { if len ( changes ) == 0 { log . Infof ( "All records are already up to date" ) return nil } zones , err := p . Zones ( ) if err != nil { return err } for _ , change := range changes { zone := dnsimpleSuitableZone ( change . ResourceRecordSet . Name , zones ) if zone == nil { log . Debugf ( "Skipping record %s because no hosted zone matching record DNS Name was detected " , change . ResourceRecordSet . Name ) continue } log . Infof ( "Changing records: %s %v in zone: %s" , change . Action , change . ResourceRecordSet , zone . Name ) change . ResourceRecordSet . Name = strings . TrimSuffix ( change . ResourceRecordSet . Name , "." + zone . Name ) if ! p . dryRun { switch change . Action { case dnsimpleCreate : _ , err := p . client . CreateRecord ( p . accountID , zone . Name , change . ResourceRecordSet ) if err != nil { return err } case dnsimpleDelete : recordID , err := p . GetRecordID ( zone . Name , change . ResourceRecordSet . Name ) if err != nil { return err } _ , err = p . client . DeleteRecord ( p . accountID , zone . Name , recordID ) if err != nil { return err } case dnsimpleUpdate : recordID , err := p . GetRecordID ( zone . Name , change . ResourceRecordSet . Name ) if err != nil { return err } _ , err = p . client . UpdateRecord ( p . accountID , zone . Name , recordID , change . ResourceRecordSet ) if err != nil { return err } } } } return nil }
2818	func flattenVMwareUplinkPortOrderPolicy ( d * schema . ResourceData , obj * types . VMwareUplinkPortOrderPolicy ) error { if obj == nil { return nil } if err := d . Set ( "active_uplinks" , obj . ActiveUplinkPort ) ; err != nil { return err } if err := d . Set ( "standby_uplinks" , obj . StandbyUplinkPort ) ; err != nil { return err } return nil }
7170	func ( s * Stack ) IterateBackward ( handler func ( depth int , header io . Reader , body io . Reader ) bool ) error { s . guard . Lock ( ) defer s . guard . Unlock ( ) if s . depth == 0 { return nil } file , err := s . getFile ( ) if err != nil { return err } defer file . Seek ( 0 , os . SEEK_END ) var ( currentBlock fileBlock currentBlockOffset uint64 ) currentBlock = s . currentBlock currentBlockOffset = uint64 ( s . currentBlockPos ) depth := s . depth for { body := io . NewSectionReader ( file , int64 ( currentBlock . DataPoint ) , int64 ( currentBlock . DataSize ) ) header := io . NewSectionReader ( file , int64 ( currentBlock . HeaderPoint ) , int64 ( currentBlock . HeaderSize ) ) if handler != nil && ! handler ( depth , header , body ) { return nil } if currentBlock . PrevBlock > currentBlockOffset { log . Printf ( "Danger back-ref link: prev block %v has greater index then current %v" , currentBlock . PrevBlock , currentBlockOffset ) } depth -- if currentBlock . PrevBlock == currentBlockOffset { break } currentBlockOffset = currentBlock . PrevBlock currentBlock , err = readBlockAt ( file , int64 ( currentBlock . PrevBlock ) ) if err != nil { return err } } if depth != 0 { log . Println ( "Broker back path detected at" , depth , "depth index" ) } return nil }
1332	func ( m * MockHttpClient ) GetInstanceIdentityDocument ( ) ( ec2metadata . EC2InstanceIdentityDocument , error ) { ret := m . ctrl . Call ( m , "GetInstanceIdentityDocument" ) ret0 , _ := ret [ 0 ] . ( ec2metadata . EC2InstanceIdentityDocument ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5380	func ( c * Config ) Getint ( key string ) ( int , error ) { if value , found := c . data [ key ] ; found { v , err := strconv . ParseInt ( value , 10 , 0 ) return int ( v ) , err } return 0 , ErrKey }
2555	func expandLinkDiscoveryProtocolConfig ( d * schema . ResourceData ) * types . LinkDiscoveryProtocolConfig { obj := & types . LinkDiscoveryProtocolConfig { Operation : d . Get ( "link_discovery_operation" ) . ( string ) , Protocol : d . Get ( "link_discovery_protocol" ) . ( string ) , } return obj }
2940	func resourceVSphereDatastoreClusterHasSDRSConfigChange ( d * schema . ResourceData ) bool { for k := range resourceVSphereDatastoreCluster ( ) . Schema { switch { case resourceVSphereDatastoreClusterHasSDRSConfigChangeExcluded ( k ) : continue case d . HasChange ( k ) : return true } } return false }
6872	func ( e * execStreamerBuilder ) Dir ( dir string ) ExecStreamerBuilder { e . d . Dir = dir return e }
4944	func ( c * Connector ) SetSessionVariables ( sessionVariables SessionVariables ) error { c . mu . Lock ( ) defer c . mu . Unlock ( ) c . sessionVariables = sessionVariables return nil }
992	func ( s * Scratch ) MapSetX ( k , mk string , v interface { } ) ( string , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) return s . mapSet ( k , mk , v , false ) }
3043	func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { var params * m . QueryParam var ch chan * m . ServiceEntry var v6 , v4 bool var addrs [ ] string var err error if l == nil { l = log . New ( ioutil . Discard , "" , 0 ) } params = new ( m . QueryParam ) if args [ "service" ] == "" { return nil , fmt . Errorf ( "discover-mdns: Service record not provided." + " Please specify a service record for the mDNS lookup." ) } params . Service = args [ "service" ] if args [ "domain" ] != "" { params . Domain = args [ "domain" ] } else { params . Domain = "local" } if args [ "timeout" ] != "" { if params . Timeout , err = time . ParseDuration ( args [ "timeout" ] ) ; err != nil { return nil , fmt . Errorf ( "discover-mdns: Failed to parse timeout: %s" , err ) } } else { params . Timeout = 5 * time . Second } if args [ "v6" ] != "" { if v6 , err = strconv . ParseBool ( args [ "v6" ] ) ; err != nil { return nil , fmt . Errorf ( "discover-mdns: Failed to parse v6: %s" , err ) } } else { v6 = true } if args [ "v4" ] != "" { if v4 , err = strconv . ParseBool ( args [ "v4" ] ) ; err != nil { return nil , fmt . Errorf ( "discover-mdns: Failed to parse v4: %s" , err ) } } else { v4 = true } ch = make ( chan * m . ServiceEntry ) defer close ( ch ) params . Entries = ch go func ( ) { var addr string for e := range ch { addr = "" if v6 && e . AddrV6 != nil { addr = net . JoinHostPort ( e . AddrV6 . String ( ) , strconv . Itoa ( e . Port ) ) } if addr == "" && v4 && e . AddrV4 != nil { addr = net . JoinHostPort ( e . AddrV4 . String ( ) , strconv . Itoa ( e . Port ) ) } if addr != "" { l . Printf ( "[DEBUG] discover-mdns: %s -> %s" , e . Host , addr ) addrs = append ( addrs , addr ) } } } ( ) return addrs , m . Query ( params ) }
2302	func ( v * TreePath ) native ( ) * C . GtkTreePath { if v == nil { return nil } return v . GtkTreePath }
7225	func ( logger * Logger ) Criticalf ( format string , a ... interface { } ) { logger . log ( CRITICAL , format , a ... ) }
6475	func CacheFunc ( bodyHandler func ( http . ResponseWriter , * http . Request ) , expiration time . Duration ) http . HandlerFunc { return Cache ( http . HandlerFunc ( bodyHandler ) , expiration ) . ServeHTTP }
1723	func ( task * Task ) UpdateMountPoints ( cont * apicontainer . Container , vols [ ] types . MountPoint ) { for _ , mountPoint := range cont . MountPoints { containerPath := getCanonicalPath ( mountPoint . ContainerPath ) for _ , vol := range vols { if strings . Compare ( vol . Destination , containerPath ) == 0 || strings . Compare ( vol . Destination , strings . TrimRight ( containerPath , string ( filepath . Separator ) ) ) == 0 { if hostVolume , exists := task . HostVolumeByName ( mountPoint . SourceVolume ) ; exists { if empty , ok := hostVolume . ( * taskresourcevolume . LocalDockerVolume ) ; ok { empty . HostPath = vol . Source } } } } } }
5382	func ( c * Config ) Getfloat ( key string ) ( float64 , error ) { if value , found := c . data [ key ] ; found { return strconv . ParseFloat ( value , 64 ) } return 0 , ErrKey }
3986	func CheckRDNSequenceWhiteSpace ( raw [ ] byte ) ( leading , trailing bool , err error ) { var seq pkix . RDNSequence if _ , err = asn1 . Unmarshal ( raw , & seq ) ; err != nil { return } for _ , rdn := range seq { for _ , atv := range rdn { if ! IsNameAttribute ( atv . Type ) { continue } value , ok := atv . Value . ( string ) if ! ok { continue } if leftStrip := strings . TrimLeftFunc ( value , unicode . IsSpace ) ; leftStrip != value { leading = true } if rightStrip := strings . TrimRightFunc ( value , unicode . IsSpace ) ; rightStrip != value { trailing = true } } } return }
7039	func ( c * Conn ) sendResponse ( id string , result interface { } , err * ResError ) error { return c . send ( response { ID : id , Result : result , Error : err } ) }
5919	func ( it * Iterator ) Set ( val [ ] byte , meta uint16 ) error { new , err := it . list . allocVal ( val , meta ) if err != nil { return err } return it . trySetValue ( new ) }
5296	func CompileRegexp ( pattern string ) ( * Regexp , error ) { compiled , err := regexp . Compile ( pattern ) if err != nil { return nil , err } re , err := syntax . Parse ( pattern , syntax . Perl ) if err != nil { return nil , err } tpl := & template { buffer : new ( bytes . Buffer ) } tpl . write ( re ) return & Regexp { compiled : compiled , template : tpl . buffer . String ( ) , groups : tpl . groups , indices : tpl . indices , } , nil }
1764	func ( task * Task ) getSSMSecretsResource ( ) ( [ ] taskresource . TaskResource , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) res , ok := task . ResourcesMapUnsafe [ ssmsecret . ResourceName ] return res , ok }
4932	func ( w * Writer ) WriteString ( s string ) { if w . err != nil { return } w . wr . WriteString ( s ) }
5214	func ( idx * Index ) GroupByFilter ( filterQuery * PQLRowQuery , rowsQueries ... * PQLRowsQuery ) * PQLBaseQuery { if len ( rowsQueries ) < 1 { return NewPQLBaseQuery ( "" , idx , errors . New ( "there should be at least one rows query" ) ) } filterText := filterQuery . serialize ( ) . String ( ) text := fmt . Sprintf ( "GroupBy(%s,filter=%s)" , strings . Join ( serializeGroupBy ( rowsQueries ... ) , "," ) , filterText ) return NewPQLBaseQuery ( text , idx , nil ) }
5402	func LookupGroup ( name string ) ( * Group , error ) { entries , err := LookupInGroup ( G_NAME , name , 1 ) if err != nil { return nil , err } return entries [ 0 ] , err }
5694	func simplify ( a AST ) AST { var seen [ ] AST skip := func ( a AST ) bool { for _ , v := range seen { if v == a { return true } } seen = append ( seen , a ) return false } if r := a . Copy ( simplifyOne , skip ) ; r != nil { return r } return a }
1455	func ( dc * DockerContainer ) String ( ) string { if dc == nil { return "nil" } return fmt . Sprintf ( "Id: %s, Name: %s, Container: %s" , dc . DockerID , dc . DockerName , dc . Container . String ( ) ) }
5042	func ( p * Pipe ) Batch ( n int ) * Pipe { p . batchSize = n return p }
1015	func ( s * Set ) String ( ) string { s . RLock ( ) defer s . RUnlock ( ) return strings . Join ( s . list , ", " ) }
1778	func ( mr * MockStateManagerMockRecorder ) ForceSave ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "ForceSave" , reflect . TypeOf ( ( * MockStateManager ) ( nil ) . ForceSave ) ) }
21	func linearRegression ( samples [ ] Point , interceptTime int64 ) ( slope , intercept float64 ) { var ( n float64 sumX , sumY float64 sumXY , sumX2 float64 ) for _ , sample := range samples { x := float64 ( sample . T - interceptTime ) / 1e3 n += 1.0 sumY += sample . V sumX += x sumXY += x * sample . V sumX2 += x * x } covXY := sumXY - sumX * sumY / n varX := sumX2 - sumX * sumX / n slope = covXY / varX intercept = sumY / n - slope * sumX / n return slope , intercept }
5379	func ( c * Config ) Getbool ( key string ) ( bool , error ) { if value , found := c . data [ key ] ; found { return strconv . ParseBool ( value ) } return false , ErrKey }
4951	func ( s * Scanner ) Next ( ) rune { s . b . Reset ( ) ch := s . next ( ) for unicode . IsSpace ( ch ) { ch = s . next ( ) } tok := ch switch { default : tok = Undefined ch = s . next ( ) case ch == EOF : break case isOperator ( ch ) : tok = Operator ch = s . scanOperator ( ch ) case isDelimiter ( ch ) : tok = Delimiter s . b . WriteRune ( ch ) ch = s . next ( ) case isNameDelimiter ( ch ) : tok = IdentifierDelimiter s . b . WriteRune ( ch ) ch = s . next ( ) case isIdentifier ( ch ) : tok = Identifier s . b . WriteRune ( ch ) ch = s . scanAlpha ( ) case isSingleQuote ( ch ) : tok = String ch = s . scanQuotedIdentifier ( ch ) case isDoubleQuote ( ch ) : tok = QuotedIdentifier ch = s . scanQuotedIdentifier ( ch ) case isQuestionMark ( ch ) : tok = Variable ch = s . next ( ) case isColon ( ch ) : ch = s . peek ( ) if isDigit ( ch ) { tok = PosVariable ch = s . scanNumeric ( ) } else { tok = NamedVariable ch = s . scanAlpha ( ) } case isNumber ( ch ) : tok = Number ch = s . scanNumber ( ) } s . ch = ch s . rd . UnreadRune ( ) if ch == Error { return ch } return tok }
1981	func ( m * MockClient ) ImageLoad ( arg0 context . Context , arg1 io . Reader , arg2 bool ) ( types . ImageLoadResponse , error ) { ret := m . ctrl . Call ( m , "ImageLoad" , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( types . ImageLoadResponse ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6259	func ( h * Handler ) UpdateOffering ( tkn string , offering * data . Offering ) error { logger := h . logger . Add ( "method" , "UpdateOffering" , "offering" , offering ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } err := h . findByPrimaryKey ( logger , ErrOfferingNotFound , & data . Offering { } , offering . ID ) if err != nil { return err } err = update ( logger , h . db . Querier , offering ) if err != nil { return err } return nil }
5401	func LookupGID ( gid int ) ( * Group , error ) { entries , err := LookupInGroup ( G_GID , gid , 1 ) if err != nil { return nil , err } return entries [ 0 ] , err }
663	func ( t Targets ) Same ( o Targets ) bool { if len ( t ) != len ( o ) { return false } sort . Stable ( t ) sort . Stable ( o ) for i , e := range t { if e != o [ i ] { return false } } return true }
7247	func ( l * logger ) Okln ( vals ... interface { } ) { l . mut . Lock ( ) defer l . mut . Unlock ( ) s := fmt . Sprintln ( vals ... ) l . logger . Output ( 2 , "OK: " + s ) l . callHandlers ( LevelOK , s ) }
3983	func IsInTLDMap ( label string ) bool { label = strings . ToLower ( label ) if _ , ok := tldMap [ label ] ; ok { return true } else { return false } }
6809	func ( t * T ) Error ( args ... interface { } ) { fmt . Fprintln ( os . Stderr , args ... ) t . Fail ( ) }
2808	func flattenVmwareDistributedVirtualSwitchVlanIDSpec ( d * schema . ResourceData , obj * types . VmwareDistributedVirtualSwitchVlanIdSpec ) error { d . Set ( "vlan_id" , obj . VlanId ) return nil }
4581	func ( c * Context ) findRoots ( ) { c . GOPATHs = map [ string ] string { } for _ , f := range getFiles ( c . Goroutines ) { if c . GOROOT != "" && strings . HasPrefix ( f , c . GOROOT + "/" ) { continue } if hasPathPrefix ( f , c . GOPATHs ) { continue } parts := splitPath ( f ) if c . GOROOT == "" { if r := rootedIn ( c . localgoroot , parts ) ; r != "" { c . GOROOT = r continue } } found := false for _ , l := range c . localgopaths { if r := rootedIn ( l , parts ) ; r != "" { c . GOPATHs [ r ] = l found = true break } } if ! found { } } }
5081	func ( socket * mongoSocket ) ServerInfo ( ) * mongoServerInfo { socket . Lock ( ) serverInfo := socket . serverInfo socket . Unlock ( ) return serverInfo }
2763	func flattenToolsConfigInfo ( d * schema . ResourceData , obj * types . ToolsConfigInfo ) error { d . Set ( "sync_time_with_host" , obj . SyncTimeWithHost ) d . Set ( "run_tools_scripts_after_power_on" , obj . AfterPowerOn ) d . Set ( "run_tools_scripts_after_resume" , obj . AfterResume ) d . Set ( "run_tools_scripts_before_guest_standby" , obj . BeforeGuestStandby ) d . Set ( "run_tools_scripts_before_guest_shutdown" , obj . BeforeGuestShutdown ) d . Set ( "run_tools_scripts_before_guest_reboot" , obj . BeforeGuestReboot ) return nil }
990	func ( s * Scratch ) SetX ( k string , v interface { } ) string { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if _ , ok := s . values [ k ] ; ! ok { s . values [ k ] = v } return "" }
4078	func FindFirstControl ( parent Control , fn func ( Control ) bool ) Control { linear := getLinearControlList ( parent , fn ) if len ( linear ) == 0 { return nil } return linear [ 0 ] }
1688	func NewECRAuthProvider ( ecrFactory ecr . ECRFactory , cache async . Cache ) DockerAuthProvider { return & ecrAuthProvider { tokenCache : cache , factory : ecrFactory , } }
6450	func ( s * Severity ) Set ( value string ) error { var threshold Severity if v , ok := severityByName ( value ) ; ok { threshold = v } else { v , err := strconv . Atoi ( value ) if err != nil { return err } threshold = Severity ( v ) } * s = threshold return nil }
6122	func ( h * Handler ) GetUserRole ( tkn string ) ( * string , error ) { logger := h . logger . Add ( "method" , "GetUserRole" ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } return & h . userRole , nil }
2815	func expandDVSFailureCriteria ( d * schema . ResourceData ) * types . DVSFailureCriteria { obj := & types . DVSFailureCriteria { CheckBeacon : structure . GetBoolPolicy ( d , "check_beacon" ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
2791	func portGroupIDsFromResourceID ( d * schema . ResourceData ) ( string , string , error ) { return splitHostPortGroupID ( d . Id ( ) ) }
2116	func ( v * ComboBoxText ) native ( ) * C . GtkComboBoxText { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkComboBoxText ( p ) }
615	func ( t * throttler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { ctx := r . Context ( ) select { case <- ctx . Done ( ) : http . Error ( w , errContextCanceled , http . StatusServiceUnavailable ) return case btok := <- t . backlogTokens : timer := time . NewTimer ( t . backlogTimeout ) defer func ( ) { t . backlogTokens <- btok } ( ) select { case <- timer . C : http . Error ( w , errTimedOut , http . StatusServiceUnavailable ) return case <- ctx . Done ( ) : http . Error ( w , errContextCanceled , http . StatusServiceUnavailable ) return case tok := <- t . tokens : defer func ( ) { t . tokens <- tok } ( ) t . h . ServeHTTP ( w , r ) } return default : http . Error ( w , errCapacityExceeded , http . StatusServiceUnavailable ) return } }
3886	func ( b * builder ) logicalBinop ( fn * Function , e * ast . BinaryExpr ) Value { rhs := fn . newBasicBlock ( "binop.rhs" ) done := fn . newBasicBlock ( "binop.done" ) t := fn . Pkg . typeOf ( e ) var short Value switch e . Op { case token . LAND : b . cond ( fn , e . X , rhs , done ) short = NewConst ( exact . MakeBool ( false ) , t ) case token . LOR : b . cond ( fn , e . X , done , rhs ) short = NewConst ( exact . MakeBool ( true ) , t ) } if rhs . Preds == nil { fn . currentBlock = done return short } if done . Preds == nil { fn . currentBlock = rhs return b . expr ( fn , e . Y ) } var edges [ ] Value for range done . Preds { edges = append ( edges , short ) } fn . currentBlock = rhs edges = append ( edges , b . expr ( fn , e . Y ) ) emitJump ( fn , done ) fn . currentBlock = done phi := & Phi { Edges : edges , Comment : e . Op . String ( ) } phi . pos = e . OpPos phi . typ = t return done . emit ( phi ) }
5148	func ( ui * PrefixUI ) Warn ( message string ) { if ui . WarnPrefix == " " { message = ui . WarnPrefix + message } else if ui . WarnPrefix != "" { message = ui . WarnPrefix + " " + message } ui . UI . Warn ( message ) }
2852	func Delete ( client * govmomi . Client , name string , dc * object . Datacenter ) error { if dc == nil { return fmt . Errorf ( "datacenter cannot be nil" ) } log . Printf ( "[DEBUG] Deleting virtual disk %q in datacenter %s" , name , dc ) vdm := object . NewVirtualDiskManager ( client . Client ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := vdm . DeleteVirtualDisk ( ctx , name , dc ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) if err := task . Wait ( tctx ) ; err != nil { return err } log . Printf ( "[DEBUG] Virtual disk %q in datacenter %s deleted succesfully" , name , dc ) return nil }
5957	func ( s Scan ) SetUDPPorts ( ports ... uint16 ) Scan { s . configUDPPorts = ports return s }
855	func setVmwareCmd ( cmd string ) string { if path , err := exec . LookPath ( cmd ) ; err == nil { return path } return filepath . Join ( "/Applications/VMware Fusion.app/Contents/Library/" , cmd ) }
247	func PreferLocalStorageFilter ( next storage . Queryable , cb startTimeCallback ) storage . Queryable { return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { localStartTime , err := cb ( ) if err != nil { return nil , err } cmaxt := maxt if mint > localStartTime { return storage . NoopQuerier ( ) , nil } if maxt > localStartTime { cmaxt = localStartTime } return next . Querier ( ctx , mint , cmaxt ) } ) }
2401	func ( g * Game ) Draw ( screen * ebiten . Image ) { if g . boardImage == nil { w , h := g . board . Size ( ) g . boardImage , _ = ebiten . NewImage ( w , h , ebiten . FilterDefault ) } screen . Fill ( backgroundColor ) g . board . Draw ( g . boardImage ) op := & ebiten . DrawImageOptions { } sw , sh := screen . Size ( ) bw , bh := g . boardImage . Size ( ) x := ( sw - bw ) / 2 y := ( sh - bh ) / 2 op . GeoM . Translate ( float64 ( x ) , float64 ( y ) ) screen . DrawImage ( g . boardImage , op ) }
3003	func resourceVSphereVAppContainerReadTags ( d * schema . ResourceData , meta interface { } , va * object . VirtualApp ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( "[DEBUG] %s: Reading tags" , resourceVSphereVAppContainerIDString ( d ) ) if err := readTagsForResource ( tagsClient , va , d ) ; err != nil { return err } } else { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping tag read" , resourceVSphereVAppContainerIDString ( d ) ) } return nil }
307	func Uname ( ) string { buf := syscall . Utsname { } err := syscall . Uname ( & buf ) if err != nil { panic ( "syscall.Uname failed: " + err . Error ( ) ) } str := "(" + charsToString ( buf . Sysname [ : ] ) str += " " + charsToString ( buf . Release [ : ] ) str += " " + charsToString ( buf . Version [ : ] ) str += " " + charsToString ( buf . Machine [ : ] ) str += " " + charsToString ( buf . Nodename [ : ] ) str += " " + charsToString ( buf . Domainname [ : ] ) + ")" return str }
4955	func Serialize ( parts ... [ ] byte ) string { result := make ( [ ] string , len ( parts ) ) for i , part := range parts { result [ i ] = base64url . Encode ( part ) } return strings . Join ( result , "." ) }
1111	func parseFloat ( s string ) ( float64 , error ) { if s == "" { return 0.0 , nil } result , err := strconv . ParseFloat ( s , 10 ) if err != nil { return 0 , errors . Wrap ( err , "parseFloat" ) } return result , nil }
5091	func Create ( c * gin . Context ) { db := c . MustGet ( "db" ) . ( * mgo . Database ) article := models . Article { } err := c . Bind ( & article ) if err != nil { c . Error ( err ) return } err = db . C ( models . CollectionArticle ) . Insert ( article ) if err != nil { c . Error ( err ) } c . Redirect ( http . StatusMovedPermanently , "/articles" ) }
4563	func NewTemplate ( input string ) ( * Template , error ) { t := & Template { Input : input , } err := t . Parse ( ) if err != nil { return t , err } return t , nil }
7109	func newDefaultLogger ( ) * Logger { return NewLogger ( "default" , DEBUG , [ ] Handler { & WriteHandler { Level : DEBUG , Formatter : & StandardFormatter { TimeFormat : StandardTimeFormat } , Writer : os . Stderr , } , } , 0 ) }
6651	func ( v Vec3 ) Assign ( v1 Vec3 ) { v [ 0 ] = v1 [ 0 ] v [ 1 ] = v1 [ 1 ] v [ 2 ] = v1 [ 2 ] }
2580	func hostStorageSystemFromHostSystemID ( client * govmomi . Client , hsID string ) ( * object . HostStorageSystem , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return nil , err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) return hs . ConfigManager ( ) . StorageSystem ( ctx ) }
1618	func ( m * MockSecretsManagerAPI ) UntagResourceRequest ( arg0 * secretsmanager . UntagResourceInput ) ( * request . Request , * secretsmanager . UntagResourceOutput ) { ret := m . ctrl . Call ( m , "UntagResourceRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . UntagResourceOutput ) return ret0 , ret1 }
5303	func New ( buf [ ] byte , options Options ) * Cmp { return NewMultiple ( buf , options , nil , true ) }
5686	func hasReturnType ( a AST ) bool { switch a := a . ( type ) { case * Template : return ! isCDtorConversion ( a . Name ) case * TypeWithQualifiers : return hasReturnType ( a . Base ) case * MethodWithQualifiers : return hasReturnType ( a . Method ) default : return false } }
7239	func ( e * Entry ) traverse ( method , urlStr string ) ( * Route , [ ] string ) { for _ , entry := range e . entries { if h , params := entry . exec ( method , urlStr ) ; h != nil { return h , params } } return nil , nil }
6834	func ( c * Client ) Device ( nickname string ) ( * Device , error ) { devices , err := c . Devices ( ) if err != nil { return nil , err } for i := range devices { if devices [ i ] . Nickname == nickname { devices [ i ] . Client = c return devices [ i ] , nil } } return nil , ErrDeviceNotFound }
4670	func getCache ( name string ) ( template . Template , bool ) { cacheMutex . RLock ( ) tpl , ok := cache [ name ] cacheMutex . RUnlock ( ) return tpl , ok }
6214	func ( w * Worker ) ClientEndpointCreate ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientEndpointCreate" , "job" , job ) ch , err := w . relatedChannel ( logger , job , data . JobClientEndpointRestore ) if err != nil { return err } var jdata data . JobEndpointCreateData if err := w . unmarshalDataTo ( logger , job . Data , & jdata ) ; err != nil { return err } msg , err := w . extractEndpointMessage ( logger , ch , jdata . EndpointSealed ) if err != nil { return err } offer , err := w . offering ( logger , ch . Offering ) if err != nil { return err } url := strings . Replace ( w . countryConfig . URLTemplate , "{{ip}}" , msg . ServiceEndpointAddress , 1 ) var countryStatus string c , err := country . GetCountry ( w . countryConfig . Timeout , url , w . countryConfig . Field ) if err != nil || len ( c ) != 2 { countryStatus = data . CountryStatusUnknown } else if c == offer . Country { countryStatus = data . CountryStatusValid } else { countryStatus = data . CountryStatusInvalid } params , _ := json . Marshal ( msg . AdditionalParams ) return w . db . InTransaction ( func ( tx * reform . TX ) error { raddr := pointer . ToString ( msg . PaymentReceiverAddress ) saddr := pointer . ToString ( msg . ServiceEndpointAddress ) endp := data . Endpoint { ID : util . NewUUID ( ) , Template : offer . Template , Channel : ch . ID , Hash : msg . TemplateHash , RawMsg : data . FromBytes ( jdata . EndpointSealed ) , PaymentReceiverAddress : raddr , ServiceEndpointAddress : saddr , Username : pointer . ToString ( msg . Username ) , Password : pointer . ToString ( msg . Password ) , AdditionalParams : params , CountryStatus : pointer . ToString ( countryStatus ) , } if err = w . db . Insert ( & endp ) ; err != nil { logger . Add ( "endpoint" , endp ) . Error ( err . Error ( ) ) return ErrInternal } ch . ServiceStatus = data . ServiceSuspended changedTime := time . Now ( ) ch . ServiceChangedTime = & changedTime ch . PreparedAt = changedTime err = w . saveRecord ( logger , w . db . Querier , ch ) if err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil } ) }
4788	func ( c Config ) computeSize ( bounds image . Rectangle , ratio image . Point ) ( p image . Point ) { if c . Options & Ratio == Ratio { if float64 ( ratio . X ) / float64 ( bounds . Dx ( ) ) > float64 ( ratio . Y ) / float64 ( bounds . Dy ( ) ) { p = image . Point { bounds . Dx ( ) , ( bounds . Dx ( ) / ratio . X ) * ratio . Y } } else { p = image . Point { ( bounds . Dy ( ) / ratio . Y ) * ratio . X , bounds . Dy ( ) } } } else { p = image . Point { ratio . X , ratio . Y } } return }
7074	func New ( db * sql . DB , tables Tables ) Fixture { fixture := Fixture { db : db , Tables : tables } return fixture }
3275	func ( d * DashboardList ) GetDashboardCountOk ( ) ( int , bool ) { if d == nil || d . DashboardCount == nil { return 0 , false } return * d . DashboardCount , true }
4983	func ( c * Consumer ) FirehoseWithoutReconnect ( subscriptionId string , authToken string , ) ( <- chan * events . Envelope , <- chan error ) { return c . firehose ( newFirehose ( subscriptionId , authToken , WithRetry ( false ) , ) ) }
4461	func IsDateTime ( str string ) bool { if len ( str ) < 4 { return false } s := strings . Split ( strings . ToLower ( str ) , "t" ) if len ( s ) < 2 || ! IsDate ( s [ 0 ] ) { return false } matches := rxDateTime . FindAllStringSubmatch ( s [ 1 ] , - 1 ) if len ( matches ) == 0 || len ( matches [ 0 ] ) == 0 { return false } m := matches [ 0 ] res := m [ 1 ] <= "23" && m [ 2 ] <= "59" && m [ 3 ] <= "59" return res }
2324	func ( c * RGBA ) SetColors ( r , g , b , a float64 ) { c . rgba . red = C . gdouble ( r ) c . rgba . green = C . gdouble ( g ) c . rgba . blue = C . gdouble ( b ) c . rgba . alpha = C . gdouble ( a ) }
5611	func ( o * GetVMByCidParams ) WithContext ( ctx context . Context ) * GetVMByCidParams { o . SetContext ( ctx ) return o }
1336	func ( m * MockClient ) DescribeECSTagsForInstance ( arg0 string ) ( [ ] * ecs . Tag , error ) { ret := m . ctrl . Call ( m , "DescribeECSTagsForInstance" , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] * ecs . Tag ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
6782	func ( v * X509NameVerifier ) Wrap ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { dn := r . Header . Get ( v . HeaderName ) var name * pkix . Name if dn != "" { name = parseDN ( dn ) } if name != nil && v . CheckCertificate ( name ) { h . ServeHTTP ( w , r ) } else if v . InvalidHandler != nil { v . InvalidHandler . ServeHTTP ( w , r ) } else { log . Printf ( "Rejected request with an invalid client certificate: %q" , dn ) w . WriteHeader ( 403 ) } } ) }
4813	func ( r * Repo ) checkoutCommit ( commitHash string ) error { var err error params := [ ] string { "checkout" , commitHash } if err = r . gitCmd ( params , r . Path ) ; err == nil { Logger ( ) . Printf ( "Commit %v checkout done.\n" , \n ) } commitHash }
2713	func selectEventsForReference ( client * govmomi . Client , ref types . ManagedObjectReference , eventTypes [ ] string ) ( [ ] types . BaseEvent , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) filter := types . EventFilterSpec { Entity : & types . EventFilterSpecByEntity { Entity : ref , Recursion : types . EventFilterSpecRecursionOptionAll , } , EventTypeId : eventTypes , } mgr := event . NewManager ( client . Client ) return mgr . QueryEvents ( ctx , filter ) }
980	func DefaultVaultConfig ( ) * VaultConfig { v := & VaultConfig { Retry : DefaultRetryConfig ( ) , SSL : DefaultSSLConfig ( ) , Transport : DefaultTransportConfig ( ) , } v . SSL . Enabled = Bool ( true ) return v }
7181	func NewClient ( nick , serverHost string , serverPort uint16 ) * Client { return & Client { nick : nick , serverHost : serverHost , serverPort : serverPort , writeTimeout : 30 * time . Second , readTimeout : 100 * time . Millisecond , channels : map [ string ] struct { } { } , mutex : & sync . Mutex { } , } }
2216	func ( v * Adjustment ) native ( ) * C . GtkAdjustment { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAdjustment ( p ) }
5077	func Connect ( c * gin . Context ) { s := db . Session . Clone ( ) defer s . Close ( ) c . Set ( "db" , s . DB ( db . Mongo . Database ) ) c . Next ( ) }
5707	func ( s * Sentinel ) defaultPool ( addr string ) * redis . Pool { return & redis . Pool { MaxIdle : 3 , MaxActive : 10 , Wait : true , IdleTimeout : 240 * time . Second , Dial : func ( ) ( redis . Conn , error ) { return s . Dial ( addr ) } , TestOnBorrow : func ( c redis . Conn , t time . Time ) error { _ , err := c . Do ( "PING" ) return err } , } }
2516	func flattenHostNicOrderPolicy ( d * schema . ResourceData , obj * types . HostNicOrderPolicy ) error { if obj == nil { return nil } if err := d . Set ( "active_nics" , structure . SliceStringsToInterfaces ( obj . ActiveNic ) ) ; err != nil { return err } if err := d . Set ( "standby_nics" , structure . SliceStringsToInterfaces ( obj . StandbyNic ) ) ; err != nil { return err } return nil }
5250	func ( c * Client ) SyncSchema ( schema * Schema ) error { span := c . tracer . StartSpan ( "Client.SyncSchema" ) defer span . Finish ( ) serverSchema , err := c . Schema ( ) if err != nil { return err } return c . syncSchema ( schema , serverSchema ) }
4319	func ( c * Client ) BuildOpts ( account , repo , branch string , opts map [ string ] interface { } ) ( * Build , error ) { build := & Build { } err := c . request ( "POST" , fmt . Sprintf ( "project/%s/%s/tree/%s" , account , repo , branch ) , build , nil , opts ) if err != nil { return nil , err } return build , nil }
5744	func initLocales ( opt Options ) language . Matcher { tags := make ( [ ] language . Tag , len ( opt . Langs ) ) for i , lang := range opt . Langs { tags [ i ] = language . Raw . Make ( lang ) fname := fmt . Sprintf ( opt . Format , lang ) custom := [ ] interface { } { } customPath := path . Join ( opt . CustomDirectory , fname ) if com . IsFile ( customPath ) { custom = append ( custom , customPath ) } var locale interface { } if data , ok := opt . Files [ fname ] ; ok { locale = data } else { locale = path . Join ( opt . Directory , fname ) } err := i18n . SetMessageWithDesc ( lang , opt . Names [ i ] , locale , custom ... ) if err != nil && err != i18n . ErrLangAlreadyExist { panic ( fmt . Errorf ( "fail to set message file(%s): %v" , lang , err ) ) } } return language . NewMatcher ( tags ) }
5039	func ( c * Collection ) Repair ( ) * Iter { session := c . Database . Session cloned := session . Clone ( ) cloned . SetMode ( Monotonic , false ) defer cloned . Close ( ) batchSize := int ( cloned . queryConfig . op . limit ) var result struct { Cursor struct { FirstBatch [ ] bson . Raw "firstBatch" Id int64 } } cmd := repairCmd { RepairCursor : c . Name , Cursor : & repairCmdCursor { batchSize } , } clonedc := c . With ( cloned ) err := clonedc . Database . Run ( cmd , & result ) return clonedc . NewIter ( session , result . Cursor . FirstBatch , result . Cursor . Id , err ) }
6190	func ExecuteCommand ( args [ ] string ) error { if len ( args ) == 0 { return nil } switch args [ 0 ] { case "db-create" : f := readFlags ( args ) if err := createDatabase ( f . connection ) ; err != nil { panic ( "failed to create database: " + err . Error ( ) ) } os . Exit ( 0 ) case "db-migrate" : f := readFlags ( args ) err := migration . Migrate ( f . connection , f . version ) if err != nil { panic ( "failed to run migration: " + err . Error ( ) ) } os . Exit ( 0 ) case "db-init-data" : f := readFlags ( args ) if err := initData ( f . connection ) ; err != nil { panic ( "failed to init database: " + err . Error ( ) ) } os . Exit ( 0 ) case "db-version" : f := readFlags ( args ) version , err := migration . Version ( f . connection ) if err != nil { msg := "failed to print database schema version: " panic ( msg + err . Error ( ) ) } fmt . Println ( "database schema version:" , version ) os . Exit ( 0 ) } return nil }
2147	func ( m * Matrix ) InitScale ( sx , sy float64 ) { C . cairo_matrix_init_scale ( m . native ( ) , C . double ( sx ) , C . double ( sy ) ) }
647	func NewKubeClient ( kubeConfig , kubeMaster string , requestTimeout time . Duration ) ( * kubernetes . Clientset , error ) { if kubeConfig == "" { if _ , err := os . Stat ( clientcmd . RecommendedHomeFile ) ; err == nil { kubeConfig = clientcmd . RecommendedHomeFile } } config , err := clientcmd . BuildConfigFromFlags ( kubeMaster , kubeConfig ) if err != nil { return nil , err } config . WrapTransport = func ( rt http . RoundTripper ) http . RoundTripper { return instrumented_http . NewTransport ( rt , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , "/" ) return parts [ len ( parts ) - 1 ] } , } ) } config . Timeout = requestTimeout client , err := kubernetes . NewForConfig ( config ) if err != nil { return nil , err } log . Infof ( "Created Kubernetes client %s" , config . Host ) return client , nil }
1805	func ( m * MockDockerClient ) KnownVersions ( ) [ ] dockerclient . DockerVersion { ret := m . ctrl . Call ( m , "KnownVersions" ) ret0 , _ := ret [ 0 ] . ( [ ] dockerclient . DockerVersion ) return ret0 }
284	func isLabel ( s string ) bool { if len ( s ) == 0 || ! isAlpha ( rune ( s [ 0 ] ) ) { return false } for _ , c := range s [ 1 : ] { if ! isAlphaNumeric ( c ) { return false } } return true }
907	func ( d * Driver ) Stop ( ) error { if err := d . checkLegacyDriver ( true ) ; err != nil { return err } c , err := d . newAzureClient ( ) if err != nil { return err } log . Info ( "NOTICE: Stopping an Azure Virtual Machine is just going to power it off, not deallocate." ) log . Info ( "NOTICE: You should remove the machine if you would like to avoid unexpected costs." ) return c . StopVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) ) }
1713	func ( task * Task ) requiresSSMSecret ( ) bool { for _ , container := range task . Containers { if container . ShouldCreateWithSSMSecret ( ) { return true } } return false }
5096	func ObjectIdHex ( s string ) ObjectId { d , err := hex . DecodeString ( s ) if err != nil || len ( d ) != 12 { panic ( fmt . Sprintf ( "Invalid input to ObjectIdHex: %q" , s ) ) } return ObjectId ( d ) }
3212	func ( client * Client ) UpdateBoard ( board * Board ) error { return client . doJsonRequest ( "PUT" , fmt . Sprintf ( "/v1/dashboard/%s" , * board . Id ) , board , nil ) }
4956	func Align ( data [ ] byte , bitSize int ) [ ] byte { actual := len ( data ) required := bitSize >> 3 if ( bitSize % 8 ) > 0 { required ++ } if ( actual >= required ) { return data } return append ( bytes . Repeat ( [ ] byte { 0 } , required - actual ) , data ... ) }
2468	func ( a * arrayBufferLayout ) totalBytes ( ) int { if a . total != 0 { return a . total } t := 0 for _ , p := range a . parts { t += float . SizeInBytes ( ) * p . num } a . total = t return a . total }
5626	func ( pk PrivKeyLedgerSecp256k1 ) getPubKey ( ) ( key PubKey , err error ) { dev , err := getLedger ( ) if err != nil { return key , fmt . Errorf ( "cannot connect to Ledger device - error: %v" , err ) } key , err = pubkeyLedgerSecp256k1 ( dev , pk . Path ) if err != nil { return key , fmt . Errorf ( "please open Cosmos app on the Ledger device - error: %v" , err ) } return key , err }
7255	func ( f * formatifier ) removeNonDigits ( ) { rp := regexp . MustCompile ( `\D` ) f . theString = rp . ReplaceAllString ( f . theString , "" ) }
437	func ( ctx * RequestCtx ) Error ( msg string , statusCode int ) { ctx . Response . Reset ( ) ctx . SetStatusCode ( statusCode ) ctx . SetContentTypeBytes ( defaultContentType ) ctx . SetBodyString ( msg ) }
797	func NewAzureProvider ( configFile string , domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , resourceGroup string , dryRun bool ) ( * AzureProvider , error ) { contents , err := ioutil . ReadFile ( configFile ) if err != nil { return nil , fmt . Errorf ( "failed to read Azure config file '%s': %v" , configFile , err ) } cfg := config { } err = yaml . Unmarshal ( contents , & cfg ) if err != nil { return nil , fmt . Errorf ( "failed to read Azure config file '%s': %v" , configFile , err ) } if resourceGroup != "" { cfg . ResourceGroup = resourceGroup } var environment azure . Environment if cfg . Cloud == "" { environment = azure . PublicCloud } else { environment , err = azure . EnvironmentFromName ( cfg . Cloud ) if err != nil { return nil , fmt . Errorf ( "invalid cloud value '%s': %v" , cfg . Cloud , err ) } } token , err := getAccessToken ( cfg , environment ) if err != nil { return nil , fmt . Errorf ( "failed to get token: %v" , err ) } zonesClient := dns . NewZonesClientWithBaseURI ( environment . ResourceManagerEndpoint , cfg . SubscriptionID ) zonesClient . Authorizer = autorest . NewBearerAuthorizer ( token ) recordsClient := dns . NewRecordSetsClientWithBaseURI ( environment . ResourceManagerEndpoint , cfg . SubscriptionID ) recordsClient . Authorizer = autorest . NewBearerAuthorizer ( token ) provider := & AzureProvider { domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , dryRun : dryRun , resourceGroup : cfg . ResourceGroup , zonesClient : zonesClient , recordsClient : recordsClient , } return provider , nil }
6922	func ( p * PushCenter ) Start ( ) error { if p . isRunning { return errors . New ( "the push center is already started" ) } p . isRunning = true go func ( ) { lastEventID := "" for { go p . session . NextEvent ( p . Channel , lastEventID ) select { case notification := <- p . Channel : for _ , event := range notification . Events { buffer := & bytes . Buffer { } if err := json . NewEncoder ( buffer ) . Encode ( event . DataMap [ 0 ] ) ; err != nil { continue } event . Data = buffer . Bytes ( ) lastEventID = notification . UUID if p . defaultHander != nil { p . defaultHander ( event ) } if handler , exists := p . handlers [ event . EntityType ] ; exists { handler ( event ) } } case <- p . stop : return } } } ( ) return nil }
6880	func MakeWidget ( w * Window , x , y int ) Widget { return Widget { w : w , x : x , y : y , } }
3006	func resourceVSphereVirtualMachineMigrateState ( version int , os * terraform . InstanceState , meta interface { } ) ( * terraform . InstanceState , error ) { if os == nil { return nil , nil } if os . Empty ( ) { return os , nil } var migrateFunc func ( * terraform . InstanceState , interface { } ) error switch version { case 2 : log . Printf ( "[DEBUG] Migrating vsphere_virtual_machine state: old v%d state: %#v" , version , os ) migrateFunc = migrateVSphereVirtualMachineStateV3 case 1 : log . Printf ( "[DEBUG] Migrating vsphere_virtual_machine state: old v%d state: %#v" , version , os ) migrateFunc = migrateVSphereVirtualMachineStateV2 case 0 : log . Printf ( "[DEBUG] Migrating vsphere_virtual_machine state: old v%d state: %#v" , version , os ) migrateFunc = migrateVSphereVirtualMachineStateV1 default : log . Printf ( "[DEBUG] Migrating vsphere_virtual_machine state: completed v%d state: %#v" , version , os ) return os , nil } if err := migrateFunc ( os , meta ) ; err != nil { return nil , err } version ++ log . Printf ( "[DEBUG] Migrating vsphere_virtual_machine state: new v%d state: %#v" , version , os ) return resourceVSphereVirtualMachineMigrateState ( version , os , meta ) }
6125	func ( b * backendInstance ) addTimeout ( ctx context . Context ) ( context . Context , context . CancelFunc ) { if ctx == nil { ctx = context . Background ( ) } return context . WithTimeout ( ctx , time . Duration ( b . cfg . Timeout ) * time . Millisecond ) }
6935	func ( g * Gauge ) Update ( v float64 ) { atomic . StoreUint64 ( & g . value , math . Float64bits ( v ) ) }
2813	func expandBaseVmwareDistributedVirtualSwitchVlanSpec ( d * schema . ResourceData ) types . BaseVmwareDistributedVirtualSwitchVlanSpec { var obj types . BaseVmwareDistributedVirtualSwitchVlanSpec _ , ide := d . GetOkExists ( "vlan_id" ) _ , pvid := d . GetOkExists ( "port_private_secondary_vlan_id" ) vteList , vteOK := d . GetOkExists ( "vlan_range" ) vte := vteOK && len ( vteList . ( * schema . Set ) . List ( ) ) > 0 switch { case vte : obj = expandVmwareDistributedVirtualSwitchTrunkVlanSpec ( d ) case pvid : obj = expandVmwareDistributedVirtualSwitchPvlanSpec ( d ) case ide : obj = expandVmwareDistributedVirtualSwitchVlanIDSpec ( d ) } return obj }
2777	func OSFamily ( client * govmomi . Client , pool * object . ResourcePool , guest string ) ( string , error ) { log . Printf ( "[DEBUG] Looking for OS family for guest ID %q" , guest ) pprops , err := Properties ( pool ) if err != nil { return "" , err } return computeresource . OSFamily ( client , pprops . Owner , guest ) }
6344	func ( this LogData ) UrlUsername ( ) string { if this . Request . URL . User != nil { return this . Request . URL . User . Username ( ) } return "" }
1652	func ( mr * MockTaskResourceMockRecorder ) Initialize ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Initialize" , reflect . TypeOf ( ( * MockTaskResource ) ( nil ) . Initialize ) , arg0 , arg1 , arg2 ) }
5715	func ( s * Sentinel ) Close ( ) error { s . mu . Lock ( ) s . close ( ) s . mu . Unlock ( ) return nil }
4419	func ( u IPv4 ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
7267	func NewPlayer ( nick string , profile Profile ) ( * Player , error ) { p := new ( Player ) newUUID , err := uuid . V4 ( ) if err != nil { } p . UUID = newUUID p . Nick = nick p . Profile = profile err = storage . Store ( p ) if err != nil { return nil , errors . New ( err . Error ( ) + " - Could not write player to storage" ) } return p , nil }
3745	func ( w * WidgetConditionalFormat ) GetImageUrl ( ) string { if w == nil || w . ImageUrl == nil { return "" } return * w . ImageUrl }
2280	func GetData ( pointer uintptr ) ( data [ ] byte ) { c := ( * C . GValue ) ( unsafe . Pointer ( pointer ) ) p := ( * C . GtkSelectionData ) ( unsafe . Pointer ( c ) ) C . gtk_selection_data_get_text ( p ) var byteData [ ] byte var length C . gint cptr := C . gtk_selection_data_get_data_with_length ( p , & length ) sliceHeader := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & byteData ) ) sliceHeader . Data = uintptr ( unsafe . Pointer ( cptr ) ) sliceHeader . Len = int ( length ) sliceHeader . Cap = int ( length ) return byteData }
4699	func newHTMLTag ( ln * line , rslt * result , src * source , parent element , opts * Options ) ( * htmlTag , error ) { if len ( ln . tokens ) < 1 { return nil , fmt . Errorf ( "an HTML tag is not specified [file: %s][line: %d]" , ln . fileName ( ) , ln . no ) } s := ln . tokens [ 0 ] tagName := extractTagName ( s ) id , err := extractID ( s , ln ) if err != nil { return nil , err } classes := extractClasses ( s ) e := & htmlTag { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , tagName : tagName , id : id , classes : classes , containPlainText : strings . HasSuffix ( s , dot ) , insertBr : strings . HasSuffix ( s , doubleDot ) , attributes : make ( [ ] htmlAttribute , 0 , 2 ) , } if err := e . setAttributes ( ) ; err != nil { return nil , err } return e , nil }
6588	func RemoveSvcAcknowledgement ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "REMOVE_SVC_ACKNOWLEDGEMENT" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
4407	func ( u URI ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
648	func NewCRDClientForAPIVersionKind ( client kubernetes . Interface , kubeConfig , kubeMaster , apiVersion , kind string ) ( * rest . RESTClient , * runtime . Scheme , error ) { if kubeConfig == "" { if _ , err := os . Stat ( clientcmd . RecommendedHomeFile ) ; err == nil { kubeConfig = clientcmd . RecommendedHomeFile } } config , err := clientcmd . BuildConfigFromFlags ( kubeMaster , kubeConfig ) if err != nil { return nil , nil , err } groupVersion , err := schema . ParseGroupVersion ( apiVersion ) if err != nil { return nil , nil , err } apiResourceList , err := client . Discovery ( ) . ServerResourcesForGroupVersion ( groupVersion . String ( ) ) if err != nil { return nil , nil , fmt . Errorf ( "error listing resources in GroupVersion %q: %s" , groupVersion . String ( ) , err ) } var crdAPIResource * metav1 . APIResource for _ , apiResource := range apiResourceList . APIResources { if apiResource . Kind == kind { crdAPIResource = & apiResource break } } if crdAPIResource == nil { return nil , nil , fmt . Errorf ( "unable to find Resource Kind %q in GroupVersion %q" , kind , apiVersion ) } scheme := runtime . NewScheme ( ) addKnownTypes ( scheme , groupVersion ) config . ContentConfig . GroupVersion = & groupVersion config . APIPath = "/apis" config . NegotiatedSerializer = serializer . DirectCodecFactory { CodecFactory : serializer . NewCodecFactory ( scheme ) } crdClient , err := rest . UnversionedRESTClientFor ( config ) if err != nil { return nil , nil , err } return crdClient , scheme , nil }
5985	func ( m * MeasuredWriter ) BytesPerSec ( ) uint64 { return uint64 ( m . rate . Rate ( time . Second ) ) }
1944	func ( mr * MockTaskEngineStateMockRecorder ) RemoveTask ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "RemoveTask" , reflect . TypeOf ( ( * MockTaskEngineState ) ( nil ) . RemoveTask ) , arg0 ) }
720	func ( p coreDNSProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { var result [ ] * endpoint . Endpoint services , err := p . client . GetServices ( coreDNSPrefix ) if err != nil { return nil , err } for _ , service := range services { domains := strings . Split ( strings . TrimPrefix ( service . Key , coreDNSPrefix ) , "/" ) reverse ( domains ) dnsName := strings . Join ( domains [ service . TargetStrip : ] , "." ) if ! p . domainFilter . Match ( dnsName ) { continue } prefix := strings . Join ( domains [ : service . TargetStrip ] , "." ) if service . Host != "" { ep := endpoint . NewEndpointWithTTL ( dnsName , guessRecordType ( service . Host ) , endpoint . TTL ( service . TTL ) , service . Host , ) ep . Labels [ "originalText" ] = service . Text ep . Labels [ randomPrefixLabel ] = prefix result = append ( result , ep ) } if service . Text != "" { ep := endpoint . NewEndpoint ( dnsName , endpoint . RecordTypeTXT , service . Text , ) ep . Labels [ randomPrefixLabel ] = prefix result = append ( result , ep ) } } return result , nil }
1707	func ( task * Task ) addTaskScopedVolumes ( ctx context . Context , dockerClient dockerapi . DockerClient , vol * TaskVolume ) error { volumeConfig := vol . Volume . ( * taskresourcevolume . DockerVolumeConfig ) volumeResource , err := taskresourcevolume . NewVolumeResource ( ctx , vol . Name , task . volumeName ( vol . Name ) , volumeConfig . Scope , volumeConfig . Autoprovision , volumeConfig . Driver , volumeConfig . DriverOpts , volumeConfig . Labels , dockerClient ) if err != nil { return err } vol . Volume = & volumeResource . VolumeConfig task . AddResource ( resourcetype . DockerVolumeKey , volumeResource ) task . updateContainerVolumeDependency ( vol . Name ) return nil }
2720	func resourceVSphereVirtualMachineUpdateLocationRelocateWithSDRS ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , spec types . VirtualMachineRelocateSpec , timeout int , ) error { client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return fmt . Errorf ( "connection ineligible to use datastore_cluster_id: %s" , err ) } log . Printf ( "[DEBUG] %s: Running virtual machine relocate Storage DRS API" , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( "datastore_cluster_id" ) . ( string ) ) if err != nil { return fmt . Errorf ( "error getting datastore cluster: %s" , err ) } err = storagepod . RelocateVM ( client , vm , spec , timeout , pod ) if err != nil { return fmt . Errorf ( "error running vMotion on datastore cluster %q: %s" , pod . Name ( ) , err ) } return nil }
191	func ( a * Adapter ) writeOutput ( ) error { arr := mapToArray ( a . groups ) b , _ := json . MarshalIndent ( arr , "" , " " ) dir , _ := filepath . Split ( a . output ) tmpfile , err := ioutil . TempFile ( dir , "sd-adapter" ) if err != nil { return err } defer tmpfile . Close ( ) _ , err = tmpfile . Write ( b ) if err != nil { return err } err = os . Rename ( tmpfile . Name ( ) , a . output ) if err != nil { return err } return nil }
1593	func ( m * MockSecretsManagerAPI ) GetSecretValueRequest ( arg0 * secretsmanager . GetSecretValueInput ) ( * request . Request , * secretsmanager . GetSecretValueOutput ) { ret := m . ctrl . Call ( m , "GetSecretValueRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . GetSecretValueOutput ) return ret0 , ret1 }
5381	func ( c * Config ) Getuint ( key string ) ( uint , error ) { if value , found := c . data [ key ] ; found { v , err := strconv . ParseUint ( value , 10 , 0 ) return uint ( v ) , err } return 0 , ErrKey }
1607	func ( m * MockSecretsManagerAPI ) PutSecretValueRequest ( arg0 * secretsmanager . PutSecretValueInput ) ( * request . Request , * secretsmanager . PutSecretValueOutput ) { ret := m . ctrl . Call ( m , "PutSecretValueRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . PutSecretValueOutput ) return ret0 , ret1 }
4034	func ( e * EditField ) SetSize ( width , height int ) { if width != KeepValue && ( width > 1000 || width < e . minW ) { return } if height != KeepValue && ( height > 200 || height < e . minH ) { return } if width != KeepValue { e . width = width } e . height = 1 }
1477	func ( c * Container ) GetFinishedAt ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . finishedAt }
2925	func DeviceListString ( l object . VirtualDeviceList ) string { var names [ ] string for _ , d := range l { if d == nil { names = append ( names , "<nil>" ) } else { names = append ( names , l . Name ( d ) ) } } return strings . Join ( names , "," ) }
2583	func virtualMachineFromContainerView ( ctx context . Context , client * govmomi . Client , uuid string ) ( object . Reference , error ) { log . Printf ( "[DEBUG] Using ContainerView to look up UUID %q" , uuid ) m := view . NewManager ( client . Client ) v , err := m . CreateContainerView ( ctx , client . ServiceContent . RootFolder , [ ] string { "VirtualMachine" } , true ) if err != nil { return nil , err } defer func ( ) { if err = v . Destroy ( ctx ) ; err != nil { log . Printf ( "[DEBUG] virtualMachineFromContainerView: Unexpected error destroying container view: %s" , err ) } } ( ) var vms , results [ ] mo . VirtualMachine err = v . Retrieve ( ctx , [ ] string { "VirtualMachine" } , [ ] string { "config.uuid" } , & results ) if err != nil { return nil , err } for _ , result := range results { if result . Config == nil { continue } if result . Config . Uuid == uuid { vms = append ( vms , result ) } } switch { case len ( vms ) < 1 : return nil , newUUIDNotFoundError ( fmt . Sprintf ( "virtual machine with UUID %q not found" , uuid ) ) case len ( vms ) > 1 : return nil , fmt . Errorf ( "multiple virtual machines with UUID %q found" , uuid ) } return object . NewReference ( client . Client , vms [ 0 ] . Self ) , nil }
1528	func ( acsSession * session ) startSessionOnce ( ) error { acsEndpoint , err := acsSession . ecsClient . DiscoverPollEndpoint ( acsSession . containerInstanceARN ) if err != nil { seelog . Errorf ( "acs: unable to discover poll endpoint, err: %v" , err ) return err } url := acsWsURL ( acsEndpoint , acsSession . agentConfig . Cluster , acsSession . containerInstanceARN , acsSession . taskEngine , acsSession . resources ) client := acsSession . resources . createACSClient ( url , acsSession . agentConfig ) defer client . Close ( ) return acsSession . startACSSession ( client ) }
2508	func ( c * pixelsCommand ) Exec ( indexOffset int ) error { p , err := c . img . image . Pixels ( ) if err != nil { return err } c . result = p return nil }
2548	func expandCustomizationIPSettings ( d * schema . ResourceData , n int , v4gwAdd , v6gwAdd bool ) ( types . CustomizationIPSettings , bool , bool ) { var v4gwFound , v6gwFound bool v4addr , v4addrOk := d . GetOk ( netifKey ( "ipv4_address" , n ) ) v4mask := d . Get ( netifKey ( "ipv4_netmask" , n ) ) . ( int ) v4gw , v4gwOk := d . Get ( cKeyPrefix + "." + "ipv4_gateway" ) . ( string ) var obj types . CustomizationIPSettings switch { case v4addrOk : obj . Ip = & types . CustomizationFixedIp { IpAddress : v4addr . ( string ) , } obj . SubnetMask = v4CIDRMaskToDotted ( v4mask ) if v4gwAdd && v4gwOk && matchGateway ( v4addr . ( string ) , v4mask , v4gw ) { obj . Gateway = [ ] string { v4gw } v4gwFound = true } default : obj . Ip = & types . CustomizationDhcpIpGenerator { } } obj . DnsServerList = structure . SliceInterfacesToStrings ( d . Get ( netifKey ( "dns_server_list" , n ) ) . ( [ ] interface { } ) ) obj . DnsDomain = d . Get ( netifKey ( "dns_domain" , n ) ) . ( string ) obj . IpV6Spec , v6gwFound = expandCustomizationIPSettingsIPV6AddressSpec ( d , n , v6gwAdd ) return obj , v4gwFound , v6gwFound }
4414	func ( e * Email ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { * e = Email ( data ) return nil } return errors . New ( "couldn't unmarshal bson raw value as Email" ) }
344	func ( rule * RecordingRule ) SetHealth ( health RuleHealth ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . health = health }
2886	func ResourcePool ( host * object . HostSystem ) ( * object . ResourcePool , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return host . ResourcePool ( ctx ) }
6172	func Migrate ( connStr string , version int64 ) error { db , err := sql . Open ( "postgres" , connStr ) if err != nil { return err } defer db . Close ( ) if version == 0 { migrations , err := goose . CollectMigrations ( "." , minVersion , maxVersion ) if err != nil { return err } last , err := migrations . Last ( ) if err != nil { return err } version = last . Version } return executeMigrationScripts ( db , version ) }
6673	func ( v Vec ) Add ( v2 Vec ) Vec { return Vec { v . X + v2 . X , v . Y + v2 . Y } }
2868	func ( v VSphereVersion ) Older ( other VSphereVersion ) bool { if ! v . ProductEqual ( other ) { return false } if v . olderVersion ( other ) { return true } if v . newerVersion ( other ) { return false } if v . Build < other . Build { return true } return false }
2256	func ( v * LinkButton ) native ( ) * C . GtkLinkButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLinkButton ( p ) }
1887	func ( engine * DockerTaskEngine ) UnmarshalJSON ( data [ ] byte ) error { return engine . state . UnmarshalJSON ( data ) }
4783	func LoadWithEnvTOML ( conf interface { } , configPaths ... string ) error { return loadWithFunc ( conf , configPaths , envReplacer , toml . Unmarshal ) }
3355	func ( i * IntegrationAWSAccount ) GetRoleNameOk ( ) ( string , bool ) { if i == nil || i . RoleName == nil { return "" , false } return * i . RoleName , true }
1788	func ( m * MockClientServer ) SetReadDeadline ( arg0 time . Time ) error { ret := m . ctrl . Call ( m , "SetReadDeadline" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
283	func lexKeywordOrIdentifier ( l * lexer ) stateFn { Loop : for { switch r := l . next ( ) ; { case isAlphaNumeric ( r ) || r == ':' : default : l . backup ( ) word := l . input [ l . start : l . pos ] if kw , ok := key [ strings . ToLower ( word ) ] ; ok { l . emit ( kw ) } else if ! strings . Contains ( word , ":" ) { l . emit ( ItemIdentifier ) } else { l . emit ( ItemMetricIdentifier ) } break Loop } } if l . seriesDesc && l . peek ( ) != '{' { return lexValueSequence } return lexStatements }
4536	func ParseVersion ( v * version . Info ) ( ServerVersion , error ) { var ret ServerVersion var err error ret . Major , err = strconv . Atoi ( v . Major ) if err != nil { return parseGitVersion ( v . GitVersion ) } v . Minor = strings . TrimSuffix ( v . Minor , "+" ) ret . Minor , err = strconv . Atoi ( v . Minor ) if err != nil { return parseGitVersion ( v . GitVersion ) } return ret , err }
4069	func SliceColorized ( str string , start , end int ) string { if str == "" { return str } if start < 0 { start = 0 } fgChanged , bgChanged := false , false curr := 0 parser := NewColorParser ( str , term . ColorBlack , term . ColorBlack ) var out string for { if end != - 1 && curr >= end { break } elem := parser . NextElement ( ) if elem . Type == ElemEndOfText { break } switch elem . Type { case ElemTextColor : fgChanged = true if out != "" { out += "<t:" + ColorToString ( elem . Fg ) + ">" } case ElemBackColor : bgChanged = true if out != "" { out += "<b:" + ColorToString ( elem . Bg ) + ">" } case ElemPrintable : if curr == start { if fgChanged { out += "<t:" + ColorToString ( elem . Fg ) + ">" } if bgChanged { out += "<b:" + ColorToString ( elem . Bg ) + ">" } } if curr >= start { out += string ( elem . Ch ) } curr ++ } } return out }
775	func ( sc * gatewaySource ) endpointsFromGatewayConfig ( config istiomodel . Config ) ( [ ] * endpoint . Endpoint , error ) { var endpoints [ ] * endpoint . Endpoint ttl , err := getTTLFromAnnotations ( config . Annotations ) if err != nil { log . Warn ( err ) } targets := getTargetsFromTargetAnnotation ( config . Annotations ) if len ( targets ) == 0 { targets , err = sc . targetsFromIstioIngressGatewayServices ( ) if err != nil { return nil , err } } gateway := config . Spec . ( * istionetworking . Gateway ) providerSpecific := getProviderSpecificAnnotations ( config . Annotations ) for _ , server := range gateway . Servers { for _ , host := range server . Hosts { if host == "" { continue } endpoints = append ( endpoints , endpointsForHostname ( host , targets , ttl , providerSpecific ) ... ) } } if ! sc . ignoreHostnameAnnotation { hostnameList := getHostnamesFromAnnotations ( config . Annotations ) for _ , hostname := range hostnameList { endpoints = append ( endpoints , endpointsForHostname ( hostname , targets , ttl , providerSpecific ) ... ) } } return endpoints , nil }
1883	func printLicense ( ) int { license := utils . NewLicenseProvider ( ) text , err := license . GetText ( ) if err != nil { fmt . Fprintln ( os . Stderr , err ) return exitcodes . ExitError } fmt . Println ( text ) return exitcodes . ExitSuccess }
2820	func flattenVmwareUplinkPortTeamingPolicy ( d * schema . ResourceData , obj * types . VmwareUplinkPortTeamingPolicy ) error { if obj == nil { return nil } structure . SetStringPolicy ( d , "teaming_policy" , obj . Policy ) structure . SetBoolPolicy ( d , "notify_switches" , obj . NotifySwitches ) structure . SetBoolPolicyReverse ( d , "failback" , obj . RollingOrder ) if err := flattenDVSFailureCriteria ( d , obj . FailureCriteria ) ; err != nil { return err } if err := flattenVMwareUplinkPortOrderPolicy ( d , obj . UplinkPortOrder ) ; err != nil { return err } return nil }
4231	func ( s * Spinner ) Color ( colors ... string ) error { colorAttributes := make ( [ ] color . Attribute , len ( colors ) ) for index , c := range colors { if ! validColor ( c ) { return errInvalidColor } colorAttributes [ index ] = colorAttributeMap [ c ] } s . lock . Lock ( ) s . color = color . New ( colorAttributes ... ) . SprintFunc ( ) s . lock . Unlock ( ) s . Restart ( ) return nil }
2029	func ( task * Task ) buildImplicitLinuxCPUSpec ( ) specs . LinuxCPU { var taskCPUShares uint64 for _ , container := range task . Containers { if container . CPU > 0 { taskCPUShares += uint64 ( container . CPU ) } } if taskCPUShares == 0 { taskCPUShares = minimumCPUShare } return specs . LinuxCPU { Shares : & taskCPUShares , } }
6518	func ( c Client ) GetCurrencies ( ) ( [ ] currency , error ) { holder := [ ] [ ] string { } if err := c . Get ( "currencies" , nil , & holder ) ; err != nil { return nil , err } finalData := [ ] currency { } for _ , curr := range holder { class := currency { Name : curr [ 0 ] , Iso : curr [ 1 ] , } finalData = append ( finalData , class ) } return finalData , nil }
703	func separateChange ( zones map [ string ] * dns . ManagedZone , change * dns . Change ) map [ string ] * dns . Change { changes := make ( map [ string ] * dns . Change ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper [ z . Name ] = z . DnsName changes [ z . Name ] = & dns . Change { Additions : [ ] * dns . ResourceRecordSet { } , Deletions : [ ] * dns . ResourceRecordSet { } , } } for _ , a := range change . Additions { if zoneName , _ := zoneNameIDMapper . FindZone ( ensureTrailingDot ( a . Name ) ) ; zoneName != "" { changes [ zoneName ] . Additions = append ( changes [ zoneName ] . Additions , a ) } else { log . Warnf ( "No matching zone for record addition: %s %s %s %d" , a . Name , a . Type , a . Rrdatas , a . Ttl ) } } for _ , d := range change . Deletions { if zoneName , _ := zoneNameIDMapper . FindZone ( ensureTrailingDot ( d . Name ) ) ; zoneName != "" { changes [ zoneName ] . Deletions = append ( changes [ zoneName ] . Deletions , d ) } else { log . Warnf ( "No matching zone for record deletion: %s %s %s %d" , d . Name , d . Type , d . Rrdatas , d . Ttl ) } } for zone , change := range changes { if len ( change . Additions ) == 0 && len ( change . Deletions ) == 0 { delete ( changes , zone ) } } return changes }
5326	func nextGUID ( isSystem bool ) ( db * dbfile , gid int , err error ) { loadConfig ( ) db , err = openDBFile ( _GROUP_FILE , os . O_RDWR ) if err != nil { return } info , err := db . file . Stat ( ) if err != nil { db . close ( ) return nil , 0 , err } if _ , err = db . file . Seek ( info . Size ( ) / 2 , os . SEEK_SET ) ; err != nil { db . close ( ) return nil , 0 , err } if _ , _ , err = db . rd . ReadLine ( ) ; err != nil { db . close ( ) return nil , 0 , err } var minGid , maxGid int if isSystem { minGid , maxGid = config . login . SYS_GID_MIN , config . login . SYS_GID_MAX } else { minGid , maxGid = config . login . GID_MIN , config . login . GID_MAX } for { line , _ , err := db . rd . ReadLine ( ) if err == io . EOF { break } gr , err := parseGroup ( string ( line ) ) if err != nil { db . close ( ) return nil , 0 , err } if gr . GID >= minGid && gr . GID <= maxGid { gid = gr . GID } } gid ++ if gid == maxGid { return nil , 0 , & IdRangeError { maxGid , isSystem , false } } return }
840	func ( c * ComputeUtil ) disk ( ) ( * raw . Disk , error ) { return c . service . Disks . Get ( c . project , c . zone , c . diskName ( ) ) . Do ( ) }
4764	func FileSize ( filename string ) int64 { info , err := os . Stat ( filename ) if err != nil { return 0 } return info . Size ( ) }
6076	func signature ( key * ecdsa . PrivateKey , msg [ ] byte ) ( [ ] byte , error ) { hash := ethcrypto . Keccak256 ( msg ) sig , err := ethcrypto . Sign ( hash , key ) if err != nil { return nil , err } sig = sig [ : len ( sig ) - 1 ] return sig , nil }
1282	func ( mr * MockCgroupFactoryMockRecorder ) Load ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Load" , reflect . TypeOf ( ( * MockCgroupFactory ) ( nil ) . Load ) , arg0 , arg1 ) }
1806	func ( mr * MockDockerClientMockRecorder ) KnownVersions ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "KnownVersions" , reflect . TypeOf ( ( * MockDockerClient ) ( nil ) . KnownVersions ) ) }
6545	func buildParams ( options * ImageOptions ) ( [ ] string , error ) { a := [ ] string { } if options . Input == "" { return [ ] string { } , errors . New ( "Must provide input" ) } a = append ( a , "-q" ) a = append ( a , "--disable-plugins" ) a = append ( a , "--format" ) if options . Format != "" { a = append ( a , options . Format ) } else { a = append ( a , "png" ) } if options . Height != 0 { a = append ( a , "--height" ) a = append ( a , strconv . Itoa ( options . Height ) ) } if options . Width != 0 { a = append ( a , "--width" ) a = append ( a , strconv . Itoa ( options . Width ) ) } if options . Quality != 0 { a = append ( a , "--quality" ) a = append ( a , strconv . Itoa ( options . Quality ) ) } if options . Input != "-" { options . Html = "" } a = append ( a , options . Input ) if options . Output == "" { a = append ( a , "-" ) } else { a = append ( a , options . Output ) } return a , nil }
2753	func flattenVMwareDVSConfigInfo ( d * schema . ResourceData , obj * types . VMwareDVSConfigInfo ) error { d . Set ( "name" , obj . Name ) d . Set ( "config_version" , obj . ConfigVersion ) d . Set ( "description" , obj . Description ) d . Set ( "ipv4_address" , obj . SwitchIpAddress ) d . Set ( "max_mtu" , obj . MaxMtu ) d . Set ( "lacp_api_version" , obj . LacpApiVersion ) d . Set ( "multicast_filtering_mode" , obj . MulticastFilteringMode ) d . Set ( "network_resource_control_version" , obj . NetworkResourceControlVersion ) d . Set ( "network_resource_control_enabled" , obj . NetworkResourceManagementEnabled ) d . Set ( "version" , obj . ProductInfo . Version ) if err := flattenDVSNameArrayUplinkPortPolicy ( d , obj . UplinkPortPolicy . ( * types . DVSNameArrayUplinkPortPolicy ) ) ; err != nil { return err } if err := flattenVMwareDVSPortSetting ( d , obj . DefaultPortConfig . ( * types . VMwareDVSPortSetting ) ) ; err != nil { return err } if err := flattenSliceOfDistributedVirtualSwitchHostMember ( d , obj . Host ) ; err != nil { return err } if err := flattenSliceOfDvsHostInfrastructureTrafficResource ( d , obj . InfrastructureTrafficResourceConfig ) ; err != nil { return err } if err := flattenDVSContactInfo ( d , obj . Contact ) ; err != nil { return err } if err := flattenLinkDiscoveryProtocolConfig ( d , obj . LinkDiscoveryProtocolConfig ) ; err != nil { return err } if err := flattenVMwareIpfixConfig ( d , obj . IpfixConfig ) ; err != nil { return err } return nil }
2336	func ( v * Context ) UserToDevice ( x , y float64 ) ( float64 , float64 ) { C . cairo_user_to_device ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y }
6866	func ( api * API ) SendPaste ( paste Paste ) ( string , error ) { if paste . UserKey == "" && paste . Privacy == "2" { return "" , PrivacyModError } values := url . Values { } values . Set ( "api_dev_key" , api . APIKey ) values . Set ( "api_user_key" , paste . UserKey ) values . Set ( "api_option" , "paste" ) values . Set ( "api_paste_code" , paste . Text ) values . Set ( "api_paste_name" , paste . Name ) values . Set ( "api_paste_private" , paste . Privacy ) values . Set ( "api_paste_expire_date" , paste . ExpireDate ) response , err := http . PostForm ( "http://pastebin.com/api/api_post.php" , values ) defer response . Body . Close ( ) if err != nil { return "" , err } if response . StatusCode != 200 { return "" , PastePostingError } buf := bytes . Buffer { } _ , err = buf . ReadFrom ( response . Body ) if err != nil { return "" , err } return buf . String ( ) , nil }
1235	func ( client * cniClient ) constructNetworkConfig ( cfg interface { } , plugin string ) ( * libcni . NetworkConfig , error ) { configBytes , err := json . Marshal ( cfg ) if err != nil { seelog . Errorf ( "[ECSCNI] Marshal configuration for plugin %s failed, error: %v" , plugin , err ) return nil , err } networkConfig := & libcni . NetworkConfig { Network : & cnitypes . NetConf { Type : plugin , } , Bytes : configBytes , } return networkConfig , nil }
4930	func ( w * Writer ) WriteFloat32 ( f float32 ) { if w . err != nil { return } bits := math . Float32bits ( f ) binary . LittleEndian . PutUint32 ( w . b [ : 4 ] , bits ) w . wr . Write ( w . b [ : 4 ] ) }
1907	func ( engine * DockerTaskEngine ) transitionContainer ( task * apitask . Task , container * apicontainer . Container , to apicontainerstatus . ContainerStatus ) { metadata := engine . applyContainerState ( task , container , to ) engine . tasksLock . RLock ( ) managedTask , ok := engine . managedTasks [ task . Arn ] engine . tasksLock . RUnlock ( ) if ok { managedTask . emitDockerContainerChange ( dockerContainerChange { container : container , event : dockerapi . DockerContainerChangeEvent { Status : to , DockerContainerMetadata : metadata , } , } ) } }
1316	func ( mr * MockFileMockRecorder ) Chmod ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "Chmod" , reflect . TypeOf ( ( * MockFile ) ( nil ) . Chmod ) , arg0 ) }
1348	func ( agent * ecsAgent ) printECSAttributes ( ) int { capabilities , err := agent . capabilities ( ) if err != nil { seelog . Warnf ( "Unable to obtain capabilities: %v" , err ) return exitcodes . ExitError } for _ , attr := range capabilities { fmt . Printf ( "%s\t%s\n" , \t , \n ) } aws . StringValue ( attr . Name ) }
514	func ( h * RequestHeader ) DelCookie ( key string ) { h . parseRawHeaders ( ) h . collectCookies ( ) h . cookies = delAllArgs ( h . cookies , key ) }
2894	func upgradeDVS ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , version string ) error { req := & types . PerformDvsProductSpecOperation_Task { This : dvs . Reference ( ) , Operation : "upgrade" , ProductSpec : & types . DistributedVirtualSwitchProductSpec { Version : version , } , } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) resp , err := methods . PerformDvsProductSpecOperation_Task ( ctx , client , req ) if err != nil { return err } task := object . NewTask ( client . Client , resp . Returnval ) tctx , tcancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer tcancel ( ) if err := task . Wait ( tctx ) ; err != nil { return err } return nil }
3951	func Uint32Zero ( x uint32 ) uint32 { h := prime32_5 + 4 + x * prime32_3 h = rol17 ( h ) * prime32_4 h ^= h >> 15 h *= prime32_2 h ^= h >> 13 h *= prime32_3 h ^= h >> 16 return h }
1023	func ( d * DedupManager ) Stop ( ) error { d . stopLock . Lock ( ) defer d . stopLock . Unlock ( ) if d . stop { return nil } log . Printf ( "[INFO] (dedup) stopping de-duplication manager" ) d . stop = true close ( d . stopCh ) d . wg . Wait ( ) return nil }
5308	func ( h * HAProxyClient ) Info ( ) ( * Info , error ) { res , err := h . RunCommand ( "show info" ) if err != nil { return nil , err } info := & Info { } err = kvcodec . Unmarshal ( res , info ) if err != nil { return nil , fmt . Errorf ( "error decoding response: %s" , err ) } return info , nil }
801	func ( n * hostOnlyNetwork ) Save ( vbox VBoxManager ) error { if err := n . SaveIPv4 ( vbox ) ; err != nil { return err } if n . DHCP { vbox . vbm ( "hostonlyif" , "ipconfig" , n . Name , "--dhcp" ) } return nil }
5801	func ( a * API ) FetchMetric ( cid CIDType ) ( * Metric , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid metric CID [none]" ) } metricCID := string ( * cid ) matched , err := regexp . MatchString ( config . MetricCIDRegex , metricCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid metric CID [%s]" , metricCID ) } result , err := a . Get ( metricCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch metric, received JSON: %s" , string ( result ) ) } metric := & Metric { } if err := json . Unmarshal ( result , metric ) ; err != nil { return nil , err } return metric , nil }
3068	func ( m * Macaron ) SetURLPrefix ( prefix string ) { m . urlPrefix = prefix m . hasURLPrefix = len ( m . urlPrefix ) > 0 }
1256	func copyHealthMetadata ( metadata * ecstcs . HealthMetadata , fin bool ) * ecstcs . HealthMetadata { return & ecstcs . HealthMetadata { Cluster : aws . String ( aws . StringValue ( metadata . Cluster ) ) , ContainerInstance : aws . String ( aws . StringValue ( metadata . ContainerInstance ) ) , Fin : aws . Bool ( fin ) , MessageId : aws . String ( aws . StringValue ( metadata . MessageId ) ) , } }
535	func ( c * Cookie ) SetDomainBytes ( domain [ ] byte ) { c . domain = append ( c . domain [ : 0 ] , domain ... ) }
5668	func printBase ( ps * printState , qual , base AST ) { ps . inner = append ( ps . inner , qual ) ps . print ( base ) if len ( ps . inner ) > 0 { qual . ( innerPrinter ) . printInner ( ps ) ps . inner = ps . inner [ : len ( ps . inner ) - 1 ] } }
4440	func ( u * ISBN10 ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { * u = ISBN10 ( data ) } }
6372	func ( iter Enumerator ) All ( p Predicate ) bool { for entry := range iter { if ! p ( entry ) { return false } } return true }
3372	func ( i * IntegrationGCPCreateRequest ) HasPrivateKey ( ) bool { if i != nil && i . PrivateKey != nil { return true } return false }
3586	func ( t * ThresholdCount ) GetWarningRecovery ( ) json . Number { if t == nil || t . WarningRecovery == nil { return "" } return * t . WarningRecovery }
1698	func ( eni * ENI ) GetIPV6Addresses ( ) [ ] string { var addresses [ ] string for _ , addr := range eni . IPV6Addresses { addresses = append ( addresses , addr . Address ) } return addresses }
6254	func ( h * Handler ) ChangeOfferingStatus ( tkn , offering , action string , gasPrice uint64 ) error { logger := h . logger . Add ( "method" , "ChangeOfferingStatus" , "offering" , offering , "action" , action , "gasPrice" , gasPrice ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return ErrAccessDenied } jobType , ok := OfferingChangeActions [ action ] if ! ok { logger . Warn ( ErrBadOfferingStatusAction . Error ( ) ) return ErrBadOfferingStatusAction } offer := & data . Offering { } err := h . findByPrimaryKey ( logger , ErrOfferingNotFound , offer , offering ) if err != nil { return err } jobData := & data . JobPublishData { GasPrice : gasPrice } if err := job . AddWithData ( h . queue , nil , jobType , data . JobOffering , offering , data . JobUser , jobData ) ; err != nil { logger . Error ( err . Error ( ) ) return ErrInternal } return nil }
484	func WriteMultipartForm ( w io . Writer , f * multipart . Form , boundary string ) error { if len ( boundary ) == 0 { panic ( "BUG: form boundary cannot be empty" ) } mw := multipart . NewWriter ( w ) if err := mw . SetBoundary ( boundary ) ; err != nil { return fmt . Errorf ( "cannot use form boundary %q: %s" , boundary , err ) } for k , vv := range f . Value { for _ , v := range vv { if err := mw . WriteField ( k , v ) ; err != nil { return fmt . Errorf ( "cannot write form field %q value %q: %s" , k , v , err ) } } } for k , fvv := range f . File { for _ , fv := range fvv { vw , err := mw . CreatePart ( fv . Header ) if err != nil { return fmt . Errorf ( "cannot create form file %q (%q): %s" , k , fv . Filename , err ) } fh , err := fv . Open ( ) if err != nil { return fmt . Errorf ( "cannot open form file %q (%q): %s" , k , fv . Filename , err ) } if _ , err = copyZeroAlloc ( vw , fh ) ; err != nil { return fmt . Errorf ( "error when copying form file %q (%q): %s" , k , fv . Filename , err ) } if err = fh . Close ( ) ; err != nil { return fmt . Errorf ( "cannot close form file %q (%q): %s" , k , fv . Filename , err ) } } } if err := mw . Close ( ) ; err != nil { return fmt . Errorf ( "error when closing multipart form writer: %s" , err ) } return nil }
4203	func ( c * DeleteOrgConfigurationCommand ) Execute ( [ ] string ) error { if err := config . NewManager ( c . ConfigDirectory ) . DeleteOrgConfig ( c . OrgName ) ; err != nil { return err } fmt . Printf ( "The org %s was successfully deleted" , c . OrgName ) return nil }
7110	func Logf ( level Level , format string , a ... interface { } ) { getDefaultLogger ( ) . log ( level , format , a ... ) }
3660	func ( w * Widget ) HasAutoRefresh ( ) bool { if w != nil && w . AutoRefresh != nil { return true } return false }
1557	func ( s * ContainerDefinition ) SetInferenceDevices ( v [ ] * string ) * ContainerDefinition { s . InferenceDevices = v return s }
6636	func RouteMiddleware ( next r2router . HandlerFunc ) r2router . HandlerFunc { return func ( w http . ResponseWriter , r * http . Request , p r2router . Params ) { p . AppSet ( "say" , "Hello" ) next ( w , r , p ) } }
4529	func ( h Hosts ) Flush ( ) error { file , err := os . Create ( h . Path ) if err != nil { return err } w := bufio . NewWriter ( file ) for _ , line := range h . Lines { fmt . Fprintf ( w , "%s%s" , line . Raw , eol ) } err = w . Flush ( ) if err != nil { return err } return h . Load ( ) }
2655	func resourceVSphereComputeClusterApplyDelete ( d structure . ResourceIDStringer , cluster * object . ClusterComputeResource ) error { log . Printf ( "[DEBUG] %s: Proceeding with cluster deletion" , resourceVSphereComputeClusterIDString ( d ) ) if err := clustercomputeresource . Delete ( cluster ) ; err != nil { return err } return nil }
4524	func Cat ( filenames ... string ) Filter { return FilterFunc ( func ( arg Arg ) error { if len ( filenames ) == 0 { for s := range arg . In { arg . Out <- s } return nil } for _ , f := range filenames { file , err := os . Open ( f ) if err == nil { err = splitIntoLines ( file , arg ) file . Close ( ) } if err != nil { return err } } return nil } ) }
911	func NewDriver ( hostName , storePath string ) * Driver { return & Driver { DiskSize : defaultDiskSize , MemSize : defaultMemory , CPU : defaultCPU , DisableDynamicMemory : defaultDisableDynamicMemory , BaseDriver : & drivers . BaseDriver { MachineName : hostName , StorePath : storePath , } , } }
3685	func ( w * Widget ) GetManageStatusTitleText ( ) string { if w == nil || w . ManageStatusTitleText == nil { return "" } return * w . ManageStatusTitleText }
110	func NewDiscovery ( cfg * SDConfig , logger log . Logger ) * Discovery { if logger == nil { logger = log . NewNopLogger ( ) } d := & Discovery { cfg : cfg , port : cfg . Port , logger : logger , } d . Discovery = refresh . NewDiscovery ( logger , "azure" , time . Duration ( cfg . RefreshInterval ) , d . refresh , ) return d }
5040	func ( p * Pipe ) Iter ( ) * Iter { cloned := p . session . Clone ( ) cloned . SetMode ( Monotonic , false ) defer cloned . Close ( ) c := p . collection . With ( cloned ) var result struct { Result [ ] bson . Raw Cursor struct { FirstBatch [ ] bson . Raw "firstBatch" Id int64 } } cmd := pipeCmd { Aggregate : c . Name , Pipeline : p . pipeline , AllowDisk : p . allowDisk , Cursor : & pipeCmdCursor { p . batchSize } , } err := c . Database . Run ( cmd , & result ) if e , ok := err . ( * QueryError ) ; ok && e . Message == `unrecognized field "cursor` { cmd . Cursor = nil cmd . AllowDisk = false err = c . Database . Run ( cmd , & result ) } firstBatch := result . Result if firstBatch == nil { firstBatch = result . Cursor . FirstBatch } return c . NewIter ( p . session , firstBatch , result . Cursor . Id , err ) }
4898	func ( s * Session ) Call ( id uint64 , prmFieldSet * ParameterFieldSet , args [ ] driver . NamedValue ) ( * FieldValues , [ ] * TableResult , error ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) s . statementID . id = & id if err := s . writeRequest ( mtExecute , false , s . statementID , newInputParameters ( prmFieldSet . inputFields ( ) , args ) ) ; err != nil { return nil , nil , err } prmFieldValues := newFieldValues ( ) var tableResults [ ] * TableResult var tableResult * TableResult f := func ( p replyPart ) { switch p := p . ( type ) { case * outputParameters : p . s = s p . outputFields = prmFieldSet . outputFields ( ) p . fieldValues = prmFieldValues case * resultMetadata : tableResult = newTableResult ( s , p . numArg ) tableResults = append ( tableResults , tableResult ) p . resultFieldSet = tableResult . resultFieldSet case * resultsetID : p . id = & ( tableResult . id ) case * resultset : p . s = s tableResult . attrs = s . ph . partAttributes p . resultFieldSet = tableResult . resultFieldSet p . fieldValues = tableResult . fieldValues } } if err := s . readReply ( f ) ; err != nil { return nil , nil , err } if err := s . writeLobStream ( prmFieldSet , prmFieldValues , args ) ; err != nil { return nil , nil , err } return prmFieldValues , tableResults , nil }
2007	func newMetricsMetadata ( cluster * string , containerInstance * string ) * ecstcs . MetricsMetadata { return & ecstcs . MetricsMetadata { Cluster : cluster , ContainerInstance : containerInstance , } }
187	func ( r * AlertingRule ) State ( ) AlertState { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) maxState := StateInactive for _ , a := range r . active { if a . State > maxState { maxState = a . State } } return maxState }
4198	func ( m * Manager ) RemoveUnknownVisibilites ( serviceInfo * ServiceInfo ) error { for servicePlanName , servicePlan := range serviceInfo . AllPlans ( ) { for _ , plan := range servicePlan { for _ , visibility := range plan . ListVisibilities ( ) { if m . Peek { lo . G . Infof ( "[dry-run]: removing plan %s for service %s to org with guid %s" , plan . Name , servicePlanName , visibility . OrganizationGuid ) continue } lo . G . Infof ( "removing plan %s for service %s to org with guid %s" , plan . Name , servicePlanName , visibility . OrganizationGuid ) err := m . Client . DeleteServicePlanVisibilityByPlanAndOrg ( visibility . ServicePlanGuid , visibility . OrganizationGuid , false ) if err != nil { return err } } } } return nil }
837	func mkTokenCallback ( path string ) azure . TokenRefreshCallback { return func ( t azure . Token ) error { if err := azure . SaveToken ( path , 0600 , t ) ; err != nil { return err } log . Debug ( "Saved token to file." ) return nil } }
7032	func ( s * RemoteOperations ) RemoveRemoteFile ( ) ( err error ) { var sftpclient SFTPClient sftpclient , err = s . getClient ( ) if err == nil { err = SafeRemoveSSH ( sftpclient , s . remotePath ) } return }
5528	func copySliceToTable ( L * lua . State , v reflect . Value , visited visitor ) { vp := v for v . Kind ( ) == reflect . Ptr { v = v . Elem ( ) } n := v . Len ( ) L . CreateTable ( n , 0 ) if v . Kind ( ) == reflect . Slice { visited . mark ( v ) } else if vp . Kind ( ) == reflect . Ptr { visited . mark ( vp ) } for i := 0 ; i < n ; i ++ { L . PushInteger ( int64 ( i + 1 ) ) val := v . Index ( i ) if isNil ( val ) { val = nullv } goToLua ( L , val , false , visited ) L . SetTable ( - 3 ) } }
2558	func flattenHostVirtualSwitchBondBridge ( d * schema . ResourceData , obj * types . HostVirtualSwitchBondBridge ) error { if err := d . Set ( "network_adapters" , structure . SliceStringsToInterfaces ( obj . NicDevice ) ) ; err != nil { return err } if err := flattenHostVirtualSwitchBeaconConfig ( d , obj . Beacon ) ; err != nil { return err } if err := flattenLinkDiscoveryProtocolConfig ( d , obj . LinkDiscoveryProtocolConfig ) ; err != nil { return err } return nil }
5204	func ( idx * Index ) HasField ( fieldName string ) bool { _ , ok := idx . fields [ fieldName ] return ok }
1013	func ( s * Set ) List ( ) [ ] Dependency { s . RLock ( ) defer s . RUnlock ( ) r := make ( [ ] Dependency , len ( s . list ) ) for i , k := range s . list { r [ i ] = s . set [ k ] } return r }
194	func NewGroupMetrics ( reg prometheus . Registerer ) * Metrics { m := & Metrics { evalDuration : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Name : "rule_evaluation_duration_seconds" , Help : "The duration for a rule to execute." , } ) , evalFailures : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : "rule_evaluation_failures_total" , Help : "The total number of rule evaluation failures." , } ) , evalTotal : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : "rule_evaluations_total" , Help : "The total number of rule evaluations." , } ) , iterationDuration : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Name : "rule_group_duration_seconds" , Help : "The duration of rule group evaluations." , Objectives : map [ float64 ] float64 { 0.01 : 0.001 , 0.05 : 0.005 , 0.5 : 0.05 , 0.90 : 0.01 , 0.99 : 0.001 } , } ) , iterationsMissed : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : "rule_group_iterations_missed_total" , Help : "The total number of rule group evaluations missed due to slow rule group evaluation." , } ) , iterationsScheduled : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : "rule_group_iterations_total" , Help : "The total number of scheduled rule group evaluations, whether executed or missed." , } ) , groupLastEvalTime : prometheus . NewGaugeVec ( prometheus . GaugeOpts { Namespace : namespace , Name : "rule_group_last_evaluation_timestamp_seconds" , Help : "The timestamp of the last rule group evaluation in seconds." , } , [ ] string { "rule_group" } , ) , groupLastDuration : prometheus . NewGaugeVec ( prometheus . GaugeOpts { Namespace : namespace , Name : "rule_group_last_duration_seconds" , Help : "The duration of the last rule group evaluation." , } , [ ] string { "rule_group" } , ) , groupRules : prometheus . NewGaugeVec ( prometheus . GaugeOpts { Namespace : namespace , Name : "rule_group_rules" , Help : "The number of rules." , } , [ ] string { "rule_group" } , ) , } if reg != nil { reg . MustRegister ( m . evalDuration , m . evalFailures , m . evalTotal , m . iterationDuration , m . iterationsMissed , m . iterationsScheduled , m . groupLastEvalTime , m . groupLastDuration , m . groupRules , ) } return m }
2887	func hostSystemNameFromID ( client * govmomi . Client , id string ) ( string , error ) { hs , err := FromID ( client , id ) if err != nil { return "" , err } return hs . Name ( ) , nil }
622	func isAWSAlias ( ep * endpoint . Endpoint , addrs [ ] * endpoint . Endpoint ) string { if prop , exists := ep . GetProviderSpecificProperty ( "alias" ) ; ep . RecordType == endpoint . RecordTypeCNAME && exists && prop . Value == "true" { for _ , addr := range addrs { if addr . DNSName == ep . Targets [ 0 ] { if hostedZone := canonicalHostedZone ( addr . Targets [ 0 ] ) ; hostedZone != "" { return hostedZone } } } } return "" }
2338	func ( v * Context ) DeviceToUser ( x , y float64 ) ( float64 , float64 ) { C . cairo_device_to_user ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y }
3906	func terminates ( fn * ssa . Function ) bool { if fn . Blocks == nil { return true } for _ , block := range fn . Blocks { if len ( block . Instrs ) == 0 { continue } if _ , ok := block . Instrs [ len ( block . Instrs ) - 1 ] . ( * ssa . Return ) ; ok { return true } } return false }
1186	func DefaultConfig ( ) Config { programData := utils . DefaultIfBlank ( os . Getenv ( "ProgramData" ) , `C:\ProgramData` ) ecsRoot := filepath . Join ( programData , "Amazon" , "ECS" ) dataDir := filepath . Join ( ecsRoot , "data" ) platformVariables := PlatformVariables { CPUUnbounded : false , } return Config { DockerEndpoint : "npipe:////./pipe/docker_engine" , ReservedPorts : [ ] uint16 { DockerReservedPort , DockerReservedSSLPort , AgentIntrospectionPort , AgentCredentialsPort , rdpPort , rpcPort , smbPort , winRMPortHTTP , winRMPortHTTPS , dnsPort , netBIOSPort , } , ReservedPortsUDP : [ ] uint16 { } , DataDir : dataDir , DataDirOnHost : dataDir , ReservedMemory : 0 , AvailableLoggingDrivers : [ ] dockerclient . LoggingDriver { dockerclient . JSONFileDriver , dockerclient . NoneDriver , dockerclient . AWSLogsDriver } , TaskCleanupWaitDuration : DefaultTaskCleanupWaitDuration , DockerStopTimeout : defaultDockerStopTimeout , ContainerStartTimeout : defaultContainerStartTimeout , ImagePullInactivityTimeout : defaultImagePullInactivityTimeout , CredentialsAuditLogFile : filepath . Join ( ecsRoot , defaultCredentialsAuditLogFile ) , CredentialsAuditLogDisabled : false , ImageCleanupDisabled : false , MinimumImageDeletionAge : DefaultImageDeletionAge , ImageCleanupInterval : DefaultImageCleanupTimeInterval , NumImagesToDeletePerCycle : DefaultNumImagesToDeletePerCycle , NumNonECSContainersToDeletePerCycle : DefaultNumNonECSContainersToDeletePerCycle , ContainerMetadataEnabled : false , TaskCPUMemLimit : ExplicitlyDisabled , PlatformVariables : platformVariables , TaskMetadataSteadyStateRate : DefaultTaskMetadataSteadyStateRate , TaskMetadataBurstRate : DefaultTaskMetadataBurstRate , SharedVolumeMatchFullConfig : false , PollMetrics : false , PollingMetricsWaitDuration : DefaultPollingMetricsWaitDuration , } }
6120	func ( n * discovery ) DeleteMapping ( protocol string , extPort , intPort int ) error { if err := n . wait ( ) ; err != nil { return err } return n . found . DeleteMapping ( protocol , extPort , intPort ) }
4373	func URIValue ( v * strfmt . URI ) strfmt . URI { if v == nil { return strfmt . URI ( "" ) } return * v }
6200	func IsIPv4 ( s string ) bool { ip := net . ParseIP ( s ) return ip != nil }
5723	func ( c * Client ) CompareAndSwap ( item * Item ) error { return c . populateOne ( cmdSet , item , item . casid ) }
3341	func ( g * GroupData ) GetTriggeringValueOk ( ) ( TriggeringValue , bool ) { if g == nil || g . TriggeringValue == nil { return TriggeringValue { } , false } return * g . TriggeringValue , true }
7052	func Scaffold ( d Dispatcher , platform Platform ) Handler { router := New ( d ) platform . Routes ( router ) return router . dispatcher }
238	func ( m * Manager ) TargetsActive ( ) map [ string ] [ ] * Target { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) targets := make ( map [ string ] [ ] * Target , len ( m . scrapePools ) ) for tset , sp := range m . scrapePools { targets [ tset ] = sp . ActiveTargets ( ) } return targets }
5512	func ( f * FileLogger ) SetMaxFileCount ( count int ) int { f . fileCount = count return f . fileCount }
7102	func ( g GRPCLoggerV2 ) Fatalf ( format string , args ... interface { } ) { g . l . Criticalf ( format , args ... ) }
1326	func NewMockEC2MetadataClient ( ctrl * gomock . Controller ) * MockEC2MetadataClient { mock := & MockEC2MetadataClient { ctrl : ctrl } mock . recorder = & MockEC2MetadataClientMockRecorder { mock } return mock }
419	func ( cc * LBClient ) DoDeadline ( req * Request , resp * Response , deadline time . Time ) error { return cc . get ( ) . DoDeadline ( req , resp , deadline ) }
3080	func ( ctx * Context ) QueryInt64 ( name string ) int64 { return com . StrTo ( ctx . Query ( name ) ) . MustInt64 ( ) }
1985	func ( m * MockClient ) PluginList ( arg0 context . Context , arg1 filters . Args ) ( types . PluginsListResponse , error ) { ret := m . ctrl . Call ( m , "PluginList" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . PluginsListResponse ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
4358	func Object ( in [ ] byte , pos int ) ( int , error ) { pos , err := skipSpace ( in , pos ) if err != nil { return 0 , err } if v := in [ pos ] ; v != '{' { return 0 , newError ( pos , v ) } pos ++ pos , err = skipSpace ( in , pos ) if err != nil { return 0 , err } if in [ pos ] == '}' { return pos + 1 , nil } for { pos , err = String ( in , pos ) if err != nil { return 0 , err } pos , err = skipSpace ( in , pos ) if err != nil { return 0 , err } pos , err = expect ( in , pos , ':' ) if err != nil { return 0 , err } pos , err = Any ( in , pos ) if err != nil { return 0 , err } pos , err = skipSpace ( in , pos ) if err != nil { return 0 , err } switch in [ pos ] { case ',' : pos ++ case '}' : return pos + 1 , nil } } }
4398	func IsHostname ( str string ) bool { if ! rxHostname . MatchString ( str ) { return false } if len ( str ) > 255 { return false } parts := strings . Split ( str , "." ) valid := true for _ , p := range parts { if len ( p ) > 63 { valid = false } } return valid }
351	func NewNode ( l log . Logger , inf cache . SharedInformer ) * Node { if l == nil { l = log . NewNopLogger ( ) } n := & Node { logger : l , informer : inf , store : inf . GetStore ( ) , queue : workqueue . NewNamed ( "node" ) } n . informer . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( o interface { } ) { eventCount . WithLabelValues ( "node" , "add" ) . Inc ( ) n . enqueue ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( "node" , "delete" ) . Inc ( ) n . enqueue ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( "node" , "update" ) . Inc ( ) n . enqueue ( o ) } , } ) return n }
3748	func ( w * WidgetMetadata ) GetAliasName ( ) string { if w == nil || w . AliasName == nil { return "" } return * w . AliasName }
433	func ( ctx * RequestCtx ) SetContentTypeBytes ( contentType [ ] byte ) { ctx . Response . Header . SetContentTypeBytes ( contentType ) }
2721	func applyVirtualDevices ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { var spec , delta [ ] types . BaseVirtualDeviceConfigSpec var err error l , delta , err = virtualdevice . NormalizeSCSIBus ( l , d . Get ( "scsi_type" ) . ( string ) , d . Get ( "scsi_controller_count" ) . ( int ) , d . Get ( "scsi_bus_sharing" ) . ( string ) ) if err != nil { return nil , err } if len ( delta ) > 0 { log . Printf ( "[DEBUG] %s: SCSI bus has changed and requires a VM restart" , resourceVSphereVirtualMachineIDString ( d ) ) d . Set ( "reboot_required" , true ) } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) l , delta , err = virtualdevice . DiskApplyOperation ( d , c , l ) if err != nil { return nil , err } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) l , delta , err = virtualdevice . NetworkInterfaceApplyOperation ( d , c , l ) if err != nil { return nil , err } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) l , delta , err = virtualdevice . CdromApplyOperation ( d , c , l ) if err != nil { return nil , err } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) log . Printf ( "[DEBUG] %s: Final device list: %s" , resourceVSphereVirtualMachineIDString ( d ) , virtualdevice . DeviceListString ( l ) ) log . Printf ( "[DEBUG] %s: Final device change spec: %s" , resourceVSphereVirtualMachineIDString ( d ) , virtualdevice . DeviceChangeString ( spec ) ) return spec , nil }
913	func ( d * Driver ) waitStopped ( ) error { log . Infof ( "Waiting for host to stop..." ) for { s , err := d . GetState ( ) if err != nil { return err } if s != state . Running { return nil } time . Sleep ( 1 * time . Second ) } }
3092	func ( ctx * Context ) GetSuperSecureCookie ( secret , name string ) ( string , bool ) { val := ctx . GetCookie ( name ) if val == "" { return "" , false } text , err := hex . DecodeString ( val ) if err != nil { return "" , false } key := pbkdf2 . Key ( [ ] byte ( secret ) , [ ] byte ( secret ) , 1000 , 16 , sha256 . New ) text , err = com . AESGCMDecrypt ( key , text ) return string ( text ) , err == nil }
1994	func ( engine * DockerStatsEngine ) waitToStop ( ) { ctx := engine . containerChangeEventStream . Context ( ) select { case <- ctx . Done ( ) : seelog . Debug ( "Event stream closed, stop listening to the event stream" ) engine . containerChangeEventStream . Unsubscribe ( containerChangeHandler ) engine . removeAll ( ) } }
1941	func ( m * MockTaskEngineState ) RemoveENIAttachment ( arg0 string ) { m . ctrl . Call ( m , "RemoveENIAttachment" , arg0 ) }
2981	func ( r * DiskSubresource ) createDisk ( l object . VirtualDeviceList ) ( * types . VirtualDisk , error ) { disk := new ( types . VirtualDisk ) disk . Backing = new ( types . VirtualDiskFlatVer2BackingInfo ) if r . rdd . Get ( "datastore_cluster_id" ) . ( string ) == "" { if err := r . assignBackingInfo ( disk ) ; err != nil { return nil , err } } disk . Key = l . NewKey ( ) return disk , nil }
7230	func ( logger * Logger ) Debugf ( format string , a ... interface { } ) { logger . log ( DEBUG , format , a ... ) }
2472	func ( s * openGLState ) reset ( context * context ) error { if err := context . reset ( ) ; err != nil { return err } s . lastProgram = zeroProgram s . lastViewportWidth = 0 s . lastViewportHeight = 0 s . lastColorMatrix = nil s . lastColorMatrixTranslation = nil s . lastSourceWidth = 0 s . lastSourceHeight = 0 s . lastFilter = nil s . lastAddress = nil if s . programs == nil { s . programs = map [ programKey ] program { } } else { for k , p := range s . programs { context . deleteProgram ( p ) delete ( s . programs , k ) } } if ! web . IsBrowser ( ) { if s . arrayBuffer != zeroBuffer { context . deleteBuffer ( s . arrayBuffer ) } if s . elementArrayBuffer != zeroBuffer { context . deleteBuffer ( s . elementArrayBuffer ) } } shaderVertexModelviewNative , err := context . newShader ( vertexShader , vertexShaderStr ( ) ) if err != nil { panic ( fmt . Sprintf ( "graphics: shader compiling error:\n%s" , \n ) ) } err defer context . deleteShader ( shaderVertexModelviewNative ) for _ , c := range [ ] bool { false , true } { for _ , a := range [ ] graphics . Address { graphics . AddressClampToZero , graphics . AddressRepeat , } { for _ , f := range [ ] graphics . Filter { graphics . FilterNearest , graphics . FilterLinear , graphics . FilterScreen , } { shaderFragmentColorMatrixNative , err := context . newShader ( fragmentShader , fragmentShaderStr ( c , f , a ) ) if err != nil { panic ( fmt . Sprintf ( "graphics: shader compiling error:\n%s" , \n ) ) } err defer context . deleteShader ( shaderFragmentColorMatrixNative ) program , err := context . newProgram ( [ ] shader { shaderVertexModelviewNative , shaderFragmentColorMatrixNative , } , theArrayBufferLayout . names ( ) ) if err != nil { return err } } } } s . programs [ programKey { useColorM : c , filter : f , address : a , } ] = program s . arrayBuffer = theArrayBufferLayout . newArrayBuffer ( context ) }
2565	func flattenStorageDrsVMConfigInfo ( d * schema . ResourceData , obj * types . StorageDrsVmConfigInfo ) error { if err := d . Set ( "sdrs_automation_level" , obj . Behavior ) ; err != nil { return fmt . Errorf ( "error setting attribute \"sdrs_automation_level\": %s" , \" ) } \" err if err := structure . SetBoolStringPtr ( d , "sdrs_enabled" , obj . Enabled ) ; err != nil { return fmt . Errorf ( "error setting attribute \"sdrs_enabled\": %s" , \" ) } }
385	func ( a * Args ) HasBytes ( key [ ] byte ) bool { return hasArg ( a . args , b2s ( key ) ) }
1283	func ( * loader ) LoadImage ( ctx context . Context , cfg * config . Config , dockerClient dockerapi . DockerClient ) ( * types . ImageInspect , error ) { log . Debugf ( "Loading pause container tarball: %s" , cfg . PauseContainerTarballPath ) if err := loadFromFile ( ctx , cfg . PauseContainerTarballPath , dockerClient , os . Default ) ; err != nil { return nil , err } return getPauseContainerImage ( config . DefaultPauseContainerImageName , config . DefaultPauseContainerTag , dockerClient ) }
3102	func ( rm * routeMap ) add ( method , pattern string , leaf * Leaf ) { rm . lock . Lock ( ) defer rm . lock . Unlock ( ) rm . routes [ method ] [ pattern ] = leaf }
1355	func ( agent * ecsAgent ) registerContainerInstance ( stateManager statemanager . StateManager , client api . ECSClient , additionalAttributes [ ] * ecs . Attribute ) error { if preflightCreds , err := agent . credentialProvider . Get ( ) ; err != nil || preflightCreds . AccessKeyID == "" { seelog . Warnf ( "Error getting valid credentials (AKID %s): %v" , preflightCreds . AccessKeyID , err ) } agentCapabilities , err := agent . capabilities ( ) if err != nil { return err } capabilities := append ( agentCapabilities , additionalAttributes ... ) tags := utils . MapToTags ( agent . cfg . ContainerInstanceTags ) if agent . cfg . ContainerInstancePropagateTagsFrom == config . ContainerInstancePropagateTagsFromEC2InstanceType { ec2Tags , err := agent . getContainerInstanceTagsFromEC2API ( ) if err != nil { return err } seelog . Infof ( "Retrieved Tags from EC2 DescribeTags API:\n%v" , \n ) ec2Tags } tags = mergeTags ( tags , ec2Tags ) platformDevices := agent . getPlatformDevices ( ) if agent . containerInstanceARN != "" { seelog . Infof ( "Restored from checkpoint file. I am running as '%s' in cluster '%s'" , agent . containerInstanceARN , agent . cfg . Cluster ) return agent . reregisterContainerInstance ( client , capabilities , tags , uuid . New ( ) , platformDevices ) } seelog . Info ( "Registering Instance with ECS" ) containerInstanceArn , availabilityZone , err := client . RegisterContainerInstance ( "" , capabilities , tags , uuid . New ( ) , platformDevices ) if err != nil { seelog . Errorf ( "Error registering: %v" , err ) if retriable , ok := err . ( apierrors . Retriable ) ; ok && ! retriable . Retry ( ) { return err } if utils . IsAWSErrorCodeEqual ( err , ecs . ErrCodeInvalidParameterException ) { seelog . Critical ( "Instance registration attempt with an invalid parameter" ) return err } if _ , ok := err . ( apierrors . AttributeError ) ; ok { seelog . Critical ( "Instance registration attempt with an invalid attribute" ) return err } return transientError { err } } seelog . Infof ( "Registration completed successfully. I am running as '%s' in cluster '%s'" , containerInstanceArn , agent . cfg . Cluster ) agent . containerInstanceARN = containerInstanceArn agent . availabilityZone = availabilityZone stateManager . Save ( ) }
4041	func SetClipRect ( x , y , w , h int ) { if x < 0 { x = 0 } if y < 0 { y = 0 } if x + w > canvas . width { w = canvas . width - x } if y + h > canvas . height { h = canvas . height - h } canvas . clipX = x canvas . clipY = y canvas . clipW = w canvas . clipH = h }
2529	func expandVMwareDVSPortgroupPolicy ( d * schema . ResourceData ) * types . VMwareDVSPortgroupPolicy { obj := & types . VMwareDVSPortgroupPolicy { DVPortgroupPolicy : types . DVPortgroupPolicy { BlockOverrideAllowed : d . Get ( "block_override_allowed" ) . ( bool ) , ShapingOverrideAllowed : d . Get ( "shaping_override_allowed" ) . ( bool ) , LivePortMovingAllowed : d . Get ( "live_port_moving_allowed" ) . ( bool ) , PortConfigResetAtDisconnect : d . Get ( "port_config_reset_at_disconnect" ) . ( bool ) , NetworkResourcePoolOverrideAllowed : structure . GetBoolPtr ( d , "network_resource_pool_override_allowed" ) , TrafficFilterOverrideAllowed : structure . GetBoolPtr ( d , "traffic_filter_override_allowed" ) , } , VlanOverrideAllowed : d . Get ( "vlan_override_allowed" ) . ( bool ) , UplinkTeamingOverrideAllowed : d . Get ( "uplink_teaming_override_allowed" ) . ( bool ) , SecurityPolicyOverrideAllowed : d . Get ( "security_policy_override_allowed" ) . ( bool ) , IpfixOverrideAllowed : structure . GetBoolPtr ( d , "netflow_override_allowed" ) , } return obj }
1021	func NewDedupManager ( config * config . DedupConfig , clients * dep . ClientSet , brain * template . Brain , templates [ ] * template . Template ) ( * DedupManager , error ) { d := & DedupManager { config : config , clients : clients , brain : brain , templates : templates , leader : make ( map [ * template . Template ] <- chan struct { } ) , lastWrite : make ( map [ * template . Template ] uint64 ) , updateCh : make ( chan struct { } , 1 ) , stopCh : make ( chan struct { } ) , } return d , nil }
3921	func CreateProgram ( lprog * loader . Program , mode ssa . BuilderMode ) * ssa . Program { prog := ssa . NewProgram ( lprog . Fset , mode ) for _ , info := range lprog . AllPackages { if info . TransitivelyErrorFree { prog . CreatePackage ( info . Pkg , info . Files , & info . Info , info . Importable ) } } return prog }
5338	func NewEdit ( filename string ) ( * edit , error ) { if err := Backup ( filename ) ; err != nil { return nil , err } file , err := os . OpenFile ( filename , os . O_RDWR , 0666 ) if err != nil { return nil , err } return & edit { _editDefault , file , bufio . NewReadWriter ( bufio . NewReader ( file ) , bufio . NewWriter ( file ) ) , } , nil }
879	func ( d * SerialDriver ) GetSSHHostname ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHHostname ( ) }
551	func FileServer ( r chi . Router , path string , root http . FileSystem ) { if strings . ContainsAny ( path , "{}*" ) { panic ( "FileServer does not permit URL parameters." ) } fs := http . StripPrefix ( path , http . FileServer ( root ) ) if path != "/" && path [ len ( path ) - 1 ] != '/' { r . Get ( path , http . RedirectHandler ( path + "/" , 301 ) . ServeHTTP ) path += "/" } path += "*" r . Get ( path , http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { fs . ServeHTTP ( w , r ) } ) ) }
2562	func saveHostVirtualSwitchID ( d * schema . ResourceData , hsID , name string ) { d . SetId ( fmt . Sprintf ( "%s:%s:%s" , hostVirtualSwitchIDPrefix , hsID , name ) ) }
1617	func ( m * MockSecretsManagerAPI ) UntagResource ( arg0 * secretsmanager . UntagResourceInput ) ( * secretsmanager . UntagResourceOutput , error ) { ret := m . ctrl . Call ( m , "UntagResource" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UntagResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2118	func ( v * AppChooserWidget ) native ( ) * C . GtkAppChooserWidget { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAppChooserWidget ( p ) }
2922	func pickSCSIController ( l object . VirtualDeviceList , bus int ) ( types . BaseVirtualController , error ) { log . Printf ( "[DEBUG] pickSCSIController: Looking for SCSI controller at bus number %d" , bus ) l = l . Select ( func ( device types . BaseVirtualDevice ) bool { switch d := device . ( type ) { case types . BaseVirtualSCSIController : return d . GetVirtualSCSIController ( ) . BusNumber == int32 ( bus ) } return false } ) if len ( l ) == 0 { return nil , fmt . Errorf ( "could not find scsi controller at bus number %d" , bus ) } log . Printf ( "[DEBUG] pickSCSIController: Found SCSI controller: %s" , l . Name ( l [ 0 ] ) ) return l [ 0 ] . ( types . BaseVirtualController ) , nil }
5088	func New ( tagName string , funcs map [ string ] Func ) * Validate { structPool = & sync . Pool { New : newStructErrors } return & Validate { tagName : tagName , validationFuncs : funcs , } }
1257	func copyTaskHealthMetrics ( from [ ] * ecstcs . TaskHealth ) [ ] * ecstcs . TaskHealth { to := make ( [ ] * ecstcs . TaskHealth , len ( from ) ) copy ( to , from ) return to }
3714	func ( w * Widget ) HasServiceService ( ) bool { if w != nil && w . ServiceService != nil { return true } return false }
1977	func ( m * MockClient ) Events ( arg0 context . Context , arg1 types . EventsOptions ) ( <- chan events . Message , <- chan error ) { ret := m . ctrl . Call ( m , "Events" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( <- chan events . Message ) ret1 , _ := ret [ 1 ] . ( <- chan error ) return ret0 , ret1 }
4971	func ReadPublic ( raw [ ] byte ) ( key * rsa . PublicKey , err error ) { var encoded * pem . Block if encoded , _ = pem . Decode ( raw ) ; encoded == nil { return nil , errors . New ( "Rsa.NewPublic(): Key must be PEM encoded PKCS1 X509 certificate or PKIX public key" ) } var parsedKey interface { } var cert * x509 . Certificate if parsedKey , err = x509 . ParsePKIXPublicKey ( encoded . Bytes ) ; err != nil { if cert , err = x509 . ParseCertificate ( encoded . Bytes ) ; err != nil { return nil , err } parsedKey = cert . PublicKey } var ok bool if key , ok = parsedKey . ( * rsa . PublicKey ) ; ! ok { return nil , errors . New ( "Rsa.NewPublic(): Key is not a valid RSA public key" ) } return key , nil }
2278	func ( v * SelectionData ) native ( ) * C . GtkSelectionData { if v == nil { return nil } return v . GtkSelectionData }
5951	func Init ( ) Scan { scan := Scan { } scan . Hosts = make ( map [ string ] Host , 0 ) return scan }
75	func NewStorage ( l log . Logger , reg prometheus . Registerer , stCallback startTimeCallback , walDir string , flushDeadline time . Duration ) * Storage { if l == nil { l = log . NewNopLogger ( ) } s := & Storage { logger : logging . Dedupe ( l , 1 * time . Minute ) , localStartTimeCallback : stCallback , flushDeadline : flushDeadline , samplesIn : newEWMARate ( ewmaWeight , shardUpdateDuration ) , walDir : walDir , } go s . run ( ) return s }
5003	func ( d * Dataset ) Children ( depth uint64 ) ( [ ] * Dataset , error ) { args := [ ] string { "list" } if depth > 0 { args = append ( args , "-d" ) args = append ( args , strconv . FormatUint ( depth , 10 ) ) } else { args = append ( args , "-r" ) } args = append ( args , "-t" , "all" , "-Hp" , "-o" , dsPropListOptions ) args = append ( args , d . Name ) out , err := zfs ( args ... ) if err != nil { return nil , err } var datasets [ ] * Dataset name := "" var ds * Dataset for _ , line := range out { if name != line [ 0 ] { name = line [ 0 ] ds = & Dataset { Name : name } datasets = append ( datasets , ds ) } if err := ds . parseLine ( line ) ; err != nil { return nil , err } } return datasets [ 1 : ] , nil }
6607	func xtoi2 ( s string , e byte ) ( byte , bool ) { if len ( s ) > 2 && s [ 2 ] != e { return 0 , false } n , ei , ok := xtoi ( s [ : 2 ] , 0 ) return byte ( n ) , ok && ei == 2 }
6666	func ( s * VecStack ) Push ( value * Vec ) { s . top = & item { value , s . top } s . size ++ }
2202	func ( v * ShortcutsShortcut ) native ( ) * C . GtkShortcutsShortcut { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkShortcutsShortcut ( p ) }
6676	func ( v Vec ) Len ( ) float64 { return float64 ( math . Hypot ( float64 ( v . X ) , float64 ( v . Y ) ) ) }
5970	func FromURL ( urlString string ) ( * HOTP , string , error ) { u , err := url . Parse ( urlString ) if err != nil { return nil , "" , err } if u . Scheme != "otpauth" { return nil , "" , ErrInvalidHOTPURL } else if u . Host != "hotp" { return nil , "" , ErrInvalidHOTPURL } v := u . Query ( ) if len ( v ) == 0 { return nil , "" , ErrInvalidHOTPURL } if v . Get ( "secret" ) == "" { return nil , "" , ErrInvalidHOTPURL } else if algo := v . Get ( "algorithm" ) ; algo != "" && algo != "SHA1" { return nil , "" , ErrInvalidHOTPURL } var identity string if len ( u . Path ) > 1 { identity = u . Path [ 1 : ] } var counter uint64 if ctr := v . Get ( "counter" ) ; ctr != "" { counter , err = strconv . ParseUint ( ctr , 10 , 64 ) if err != nil { return nil , "" , ErrInvalidHOTPURL } } secret , err := base32 . StdEncoding . DecodeString ( v . Get ( "secret" ) ) if err != nil { return nil , "" , ErrInvalidHOTPURL } var digits int64 = 6 if v . Get ( "digits" ) != "" { digits , err = strconv . ParseInt ( v . Get ( "digits" ) , 10 , 8 ) if err != nil { return nil , "" , ErrInvalidHOTPURL } } otp := NewHOTP ( secret , counter , int ( digits ) ) return otp , identity , nil }
4799	func gitWrapperScript ( ) [ ] byte { scriptTemplate := `#!/usr/bin/env {shell}# The MIT License (MIT)# Copyright (c) 2013 Alvin Abadif [ $# -eq 0 ]; then echo "Git wrapper script that can specify an ssh-key fileUsage: git.sh -i ssh-key-file git-command " exit 1fi# remove temporary file on exittrap 'rm -f {tmp_dir}/.git_ssh.$$' 0if [ "$1" = "-i" ]; then SSH_KEY=$2; shift; shift echo -e "#!/usr/bin/env {shell}\n \ ssh -i $SSH_KEY \$@" > {tmp_dir}/.git_ssh.$$ chmod +x {tmp_dir}/.git_ssh.$$ export GIT_SSH={tmp_dir}/.git_ssh.$$fi# in case the git command is repeated[ "$1" = "git" ] && shift# Run the git command{git_binary} "$@"` replacer := strings . NewReplacer ( "{shell}" , shell , "{tmp_dir}" , strings . TrimSuffix ( gos . TempDir ( ) , "/" ) , "{git_binary}" , gitBinary , ) return [ ] byte ( replacer . Replace ( scriptTemplate ) ) }
83	func ( api * API ) HTTPHandler ( ctx context . Context , grpcAddr string ) ( http . Handler , error ) { enc := new ( protoutil . JSONPb ) mux := runtime . NewServeMux ( runtime . WithMarshalerOption ( enc . ContentType ( ) , enc ) ) opts := [ ] grpc . DialOption { grpc . WithInsecure ( ) , grpc . WithContextDialer ( func ( ctx context . Context , addr string ) ( net . Conn , error ) { return ( & net . Dialer { } ) . DialContext ( ctx , "tcp" , addr ) } ) , } err := pb . RegisterAdminHandlerFromEndpoint ( ctx , mux , grpcAddr , opts ) if err != nil { return nil , err } return mux , nil }
2775	func Properties ( obj * object . ResourcePool ) ( * mo . ResourcePool , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . ResourcePool if err := obj . Properties ( ctx , obj . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
2123	func ( v * Variant ) TypeString ( ) string { return C . GoString ( ( * C . char ) ( C . g_variant_get_type_string ( v . native ( ) ) ) ) }
2700	func ( c * Config ) EnableDebug ( ) error { if ! c . Debug { return nil } r := c . DebugPath if r == "" { r = filepath . Join ( os . Getenv ( "HOME" ) , ".govmomi" ) } r = filepath . Join ( r , "debug" ) run := c . DebugPathRun if run == "" { now := time . Now ( ) . Format ( "2006-01-02T15-04-05.999999999" ) r = filepath . Join ( r , now ) } else { r = filepath . Join ( r , run ) _ = os . RemoveAll ( r ) } err := os . MkdirAll ( r , 0700 ) if err != nil { log . Printf ( "[ERROR] Client debug setup failed: %v" , err ) return err } p := debug . FileProvider { Path : r , } debug . SetProvider ( & p ) return nil }
7118	func ( c * Config ) Get ( section , key string ) string { for _ , sect := range c . sections { if sect . name == section { for _ , opt := range sect . options { if opt . name == key { return opt . value } } return "" } } return "" }
4008	func ( u * URI ) UnmarshalJSON ( data [ ] byte ) error { if string ( data ) == "null" { return nil } var s string err := json . Unmarshal ( data , & s ) if err != nil { return err } u . URL , err = url . Parse ( s ) return err }
4220	func ( mkc * memoryKeyCacher ) Get ( keyID string ) ( * jose . JSONWebKey , error ) { searchKey , ok := mkc . entries [ keyID ] if ok { if mkc . maxKeyAge == MaxKeyAgeNoCheck || ! mkc . keyIsExpired ( keyID ) { return & searchKey . JSONWebKey , nil } return nil , ErrKeyExpired } return nil , ErrNoKeyFound }
277	func lexString ( l * lexer ) stateFn { Loop : for { switch l . next ( ) { case '\\' : lexEscape ( l ) case utf8 . RuneError : return l . errorf ( "invalid UTF-8 rune" ) case eof , '\n' : return l . errorf ( "unterminated quoted string" ) case l . stringOpen : break Loop } } l . emit ( ItemString ) return lexStatements }
1383	func ( queue * Queue ) Add ( dockerStat * types . StatsJSON ) error { queue . setLastStat ( dockerStat ) stat , err := dockerStatsToContainerStats ( dockerStat ) if err != nil { return err } queue . add ( stat ) return nil }
4947	func readShortUtf8 ( rd * bufio . Reader ) ( [ ] byte , int ) { size := rd . ReadB ( ) b := rd . ReadCesu8 ( int ( size ) ) return b , int ( size ) }
257	func ( n * Manager ) Alertmanagers ( ) [ ] * url . URL { n . mtx . RLock ( ) amSets := n . alertmanagers n . mtx . RUnlock ( ) var res [ ] * url . URL for _ , ams := range amSets { ams . mtx . RLock ( ) for _ , am := range ams . ams { res = append ( res , am . url ( ) ) } ams . mtx . RUnlock ( ) } return res }
5661	func Cost ( hashedPassword [ ] byte ) ( int , error ) { p , err := newFromHash ( hashedPassword ) if err != nil { return 0 , err } return p . cost , nil }
4006	func GetMappedPolicies ( polMap * pkix . Extension ) ( out [ ] [ 2 ] asn1 . ObjectIdentifier , err error ) { if polMap == nil { return nil , errors . New ( "policyMap: null pointer" ) } var outSeq , inSeq asn1 . RawValue empty , err := asn1 . Unmarshal ( polMap . Value , & outSeq ) if err != nil || len ( empty ) != 0 || outSeq . Class != 0 || outSeq . Tag != 16 || outSeq . IsCompound == false { return nil , errors . New ( "policyMap: Could not unmarshal outer sequence." ) } for done := false ; ! done ; { outSeq . Bytes , err = asn1 . Unmarshal ( outSeq . Bytes , & inSeq ) if err != nil || inSeq . Class != 0 || inSeq . Tag != 16 || inSeq . IsCompound == false { err = errors . New ( "policyMap: Could not unmarshal inner sequence." ) return } if len ( outSeq . Bytes ) == 0 { done = true } var oidIssue , oidSubject asn1 . ObjectIdentifier var restIn asn1 . RawContent restIn , err = asn1 . Unmarshal ( inSeq . Bytes , & oidIssue ) if err != nil || len ( restIn ) == 0 { err = errors . New ( "policyMap: Could not unmarshal inner sequence." ) return } empty , err = asn1 . Unmarshal ( restIn , & oidSubject ) if err != nil || len ( empty ) != 0 { err = errors . New ( "policyMap: Could not unmarshal inner sequence." ) return } out = append ( out , [ 2 ] asn1 . ObjectIdentifier { oidIssue , oidSubject } ) } return }
6255	func ( h * Handler ) GetClientOfferings ( tkn string , agent data . HexString , minUnitPrice , maxUnitPrice uint64 , countries [ ] string , offset , limit uint ) ( * GetClientOfferingsResult , error ) { logger := h . logger . Add ( "method" , "GetClientOfferings" , "agent" , agent , "minUnitPrice" , minUnitPrice , "maxUnitPrice" , maxUnitPrice , "countries" , countries , "offset" , offset , "limit" , limit ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } if minUnitPrice != 0 && maxUnitPrice != 0 && minUnitPrice > maxUnitPrice { logger . Error ( ErrBadUnitPriceRange . Error ( ) ) return nil , ErrBadUnitPriceRange } cond , args := h . getClientOfferingsConditions ( agent , minUnitPrice , maxUnitPrice , countries ) count , err := h . numberOfObjects ( logger , data . OfferingTable . Name ( ) , cond , args ) if err != nil { return nil , err } offsetLimit := h . offsetLimit ( offset , limit ) tail := fmt . Sprintf ( "%s %s %s" , cond , activeOfferingSorting , offsetLimit ) result , err := h . selectAllFrom ( logger , data . OfferingTable , tail , args ... ) if err != nil { return nil , err } offerings := make ( [ ] data . Offering , len ( result ) ) for k , v := range result { offerings [ k ] = * v . ( * data . Offering ) } return & GetClientOfferingsResult { offerings , count } , nil }
3605	func ( t * TimeRange ) GetLiveOk ( ) ( bool , bool ) { if t == nil || t . Live == nil { return false , false } return * t . Live , true }
1720	func convertENIToCNIConfig ( eni * apieni . ENI , cfg * ecscni . Config ) { cfg . ENIID = eni . ID cfg . ID = eni . MacAddress cfg . ENIMACAddress = eni . MacAddress cfg . SubnetGatewayIPV4Address = eni . GetSubnetGatewayIPV4Address ( ) for _ , ipv4 := range eni . IPV4Addresses { if ipv4 . Primary { cfg . ENIIPV4Address = ipv4 . Address break } } if len ( eni . IPV6Addresses ) > 0 { cfg . ENIIPV6Address = eni . IPV6Addresses [ 0 ] . Address } }
1130	func ( c * cache ) Get ( k string ) ( interface { } , bool ) { c . mu . RLock ( ) item , found := c . items [ k ] if ! found { c . mu . RUnlock ( ) return nil , false } if item . Expiration > 0 { if time . Now ( ) . UnixNano ( ) > item . Expiration { c . mu . RUnlock ( ) return nil , false } } c . mu . RUnlock ( ) return item . Object , true }
6576	func DelAllSvcComments ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "DEL_ALL_SVC_COMMENTS" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
4564	func ( t * Template ) Parse ( ) error { if t . program != nil { return nil } program , err := parser . Parse ( t . Input ) if err != nil { return err } t . program = program return nil }
2027	func ( task * Task ) BuildLinuxResourceSpec ( ) ( specs . LinuxResources , error ) { linuxResourceSpec := specs . LinuxResources { } if task . CPU > 0 { linuxCPUSpec , err := task . buildExplicitLinuxCPUSpec ( ) if err != nil { return specs . LinuxResources { } , err } linuxResourceSpec . CPU = & linuxCPUSpec } else { linuxCPUSpec := task . buildImplicitLinuxCPUSpec ( ) linuxResourceSpec . CPU = & linuxCPUSpec } if task . Memory > 0 { linuxMemorySpec , err := task . buildLinuxMemorySpec ( ) if err != nil { return specs . LinuxResources { } , err } linuxResourceSpec . Memory = & linuxMemorySpec } return linuxResourceSpec , nil }
5090	func ( v * Validate ) FieldWithValue ( val interface { } , f interface { } , tag string ) * FieldError { return v . fieldWithNameAndValue ( nil , val , f , tag , "" , true , nil ) }
897	func ( d * Driver ) Remove ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } if err := c . deleteInstance ( ) ; err != nil { if isNotFound ( err ) { log . Warn ( "Remote instance does not exist, proceeding with removing local reference" ) } else { return err } } if err := c . deleteDisk ( ) ; err != nil { if isNotFound ( err ) { log . Warn ( "Remote disk does not exist, proceeding" ) } else { return err } } return nil }
2125	func ( v * Variant ) GetStrv ( ) [ ] string { gstrv := C . g_variant_get_strv ( v . native ( ) , nil ) c := gstrv defer C . g_free ( C . gpointer ( gstrv ) ) var strs [ ] string for * c != nil { strs = append ( strs , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return strs }
4194	func ( u * Updater ) UpdateSpaces ( ) error { scs , err := u . Cfg . GetSpaceConfigs ( ) if err != nil { return err } isolationSegmentMap , err := u . isolationSegmentMap ( ) if err != nil { return err } for _ , sc := range scs { space , err := u . SpaceManager . FindSpace ( sc . Org , sc . Space ) if err != nil { return err } isolationSegmentGUID , err := u . getIsolationSegmentGUID ( sc . IsoSegment , isolationSegmentMap ) if err != nil { return err } if space . IsolationSegmentGuid != isolationSegmentGUID { if u . Peek { if sc . IsoSegment != "" { lo . G . Infof ( "[dry-run]: set isolation segment for space %s to %s (org %s)" , sc . Space , sc . IsoSegment , sc . Org ) } else { lo . G . Infof ( "[dry-run]: reset isolation segment for space %s (org %s)" , sc . Space , sc . Org ) } continue } if sc . IsoSegment != "" { lo . G . Infof ( "set isolation segment for space %s to %s (org %s)" , sc . Space , sc . IsoSegment , sc . Org ) err = u . Client . IsolationSegmentForSpace ( space . Guid , isolationSegmentGUID ) if err != nil { return err } } else { lo . G . Infof ( "reset isolation segment for space %s (org %s)" , sc . Space , sc . Org ) err = u . Client . ResetIsolationSegmentForSpace ( space . Guid ) if err != nil { return err } } } } return nil }
4063	func ( s * ThemeManager ) loadTheme ( name string ) { thememtx . Lock ( ) defer thememtx . Unlock ( ) if _ , ok := s . themes [ name ] ; ok { return } theme := theme { parent : defaultTheme , title : "" , author : "" } theme . colors = make ( map [ string ] term . Attribute , 0 ) theme . objects = make ( map [ string ] string , 0 ) file , err := os . Open ( s . themePath + string ( os . PathSeparator ) + name + themeSuffix ) if err != nil { panic ( "Failed to open theme " + name + " : " + err . Error ( ) ) } defer file . Close ( ) scanner := bufio . NewScanner ( file ) for scanner . Scan ( ) { line := scanner . Text ( ) line = strings . TrimSpace ( line ) if strings . HasPrefix ( line , "#" ) || strings . HasPrefix ( line , "/" ) { continue } if ! strings . Contains ( line , "=" ) { continue } parts := strings . SplitN ( line , "=" , 2 ) key := strings . TrimSpace ( parts [ 0 ] ) value := strings . TrimSpace ( parts [ 1 ] ) if ( strings . HasPrefix ( value , "'" ) && strings . HasSuffix ( value , "'" ) ) || ( strings . HasPrefix ( value , "\"" ) && \" ) strings . HasSuffix ( value , "\"" ) \" { toTrim , _ := utf8 . DecodeRuneInString ( value ) value = strings . Trim ( value , string ( toTrim ) ) } } low := strings . ToLower ( key ) }
6568	func ChangeContactModhattr ( contact_name string , value string , ) * livestatus . Command { return livestatus . NewCommand ( "CHANGE_CONTACT_MODHATTR" , stringifyArg ( "contact_name" , "string" , contact_name ) , stringifyArg ( "value" , "string" , value ) , ) }
6068	func ( c * Client ) Endpoint ( channelKey data . Base64String ) ( data . Base64String , error ) { return c . requestWithPayload ( "api_endpoint" , string ( channelKey ) ) }
5384	func Run ( command string ) ( output [ ] byte , err error ) { output , _ , err = RunWithMatch ( command ) return }
1399	func ( manager * metadataManager ) Clean ( taskARN string ) error { metadataPath , err := getTaskMetadataDir ( taskARN , manager . dataDir ) if err != nil { return fmt . Errorf ( "clean task metadata: unable to get metadata directory for task %s: %v" , taskARN , err ) } return manager . osWrap . RemoveAll ( metadataPath ) }
4808	func ( g Git ) Repo ( i int ) * Repo { if i < len ( g ) { return g [ i ] } return nil }
326	func ( l * openMetricsLexer ) next ( ) byte { l . i ++ if l . i >= len ( l . b ) { l . err = io . EOF return byte ( tEOF ) } for l . b [ l . i ] == 0 && ( l . state == sLValue || l . state == sMeta2 || l . state == sComment ) { l . i ++ if l . i >= len ( l . b ) { l . err = io . EOF return byte ( tEOF ) } } return l . b [ l . i ] }
4490	func ( d * Date ) SetBSON ( raw bson . Raw ) error { var m bson . M if err := raw . Unmarshal ( & m ) ; err != nil { return err } if data , ok := m [ "data" ] . ( string ) ; ok { rd , err := time . Parse ( RFC3339FullDate , data ) * d = Date ( rd ) return err } return errors . New ( "couldn't unmarshal bson raw value as Date" ) }
6303	func ( di * dependencyInjector ) Create ( avar interface { } ) interface { } { varType := reflect . TypeOf ( avar ) if di . caching { return di . cachedCreateFromType ( varType ) . Interface ( ) } else { return di . CreateFromType ( varType ) . Interface ( ) } }
6841	func ( c * Client ) PushNoteToChannel ( tag string , title , body string ) error { data := Note { Tag : tag , Type : "note" , Title : title , Body : body , } return c . Push ( "/pushes" , data ) }
5745	func I18n ( options ... Options ) macaron . Handler { opt := prepareOptions ( options ) m := initLocales ( opt ) return func ( ctx * macaron . Context ) { isNeedRedir := false hasCookie := false lang := ctx . Query ( opt . Parameter ) if len ( lang ) == 0 { lang = ctx . GetCookie ( "lang" ) hasCookie = true } else { isNeedRedir = true } if ! i18n . IsExist ( lang ) { lang = "" isNeedRedir = false hasCookie = false } if len ( lang ) == 0 { tags , _ , _ := language . ParseAcceptLanguage ( ctx . Req . Header . Get ( "Accept-Language" ) ) tag , _ , _ := m . Match ( tags ... ) lang = tag . String ( ) isNeedRedir = false } curLang := LangType { Lang : lang , } if ! hasCookie { ctx . SetCookie ( "lang" , curLang . Lang , 1 << 31 - 1 , "/" + strings . TrimPrefix ( opt . SubURL , "/" ) , opt . CookieDomain ) } restLangs := make ( [ ] LangType , 0 , i18n . Count ( ) - 1 ) langs := i18n . ListLangs ( ) names := i18n . ListLangDescs ( ) for i , v := range langs { if lang != v { restLangs = append ( restLangs , LangType { v , names [ i ] } ) } else { curLang . Name = names [ i ] } } locale := Locale { i18n . Locale { lang } } ctx . Map ( locale ) ctx . Locale = locale ctx . Data [ opt . TmplName ] = locale ctx . Data [ "Tr" ] = i18n . Tr ctx . Data [ "Lang" ] = locale . Lang ctx . Data [ "LangName" ] = curLang . Name ctx . Data [ "AllLangs" ] = append ( [ ] LangType { curLang } , restLangs ... ) ctx . Data [ "RestLangs" ] = restLangs if opt . Redirect && isNeedRedir { ctx . Redirect ( opt . SubURL + ctx . Req . RequestURI [ : strings . Index ( ctx . Req . RequestURI , "?" ) ] ) } } }
7135	func NewContentNegotiator ( defaultEncoder Encoder , responseWriter http . ResponseWriter ) * ContentNegotiator { result := & ContentNegotiator { } result . DefaultEncoder = defaultEncoder result . ResponseWriter = responseWriter return result }
2570	func NetworkInterfaceDiffOperation ( d * schema . ResourceDiff , c * govmomi . Client ) error { n := d . Get ( subresourceTypeNetworkInterface ) log . Printf ( "[DEBUG] NetworkInterfaceDiffOperation: Beginning diff validation" ) for ni , ne := range n . ( [ ] interface { } ) { nm := ne . ( map [ string ] interface { } ) r := NewNetworkInterfaceSubresource ( c , d , nm , nil , ni ) if err := r . ValidateDiff ( ) ; err != nil { return fmt . Errorf ( "%s: %s" , r . Addr ( ) , err ) } } log . Printf ( "[DEBUG] NetworkInterfaceDiffOperation: Diff validation complete" ) return nil }
5903	func Transport ( transport http . RoundTripper ) Option { return func ( tok * Bearer ) error { tok . transport = transport return nil } }
6373	func Any ( iterator Enumerable ) bool { done := make ( chan struct { } ) defer close ( done ) for range iterator . Enumerate ( done ) { return true } return false }
967	func NewCatalogNodeQuery ( s string ) ( * CatalogNodeQuery , error ) { if s != "" && ! CatalogNodeQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "catalog.node: invalid format: %q" , s ) } m := regexpMatch ( CatalogNodeQueryRe , s ) return & CatalogNodeQuery { dc : m [ "dc" ] , name : m [ "name" ] , stopCh : make ( chan struct { } , 1 ) , } , nil }
7312	func WaitPeerListening ( network , address string , timeout time . Duration ) bool { return WaitFunc ( 100 * time . Millisecond , timeout , func ( ) bool { c , err := net . Dial ( network , address ) if err == nil { c . Close ( ) return true } return false } ) }
242	func ( c * Client ) Write ( samples model . Samples ) error { reqs := make ( [ ] StoreSamplesRequest , 0 , len ( samples ) ) for _ , s := range samples { v := float64 ( s . Value ) if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { level . Debug ( c . logger ) . Log ( "msg" , "cannot send value to OpenTSDB, skipping sample" , "value" , v , "sample" , s ) continue } metric := TagValue ( s . Metric [ model . MetricNameLabel ] ) reqs = append ( reqs , StoreSamplesRequest { Metric : metric , Timestamp : s . Timestamp . Unix ( ) , Value : v , Tags : tagsFromMetric ( s . Metric ) , } ) } u , err := url . Parse ( c . url ) if err != nil { return err } u . Path = putEndpoint buf , err := json . Marshal ( reqs ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , c . timeout ) defer cancel ( ) req , err := http . NewRequest ( "POST" , u . String ( ) , bytes . NewBuffer ( buf ) ) if err != nil { return err } req . Header . Set ( "Content-Type" , contentTypeJSON ) resp , err := http . DefaultClient . Do ( req . WithContext ( ctx ) ) if err != nil { return err } defer func ( ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } ( ) if resp . StatusCode == http . StatusNoContent { return nil } buf , err = ioutil . ReadAll ( resp . Body ) if err != nil { return err } var r map [ string ] int if err := json . Unmarshal ( buf , & r ) ; err != nil { return err } return errors . Errorf ( "failed to write %d samples to OpenTSDB, %d succeeded" , r [ "failed" ] , r [ "success" ] ) }
2504	func ( q * commandQueue ) Flush ( ) { if q . err != nil { return } es := q . indices vs := q . vertices if recordLog ( ) { fmt . Println ( "--" ) } theGraphicsDriver . Begin ( ) for len ( q . commands ) > 0 { nv := 0 ne := 0 nc := 0 for _ , c := range q . commands { if c . NumIndices ( ) > graphics . IndicesNum { panic ( fmt . Sprintf ( "graphicscommand: c.NumIndices() must be <= graphics.IndicesNum but not at Flush: c.NumIndices(): %d, graphics.IndicesNum: %d" , c . NumIndices ( ) , graphics . IndicesNum ) ) } if ne + c . NumIndices ( ) > graphics . IndicesNum { break } nv += c . NumVertices ( ) ne += c . NumIndices ( ) nc ++ } if 0 < ne { theGraphicsDriver . SetVertices ( vs [ : nv ] , es [ : ne ] ) es = es [ ne : ] vs = vs [ nv : ] } indexOffset := 0 for _ , c := range q . commands [ : nc ] { if err := c . Exec ( indexOffset ) ; err != nil { q . err = err return } if recordLog ( ) { fmt . Printf ( "%s\n" , \n ) } c } indexOffset += c . NumIndices ( ) if 0 < nc { theGraphicsDriver . Flush ( ) } } q . commands = q . commands [ nc : ] theGraphicsDriver . End ( ) q . commands = nil q . nvertices = 0 q . nindices = 0 q . tmpNumIndices = 0 }
6321	func ( r * Request ) BodyData ( ) [ ] byte { var err error if ! r . bodyRead { if r . Body != nil { r . bodyData , err = ioutil . ReadAll ( r . Body ) if err != nil { neterr , isNetError := err . ( net . Error ) if isNetError && neterr . Timeout ( ) { panic ( ghttp . NewHttpError ( err , http . StatusRequestTimeout ) ) } else { panic ( err ) } } } r . bodyRead = true } return r . bodyData }
5450	func ( c * CallService ) Create ( ctx context . Context , data url . Values ) ( * Call , error ) { call := new ( Call ) err := c . client . CreateResource ( ctx , callsPathPart , data , call ) return call , err }
279	func lexLineComment ( l * lexer ) stateFn { l . pos += Pos ( len ( lineComment ) ) for r := l . next ( ) ; ! isEndOfLine ( r ) && r != eof ; { r = l . next ( ) } l . backup ( ) l . emit ( ItemComment ) return lexStatements }
3626	func ( t * TraceServiceDefinition ) GetShowBreakdownOk ( ) ( bool , bool ) { if t == nil || t . ShowBreakdown == nil { return false , false } return * t . ShowBreakdown , true }
4506	func Uniq ( ) Filter { return FilterFunc ( func ( arg Arg ) error { first := true last := "" for s := range arg . In { if first || last != s { arg . Out <- s } last = s first = false } return nil } ) }
4035	func PopAttributes ( ) { if len ( canvas . attrStack ) == 0 { return } a := canvas . attrStack [ len ( canvas . attrStack ) - 1 ] canvas . attrStack = canvas . attrStack [ : len ( canvas . attrStack ) - 1 ] SetTextColor ( a . text ) SetBackColor ( a . back ) }
4794	func ( g * gitCmd ) haltProcess ( ) { g . RLock ( ) monitoring := g . monitoring g . RUnlock ( ) if monitoring { g . haltChan <- struct { } { } } }
7079	func NewSendToLogger ( logger * golog . Logger ) LogBackend { if logger == nil { return & SendToLogger { Logger : golog . New ( os . Stderr , "" , golog . LstdFlags ) , } } return & SendToLogger { Logger : logger , } }
6726	func ( c * Client ) DatabaseSnapshot ( identifier string ) ( * DatabaseSnapshot , error ) { database_snapshot := new ( DatabaseSnapshot ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/database_snapshots/" + identifier , nil , database_snapshot ) if err != nil { return nil , err } return database_snapshot , err }
4844	func SchemeDriverAndAliases ( name string ) ( string , [ ] string ) { if scheme , ok := schemeMap [ name ] ; ok { driver := scheme . Driver if scheme . Override != "" { driver = scheme . Override } var aliases [ ] string for _ , alias := range scheme . Aliases { if alias == driver { continue } aliases = append ( aliases , alias ) } sort . Sort ( ss ( aliases ) ) return driver , aliases } return "" , nil }
359	func ( tg * Group ) UnmarshalJSON ( b [ ] byte ) error { g := struct { Targets [ ] string `json:"targets"` Labels model . LabelSet `json:"labels"` } { } dec := json . NewDecoder ( bytes . NewReader ( b ) ) dec . DisallowUnknownFields ( ) if err := dec . Decode ( & g ) ; err != nil { return err } tg . Targets = make ( [ ] model . LabelSet , 0 , len ( g . Targets ) ) for _ , t := range g . Targets { tg . Targets = append ( tg . Targets , model . LabelSet { model . AddressLabel : model . LabelValue ( t ) , } ) } tg . Labels = g . Labels return nil }
7086	func ( s * CORSHandler ) CreatePreflight ( routes Routes ) Routes { list := make ( Routes , 0 , len ( routes ) ) hList := make ( map [ string ] * CORSPreflight , len ( routes ) ) for _ , v := range routes { preflight , ok := hList [ v . Path ] if ! ok { preflight = & CORSPreflight { * s , make ( [ ] string , 0 , 1 ) , v . MustAuth , } hList [ v . Path ] = preflight } preflight . Methods = append ( preflight . Methods , v . Method ) if v . MustAuth { preflight . UseCredentials = true } } for k , v := range hList { list = append ( list , Route { Name : "" , Method : DEFAULT_CORS_PREFLIGHT_METHOD , Path : k , MustAuth : v . UseCredentials , ActionFunc : v . ServeHTTP , } ) } return list }
4083	func ClippedParent ( c Control ) Control { var clipped Control ctrl := c . Parent ( ) clipped = c for ctrl != nil { if ctrl . Clipped ( ) { clipped = ctrl break } ctrl = ctrl . Parent ( ) } return clipped }
4032	func ( e * EditField ) SetTitle ( title string ) { e . setTitleInternal ( title ) e . offset = 0 e . end ( ) }
2712	func ( w * virtualMachineCustomizationWaiter ) wait ( client * govmomi . Client , vm * object . VirtualMachine , timeout int ) error { if timeout < 1 { return nil } cbErr := make ( chan error , 1 ) cb := func ( obj types . ManagedObjectReference , page [ ] types . BaseEvent ) error { for _ , be := range page { switch e := be . ( type ) { case types . BaseCustomizationFailed : cbErr <- errors . New ( e . GetCustomizationFailed ( ) . GetEvent ( ) . FullFormattedMessage ) case * types . CustomizationSucceeded : close ( cbErr ) } } return nil } mgr := event . NewManager ( client . Client ) mgrErr := make ( chan error , 1 ) pctx , pcancel := context . WithCancel ( context . Background ( ) ) defer pcancel ( ) go func ( ) { mgrErr <- mgr . Events ( pctx , [ ] types . ManagedObjectReference { vm . Reference ( ) } , 10 , true , false , cb ) } ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Duration ( timeout ) * time . Minute ) defer cancel ( ) var err error select { case <- ctx . Done ( ) : if ctx . Err ( ) == context . DeadlineExceeded { err = fmt . Errorf ( "timeout waiting for customization to complete" ) } case err = <- mgrErr : case err = <- cbErr : } return err }
3625	func ( t * TraceServiceDefinition ) GetShowBreakdown ( ) bool { if t == nil || t . ShowBreakdown == nil { return false } return * t . ShowBreakdown }
873	func saveTenantID ( path string , tenantID string ) error { var perm os . FileMode = 0600 dir := filepath . Dir ( path ) if err := os . MkdirAll ( dir , os . ModePerm ) ; err != nil { return fmt . Errorf ( "Failed to create directory %s: %v" , dir , err ) } f , err := ioutil . TempFile ( dir , "tenantid" ) if err != nil { return fmt . Errorf ( "Failed to create temp file: %v" , err ) } defer f . Close ( ) fp := f . Name ( ) if _ , err := f . Write ( [ ] byte ( tenantID ) ) ; err != nil { return fmt . Errorf ( "Failed to write tenant ID to file: %v" , err ) } f . Close ( ) if err := os . Rename ( fp , path ) ; err != nil { return fmt . Errorf ( "Failed to rename file. src=%s dst=%s error=%v" , fp , path , err ) } if err := os . Chmod ( path , perm ) ; err != nil { return fmt . Errorf ( "Failed to chmod the file %s: %v" , path , err ) } return nil }
3914	func ( c * Checker ) processConversion ( pkg * lint . Pkg , node ast . Node ) { if node , ok := node . ( * ast . CallExpr ) ; ok { callTyp := pkg . TypesInfo . TypeOf ( node . Fun ) var typDst * types . Struct var ok bool switch typ := callTyp . ( type ) { case * types . Named : typDst , ok = typ . Underlying ( ) . ( * types . Struct ) case * types . Pointer : typDst , ok = typ . Elem ( ) . Underlying ( ) . ( * types . Struct ) default : return } if ! ok { return } if typ , ok := pkg . TypesInfo . TypeOf ( node . Args [ 0 ] ) . ( * types . Basic ) ; ok && typ . Kind ( ) == types . UnsafePointer { n := typDst . NumFields ( ) for i := 0 ; i < n ; i ++ { c . graph . markUsedBy ( typDst . Field ( i ) , typDst ) } return } typSrc , ok := dereferenceType ( pkg . TypesInfo . TypeOf ( node . Args [ 0 ] ) ) . Underlying ( ) . ( * types . Struct ) if ! ok { return } n := typDst . NumFields ( ) for i := 0 ; i < n ; i ++ { fDst := typDst . Field ( i ) fSrc := typSrc . Field ( i ) c . graph . markUsedBy ( fDst , fSrc ) c . graph . markUsedBy ( fSrc , fDst ) } } }
233	func ( m * Manager ) Run ( tsets <- chan map [ string ] [ ] * targetgroup . Group ) error { go m . reloader ( ) for { select { case ts := <- tsets : m . updateTsets ( ts ) select { case m . triggerReload <- struct { } { } : default : } case <- m . graceShut : return nil } } }
4885	func DecodeRune ( p [ ] byte ) ( rune , int ) { high , n1 , _ := decodeRune ( p ) if ! utf16 . IsSurrogate ( high ) { return high , n1 } low , n2 , _ := decodeRune ( p [ n1 : ] ) if low == utf8 . RuneError { return low , n1 + n2 } return utf16 . DecodeRune ( high , low ) , n1 + n2 }
4733	func StringMarshalJSON ( data interface { } , indent string ) string { buffer , err := json . MarshalIndent ( data , "" , indent ) if err != nil { return "" } return string ( buffer ) }
2706	func ( c * Config ) restoreVimClient ( client * vim25 . Client ) ( bool , error ) { if ! c . Persist { return false , nil } p , err := c . vimSessionFile ( ) if err != nil { return false , err } log . Printf ( "[DEBUG] Attempting to locate SOAP client session data in %q" , p ) f , err := os . Open ( p ) if err != nil { if os . IsNotExist ( err ) { log . Printf ( "[DEBUG] SOAP client session data not found in %q" , p ) return false , nil } return false , err } defer func ( ) { if err = f . Close ( ) ; err != nil { log . Printf ( "[DEBUG] Error closing SOAP client session file %q: %s" , p , err ) } } ( ) dec := json . NewDecoder ( f ) err = dec . Decode ( client ) if err != nil { return false , err } return true , nil }
6247	func Uint192ToBytes ( x * big . Int ) [ 24 ] byte { var ret [ 24 ] byte xBytes := x . Bytes ( ) for i , v := range xBytes { ret [ 24 - len ( xBytes ) + i ] = v } return ret }
666	func NewEndpointWithTTL ( dnsName , recordType string , ttl TTL , targets ... string ) * Endpoint { cleanTargets := make ( [ ] string , len ( targets ) ) for idx , target := range targets { cleanTargets [ idx ] = strings . TrimSuffix ( target , "." ) } return & Endpoint { DNSName : strings . TrimSuffix ( dnsName , "." ) , Targets : cleanTargets , RecordType : recordType , Labels : NewLabels ( ) , RecordTTL : ttl , } }
917	func ( d * Driver ) generateDiskImage ( ) ( string , error ) { diskImage := d . ResolveStorePath ( "disk.vhd" ) fixed := d . ResolveStorePath ( "fixed.vhd" ) isWindowsAdmin , err := isWindowsAdministrator ( ) if err != nil { return "" , err } fixedDiskSize := "10MB" if ! isWindowsAdmin { fixedDiskSize = toMb ( d . DiskSize ) } log . Infof ( "Creating VHD" ) if err := cmd ( "Hyper-V\\New-VHD" , \\ , "-Path" , quote ( fixed ) , "-SizeBytes" , fixedDiskSize ) ; "-Fixed" err != nil { return "" , err } tarBuf , err := mcnutils . MakeDiskImage ( d . publicSSHKeyPath ( ) ) if err != nil { return "" , err } file , err := os . OpenFile ( fixed , os . O_WRONLY , 0644 ) if err != nil { return "" , err } defer file . Close ( ) file . Seek ( 0 , os . SEEK_SET ) _ , err = file . Write ( tarBuf . Bytes ( ) ) if err != nil { return "" , err } file . Close ( ) if err := cmd ( "Hyper-V\\Convert-VHD" , \\ , "-Path" , quote ( fixed ) , "-DestinationPath" , quote ( diskImage ) , "-VHDType" , "Dynamic" ) ; "-DeleteSource" err != nil { return "" , err } }
6184	func ( h * Handler ) CreateTemplate ( tkn string , template * data . Template ) ( * string , error ) { logger := h . logger . Add ( "method" , "CreateTemplate" , "template" , template ) if ! h . token . Check ( tkn ) { logger . Warn ( "access denied" ) return nil , ErrAccessDenied } err := checkTemplate ( logger , template ) if err != nil { return nil , err } template . ID = util . NewUUID ( ) template . Hash = data . HexFromBytes ( crypto . Keccak256 ( template . Raw ) ) err = h . insertObject ( template ) if err != nil { return nil , err } return & template . ID , nil }
7206	func NewNewsItem ( itemdata NewsItem , author uuid . UUID ) ( * NewsItem , error ) { c := new ( NewsItem ) if err := mergo . MergeWithOverwrite ( c , itemdata ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not set initial NewsItem data" ) } c . UUID , _ = uuid . V4 ( ) c . Author = author c . Created = time . Now ( ) if err := storage . Store ( c ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not write NewsItem to storage" ) } eventqueue . Publish ( utils . CKPTEvent { Type : utils . NEWS_EVENT , Subject : "Nytt bidrag lagt ut" , Message : "Det er lagt ut et nytt bidrag på ckpt.no!"} } ) ) }
5289	func Format ( lines [ ] string , config * Config ) string { conf := MergeConfig ( DefaultConfig ( ) , config ) widths := widthsFromLines ( conf , lines ) glueSize := len ( conf . Glue ) var size int for _ , w := range widths { size += w + glueSize } size *= len ( lines ) buf := bytes . NewBuffer ( make ( [ ] byte , 0 , size ) ) fmtCache := make ( map [ int ] string , 16 ) for _ , line := range lines { elems := elementsFromLine ( conf , line ) numElems := len ( elems ) stringfmt , ok := fmtCache [ numElems ] if ! ok { stringfmt = stringFormat ( conf , widths , numElems ) fmtCache [ numElems ] = stringfmt } fmt . Fprintf ( buf , stringfmt , elems ... ) } result := buf . String ( ) if n := len ( result ) ; n > 0 && result [ n - 1 ] == '\n' { result = result [ : n - 1 ] } return result }
1784	func ( m * MockClientServer ) IsConnected ( ) bool { ret := m . ctrl . Call ( m , "IsConnected" ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 }
5395	func LockUser ( name string ) error { shadow , err := LookupShadow ( name ) if err != nil { return err } if shadow . password [ 0 ] != _LOCK_CHAR { shadow . password = string ( _LOCK_CHAR ) + shadow . password return edit ( name , shadow ) } return nil }
5372	func GetUsernameFromEnv ( ) string { user_env := [ ] string { "USER" , "USERNAME" , "LOGNAME" , "LNAME" } for _ , val := range user_env { name := os . Getenv ( val ) if name != "" { return name } } return "" }
4888	func SetOn ( on bool ) { tracer . mu . Lock ( ) tracer . on = on tracer . mu . Unlock ( ) }
1650	func ( m * MockTaskResource ) GetCreatedAt ( ) time . Time { ret := m . ctrl . Call ( m , "GetCreatedAt" ) ret0 , _ := ret [ 0 ] . ( time . Time ) return ret0 }
513	func ( h * ResponseHeader ) DelCookie ( key string ) { h . cookies = delAllArgs ( h . cookies , key ) }
618	func NewAWSProvider ( awsConfig AWSConfig ) ( * AWSProvider , error ) { config := aws . NewConfig ( ) . WithMaxRetries ( awsConfig . APIRetries ) config . WithHTTPClient ( instrumented_http . NewClient ( config . HTTPClient , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , "/" ) return parts [ len ( parts ) - 1 ] } , } ) , ) session , err := session . NewSessionWithOptions ( session . Options { Config : * config , SharedConfigState : session . SharedConfigEnable , } ) if err != nil { return nil , err } if awsConfig . AssumeRole != "" { log . Infof ( "Assuming role: %s" , awsConfig . AssumeRole ) session . Config . WithCredentials ( stscreds . NewCredentials ( session , awsConfig . AssumeRole ) ) } provider := & AWSProvider { client : route53 . New ( session ) , domainFilter : awsConfig . DomainFilter , zoneIDFilter : awsConfig . ZoneIDFilter , zoneTypeFilter : awsConfig . ZoneTypeFilter , zoneTagFilter : awsConfig . ZoneTagFilter , batchChangeSize : awsConfig . BatchChangeSize , batchChangeInterval : awsConfig . BatchChangeInterval , evaluateTargetHealth : awsConfig . EvaluateTargetHealth , dryRun : awsConfig . DryRun , } return provider , nil }
188	func ( r * AlertingRule ) ActiveAlerts ( ) [ ] * Alert { var res [ ] * Alert for _ , a := range r . currentAlerts ( ) { if a . ResolvedAt . IsZero ( ) { res = append ( res , a ) } } return res }
4597	func ( s * Stack ) merge ( r * Stack ) * Stack { out := & Stack { Calls : make ( [ ] Call , len ( s . Calls ) ) , Elided : s . Elided , } for i := range s . Calls { out . Calls [ i ] = s . Calls [ i ] . merge ( & r . Calls [ i ] ) } return out }
881	func ( d * SerialDriver ) GetSSHUsername ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHUsername ( ) }
3474	func ( r * reqComment ) GetCommentOk ( ) ( Comment , bool ) { if r == nil || r . Comment == nil { return Comment { } , false } return * r . Comment , true }
6682	func ErrNotFound ( id string ) error { return ErrorResponse { Code : http . StatusNotFound , Message : fmt . Sprintf ( "request %s not found" , id ) , } }
1132	func ( c * cache ) Delete ( k string ) { c . mu . Lock ( ) v , evicted := c . delete ( k ) c . mu . Unlock ( ) if evicted { c . onEvicted ( k , v ) } }
3845	func New ( items interface { } , size int ) ( * List , error ) { if size < 1 { return nil , fmt . Errorf ( "list size %d must be greater than 0" , size ) } if items == nil || reflect . TypeOf ( items ) . Kind ( ) != reflect . Slice { return nil , fmt . Errorf ( "items %v is not a slice" , items ) } slice := reflect . ValueOf ( items ) values := make ( [ ] * interface { } , slice . Len ( ) ) for i := range values { item := slice . Index ( i ) . Interface ( ) values [ i ] = & item } return & List { size : size , items : values , scope : values } , nil }
6298	func ( e * encoder ) nextSpecialChar ( p [ ] byte ) ( i int ) { for i = 0 ; i < len ( p ) ; i ++ { if ! ( ( p [ i ] >= 32 && p [ i ] <= 126 && p [ i ] != byte ( '=' ) ) || p [ i ] == byte ( '\t' ) ) { return i } } return i }
503	func ( h * RequestHeader ) SetMethodBytes ( method [ ] byte ) { h . method = append ( h . method [ : 0 ] , method ... ) }
2474	func NewInfiniteLoopWithIntro ( src ReadSeekCloser , introLength int64 , loopLength int64 ) * InfiniteLoop { return & InfiniteLoop { src : src , lstart : introLength , llength : loopLength , pos : - 1 , } }
3861	func ( c * Cursor ) Place ( position int ) { c . Position = position c . correctPosition ( ) }
6605	func NewClientWithDialer ( network , address string , dialer * net . Dialer ) * Client { return & Client { network : network , address : address , dialer : dialer , } }
5456	func ( cvps * CountryVoicePriceService ) Get ( ctx context . Context , isoCountry string ) ( * VoicePrice , error ) { voicePrice := new ( VoicePrice ) err := cvps . client . GetResource ( ctx , voicePathPart + "/Countries" , isoCountry , voicePrice ) return voicePrice , err }
3199	func ( client * Client ) GetDashboard ( id interface { } ) ( * Dashboard , error ) { stringId , err := GetStringId ( id ) if err != nil { return nil , err } var out reqGetDashboard if err := client . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/dash/%s" , stringId ) , nil , & out ) ; err != nil { return nil , err } return out . Dashboard , nil }
3446	func ( o * Options ) GetTimeoutH ( ) int { if o == nil || o . TimeoutH == nil { return 0 } return * o . TimeoutH }
5886	func Encode ( alg Algorithm , signer Signer , obj interface { } ) ( [ ] byte , error ) { var err error headerObj , payloadObj , err := encodeTargets ( alg , obj ) if err != nil { return nil , err } header , err := json . Marshal ( headerObj ) if err != nil { return nil , err } headerEnc := make ( [ ] byte , b64 . EncodedLen ( len ( header ) ) ) b64 . Encode ( headerEnc , header ) payload , err := json . Marshal ( payloadObj ) if err != nil { return nil , err } payloadEnc := make ( [ ] byte , b64 . EncodedLen ( len ( payload ) ) ) b64 . Encode ( payloadEnc , payload ) var buf bytes . Buffer _ , err = buf . Write ( headerEnc ) if err != nil { return nil , err } _ , err = buf . Write ( tokenSep ) if err != nil { return nil , err } _ , err = buf . Write ( payloadEnc ) if err != nil { return nil , err } sig , err := signer . Sign ( buf . Bytes ( ) ) if err != nil { return nil , err } _ , err = buf . Write ( tokenSep ) if err != nil { return nil , err } _ , err = buf . Write ( sig ) if err != nil { return nil , err } return buf . Bytes ( ) , nil }
5520	func NewPhoneNumberButton ( title string , phone string ) Button { return Button { Type : ButtonTypePhoneNumber , Title : title , Payload : phone , } }
1940	func ( m * MockTaskEngineState ) GetAllContainerIDs ( ) [ ] string { ret := m . ctrl . Call ( m , "GetAllContainerIDs" ) ret0 , _ := ret [ 0 ] . ( [ ] string ) return ret0 }
1870	func ( m * MockManager ) SetContainerInstanceARN ( arg0 string ) { m . ctrl . Call ( m , "SetContainerInstanceARN" , arg0 ) }
3206	func ( client * Client ) GetUser ( handle string ) ( user User , err error ) { var udata userData uri := "/v1/user/" + handle err = client . doJsonRequest ( "GET" , uri , nil , & udata ) user = udata . User return }
3604	func ( t * TimeRange ) GetLive ( ) bool { if t == nil || t . Live == nil { return false } return * t . Live }
4020	func RefreshScreen ( ) { comp . BeginUpdate ( ) term . Clear ( ColorWhite , ColorBlack ) comp . EndUpdate ( ) windows := comp . getWindowList ( ) for _ , wnd := range windows { v := wnd . ( * Window ) if v . Visible ( ) { wnd . Draw ( ) WindowManager ( ) . BeginUpdate ( ) PushAttributes ( ) term . Flush ( ) PopAttributes ( ) WindowManager ( ) . EndUpdate ( ) } } comp . BeginUpdate ( ) term . Flush ( ) comp . EndUpdate ( ) }
3767	func ( k APIKey ) MarshalJSON ( ) ( [ ] byte , error ) { type Alias APIKey return json . Marshal ( & struct { Created * string `json:"created,omitempty"` * Alias } { Created : String ( k . Created . Format ( createdTimeLayout ) ) , Alias : ( * Alias ) ( & k ) , } ) }
4284	func InitLabels ( options [ ] string ) ( string , string , error ) { if ! selinux . SelinuxEnabled ( ) { return "" , "" , nil } processLabel , mountLabel := selinux . GetLxcContexts ( ) if processLabel != "" { pcon := selinux . NewContext ( processLabel ) mcon := selinux . NewContext ( mountLabel ) for _ , opt := range options { if opt == "disable" { return "" , "" , nil } if i := strings . Index ( opt , ":" ) ; i == - 1 { return "" , "" , fmt . Errorf ( "Bad SELinux Option" ) } con := strings . SplitN ( opt , ":" , 2 ) pcon [ con [ 0 ] ] = con [ 1 ] if con [ 0 ] == "level" || con [ 0 ] == "user" { mcon [ con [ 0 ] ] = con [ 1 ] } } processLabel = pcon . Get ( ) mountLabel = mcon . Get ( ) } return processLabel , mountLabel , nil }
1440	func ( state * DockerTaskEngineState ) TaskByArn ( arn string ) ( * apitask . Task , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . taskByArn ( arn ) }
29	func ( h * Handler ) ApplyConfig ( conf * config . Config ) error { h . mtx . Lock ( ) defer h . mtx . Unlock ( ) h . config = conf return nil }
5729	func OnClosedContext ( p goprocess . Process ) context . Context { return & procContext { done : p . Closed ( ) , which : closed , } }
3965	func NewClient ( address , path string , eventBus Bus ) * Client { client := new ( Client ) client . eventBus = eventBus client . address = address client . path = path client . service = & ClientService { client , & sync . WaitGroup { } , false } return client }
4508	func Reverse ( ) Filter { return FilterFunc ( func ( arg Arg ) error { var data [ ] string for s := range arg . In { data = append ( data , s ) } for i := len ( data ) - 1 ; i >= 0 ; i -- { arg . Out <- data [ i ] } return nil } ) }
5099	func NewObjectIdWithTime ( t time . Time ) ObjectId { var b [ 12 ] byte binary . BigEndian . PutUint32 ( b [ : 4 ] , uint32 ( t . Unix ( ) ) ) return ObjectId ( string ( b [ : ] ) ) }
1182	func ( m * MockContainerMetadataResolver ) ResolveTask ( arg0 string ) ( * task . Task , error ) { ret := m . ctrl . Call ( m , "ResolveTask" , arg0 ) ret0 , _ := ret [ 0 ] . ( * task . Task ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
86	func ( c * compressedResponseWriter ) Close ( ) { if zlibWriter , ok := c . writer . ( * zlib . Writer ) ; ok { zlibWriter . Flush ( ) } if gzipWriter , ok := c . writer . ( * gzip . Writer ) ; ok { gzipWriter . Flush ( ) } if closer , ok := c . writer . ( io . Closer ) ; ok { defer closer . Close ( ) } }
7019	func ConvertErrorStatus ( status int , err error ) error { return & errStatus { error : err , status : status , } }
3381	func ( i * integrationPD ) GetAPITokenOk ( ) ( string , bool ) { if i == nil || i . APIToken == nil { return "" , false } return * i . APIToken , true }
3739	func ( w * WidgetApmOrLogQuery ) GetSearch ( ) ApmOrLogQuerySearch { if w == nil || w . Search == nil { return ApmOrLogQuerySearch { } } return * w . Search }
138	func ( p * problems ) Add ( mf dto . MetricFamily , text string ) { * p = append ( * p , Problem { Metric : mf . GetName ( ) , Text : text , } ) }
6203	func IsTLSCert ( block string ) bool { var cert tls . Certificate pemBlock := [ ] byte ( block ) for { var derBlock * pem . Block derBlock , pemBlock = pem . Decode ( pemBlock ) if derBlock == nil { break } if derBlock . Type == certificate { cert . Certificate = append ( cert . Certificate , derBlock . Bytes ) } } if len ( cert . Certificate ) == 0 { return false } return true }
3504	func ( s * Series ) GetUnits ( ) UnitPair { if s == nil || s . Units == nil { return UnitPair { } } return * s . Units }
208	func ( m * Manager ) Rules ( ) [ ] Rule { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) var rules [ ] Rule for _ , g := range m . groups { rules = append ( rules , g . rules ... ) } return rules }
7279	func NewImage ( d * Docker , name string ) * Image { return & Image { docker : d , name : name , } }
2422	func ( p * Path ) Draw ( target * ebiten . Image , op * DrawPathOptions ) { if op == nil { return } if op . StrokeColor != nil { vs , is := p . strokeVertices ( op . LineWidth , op . StrokeColor ) op := & ebiten . DrawTrianglesOptions { } op . Address = ebiten . AddressRepeat target . DrawTriangles ( vs , is , emptyImage , op ) } }
4266	func ( w * whitelist ) drop ( ) error { w . pid . Clear ( allCapabilityTypes ) w . pid . Set ( allCapabilityTypes , w . keep ... ) return w . pid . Apply ( allCapabilityTypes ) }
245	func ExternalLabelsHandler ( next storage . Queryable , externalLabels labels . Labels ) storage . Queryable { return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { q , err := next . Querier ( ctx , mint , maxt ) if err != nil { return nil , err } return & externalLabelsQuerier { Querier : q , externalLabels : externalLabels } , nil } ) }
6525	func ( c Client ) GetSellPrice ( qty int ) ( * pricesHolder , error ) { return c . getPrice ( "sell" , qty ) }
3731	func ( w * Widget ) GetURLOk ( ) ( string , bool ) { if w == nil || w . URL == nil { return "" , false } return * w . URL , true }
3564	func ( t * TemplateVariable ) HasDefault ( ) bool { if t != nil && t . Default != nil { return true } return false }
6097	func ReadSetting ( db * reform . Querier , key string ) ( string , error ) { var st Setting if err := FindByPrimaryKeyTo ( db , & st , key ) ; err != nil { return "" , fmt . Errorf ( "failed to find '%s' setting: %s" , key , err ) } return st . Value , nil }
1532	func acsWsURL ( endpoint , cluster , containerInstanceArn string , taskEngine engine . TaskEngine , acsSessionState sessionState ) string { acsURL := endpoint if endpoint [ len ( endpoint ) - 1 ] != '/' { acsURL += "/" } acsURL += "ws" query := url . Values { } query . Set ( "clusterArn" , cluster ) query . Set ( "containerInstanceArn" , containerInstanceArn ) query . Set ( "agentHash" , version . GitHashString ( ) ) query . Set ( "agentVersion" , version . Version ) query . Set ( "seqNum" , "1" ) if dockerVersion , err := taskEngine . Version ( ) ; err == nil { query . Set ( "dockerVersion" , "DockerVersion: " + dockerVersion ) } query . Set ( sendCredentialsURLParameterName , acsSessionState . getSendCredentialsURLParameter ( ) ) return acsURL + "?" + query . Encode ( ) }
6176	func ( m * Monitor ) VerifySuspendedChannelsAndTryToUnsuspend ( ) error { query := ` SELECT channels.id :: text FROM channels LEFT JOIN sessions ses ON channels.id = ses.channel LEFT JOIN offerings offer ON channels.offering = offer.id INNER JOIN accounts acc ON channels.agent = acc.eth_addr WHERE channels.service_status IN ('suspended') AND channels.channel_status NOT IN ('pending') AND acc.in_use GROUP BY channels.id, offer.billing_interval, offer.setup_price, offer.unit_price, offer.max_billing_unit_lag HAVING COALESCE(SUM(ses.units_used), 0) / offer.billing_interval - (channels.receipt_balance - offer.setup_price) / offer.unit_price <= offer.max_billing_unit_lag;` return m . processEachChannel ( query , m . unsuspendService ) }
7046	func ( r * MockReadWriteCloser ) Read ( p [ ] byte ) ( n int , err error ) { if err = r . ReadErr ; err == nil { r . BytesRead = p n = len ( p ) } return }
7224	func ( logger * Logger ) Alertf ( format string , a ... interface { } ) { logger . log ( ALERT , format , a ... ) }
2296	func ( v * ToolButton ) native ( ) * C . GtkToolButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToolButton ( p ) }
4740	func StringMap ( f func ( string ) string , data [ ] string ) [ ] string { size := len ( data ) result := make ( [ ] string , size , size ) for i := 0 ; i < size ; i ++ { result [ i ] = f ( data [ i ] ) } return result }
1406	func ( m * MockECSSDK ) ListTagsForResource ( arg0 * ecs . ListTagsForResourceInput ) ( * ecs . ListTagsForResourceOutput , error ) { ret := m . ctrl . Call ( m , "ListTagsForResource" , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . ListTagsForResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1871	func ( m * MockManager ) SetHostPublicIPv4Address ( arg0 string ) { m . ctrl . Call ( m , "SetHostPublicIPv4Address" , arg0 ) }
5353	func SetForUid ( id int , key , value string ) error { _settings , err := getSettingsForUid ( id ) if err != nil { return err } if err = _Set ( _settings . user , key , value ) ; err != nil { return err } if _settings . useKDE { return _Set ( _settings . kde , key , value ) } return nil }
1157	func ( c * ec2MetadataClientImpl ) VPCID ( mac string ) ( string , error ) { return c . client . GetMetadata ( fmt . Sprintf ( VPCIDResourceFormat , mac ) ) }
172	func NewFanout ( logger log . Logger , primary Storage , secondaries ... Storage ) Storage { return & fanout { logger : logger , primary : primary , secondaries : secondaries , } }
2851	func QueryDiskType ( client * govmomi . Client , name string , dc * object . Datacenter ) ( types . VirtualDiskType , error ) { vdm := object . NewVirtualDiskManager ( client . Client ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) di , err := vdm . QueryVirtualDiskInfo ( ctx , name , dc , false ) if err != nil { return types . VirtualDiskType ( "" ) , err } t := di [ 0 ] . DiskType log . Printf ( "[DEBUG] QueryDiskType: Disk %q is of type %q" , name , t ) return types . VirtualDiskType ( t ) , nil }
2550	func ExpandCustomizationSpec ( d * schema . ResourceData , family string ) types . CustomizationSpec { obj := types . CustomizationSpec { Identity : expandBaseCustomizationIdentitySettings ( d , family ) , GlobalIPSettings : expandCustomizationGlobalIPSettings ( d ) , NicSettingMap : expandSliceOfCustomizationAdapterMapping ( d ) , } return obj }
3978	func ( server * Server ) HasClientSubscribed ( arg * SubscribeArg ) bool { if topicSubscribers , ok := server . subscribers [ arg . Topic ] ; ok { for _ , topicSubscriber := range topicSubscribers { if * topicSubscriber == * arg { return true } } } return false }
6144	func ( b * backendInstance ) PTCAddress ( ) common . Address { return common . HexToAddress ( b . cfg . Contract . PTCAddrHex ) }
3675	func ( w * Widget ) HasLegend ( ) bool { if w != nil && w . Legend != nil { return true } return false }
4013	func ( d * FileSelectDialog ) populateFiles ( ) error { d . listBox . Clear ( ) isRoot := filepath . Dir ( d . currPath ) == d . currPath if ! isRoot { d . listBox . AddItem ( ".." ) } f , err := os . Open ( d . currPath ) if err != nil { return err } finfos , err := f . Readdir ( 0 ) f . Close ( ) if err != nil { return err } fnLess := func ( i , j int ) bool { if finfos [ i ] . IsDir ( ) && ! finfos [ j ] . IsDir ( ) { return true } else if ! finfos [ i ] . IsDir ( ) && finfos [ j ] . IsDir ( ) { return false } return strings . ToLower ( finfos [ i ] . Name ( ) ) < strings . ToLower ( finfos [ j ] . Name ( ) ) } sort . Slice ( finfos , fnLess ) for _ , finfo := range finfos { if ! d . fileFitsMask ( finfo ) { continue } if finfo . IsDir ( ) { d . listBox . AddItem ( finfo . Name ( ) + string ( os . PathSeparator ) ) } else { d . listBox . AddItem ( finfo . Name ( ) ) } } return nil }
5427	func ( g * Group ) Send ( val interface { } ) { g . in <- Message { sender : nil , payload : val } }
2432	func newScreenFramebuffer ( context * context , width , height int ) * framebuffer { return & framebuffer { native : context . getScreenFramebuffer ( ) , width : width , height : height , } }
5690	func ( st * state ) setTemplate ( a AST , tmpl * Template ) { var seen [ ] AST a . Traverse ( func ( a AST ) bool { switch a := a . ( type ) { case * TemplateParam : if a . Template != nil { if tmpl != nil { st . fail ( "duplicate template parameters" ) } return false } if tmpl == nil { st . fail ( "cast template parameter not in scope of template" ) } if a . Index >= len ( tmpl . Args ) { st . fail ( fmt . Sprintf ( "cast template index out of range (%d >= %d)" , a . Index , len ( tmpl . Args ) ) ) } a . Template = tmpl return false default : for _ , v := range seen { if v == a { return false } } seen = append ( seen , a ) return true } } ) }
4101	func ( c * Radio ) OnChange ( fn func ( bool ) ) { c . mtx . Lock ( ) defer c . mtx . Unlock ( ) c . onChange = fn }
1288	func ( cgroup * CgroupResource ) UnmarshalJSON ( b [ ] byte ) error { temp := cgroupResourceJSON { } if err := json . Unmarshal ( b , & temp ) ; err != nil { return err } cgroup . cgroupRoot = temp . CgroupRoot cgroup . cgroupMountPath = temp . CgroupMountPath cgroup . resourceSpec = temp . LinuxSpec if temp . DesiredStatus != nil { cgroup . SetDesiredStatus ( resourcestatus . ResourceStatus ( * temp . DesiredStatus ) ) } if temp . KnownStatus != nil { cgroup . SetKnownStatus ( resourcestatus . ResourceStatus ( * temp . KnownStatus ) ) } return nil }
3138	func ( c * Cache ) GetShard ( key string ) * Shard { return c . data [ uint ( fnv32 ( key ) ) % uint ( shardCount ) ] }
5996	func ( ds * DNSServer ) DeleteA ( host string ) { ds . aMutex . Lock ( ) delete ( ds . aRecords , ds . qualifyHost ( host ) ) ds . aMutex . Unlock ( ) }
2235	func ( v * Clipboard ) WaitIsTargetAvailable ( target gdk . Atom ) bool { c := C . gtk_clipboard_wait_is_target_available ( v . native ( ) , C . GdkAtom ( unsafe . Pointer ( target ) ) ) return gobool ( c ) }
6503	func OAuthClient ( tokens * oauthTokens ) Client { c := Client { rpc : rpc { auth : clientOAuth ( tokens ) , mock : false , } , } return c }
2363	func GetError ( ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetError , 0 , 0 , 0 , 0 ) return ( uint32 ) ( ret ) }
4011	func ( c * Client ) Query ( ctx context . Context , q interface { } , variables map [ string ] interface { } ) error { return c . client . Query ( ctx , q , variables ) }
3763	func ( client * Client ) CreateDowntime ( downtime * Downtime ) ( * Downtime , error ) { var out Downtime if err := client . doJsonRequest ( "POST" , "/v1/downtime" , downtime , & out ) ; err != nil { return nil , err } return & out , nil }
4018	func ( d * dbCache ) preload ( firstRow , rowCount int ) { if firstRow == d . firstRow && rowCount == d . rowCount { return } fNames := [ ] string { "Jack" , "Alisa" , "Richard" , "Paul" , "Nicole" , "Steven" , "Jane" } lNames := [ ] string { "Smith" , "Catcher" , "Stone" , "White" , "Black" } posts := [ ] string { "Engineer" , "Manager" , "Janitor" , "Driver" } deps := [ ] string { "IT" , "Financial" , "Support" } salary := [ ] int { 40000 , 38000 , 41000 , 32000 } d . data = make ( [ ] [ ] string , rowCount , rowCount ) for i := 0 ; i < rowCount ; i ++ { absIndex := firstRow + i d . data [ i ] = make ( [ ] string , columnInTable , columnInTable ) d . data [ i ] [ 0 ] = fNames [ absIndex % len ( fNames ) ] d . data [ i ] [ 1 ] = lNames [ absIndex % len ( lNames ) ] d . data [ i ] [ 2 ] = fmt . Sprintf ( "%08d" , 100 + absIndex ) d . data [ i ] [ 3 ] = posts [ absIndex % len ( posts ) ] d . data [ i ] [ 4 ] = deps [ absIndex % len ( deps ) ] d . data [ i ] [ 5 ] = fmt . Sprintf ( "%d k/year" , salary [ absIndex % len ( salary ) ] / 1000 ) } d . firstRow = firstRow d . rowCount = rowCount }
6134	func ( b * backendInstance ) PSCBalanceOf ( opts * bind . CallOpts , owner common . Address ) ( uint64 , error ) { ctx2 , cancel := b . addTimeout ( opts . Context ) defer cancel ( ) opts . Context = ctx2 val , err := b . psc . BalanceOf ( opts , owner ) if err != nil { err = fmt . Errorf ( "failed to get PSC balance: %s" , err ) } return val , err }
5157	func ( s * SegmentStack ) Peek ( ) int64 { if s . Len ( ) == 0 { return rootSegment } return s . s [ s . Len ( ) - 1 ] }
1255	func copyTaskMetrics ( from [ ] * ecstcs . TaskMetric ) [ ] * ecstcs . TaskMetric { to := make ( [ ] * ecstcs . TaskMetric , len ( from ) ) copy ( to , from ) return to }
169	func ParseFile ( file string ) ( * RuleGroups , [ ] error ) { b , err := ioutil . ReadFile ( file ) if err != nil { return nil , [ ] error { err } } return Parse ( b ) }
3680	func ( w * Widget ) GetManageStatusTitleAlignOk ( ) ( string , bool ) { if w == nil || w . ManageStatusTitleAlign == nil { return "" , false } return * w . ManageStatusTitleAlign , true }
5693	func ( st * state ) cloneSuffix ( a AST ) AST { i := 0 if len ( st . str ) > 1 && st . str [ 0 ] == '.' && ( isLower ( st . str [ 1 ] ) || st . str [ 1 ] == '_' ) { i += 2 for len ( st . str ) > i && ( isLower ( st . str [ i ] ) || st . str [ i ] == '_' ) { i ++ } } for len ( st . str ) > i + 1 && st . str [ i ] == '.' && isDigit ( st . str [ i + 1 ] ) { i += 2 for len ( st . str ) > i && isDigit ( st . str [ i ] ) { i ++ } } suffix := st . str [ : i ] st . advance ( i ) return & Clone { Base : a , Suffix : suffix } }
6520	func ( c Client ) GetExchangeRate ( from string , to string ) ( float64 , error ) { exchanges , err := c . GetExchangeRates ( ) if err != nil { return 0.0 , err } key := from + "_to_" + to if exchanges [ key ] == "" { return 0.0 , errors . New ( "The exchange rate does not exist for this currency pair" ) } exchangeFloat , err := strconv . ParseFloat ( exchanges [ key ] , 64 ) if err != nil { return 0.0 , err } return exchangeFloat , nil }
4485	func ( d * Date ) Scan ( raw interface { } ) error { switch v := raw . ( type ) { case [ ] byte : return d . UnmarshalText ( v ) case string : return d . UnmarshalText ( [ ] byte ( v ) ) case time . Time : * d = Date ( v ) return nil case nil : * d = Date { } return nil default : return fmt . Errorf ( "cannot sql.Scan() strfmt.Date from: %#v" , v ) } }
921	func ( d * BaseDriver ) GetSSHUsername ( ) string { if d . SSHUser == "" { d . SSHUser = DefaultSSHUser } return d . SSHUser }
4421	func ( u IPv6 ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
1586	func ( m * MockSecretsManagerAPI ) GetRandomPassword ( arg0 * secretsmanager . GetRandomPasswordInput ) ( * secretsmanager . GetRandomPasswordOutput , error ) { ret := m . ctrl . Call ( m , "GetRandomPassword" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetRandomPasswordOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
3294	func ( d * Downtime ) HasRecurrence ( ) bool { if d != nil && d . Recurrence != nil { return true } return false }
6593	func ( q * Query ) Filter ( rule string ) * Query { q . headers = append ( q . headers , "Filter: " + rule ) return q }
3882	func findDuplicate ( blocks [ ] * BasicBlock ) * BasicBlock { if len ( blocks ) < 2 { return nil } if blocks [ 0 ] == blocks [ 1 ] { return blocks [ 0 ] } m := make ( map [ * BasicBlock ] bool ) for _ , b := range blocks { if m [ b ] { return b } m [ b ] = true } return nil }
962	func NewView ( i * NewViewInput ) ( * View , error ) { return & View { dependency : i . Dependency , clients : i . Clients , maxStale : i . MaxStale , once : i . Once , retryFunc : i . RetryFunc , stopCh : make ( chan struct { } , 1 ) , vaultGrace : i . VaultGrace , } , nil }
6606	func ( c * Client ) Exec ( r Request ) ( * Response , error ) { var err error if c . conn == nil { c . conn , err = c . dialer . Dial ( c . network , c . address ) if err != nil { return nil , err } if r . keepAlive ( ) { switch c . network { case "tcp" : c . conn . ( * net . TCPConn ) . SetKeepAlive ( true ) } } else { defer c . Close ( ) } } return r . handle ( c . conn ) }
1899	func ( engine * DockerTaskEngine ) handleDockerEvents ( ctx context . Context ) { for { select { case <- ctx . Done ( ) : return case event := <- engine . events : engine . handleDockerEvent ( event ) } } }
1549	func ( m * MockCgroup ) Processes ( arg0 cgroups . Name , arg1 bool ) ( [ ] cgroups . Process , error ) { ret := m . ctrl . Call ( m , "Processes" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( [ ] cgroups . Process ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
5299	func ( r * Regexp ) Revert ( values url . Values ) ( string , error ) { vars := make ( [ ] interface { } , len ( r . groups ) ) for k , v := range r . groups { if len ( values [ v ] ) == 0 { return "" , fmt . Errorf ( "Missing key %q to revert the regexp " + "(expected a total of %d variables)" , v , len ( r . groups ) ) } vars [ k ] = values [ v ] [ 0 ] values [ v ] = values [ v ] [ 1 : ] } return fmt . Sprintf ( r . template , vars ... ) , nil }
688	func ( p * dnsimpleProvider ) Zones ( ) ( map [ string ] dnsimple . Zone , error ) { zones := make ( map [ string ] dnsimple . Zone ) page := 1 listOptions := & dnsimple . ZoneListOptions { } for { listOptions . Page = page zonesResponse , err := p . client . ListZones ( p . accountID , listOptions ) if err != nil { return nil , err } for _ , zone := range zonesResponse . Data { if ! p . domainFilter . Match ( zone . Name ) { continue } if ! p . zoneIDFilter . Match ( strconv . Itoa ( zone . ID ) ) { continue } zones [ strconv . Itoa ( zone . ID ) ] = zone } page ++ if page > zonesResponse . Pagination . TotalPages { break } } return zones , nil }
698	func ( p * dnsimpleProvider ) ApplyChanges ( changes * plan . Changes ) error { combinedChanges := make ( [ ] * dnsimpleChange , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , newDnsimpleChanges ( dnsimpleCreate , changes . Create ) ... ) combinedChanges = append ( combinedChanges , newDnsimpleChanges ( dnsimpleUpdate , changes . UpdateNew ) ... ) combinedChanges = append ( combinedChanges , newDnsimpleChanges ( dnsimpleDelete , changes . Delete ) ... ) return p . submitChanges ( combinedChanges ) }
7090	func ( handler * SyslogHandler ) Handle ( record * Record ) error { if handler . writter == nil { writter , err := syslog . Dial ( handler . Network , handler . Address , handler . Facility | handler . Severity , handler . Tag , ) if err != nil { return err } handler . writter = writter } msg := handler . Formatter . Format ( record ) switch record . Level { case EMERGENCY : return handler . writter . Emerg ( msg ) case ALERT : return handler . writter . Alert ( msg ) case CRITICAL : return handler . writter . Crit ( msg ) case ERROR : return handler . writter . Err ( msg ) case WARNING : return handler . writter . Warning ( msg ) case NOTICE : return handler . writter . Notice ( msg ) case INFO : return handler . writter . Info ( msg ) default : return handler . writter . Debug ( msg ) } }
4478	func ( d * Duration ) UnmarshalJSON ( data [ ] byte ) error { l := jlexer . Lexer { Data : data } d . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
17	func scalarBinop ( op ItemType , lhs , rhs float64 ) float64 { switch op { case ItemADD : return lhs + rhs case ItemSUB : return lhs - rhs case ItemMUL : return lhs * rhs case ItemDIV : return lhs / rhs case ItemPOW : return math . Pow ( lhs , rhs ) case ItemMOD : return math . Mod ( lhs , rhs ) case ItemEQL : return btos ( lhs == rhs ) case ItemNEQ : return btos ( lhs != rhs ) case ItemGTR : return btos ( lhs > rhs ) case ItemLSS : return btos ( lhs < rhs ) case ItemGTE : return btos ( lhs >= rhs ) case ItemLTE : return btos ( lhs <= rhs ) } panic ( errors . Errorf ( "operator %q not allowed for Scalar operations" , op ) ) }
1679	func ( auth * ASMAuthResource ) MarshalJSON ( ) ( [ ] byte , error ) { if auth == nil { return nil , errors . New ( "asm-auth resource is nil" ) } createdAt := auth . GetCreatedAt ( ) return json . Marshal ( asmAuthResourceJSON { TaskARN : auth . taskARN , CreatedAt : & createdAt , DesiredStatus : func ( ) * ASMAuthStatus { desiredState := auth . GetDesiredStatus ( ) status := ASMAuthStatus ( desiredState ) return & status } ( ) , KnownStatus : func ( ) * ASMAuthStatus { knownState := auth . GetKnownStatus ( ) status := ASMAuthStatus ( knownState ) return & status } ( ) , RequiredASMResources : auth . GetRequiredASMResources ( ) , ExecutionCredentialsID : auth . GetExecutionCredentialsID ( ) , } ) }
5043	func IsDup ( err error ) bool { switch e := err . ( type ) { case * LastError : return e . Code == 11000 || e . Code == 11001 || e . Code == 12582 || e . Code == 16460 && strings . Contains ( e . Err , " E11000 " ) case * QueryError : return e . Code == 11000 || e . Code == 11001 || e . Code == 12582 } return false }
1086	func ValidateLevelFilter ( min logutils . LogLevel , filter * logutils . LevelFilter ) bool { for _ , level := range filter . Levels { if level == min { return true } } return false }
2030	func ( task * Task ) buildLinuxMemorySpec ( ) ( specs . LinuxMemory , error ) { for _ , container := range task . Containers { containerMemoryLimit := int64 ( container . Memory ) if containerMemoryLimit > task . Memory { return specs . LinuxMemory { } , errors . Errorf ( "task memory spec builder: container memory limit(%d) greater than task memory limit(%d)" , containerMemoryLimit , task . Memory ) } } memoryBytes := task . Memory * bytesPerMegabyte return specs . LinuxMemory { Limit : & memoryBytes , } , nil }
4215	func ( j * JWKClient ) GetKey ( ID string ) ( jose . JSONWebKey , error ) { j . mu . Lock ( ) defer j . mu . Unlock ( ) searchedKey , err := j . keyCacher . Get ( ID ) if err != nil { keys , err := j . downloadKeys ( ) if err != nil { return jose . JSONWebKey { } , err } addedKey , err := j . keyCacher . Add ( ID , keys ) if err != nil { return jose . JSONWebKey { } , err } return * addedKey , nil } return * searchedKey , nil }
1430	func ( state * DockerTaskEngineState ) AllImageStates ( ) [ ] * image . ImageState { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . allImageStatesUnsafe ( ) }
4439	func ( u ISBN10 ) MarshalEasyJSON ( w * jwriter . Writer ) { w . String ( string ( u ) ) }
3296	func ( d * Downtime ) GetTimezoneOk ( ) ( string , bool ) { if d == nil || d . Timezone == nil { return "" , false } return * d . Timezone , true }
1367	func ( handler * TaskHandler ) AddStateChangeEvent ( change statechange . Event , client api . ECSClient ) error { handler . lock . Lock ( ) defer handler . lock . Unlock ( ) switch change . GetEventType ( ) { case statechange . TaskEvent : event , ok := change . ( api . TaskStateChange ) if ! ok { return errors . New ( "eventhandler: unable to get task event from state change event" ) } handler . flushBatchUnsafe ( & event , client ) return nil case statechange . ContainerEvent : event , ok := change . ( api . ContainerStateChange ) if ! ok { return errors . New ( "eventhandler: unable to get container event from state change event" ) } handler . batchContainerEventUnsafe ( event ) return nil default : return errors . New ( "eventhandler: unable to determine event type from state change event" ) } }
1968	func ( m * MockResult ) Print ( ) error { ret := m . ctrl . Call ( m , "Print" ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
5850	func ( m * CirconusMetrics ) IncrementByValue ( metric string , val uint64 ) { m . Add ( metric , val ) }
782	func ( in ProviderSpecific ) DeepCopy ( ) ProviderSpecific { if in == nil { return nil } out := new ( ProviderSpecific ) in . DeepCopyInto ( out ) return * out }
2590	func MoveToFolder ( client * govmomi . Client , vm * object . VirtualMachine , relative string ) error { log . Printf ( "[DEBUG] Moving virtual %q to VM path %q" , vm . InventoryPath , relative ) f , err := folder . VirtualMachineFolderFromObject ( client , vm , relative ) if err != nil { return err } return folder . MoveObjectTo ( vm . Reference ( ) , f ) }
381	func ( a * Args ) PeekBytes ( key [ ] byte ) [ ] byte { return peekArgBytes ( a . args , key ) }
2768	func flattenVirtualMachineResourceAllocation ( d * schema . ResourceData , obj * types . ResourceAllocationInfo , key string ) error { shareLevelKey := fmt . Sprintf ( "%s_share_level" , key ) shareCountKey := fmt . Sprintf ( "%s_share_count" , key ) limitKey := fmt . Sprintf ( "%s_limit" , key ) reservationKey := fmt . Sprintf ( "%s_reservation" , key ) structure . SetInt64Ptr ( d , limitKey , obj . Limit ) structure . SetInt64Ptr ( d , reservationKey , obj . Reservation ) if obj . Shares != nil { d . Set ( shareLevelKey , obj . Shares . Level ) d . Set ( shareCountKey , obj . Shares . Shares ) } return nil }
5354	func MSetForUid ( id int , keys , values [ ] string ) error { _settings , err := getSettingsForUid ( id ) if err != nil { return err } if err = _MSet ( _settings . user , keys , values ) ; err != nil { return err } if _settings . useKDE { return _MSet ( _settings . kde , keys , values ) } return nil }
1755	func ( task * Task ) GetExecutionStoppedAt ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ExecutionStoppedAtUnsafe }
7101	func ( g GRPCLoggerV2 ) Errorf ( format string , args ... interface { } ) { g . l . Errorf ( format , args ... ) }
6535	func ( c * singleConn ) Close ( ) error { c . eventMu . Lock ( ) if c . event != nil { evt := c . event c . event = nil defer evt . Close ( ) } c . eventMu . Unlock ( ) return c . maconn . Close ( ) }
3802	func ( h * HandlerWithErrorConfigurer ) Handle ( ctx context . Context , conn * Conn , req * Request ) { result , err := h . handleFunc ( ctx , conn , req ) if req . Notif { if err != nil { log . Printf ( "jsonrpc2 handler: notification %q handling error: %s" , req . Method , err ) } return } resp := & Response { ID : req . ID } if err == nil { err = resp . SetResult ( result ) } if err != nil { if e , ok := err . ( * Error ) ; ok { resp . Error = e } else { resp . Error = & Error { Message : err . Error ( ) } } } if ! req . Notif { if err := conn . SendResponse ( ctx , resp ) ; err != nil { if err != ErrClosed || ! h . suppressErrClosed { log . Printf ( "jsonrpc2 handler: sending response %s: %s" , resp . ID , err ) } } } }
1751	func ( task * Task ) GetPullStartedAt ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . PullStartedAtUnsafe }
6225	func ( w * Worker ) ClientAfterOfferingMsgBCPublish ( job * data . Job ) error { logger := w . logger . Add ( "method" , "ClientAfterOfferingMsgBCPublish" , "job" , job ) ethLog , err := w . ethLog ( logger , job ) if err != nil { return err } logOfferingCreated , err := extractLogOfferingCreated ( logger , ethLog ) if err != nil { return err } return w . clientRetrieveAndSaveOffering ( logger , job , ethLog . Block , logOfferingCreated . somcType , logOfferingCreated . somcData , logOfferingCreated . agentAddr , logOfferingCreated . offeringHash , logOfferingCreated . currentSupply ) }
6884	func ( w * Window ) setCell ( x , y int , c Cell ) { c . dirty = true pos := x + ( y * w . x ) if pos < len ( w . backingStore ) { w . backingStore [ pos ] = c } }
3433	func ( o * Options ) HasQueryConfig ( ) bool { if o != nil && o . QueryConfig != nil { return true } return false }
6632	func ( t * Timer ) Get ( name string ) * Counter { if c , exist := t . routes [ name ] ; exist { return c } t . mux . Lock ( ) defer t . mux . Unlock ( ) if c , exist := t . routes [ name ] ; exist { return c } t . routes [ name ] = & Counter { } t . routes [ name ] . Min = 1 << 63 - 1 return t . routes [ name ] }
1598	func ( m * MockSecretsManagerAPI ) ListSecretVersionIdsRequest ( arg0 * secretsmanager . ListSecretVersionIdsInput ) ( * request . Request , * secretsmanager . ListSecretVersionIdsOutput ) { ret := m . ctrl . Call ( m , "ListSecretVersionIdsRequest" , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . ListSecretVersionIdsOutput ) return ret0 , ret1 }
2825	func expandDVSTrafficShapingPolicyIngress ( d * schema . ResourceData ) * types . DVSTrafficShapingPolicy { obj := & types . DVSTrafficShapingPolicy { Enabled : structure . GetBoolPolicy ( d , "ingress_shaping_enabled" ) , AverageBandwidth : structure . GetLongPolicy ( d , "ingress_shaping_average_bandwidth" ) , PeakBandwidth : structure . GetLongPolicy ( d , "ingress_shaping_peak_bandwidth" ) , BurstSize : structure . GetLongPolicy ( d , "ingress_shaping_burst_size" ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj }
3560	func ( s * SyntheticsTest ) GetPublicIdOk ( ) ( string , bool ) { if s == nil || s . PublicId == nil { return "" , false } return * s . PublicId , true }
1100	func base64Decode ( s string ) ( string , error ) { v , err := base64 . StdEncoding . DecodeString ( s ) if err != nil { return "" , errors . Wrap ( err , "base64Decode" ) } return string ( v ) , nil }
1928	func ( agent * ecsAgent ) startUdevWatcher ( state dockerstate . TaskEngineState , stateChangeEvents chan <- statechange . Event ) error { seelog . Debug ( "Setting up ENI Watcher" ) udevMonitor , err := udevwrapper . New ( ) if err != nil { return errors . Wrapf ( err , "unable to create udev monitor" ) } eniWatcher := watcher . New ( agent . ctx , agent . mac , udevMonitor , state , stateChangeEvents ) if err := eniWatcher . Init ( ) ; err != nil { return errors . Wrapf ( err , "unable to initialize eni watcher" ) } go eniWatcher . Start ( ) return nil }
2450	func ( i * Image ) hasDependency ( ) bool { if i . stale { return false } return len ( i . drawTrianglesHistory ) > 0 }
5746	func ( a * API ) FetchCheck ( cid CIDType ) ( * Check , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid check CID [none]" ) } checkCID := string ( * cid ) matched , err := regexp . MatchString ( config . CheckCIDRegex , checkCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid check CID [%s]" , checkCID ) } result , err := a . Get ( checkCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch check, received JSON: %s" , string ( result ) ) } check := new ( Check ) if err := json . Unmarshal ( result , check ) ; err != nil { return nil , err } return check , nil }
5280	func NewColumnIterator ( format Format , reader io . Reader ) * Iterator { return NewIterator ( reader , ColumnUnmarshaller ( format ) ) }
2743	func expandDistributedVirtualSwitchHostMemberConfigSpec ( d map [ string ] interface { } ) types . DistributedVirtualSwitchHostMemberConfigSpec { hostRef := & types . ManagedObjectReference { Type : "HostSystem" , Value : d [ "host_system_id" ] . ( string ) , } var pnSpecs [ ] types . DistributedVirtualSwitchHostMemberPnicSpec nics := structure . SliceInterfacesToStrings ( d [ "devices" ] . ( [ ] interface { } ) ) for _ , nic := range nics { pnSpec := types . DistributedVirtualSwitchHostMemberPnicSpec { PnicDevice : nic , } pnSpecs = append ( pnSpecs , pnSpec ) } backing := types . DistributedVirtualSwitchHostMemberPnicBacking { PnicSpec : pnSpecs , } obj := types . DistributedVirtualSwitchHostMemberConfigSpec { Host : * hostRef , Backing : & backing , } return obj }
5295	func redirectPath ( path string , r * http . Request ) http . Handler { t1 := strings . HasSuffix ( path , "/" ) t2 := strings . HasSuffix ( r . URL . Path , "/" ) if t1 != t2 { u , _ := url . Parse ( r . URL . String ( ) ) if t1 { u . Path += "/" } else { u . Path = u . Path [ : len ( u . Path ) - 1 ] } return http . RedirectHandler ( u . String ( ) , 301 ) } return nil }
3364	func ( i * IntegrationGCPCreateRequest ) GetClientIDOk ( ) ( string , bool ) { if i == nil || i . ClientID == nil { return "" , false } return * i . ClientID , true }
4712	func ( l * line ) childOf ( parent element ) ( bool , error ) { var ok bool var err error switch { case l . isEmpty ( ) : ok = true case parent . ContainPlainText ( ) : switch { case parent . Base ( ) . ln . indent < l . indent : ok = true } default : switch { case l . indent == parent . Base ( ) . ln . indent + 1 : ok = true case l . indent > parent . Base ( ) . ln . indent + 1 : err = fmt . Errorf ( "the indent is invalid [file: %s][line: %d]" , l . fileName ( ) , l . no ) } } return ok , err }
2061	func NewTasksResponse ( state dockerstate . TaskEngineState ) * TasksResponse { allTasks := state . AllTasks ( ) taskResponses := make ( [ ] * TaskResponse , len ( allTasks ) ) for ndx , task := range allTasks { containerMap , _ := state . ContainerMapByArn ( task . Arn ) taskResponses [ ndx ] = NewTaskResponse ( task , containerMap ) } return & TasksResponse { Tasks : taskResponses } }
2620	func BoolStringPtrState ( v interface { } ) string { b , err := strconv . ParseBool ( v . ( string ) ) if err != nil { return "" } return strconv . FormatBool ( b ) }
3563	func ( t * TemplateVariable ) GetDefaultOk ( ) ( string , bool ) { if t == nil || t . Default == nil { return "" , false } return * t . Default , true }
2304	func ( v * TreeSelection ) native ( ) * C . GtkTreeSelection { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeSelection ( p ) }
5220	func ( f * Field ) Set ( rowIDOrKey , colIDOrKey interface { } ) * PQLBaseQuery { rowStr , colStr , err := formatRowColIDKey ( rowIDOrKey , colIDOrKey ) if err != nil { return NewPQLBaseQuery ( "" , f . index , err ) } text := fmt . Sprintf ( "Set(%s,%s=%s)" , colStr , f . name , rowStr ) q := NewPQLBaseQuery ( text , f . index , nil ) q . hasKeys = f . options . keys || f . index . options . keys return q }
2549	func expandSliceOfCustomizationAdapterMapping ( d * schema . ResourceData ) [ ] types . CustomizationAdapterMapping { s := d . Get ( cKeyPrefix + "." + "network_interface" ) . ( [ ] interface { } ) if len ( s ) < 1 { return nil } result := make ( [ ] types . CustomizationAdapterMapping , len ( s ) ) var v4gwFound , v6gwFound bool for i := range s { var adapter types . CustomizationIPSettings adapter , v4gwFound , v6gwFound = expandCustomizationIPSettings ( d , i , ! v4gwFound , ! v6gwFound ) obj := types . CustomizationAdapterMapping { Adapter : adapter , } result [ i ] = obj } return result }
2828	func flattenVMwareDVSPortSetting ( d * schema . ResourceData , obj * types . VMwareDVSPortSetting ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , "block_all_ports" , obj . Blocked ) structure . SetBoolPolicy ( d , "netflow_enabled" , obj . IpfixEnabled ) structure . SetBoolPolicy ( d , "tx_uplink" , obj . TxUplink ) structure . SetBoolPolicy ( d , "directpath_gen2_allowed" , obj . VmDirectPathGen2Allowed ) if err := flattenDVSTrafficShapingPolicyIngress ( d , obj . InShapingPolicy ) ; err != nil { return err } if err := flattenDVSTrafficShapingPolicyEgress ( d , obj . OutShapingPolicy ) ; err != nil { return err } if err := flattenBaseVmwareDistributedVirtualSwitchVlanSpec ( d , obj . Vlan ) ; err != nil { return err } if err := flattenVmwareUplinkPortTeamingPolicy ( d , obj . UplinkTeamingPolicy ) ; err != nil { return err } if err := flattenDVSSecurityPolicy ( d , obj . SecurityPolicy ) ; err != nil { return err } if err := flattenVMwareUplinkLacpPolicy ( d , obj . LacpPolicy ) ; err != nil { return err } return nil }
3527	func ( s * SyntheticsOptions ) GetFollowRedirectsOk ( ) ( bool , bool ) { if s == nil || s . FollowRedirects == nil { return false , false } return * s . FollowRedirects , true }
6864	func ( dl * DefaultLogger ) Error ( message string , params ... interface { } ) { dl . logger . Errorf ( fmt . Sprintf ( "%s %s" , caller ( ) , message ) , params ... ) }
3331	func ( g * GroupData ) GetLastNotifiedTs ( ) int { if g == nil || g . LastNotifiedTs == nil { return 0 } return * g . LastNotifiedTs }
7108	func ToIRSA ( theString string ) ( string , error ) { f := New ( theString ) if f . length < 1 { return "" , errors . New ( lengthError ) } f . makeLower ( ) var buffer bytes . Buffer for _ , i := range f . theString { key := strings . ToLower ( string ( i ) ) if _ , ok := irsa [ key ] ; ok { buffer . WriteString ( irsa [ key ] + " " ) } } return buffer . String ( ) , nil }
6609	func New ( file string ) * OuiDb { db := & OuiDb { } if err := db . Load ( file ) ; err != nil { return nil } return db }
2082	func NewMockRoundTripper ( ctrl * gomock . Controller ) * MockRoundTripper { mock := & MockRoundTripper { ctrl : ctrl } mock . recorder = & MockRoundTripperMockRecorder { mock } return mock }
3960	func ( z * Writer ) Reset ( w io . Writer ) { z . Header = Header { } z . dst = w z . checksum . Reset ( ) z . zdata = z . zdata [ : 0 ] z . data = z . data [ : 0 ] z . idx = 0 }
132	func ( p * parser ) number ( val string ) float64 { n , err := strconv . ParseInt ( val , 0 , 64 ) f := float64 ( n ) if err != nil { f , err = strconv . ParseFloat ( val , 64 ) } if err != nil { p . errorf ( "error parsing number: %s" , err ) } return f }
2904	func ( r * Subresource ) GetWithRestart ( key string ) interface { } { if r . HasChange ( key ) { r . SetRestart ( key ) } return r . Get ( key ) }
5351	func Set ( key , value string ) error { err := _Set ( _SETTINGS . user , key , value ) if err != nil { return err } if _SETTINGS . useKDE { return _Set ( _SETTINGS . kde , key , value ) } return nil }
1884	func ( c * GlobalCgroupFactory ) Load ( hierarchy cgroups . Hierarchy , path cgroups . Path ) ( cgroups . Cgroup , error ) { return cgroups . Load ( hierarchy , path ) }
11	func ( enh * EvalNodeHelper ) dropMetricName ( l labels . Labels ) labels . Labels { if enh . dmn == nil { enh . dmn = make ( map [ uint64 ] labels . Labels , len ( enh . out ) ) } h := l . Hash ( ) ret , ok := enh . dmn [ h ] if ok { return ret } ret = dropMetricName ( l ) enh . dmn [ h ] = ret return ret }
6251	func ChannelKey ( client , agent HexString , block uint32 , offeringHash HexString ) ( [ ] byte , error ) { clientAddr , err := HexToAddress ( client ) if err != nil { return nil , err } agentAddr , err := HexToAddress ( agent ) if err != nil { return nil , err } hash , err := base64 . URLEncoding . DecodeString ( strings . TrimSpace ( string ( offeringHash ) ) ) if err != nil { return nil , err } blockBytes := Uint32ToBytes ( block ) return crypto . Keccak256 ( clientAddr . Bytes ( ) , agentAddr . Bytes ( ) , blockBytes [ : ] , common . BytesToHash ( hash ) . Bytes ( ) ) , nil }
853	func ( c * ComputeUtil ) ip ( ) ( string , error ) { instance , err := c . service . Instances . Get ( c . project , c . zone , c . instanceName ) . Do ( ) if err != nil { return "" , unwrapGoogleError ( err ) } nic := instance . NetworkInterfaces [ 0 ] if c . useInternalIP { return nic . NetworkIP , nil } return nic . AccessConfigs [ 0 ] . NatIP , nil }
267	func ( i ItemType ) precedence ( ) int { switch i { case ItemLOR : return 1 case ItemLAND , ItemLUnless : return 2 case ItemEQL , ItemNEQ , ItemLTE , ItemLSS , ItemGTE , ItemGTR : return 3 case ItemADD , ItemSUB : return 4 case ItemMUL , ItemDIV , ItemMOD : return 5 case ItemPOW : return 6 default : return LowestPrec } }
3065	func ( m * Macaron ) Handlers ( handlers ... Handler ) { m . handlers = make ( [ ] Handler , 0 ) for _ , handler := range handlers { m . Use ( handler ) } }
5245	func ( c * Client ) CreateField ( field * Field ) error { span := c . tracer . StartSpan ( "Client.CreateField" ) defer span . Finish ( ) data := [ ] byte ( field . options . String ( ) ) path := fmt . Sprintf ( "/index/%s/field/%s" , field . index . name , field . name ) response , _ , err := c . httpRequest ( "POST" , path , data , nil , false ) if err != nil { if response != nil && response . StatusCode == 409 { return ErrFieldExists } return err } return nil }
3855	func NewCursor ( startinginput string , pointer Pointer , eraseDefault bool ) Cursor { if pointer == nil { pointer = defaultCursor } cur := Cursor { Cursor : pointer , Position : len ( startinginput ) , input : [ ] rune ( startinginput ) , erase : eraseDefault } if eraseDefault { cur . Start ( ) } else { cur . End ( ) } return cur }
7240	func ( e * Entry ) getExecMatch ( name string , matcher Matcher ) ExecFunc { return func ( method , urlStr string ) ( * Route , [ ] string ) { offset , matchStr := matcher . Match ( urlStr ) if offset == - 1 { return nil , nil } if len ( urlStr ) == offset { if h := e . GetHandler ( method ) ; h != nil { return h , [ ] string { name , matchStr } } return nil , nil } for _ , entry := range e . entries { if h , params := entry . exec ( method , urlStr [ offset : ] ) ; h != nil { params = append ( params , name , matchStr ) return h , params } } return nil , nil } }
2854	func vimSoapFault ( err error ) ( types . AnyType , bool ) { if sf , ok := soapFault ( err ) ; ok { return sf . VimFault ( ) , true } return nil , false }
3518	func ( s * SyntheticsDevice ) GetIsMobileOk ( ) ( bool , bool ) { if s == nil || s . IsMobile == nil { return false , false } return * s . IsMobile , true }
292	func ( s * ReadyStorage ) Querier ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { if x := s . get ( ) ; x != nil { return x . Querier ( ctx , mint , maxt ) } return nil , ErrNotReady }
4469	func ( t * DateTime ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { tt , err := ParseDateTime ( data ) if err != nil { in . AddError ( err ) return } * t = tt } }
259	func ( n * Manager ) sendAll ( alerts ... * Alert ) bool { begin := time . Now ( ) b , err := json . Marshal ( alerts ) if err != nil { level . Error ( n . logger ) . Log ( "msg" , "Encoding alerts failed" , "err" , err ) return false } n . mtx . RLock ( ) amSets := n . alertmanagers n . mtx . RUnlock ( ) var ( wg sync . WaitGroup numSuccess uint64 ) for _ , ams := range amSets { ams . mtx . RLock ( ) for _ , am := range ams . ams { wg . Add ( 1 ) ctx , cancel := context . WithTimeout ( n . ctx , time . Duration ( ams . cfg . Timeout ) ) defer cancel ( ) go func ( ams * alertmanagerSet , am alertmanager ) { u := am . url ( ) . String ( ) if err := n . sendOne ( ctx , ams . client , u , b ) ; err != nil { level . Error ( n . logger ) . Log ( "alertmanager" , u , "count" , len ( alerts ) , "msg" , "Error sending alert" , "err" , err ) n . metrics . errors . WithLabelValues ( u ) . Inc ( ) } else { atomic . AddUint64 ( & numSuccess , 1 ) } n . metrics . latency . WithLabelValues ( u ) . Observe ( time . Since ( begin ) . Seconds ( ) ) n . metrics . sent . WithLabelValues ( u ) . Add ( float64 ( len ( alerts ) ) ) wg . Done ( ) } ( ams , am ) } ams . mtx . RUnlock ( ) } wg . Wait ( ) return numSuccess > 0 }
3055	func virtualMachinesForTag ( ctx context . Context , client * vSphereClient , id string ) ( [ ] * object . VirtualMachine , error ) { logger . Printf ( "[DEBUG] Locating all virtual machines under tag ID %q" , id ) var vms [ ] * object . VirtualMachine objs , err := client . TagsClient . ListAttachedObjects ( ctx , id ) if err != nil { return nil , err } for i , obj := range objs { switch { case obj . Type == nil || obj . ID == nil : logger . Printf ( "[WARN] Discovered object at index %d has either no ID or type" , i ) continue case * obj . Type != "VirtualMachine" : logger . Printf ( "[DEBUG] Discovered object ID %q is not a virutal machine" , * obj . ID ) continue } vm , err := virtualMachineFromMOID ( ctx , client . VimClient , * obj . ID ) if err != nil { return nil , fmt . Errorf ( "error locating virtual machine with ID %q: %s" , * obj . ID , err ) } vms = append ( vms , vm ) } logger . Printf ( "[DEBUG] Discovered virtual machines: %s" , virtualMachineNames ( vms ) ) return vms , nil }
1861	func ( secret * SSMSecretResource ) Create ( ) error { executionCredentials , ok := secret . credentialsManager . GetTaskCredentials ( secret . getExecutionCredentialsID ( ) ) if ! ok { err := errors . New ( "ssm secret resource: unable to find execution role credentials" ) secret . setTerminalReason ( err . Error ( ) ) return err } iamCredentials := executionCredentials . GetIAMRoleCredentials ( ) var wg sync . WaitGroup chanLen := secret . getGoRoutineMaxNum ( ) errorEvents := make ( chan error , chanLen ) seelog . Infof ( "ssm secret resource: retrieving secrets for containers in task: [%s]" , secret . taskARN ) secret . secretData = make ( map [ string ] string ) for region , secrets := range secret . getRequiredSecrets ( ) { wg . Add ( 1 ) go secret . retrieveSSMSecretValuesByRegion ( region , secrets , iamCredentials , & wg , errorEvents ) } wg . Wait ( ) select { case err := <- errorEvents : secret . setTerminalReason ( err . Error ( ) ) return err default : return nil } }
4201	func ( c * CreateOrgsCommand ) Execute ( [ ] string ) error { var cfMgmt * CFMgmt var err error if cfMgmt , err = InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { err = cfMgmt . OrgManager . CreateOrgs ( ) } return err }
1660	func ( m * MockTaskResource ) SetKnownStatus ( arg0 status0 . ResourceStatus ) { m . ctrl . Call ( m , "SetKnownStatus" , arg0 ) }
4135	func ( n NetworkNumber ) Equal ( n1 NetworkNumber ) bool { if len ( n ) != len ( n1 ) { return false } if n [ 0 ] != n1 [ 0 ] { return false } if len ( n ) == IPv6Uint32Count { return n [ 1 ] == n1 [ 1 ] && n [ 2 ] == n1 [ 2 ] && n [ 3 ] == n1 [ 3 ] } return true }
5098	func NewObjectId ( ) ObjectId { var b [ 12 ] byte binary . BigEndian . PutUint32 ( b [ : ] , uint32 ( time . Now ( ) . Unix ( ) ) ) b [ 4 ] = machineId [ 0 ] b [ 5 ] = machineId [ 1 ] b [ 6 ] = machineId [ 2 ] pid := os . Getpid ( ) b [ 7 ] = byte ( pid >> 8 ) b [ 8 ] = byte ( pid ) i := atomic . AddUint32 ( & objectIdCounter , 1 ) b [ 9 ] = byte ( i >> 16 ) b [ 10 ] = byte ( i >> 8 ) b [ 11 ] = byte ( i ) return ObjectId ( b [ : ] ) }
6733	func RandomSecret ( length int , rnd * rand . Rand ) string { if 0 <= length { length = 10 } secret := make ( [ ] byte , length ) for i , _ := range secret { secret [ i ] = byte ( rnd . Int31 ( ) % 256 ) } return base32 . StdEncoding . EncodeToString ( secret ) }
1980	func ( m * MockClient ) ImageList ( arg0 context . Context , arg1 types . ImageListOptions ) ( [ ] types . ImageSummary , error ) { ret := m . ctrl . Call ( m , "ImageList" , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( [ ] types . ImageSummary ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
1322	func ( m * MockOS ) RemoveAll ( arg0 string ) error { ret := m . ctrl . Call ( m , "RemoveAll" , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 }
4879	func ( e * hdbErrors ) IsWarning ( ) bool { return e . errors [ e . idx ] . errorLevel == errorLevelWarning }
2140	func ( v * VariantType ) String ( ) string { ch := C . g_variant_type_dup_string ( v . native ( ) ) defer C . g_free ( C . gpointer ( ch ) ) return C . GoString ( ( * C . char ) ( ch ) ) }
3536	func ( s * SyntheticsOptions ) GetTickEveryOk ( ) ( int , bool ) { if s == nil || s . TickEvery == nil { return 0 , false } return * s . TickEvery , true }
4982	func ( c * Consumer ) Firehose ( subscriptionId string , authToken string , ) ( <- chan * events . Envelope , <- chan error ) { return c . firehose ( newFirehose ( subscriptionId , authToken , ) ) }
3029	func Any ( vs [ ] string , f func ( string ) bool ) bool { for _ , v := range vs { if f ( v ) { return true } } return false }
5146	func ( ui * PrefixUI ) Info ( message string ) { if ui . InfoPrefix == " " { message = ui . InfoPrefix + message } else if ui . InfoPrefix != "" { message = ui . InfoPrefix + " " + message } ui . UI . Info ( message ) }
4380	func UUIDValue ( v * strfmt . UUID ) strfmt . UUID { if v == nil { return strfmt . UUID ( "" ) } return * v }
6326	func RemoveStringsFromString ( s string , substrs [ ] string ) string { for loop := true ; loop ; { loop = false for _ , substr := range substrs { lastS := s s = strings . Join ( strings . Split ( s , substr ) , "" ) if lastS != s { loop = true break } } } return s }
2499	func ( u * UserInterface ) currentMonitor ( ) * glfw . Monitor { w := u . window if m := w . GetMonitor ( ) ; m != nil { return m } return u . currentMonitorFromPosition ( ) }
6591	func NewQuery ( table string ) * Query { return & Query { table : table , headers : [ ] string { } , columns : [ ] string { } , } }
8	func extractFuncFromPath ( p [ ] Node ) string { if len ( p ) == 0 { return "" } switch n := p [ len ( p ) - 1 ] . ( type ) { case * AggregateExpr : return n . Op . String ( ) case * Call : return n . Func . Name case * BinaryExpr : return "" } return extractFuncFromPath ( p [ : len ( p ) - 1 ] ) }
2464	func RotateHue ( theta float64 ) ColorM { c := ColorM { } c . RotateHue ( theta ) return c }
4202	func ( c * UpdateOrgsMetadataCommand ) Execute ( [ ] string ) error { var cfMgmt * CFMgmt var err error if cfMgmt , err = InitializePeekManagers ( c . BaseCFConfigCommand , c . Peek ) ; err == nil { err = cfMgmt . OrgManager . UpdateOrgsMetadata ( ) } return err }
1935	func ( m * MockTaskEngineState ) AllImageStates ( ) [ ] * image . ImageState { ret := m . ctrl . Call ( m , "AllImageStates" ) ret0 , _ := ret [ 0 ] . ( [ ] * image . ImageState ) return ret0 }
3849	func ( l * List ) SetStart ( i int ) { if i < 0 { i = 0 } if i > l . cursor { l . start = l . cursor } else { l . start = i } }
7038	func ( c * Conn ) Close ( ) error { c . connected . Store ( false ) ws := c . ws . Load ( ) . ( * websocket . Conn ) if ws != nil { ws . Close ( ) } return nil }
6182	func RecoverPubKey ( signer types . Signer , tx * types . Transaction ) ( * ecdsa . PublicKey , error ) { V , R , S := tx . RawSignatureValues ( ) hash := signer . Hash ( tx ) r , s := R . Bytes ( ) , S . Bytes ( ) sig := make ( [ ] byte , 65 ) copy ( sig [ 32 - len ( r ) : 32 ] , r ) copy ( sig [ 64 - len ( s ) : 64 ] , s ) sig [ 64 ] = byte ( V . Uint64 ( ) - 27 ) pub , err := crypto . Ecrecover ( hash [ : ] , sig ) if err != nil { return nil , err } return crypto . UnmarshalPubkey ( pub ) }
3409	func ( n * NoteDefinition ) HasShowTick ( ) bool { if n != nil && n . ShowTick != nil { return true } return false }
5058	func ( cluster * mongoCluster ) Acquire ( ) { cluster . Lock ( ) cluster . references ++ debugf ( "Cluster %p acquired (refs=%d)" , cluster , cluster . references ) cluster . Unlock ( ) }
5275	func OptImportRoaring ( enable bool ) ImportOption { return func ( options * ImportOptions ) error { options . wantRoaring = & enable return nil } }
773	func NewIstioGatewaySource ( kubeClient kubernetes . Interface , istioClient istiomodel . ConfigStore , istioIngressGatewayServices [ ] string , namespace string , annotationFilter string , fqdnTemplate string , combineFqdnAnnotation bool , ignoreHostnameAnnotation bool , ) ( Source , error ) { var ( tmpl * template . Template err error ) for _ , lbService := range istioIngressGatewayServices { if _ , _ , err = parseIngressGateway ( lbService ) ; err != nil { return nil , err } } if fqdnTemplate != "" { tmpl , err = template . New ( "endpoint" ) . Funcs ( template . FuncMap { "trimPrefix" : strings . TrimPrefix , } ) . Parse ( fqdnTemplate ) if err != nil { return nil , err } } return & gatewaySource { kubeClient : kubeClient , istioClient : istioClient , istioIngressGatewayServices : istioIngressGatewayServices , namespace : namespace , annotationFilter : annotationFilter , fqdnTemplate : tmpl , combineFQDNAnnotation : combineFqdnAnnotation , ignoreHostnameAnnotation : ignoreHostnameAnnotation , } , nil }
99	func ( t * Target ) LastError ( ) error { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . lastError }
1090	func fileFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { if len ( s ) == 0 { return "" , nil } d , err := dep . NewFileQuery ( s ) if err != nil { return "" , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { if value == nil { return "" , nil } return value . ( string ) , nil } missing . Add ( d ) return "" , nil } }
3021	func validateVirtualMachineFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeVM { return nil , fmt . Errorf ( "%q is not a VM folder" , folder . InventoryPath ) } log . Printf ( "[DEBUG] Folder located: %q" , folder . InventoryPath ) return folder , nil }
6966	func GetHolidays ( countryCode string , year int ) ( [ ] Holiday , error ) { requiredCodes := [ ] string { countryCode } result := [ ] Holiday { } for len ( requiredCodes ) > 0 { cc := requiredCodes [ 0 ] hds , ok := holidayProviders [ cc ] if ! ok { return nil , HolidayDataNotFoundError } requiredCodes = append ( requiredCodes , hds . GetIncludes ( ) ... ) result = append ( result , hds . GetHolidays ( year ) ... ) requiredCodes = requiredCodes [ 1 : ] } sort . Sort ( holidays ( result ) ) return result , nil }
447	func ( s * Server ) ListenAndServeUNIX ( addr string , mode os . FileMode ) error { if err := os . Remove ( addr ) ; err != nil && ! os . IsNotExist ( err ) { return fmt . Errorf ( "unexpected error when trying to remove unix socket file %q: %s" , addr , err ) } ln , err := net . Listen ( "unix" , addr ) if err != nil { return err } if err = os . Chmod ( addr , mode ) ; err != nil { return fmt . Errorf ( "cannot chmod %#o for %q: %s" , mode , addr , err ) } return s . Serve ( ln ) }
2524	func flattenHostNetworkPolicy ( d * schema . ResourceData , obj * types . HostNetworkPolicy ) error { if err := flattenHostNetworkSecurityPolicy ( d , obj . Security ) ; err != nil { return err } if err := flattenHostNicTeamingPolicy ( d , obj . NicTeaming ) ; err != nil { return err } if err := flattenHostNetworkTrafficShapingPolicy ( d , obj . ShapingPolicy ) ; err != nil { return err } return nil }
4789	func ( c Config ) computedCropArea ( bounds image . Rectangle , size image . Point ) ( r image . Rectangle ) { min := bounds . Min switch c . Mode { case Centered : rMin := c . centeredMin ( bounds ) r = image . Rect ( rMin . X - size . X / 2 , rMin . Y - size . Y / 2 , rMin . X - size . X / 2 + size . X , rMin . Y - size . Y / 2 + size . Y ) default : rMin := image . Point { min . X + c . Anchor . X , min . Y + c . Anchor . Y } r = image . Rect ( rMin . X , rMin . Y , rMin . X + size . X , rMin . Y + size . Y ) } return }
3061	func virtualMachineNames ( vms [ ] * object . VirtualMachine ) string { var s [ ] string for _ , vm := range vms { s = append ( s , vm . Name ( ) ) } return strings . Join ( s , "," ) }
686	func ( p * dnsimpleProvider ) GetAccountID ( credentials dnsimple . Credentials , client dnsimple . Client ) ( accountID string , err error ) { whoamiResponse , err := client . Identity . Whoami ( ) if err != nil { return "" , err } return strconv . Itoa ( whoamiResponse . Data . Account . ID ) , nil }
501	func ( h * RequestHeader ) Method ( ) [ ] byte { if len ( h . method ) == 0 { return strGet } return h . method }
7069	func ataWrite ( r * ATAArg , rs io . ReadSeeker ) ( * ATAArg , error ) { if r . CmdStatus != ATACmdStatusWrite28Bit && r . CmdStatus != ATACmdStatusWrite48Bit { return nil , errATAAbort } if ! r . FlagWrite { return nil , errATAAbort } if sectors := len ( r . Data ) / sectorSize ; sectors != int ( r . SectorCount ) { return nil , errATAAbort } rws , ok := rs . ( io . ReadWriteSeeker ) if ! ok { return nil , errATAAbort } offset := calculateLBA ( r . LBA , r . FlagLBA48Extended ) * sectorSize if _ , err := rs . Seek ( offset , os . SEEK_SET ) ; err != nil { return nil , err } n , err := rws . Write ( r . Data ) if err != nil { return nil , err } if sectors := n / sectorSize ; sectors != int ( r . SectorCount ) { return nil , errATAAbort } return & ATAArg { CmdStatus : ATACmdStatusReadyStatus , } , nil }
3182	func ( client * Client ) GetAlerts ( ) ( [ ] Alert , error ) { var out reqAlerts if err := client . doJsonRequest ( "GET" , "/v1/alert" , nil , & out ) ; err != nil { return nil , err } return out . Alerts , nil }
2142	func ( v * MenuShell ) native ( ) * C . GtkMenuShell { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenuShell ( p ) }
971	func ( b * Brain ) Remember ( d dep . Dependency , data interface { } ) { b . Lock ( ) defer b . Unlock ( ) b . data [ d . String ( ) ] = data b . receivedData [ d . String ( ) ] = struct { } { } }
4968	func DecodeBytes ( token string , key interface { } ) ( [ ] byte , map [ string ] interface { } , error ) { parts , err := compact . Parse ( token ) if err != nil { return nil , nil , err } if len ( parts ) == 3 { return verify ( parts , key ) } if len ( parts ) == 5 { return decrypt ( parts , key ) } return nil , nil , errors . New ( fmt . Sprintf ( "jwt.DecodeBytes() expects token of 3 or 5 parts, but was given: %v parts" , len ( parts ) ) ) }
5159	func Init ( app , key string ) { if _ , err := sdk . InitEmbeddedMode ( key , app ) ; err != nil { panic ( err ) } }
133	func ( p * parser ) expectType ( node Node , want ValueType , context string ) { t := p . checkType ( node ) if t != want { p . errorf ( "expected type %s in %s, got %s" , documentedType ( want ) , context , documentedType ( t ) ) } }
3411	func ( o * Options ) GetEnableLogsSampleOk ( ) ( bool , bool ) { if o == nil || o . EnableLogsSample == nil { return false , false } return * o . EnableLogsSample , true }
2976	func ( r * DiskSubresource ) DiffGeneral ( ) error { log . Printf ( "[DEBUG] %s: Beginning diff validation" , r ) name , err := diskLabelOrName ( r . data ) if err != nil { return err } ctlrCount := r . rdd . Get ( "scsi_controller_count" ) . ( int ) maxUnit := ctlrCount * 15 - 1 currentUnit := r . Get ( "unit_number" ) . ( int ) if currentUnit > maxUnit { return fmt . Errorf ( "unit_number on disk %q too high (%d) - maximum value is %d with %d SCSI controller(s)" , name , currentUnit , maxUnit , ctlrCount ) } if r . Get ( "attach" ) . ( bool ) { switch { case r . Get ( "datastore_id" ) . ( string ) == "" : return fmt . Errorf ( "datastore_id for disk %q is required when attach is set" , name ) case r . Get ( "size" ) . ( int ) > 0 : return fmt . Errorf ( "size for disk %q cannot be defined when attach is set" , name ) case r . Get ( "eagerly_scrub" ) . ( bool ) : return fmt . Errorf ( "eagerly_scrub for disk %q cannot be defined when attach is set" , name ) case r . Get ( "keep_on_remove" ) . ( bool ) : return fmt . Errorf ( "keep_on_remove for disk %q is implicit when attach is set, please remove this setting" , name ) } } else { if r . Get ( "size" ) . ( int ) < 1 { return fmt . Errorf ( "size for disk %q: required option not set" , name ) } } version := viapi . ParseVersionFromClient ( r . client ) if r . Get ( "disk_sharing" ) . ( string ) != string ( types . VirtualDiskSharingSharingNone ) { if version . Older ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { return fmt . Errorf ( "multi-writer disk_sharing is only supported on vSphere 6 and higher" ) } } if r . Get ( "eagerly_scrub" ) . ( bool ) && r . Get ( "thin_provisioned" ) . ( bool ) { return fmt . Errorf ( "%s: eagerly_scrub and thin_provisioned cannot both be set to true" , name ) } log . Printf ( "[DEBUG] %s: Diff validation complete" , r ) return nil }
346	func ( rule * RecordingRule ) GetEvaluationDuration ( ) time . Duration { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . evaluationDuration }
3877	func yaml_parser_save_simple_key ( parser * yaml_parser_t ) bool { required := parser . flow_level == 0 && parser . indent == parser . mark . column if parser . simple_key_allowed { simple_key := yaml_simple_key_t { possible : true , required : required , token_number : parser . tokens_parsed + ( len ( parser . tokens ) - parser . tokens_head ) , } simple_key . mark = parser . mark if ! yaml_parser_remove_simple_key ( parser ) { return false } parser . simple_keys [ len ( parser . simple_keys ) - 1 ] = simple_key } return true }
4223	func ( mkc * memoryKeyCacher ) handleOverflow ( ) { if mkc . maxCacheSize < len ( mkc . entries ) { var oldestEntryKeyID string var latestAddedTime = time . Now ( ) for entryKeyID , entry := range mkc . entries { if entry . addedAt . Before ( latestAddedTime ) { latestAddedTime = entry . addedAt oldestEntryKeyID = entryKeyID } } delete ( mkc . entries , oldestEntryKeyID ) } }
3217	func ( client * Client ) UnmuteHost ( host string ) ( * HostActionResp , error ) { var out HostActionResp uri := "/v1/host/" + host + "/unmute" if err := client . doJsonRequest ( "POST" , uri , nil , & out ) ; err != nil { return nil , err } return & out , nil }
4389	func HexColorValue ( v * strfmt . HexColor ) strfmt . HexColor { if v == nil { return strfmt . HexColor ( "" ) } return * v }
54	func ( d * Discovery ) watchServices ( ctx context . Context , ch chan <- [ ] * targetgroup . Group , lastIndex * uint64 , services map [ string ] func ( ) ) error { catalog := d . client . Catalog ( ) level . Debug ( d . logger ) . Log ( "msg" , "Watching services" , "tags" , d . watchedTags ) t0 := time . Now ( ) opts := & consul . QueryOptions { WaitIndex : * lastIndex , WaitTime : watchTimeout , AllowStale : d . allowStale , NodeMeta : d . watchedNodeMeta , } srvs , meta , err := catalog . Services ( opts . WithContext ( ctx ) ) elapsed := time . Since ( t0 ) rpcDuration . WithLabelValues ( "catalog" , "services" ) . Observe ( elapsed . Seconds ( ) ) if err != nil { level . Error ( d . logger ) . Log ( "msg" , "Error refreshing service list" , "err" , err ) rpcFailuresCount . Inc ( ) time . Sleep ( retryInterval ) return err } if meta . LastIndex == * lastIndex { return nil } * lastIndex = meta . LastIndex for name := range srvs { if ! d . shouldWatch ( name , srvs [ name ] ) { continue } if _ , ok := services [ name ] ; ok { continue } wctx , cancel := context . WithCancel ( ctx ) d . watchService ( wctx , ch , name ) services [ name ] = cancel } for name , cancel := range services { if _ , ok := srvs [ name ] ; ! ok { cancel ( ) delete ( services , name ) select { case <- ctx . Done ( ) : return ctx . Err ( ) case ch <- [ ] * targetgroup . Group { { Source : name } } : } } } return nil }
3871	func getGoPath ( ) string { path := os . Getenv ( "GOPATH" ) if path == "" { user , err := user . Current ( ) kingpin . FatalIfError ( err , "" ) path = filepath . Join ( user . HomeDir , "go" ) } return path }
1740	func ( task * Task ) GetDesiredStatus ( ) apitaskstatus . TaskStatus { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . DesiredStatusUnsafe }
6429	func EnableVirtualTerminalProcessing ( fd int ) error { var st uint32 err := windows . GetConsoleMode ( windows . Handle ( fd ) , & st ) if err != nil { return err } if st & windows . ENABLE_VIRTUAL_TERMINAL_PROCESSING == 0 { return windows . SetConsoleMode ( windows . Handle ( fd ) , st | windows . ENABLE_VIRTUAL_TERMINAL_PROCESSING ) } return nil }
2423	func ( g * GeoM ) String ( ) string { return fmt . Sprintf ( "[[%f, %f, %f], [%f, %f, %f]]" , g . a_1 + 1 , g . b , g . tx , g . c , g . d_1 + 1 , g . ty ) }
70	func New ( ls ... Label ) Labels { set := make ( Labels , 0 , len ( ls ) ) for _ , l := range ls { set = append ( set , l ) } sort . Sort ( set ) return set }
3233	func ( b * Board ) GetAuthorHandleOk ( ) ( string , bool ) { if b == nil || b . AuthorHandle == nil { return "" , false } return * b . AuthorHandle , true }
1028	func ( d * DedupManager ) parseData ( path string , raw [ ] byte ) { r := bytes . NewReader ( raw ) decompress := lzw . NewReader ( r , lzw . LSB , 8 ) defer decompress . Close ( ) dec := gob . NewDecoder ( decompress ) var td templateData if err := dec . Decode ( & td ) ; err != nil { log . Printf ( "[ERR] (dedup) failed to decode '%s': %v" , path , err ) return } if td . Version != version . Version { log . Printf ( "[WARN] (dedup) created with different version (%s vs %s)" , td . Version , version . Version ) return } log . Printf ( "[INFO] (dedup) loading %d dependencies from '%s'" , len ( td . Data ) , path ) for hashCode , value := range td . Data { d . brain . ForceSet ( hashCode , value ) } select { case d . updateCh <- struct { } { } : default : } }
3843	func ( s * ScreenBuf ) Flush ( ) error { for i := s . cursor ; i < s . height ; i ++ { if i < s . height { _ , err := s . buf . Write ( clearLine ) if err != nil { return err } } _ , err := s . buf . Write ( moveDown ) if err != nil { return err } } _ , err := s . buf . WriteTo ( s . w ) if err != nil { return err } s . buf . Reset ( ) for i := 0 ; i < s . height ; i ++ { _ , err := s . buf . Write ( moveUp ) if err != nil { return err } } s . cursor = 0 return nil }
783	func ( in Targets ) DeepCopy ( ) Targets { if in == nil { return nil } out := new ( Targets ) in . DeepCopyInto ( out ) return * out }
7130	func ( s * HttpHeader ) GetReader ( h http . Header ) * HttpHeader { s . Value = h . Get ( s . Name ) return s }
750	func suitableType ( target string ) string { if net . ParseIP ( target ) != nil { return endpoint . RecordTypeA } return endpoint . RecordTypeCNAME }
2346	func filterPaeth ( cdat , pdat [ ] byte , bytesPerPixel int ) { var a , b , c , pa , pb , pc int for i := 0 ; i < bytesPerPixel ; i ++ { a , c = 0 , 0 for j := i ; j < len ( cdat ) ; j += bytesPerPixel { b = int ( pdat [ j ] ) pa = b - c pb = a - c pc = abs ( pa + pb ) pa = abs ( pa ) pb = abs ( pb ) if pa <= pb && pa <= pc { } else if pb <= pc { a = b } else { a = c } a += int ( cdat [ j ] ) a &= 0xff cdat [ j ] = uint8 ( a ) c = b } } }
954	func vaultRenewDuration ( s * Secret ) time . Duration { base := s . LeaseDuration if s . Auth != nil && s . Auth . LeaseDuration > 0 { base = s . Auth . LeaseDuration } if base <= 0 { base = int ( VaultDefaultLeaseDuration . Seconds ( ) ) } sleep := float64 ( time . Duration ( base ) * time . Second ) if vaultSecretRenewable ( s ) { sleep = sleep / 3.0 sleep = sleep * ( rand . Float64 ( ) + 1 ) / 2.0 } else { sleep = sleep * ( .85 + rand . Float64 ( ) * 0.1 ) } return time . Duration ( sleep ) }
1341	func NewStateManager ( cfg * config . Config , options ... Option ) ( StateManager , error ) { fi , err := os . Stat ( cfg . DataDir ) if err != nil { return nil , err } if ! fi . IsDir ( ) { return nil , errors . New ( "State manager DataDir must exist" ) } state := & state { Data : make ( saveableState ) , Version : ECSDataVersion , } manager := & basicStateManager { statePath : cfg . DataDir , state : state , } for _ , option := range options { option ( manager ) } manager . platformDependencies = newPlatformDependencies ( ) return manager , nil }
6558	func ( c * Command ) Arg ( v interface { } ) * Command { c . args = append ( c . args , fmt . Sprintf ( "%v" , v ) ) return c }
6050	func PostCheque ( db * reform . DB , channel string , pscAddr data . HexString , pass string , amount uint64 , tls bool , timeout uint , pr * proc . Processor ) error { pld , err := newPayload ( db , channel , pscAddr , pass , amount ) if err != nil { return err } return postPayload ( db , channel , pld , tls , timeout , pr , srv . Send ) }
4738	func ( s StringGroupedNumberPostfixSorter ) Less ( i , j int ) bool { bi , ni := StringSplitNumberPostfix ( s [ i ] ) bj , nj := StringSplitNumberPostfix ( s [ j ] ) if bi == bj { if len ( ni ) == len ( nj ) { inti , _ := strconv . Atoi ( ni ) intj , _ := strconv . Atoi ( nj ) return inti < intj } else { return len ( ni ) < len ( nj ) } } return bi < bj }
4352	func DateEntropy ( dateMatch match . DateMatch ) float64 { var entropy float64 if dateMatch . Year < 100 { entropy = math . Log2 ( numDays * numMonths * 100 ) } else { entropy = math . Log2 ( numDays * numMonths * numYears ) } if dateMatch . Separator != "" { entropy += 2 } return entropy }
4324	func ( c * Client ) ListCheckoutKeys ( account , repo string ) ( [ ] * CheckoutKey , error ) { checkoutKeys := [ ] * CheckoutKey { } err := c . request ( "GET" , fmt . Sprintf ( "project/%s/%s/checkout-key" , account , repo ) , & checkoutKeys , nil , nil ) if err != nil { return nil , err } return checkoutKeys , nil }
5701	func ErrorHandler ( errs Errors , resp http . ResponseWriter ) { if len ( errs ) > 0 { resp . Header ( ) . Set ( "Content-Type" , jsonContentType ) if errs . Has ( DeserializationError ) { resp . WriteHeader ( http . StatusBadRequest ) } else if errs . Has ( ContentTypeError ) { resp . WriteHeader ( http . StatusUnsupportedMediaType ) } else { resp . WriteHeader ( StatusUnprocessableEntity ) } errOutput , _ := json . Marshal ( errs ) resp . Write ( errOutput ) return } }
4187	func ( m * yamlManager ) DeleteConfigIfExists ( ) error { if ! FileOrDirectoryExists ( m . ConfigDir ) { lo . G . Infof ( "%s doesn't exists, nothing to delete" , m . ConfigDir ) return nil } if err := os . RemoveAll ( m . ConfigDir ) ; err != nil { lo . G . Errorf ( "Error deleting config folder. Error: %s" , err ) return fmt . Errorf ( "cannot delete %s: %v" , m . ConfigDir , err ) } lo . G . Info ( "Config directory deleted" ) return nil }
968	func ( d * CatalogNodeQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , } ) name := d . name if name == "" { log . Printf ( "[TRACE] %s: getting local agent name" , d ) var err error name , err = clients . Consul ( ) . Agent ( ) . NodeName ( ) if err != nil { return nil , nil , errors . Wrapf ( err , d . String ( ) ) } } log . Printf ( "[TRACE] %s: GET %s" , d , & url . URL { Path : "/v1/catalog/node/" + name , RawQuery : opts . String ( ) , } ) node , qm , err := clients . Consul ( ) . Catalog ( ) . Node ( name , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( "[TRACE] %s: returned response" , d ) rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } if node == nil { log . Printf ( "[WARN] %s: no node exists with the name %q" , d , name ) var node CatalogNode return & node , rm , nil } services := make ( [ ] * CatalogNodeService , 0 , len ( node . Services ) ) for _ , v := range node . Services { services = append ( services , & CatalogNodeService { ID : v . ID , Service : v . Service , Tags : ServiceTags ( deepCopyAndSortTags ( v . Tags ) ) , Meta : v . Meta , Port : v . Port , Address : v . Address , EnableTagOverride : v . EnableTagOverride , } ) } sort . Stable ( ByService ( services ) ) detail := & CatalogNode { Node : & Node { ID : node . Node . ID , Node : node . Node . Node , Address : node . Node . Address , Datacenter : node . Node . Datacenter , TaggedAddresses : node . Node . TaggedAddresses , Meta : node . Node . Meta , } , Services : services , } return detail , rm , nil }
140	func lint ( mf dto . MetricFamily ) [ ] Problem { fns := [ ] func ( mf dto . MetricFamily ) [ ] Problem { lintHelp , lintMetricUnits , lintCounter , lintHistogramSummaryReserved , } var problems [ ] Problem for _ , fn := range fns { problems = append ( problems , fn ( mf ) ... ) } return problems }
6719	func ( c * Client ) CloudIP ( identifier string ) ( * CloudIP , error ) { cloudip := new ( CloudIP ) _ , err := c . MakeApiRequest ( "GET" , "/1.0/cloud_ips/" + identifier , nil , cloudip ) if err != nil { return nil , err } return cloudip , err }
5730	func LimitChan ( limit int ) chan struct { } { limitch := make ( chan struct { } , limit ) for i := 0 ; i < limit ; i ++ { limitch <- struct { } { } } return limitch }
6315	func ( c * Controller ) Session ( ) Session { if c . Request . session == nil { c . Request . session = c . sessionFinder ( c . Request ) } return c . Request . session }
4917	func ( r * Reader ) ReadFloat64 ( ) float64 { if r . err != nil { return 0 } var n int n , r . err = io . ReadFull ( r . rd , r . b [ : 8 ] ) r . cnt += n if r . err != nil { return 0 } bits := binary . LittleEndian . Uint64 ( r . b [ : 8 ] ) return math . Float64frombits ( bits ) }
849	func ( c * ComputeUtil ) startInstance ( ) error { op , err := c . service . Instances . Start ( c . project , c . zone , c . instanceName ) . Do ( ) if err != nil { return err } log . Infof ( "Waiting for instance to start." ) return c . waitForRegionalOp ( op . Name ) }
866	func osDiskStorageBlobURL ( account * storage . AccountProperties , vmName string ) string { containerURL := osDiskStorageContainerURL ( account , vmName ) blobName := fmt . Sprintf ( fmtOSDiskBlobName , vmName ) return containerURL + blobName }
3681	func ( w * Widget ) HasManageStatusTitleAlign ( ) bool { if w != nil && w . ManageStatusTitleAlign != nil { return true } return false }
4680	func newHTMLComment ( ln * line , rslt * result , src * source , parent element , opts * Options ) * htmlComment { return & htmlComment { elementBase : newElementBase ( ln , rslt , src , parent , opts ) , } }
3522	func ( s * SyntheticsDevice ) HasUserAgent ( ) bool { if s != nil && s . UserAgent != nil { return true } return false }
6047	func ( h * Handler ) GetProductUsage ( password , productID string ) ( * uint , error ) { logger := h . logger . Add ( "method" , "GetProductUsage" , "productID" , productID ) return h . uintFromQuery ( logger , password , `SELECT SUM(sessions.units_used) FROM offerings JOIN channels ON channels.offering=offerings.id AND offerings.product=$1 JOIN sessions ON sessions.channel=channels.id` , productID ) }
2261	func ( v * MenuItem ) GetLabel ( ) string { l := C . gtk_menu_item_get_label ( v . native ( ) ) return goString ( l ) }
1397	func ( manager * metadataManager ) Create ( config * dockercontainer . Config , hostConfig * dockercontainer . HostConfig , task * apitask . Task , containerName string ) error { metadataDirectoryPath , err := getMetadataFilePath ( task . Arn , containerName , manager . dataDir ) if err != nil { return fmt . Errorf ( "container metadata create for task %s container %s: %v" , task . Arn , containerName , err ) } err = manager . osWrap . MkdirAll ( metadataDirectoryPath , os . ModePerm ) if err != nil { return fmt . Errorf ( "creating metadata directory for task %s: %v" , task . Arn , err ) } metadata := manager . parseMetadataAtContainerCreate ( task , containerName ) err = manager . marshalAndWrite ( metadata , task . Arn , containerName ) if err != nil { return err } binds , env := createBindsEnv ( hostConfig . Binds , config . Env , manager . dataDirOnHost , metadataDirectoryPath ) config . Env = env hostConfig . Binds = binds return nil }
1962	func verifyTasksMetadata ( tasksMetadataRawMsg json . RawMessage ) error { var tasksMetadataMap map [ string ] json . RawMessage json . Unmarshal ( tasksMetadataRawMsg , & tasksMetadataMap ) if tasksMetadataMap [ "Tasks" ] == nil { return notEmptyErrMsg ( "Tasks" ) } var tasksMetadataArray [ ] json . RawMessage json . Unmarshal ( tasksMetadataMap [ "Tasks" ] , & tasksMetadataArray ) if len ( tasksMetadataArray ) != 1 { return fmt . Errorf ( "incorrect number of tasks, expected 1, received %d" , len ( tasksMetadataArray ) ) } return verifyTaskMetadata ( tasksMetadataArray [ 0 ] ) }
2479	func ( p * player ) MoveForward ( ) { w , h := gophersImage . Size ( ) mx := w * 16 my := h * 16 s , c := math . Sincos ( float64 ( p . angle ) * 2 * math . Pi / maxAngle ) p . x16 += int ( round ( 16 * c ) * 2 ) p . y16 += int ( round ( 16 * s ) * 2 ) for mx <= p . x16 { p . x16 -= mx } for my <= p . y16 { p . y16 -= my } for p . x16 < 0 { p . x16 += mx } for p . y16 < 0 { p . y16 += my } }
918	func ( d * BaseDriver ) GetIP ( ) ( string , error ) { if d . IPAddress == "" { return "" , errors . New ( "IP address is not set" ) } return d . IPAddress , nil }
515	func ( h * RequestHeader ) DelAllCookies ( ) { h . parseRawHeaders ( ) h . collectCookies ( ) h . cookies = h . cookies [ : 0 ] }
6364	func ( w * Writer ) Levels ( ) map [ string ] string { w . mutex . Lock ( ) defer w . mutex . Unlock ( ) if w . levels == nil { w . setLevels ( Levels ) } levels := make ( map [ string ] string ) for level , effect := range w . levels { levels [ level ] = effect } return levels }
887	func MigrateHostMetadataV0ToHostMetadataV1 ( m * MetadataV0 ) * Metadata { hostMetadata := & Metadata { } hostMetadata . DriverName = m . DriverName hostMetadata . HostOptions . EngineOptions = & engine . Options { } hostMetadata . HostOptions . AuthOptions = & auth . Options { StorePath : m . StorePath , CaCertPath : m . CaCertPath , CaCertRemotePath : "" , ServerCertPath : m . ServerCertPath , ServerKeyPath : m . ServerKeyPath , ClientKeyPath : "" , ServerCertRemotePath : "" , ServerKeyRemotePath : "" , CaPrivateKeyPath : m . PrivateKeyPath , ClientCertPath : m . ClientCertPath , } hostMetadata . ConfigVersion = m . ConfigVersion return hostMetadata }
5954	func ( s Scan ) AddPorts ( ports ... uint16 ) Scan { s . configPorts = append ( s . configPorts , ports ... ) return s }
3774	func ( client * Client ) GetScreenboard ( id interface { } ) ( * Screenboard , error ) { stringId , err := GetStringId ( id ) if err != nil { return nil , err } out := & Screenboard { } if err := client . doJsonRequest ( "GET" , fmt . Sprintf ( "/v1/screen/%s" , stringId ) , nil , out ) ; err != nil { return nil , err } return out , nil }
453	func ( s * Server ) Serve ( ln net . Listener ) error { var lastOverflowErrorTime time . Time var lastPerIPErrorTime time . Time var c net . Conn var err error s . mu . Lock ( ) { if s . ln != nil { s . mu . Unlock ( ) return ErrAlreadyServing } s . ln = ln s . done = make ( chan struct { } ) } s . mu . Unlock ( ) maxWorkersCount := s . getConcurrency ( ) s . concurrencyCh = make ( chan struct { } , maxWorkersCount ) wp := & workerPool { WorkerFunc : s . serveConn , MaxWorkersCount : maxWorkersCount , LogAllErrors : s . LogAllErrors , Logger : s . logger ( ) , connState : s . setState , } wp . Start ( ) atomic . AddInt32 ( & s . open , 1 ) defer atomic . AddInt32 ( & s . open , - 1 ) for { if c , err = acceptConn ( s , ln , & lastPerIPErrorTime ) ; err != nil { wp . Stop ( ) if err == io . EOF { return nil } return err } s . setState ( c , StateNew ) atomic . AddInt32 ( & s . open , 1 ) if ! wp . Serve ( c ) { atomic . AddInt32 ( & s . open , - 1 ) s . writeFastError ( c , StatusServiceUnavailable , "The connection cannot be served because Server.Concurrency limit exceeded" ) c . Close ( ) s . setState ( c , StateClosed ) if time . Since ( lastOverflowErrorTime ) > time . Minute { s . logger ( ) . Printf ( "The incoming connection cannot be served, because %d concurrent connections are served. " + "Try increasing Server.Concurrency" , maxWorkersCount ) lastOverflowErrorTime = time . Now ( ) } if s . SleepWhenConcurrencyLimitsExceeded > 0 { time . Sleep ( s . SleepWhenConcurrencyLimitsExceeded ) } } c = nil } }
3863	func ( c * Cursor ) Backspace ( ) { a := c . input i := c . Position if i == 0 { return } if i == len ( a ) { c . input = a [ : i - 1 ] } else { c . input = append ( a [ : i - 1 ] , a [ i : ] ... ) } c . Move ( - 1 ) }
6002	func JsonFile ( path string ) ( Typed , error ) { data , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } return Json ( data ) }
3428	func ( o * Options ) GetNotifyAudit ( ) bool { if o == nil || o . NotifyAudit == nil { return false } return * o . NotifyAudit }
785	func NewNoopRegistry ( provider provider . Provider ) ( * NoopRegistry , error ) { return & NoopRegistry { provider : provider , } , nil }
2034	func ( retriever * macAddressRetriever ) retrieve ( ) ( string , error ) { backoff := retry . NewExponentialBackoff ( macAddressBackoffMin , macAddressBackoffMax , macAddressBackoffJitter , macAddressBackoffMultiple ) ctx , cancel := context . WithTimeout ( retriever . ctx , retriever . timeout ) defer cancel ( ) err := retry . RetryWithBackoffCtx ( ctx , backoff , func ( ) error { retErr := retriever . retrieveOnce ( ) if retErr != nil { seelog . Warnf ( "Unable to retrieve mac address for device '%s': %v" , retriever . dev , retErr ) return retErr } if retriever . macAddress == "" { seelog . Debugf ( "Empty mac address for device '%s'" , retriever . dev ) return errors . Errorf ( "eni mac address: retrieved empty address for device %s" , retriever . dev ) } return nil } ) if err != nil { return "" , err } if err = ctx . Err ( ) ; err != nil { return "" , errors . Wrapf ( err , "eni mac address: timed out waiting for eni device '%s'" , retriever . dev ) } return retriever . macAddress , nil }
2661	func expandBaseClusterDasAdmissionControlPolicy ( d * schema . ResourceData , policy string , version viapi . VSphereVersion , ) types . BaseClusterDasAdmissionControlPolicy { var obj types . BaseClusterDasAdmissionControlPolicy switch policy { case clusterAdmissionControlTypeResourcePercentage : obj = expandClusterFailoverResourcesAdmissionControlPolicy ( d , version ) case clusterAdmissionControlTypeSlotPolicy : obj = expandClusterFailoverLevelAdmissionControlPolicy ( d ) case clusterAdmissionControlTypeFailoverHosts : obj = expandClusterFailoverHostAdmissionControlPolicy ( d , version ) case clusterAdmissionControlTypeDisabled : return nil } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . GetClusterDasAdmissionControlPolicy ( ) . ResourceReductionToToleratePercent = int32 ( d . Get ( "ha_admission_control_host_failure_tolerance" ) . ( int ) ) } return obj }
4295	func SelinuxEnabled ( ) bool { if selinuxEnabledChecked { return selinuxEnabled } selinuxEnabledChecked = true if fs := getSelinuxMountPoint ( ) ; fs != "" { if con , _ := Getcon ( ) ; con != "kernel" { selinuxEnabled = true } } return selinuxEnabled }
2343	func IsMouseButtonPressed ( mouseButton MouseButton ) bool { return uiDriver ( ) . Input ( ) . IsMouseButtonPressed ( driver . MouseButton ( mouseButton ) ) }
3481	func ( r * reqGetEvent ) HasEvent ( ) bool { if r != nil && r . Event != nil { return true } return false }
4722	func ParseJSONBody ( r io . Reader ) ( interface { } , error ) { var v interface { } if err := json . NewDecoder ( r ) . Decode ( & v ) ; err != nil { return nil , err } return v , nil }
4181	func ( m * yamlManager ) GetGlobalConfig ( ) ( * GlobalConfig , error ) { globalConfig := & GlobalConfig { } LoadFile ( path . Join ( m . ConfigDir , "cf-mgmt.yml" ) , globalConfig ) if len ( globalConfig . MetadataPrefix ) == 0 { globalConfig . MetadataPrefix = "cf-mgmt.pivotal.io" } return globalConfig , nil }
4867	func ( r * RateLimiter ) Attempt ( id string ) ( bool , error ) { hash := r . hasher . Hash ( id ) exists := true val , err := r . redisClient . Get ( hash ) . Result ( ) if err != nil { if err == redis . Nil { exists = false } else { return false , err } } if exists { intVal , err := strconv . ParseInt ( val , 10 , 64 ) if err != nil { return false , err } if intVal >= r . max { return false , nil } } err = r . redisClient . Watch ( func ( rx * redis . Tx ) error { _ , err := rx . Pipelined ( func ( pipe * redis . Pipeline ) error { if err := pipe . Incr ( hash ) . Err ( ) ; err != nil { return err } return pipe . Expire ( hash , r . hasher . Duration ( ) ) . Err ( ) } ) return err } ) if err != nil { return false , err } return true , nil }
1407	func NewMockECSSubmitStateSDK ( ctrl * gomock . Controller ) * MockECSSubmitStateSDK { mock := & MockECSSubmitStateSDK { ctrl : ctrl } mock . recorder = & MockECSSubmitStateSDKMockRecorder { mock } return mock }
2320	func ( v * DragContext ) native ( ) * C . GdkDragContext { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDragContext ( p ) }
9	func ( ev * evaluator ) errorf ( format string , args ... interface { } ) { ev . error ( errors . Errorf ( format , args ... ) ) }
6747	func ( c * MConnection ) sendSomeMsgPackets ( ) bool { c . sendMonitor . Limit ( maxMsgPacketTotalSize , atomic . LoadInt64 ( & c . config . SendRate ) , true ) for i := 0 ; i < numBatchMsgPackets ; i ++ { if c . sendMsgPacket ( ) { return true } } return false }
7306	func ( b Bucket ) Put ( k [ ] [ ] byte , v [ ] byte ) error { bb , err := b . CreateBucketIfNotExists ( k [ : len ( k ) - 1 ] ) if err != nil { return errorsp . WithStacksAndMessage ( err , "CreateBucketIfNotExists %q failed" , string ( bytes . Join ( k [ : len ( k ) - 1 ] , [ ] byte ( " " ) ) ) ) } return errorsp . WithStacks ( bb . Bucket . Put ( k [ len ( k ) - 1 ] , v ) ) }
3722	func ( w * Widget ) GetTickOk ( ) ( bool , bool ) { if w == nil || w . Tick == nil { return false , false } return * w . Tick , true }
4912	func ( r * Reader ) ReadInt32 ( ) int32 { if r . err != nil { return 0 } var n int n , r . err = io . ReadFull ( r . rd , r . b [ : 4 ] ) r . cnt += n if r . err != nil { return 0 } return int32 ( binary . LittleEndian . Uint32 ( r . b [ : 4 ] ) ) }
1214	func ( dg * dockerGoClient ) LoadImage ( ctx context . Context , inputStream io . Reader , timeout time . Duration ) error { ctx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) defer metrics . MetricsEngineGlobal . RecordDockerMetric ( "LOAD_IMAGE" ) ( ) response := make ( chan error , 1 ) go func ( ) { response <- dg . loadImage ( ctx , inputStream ) } ( ) select { case resp := <- response : return resp case <- ctx . Done ( ) : return & DockerTimeoutError { timeout , "loading image" } } }
5000	func ( d * Dataset ) Rename ( name string , createParent bool , recursiveRenameSnapshots bool ) ( * Dataset , error ) { args := make ( [ ] string , 3 , 5 ) args [ 0 ] = "rename" args [ 1 ] = d . Name args [ 2 ] = name if createParent { args = append ( args , "-p" ) } if recursiveRenameSnapshots { args = append ( args , "-r" ) } _ , err := zfs ( args ... ) if err != nil { return d , err } return GetDataset ( name ) }
1145	func ( m * MockTaskEngine ) StateChangeEvents ( ) chan statechange . Event { ret := m . ctrl . Call ( m , "StateChangeEvents" ) ret0 , _ := ret [ 0 ] . ( chan statechange . Event ) return ret0 }
6950	func ( e * EnvVar ) Set ( key , value string ) { keyVal := key + "=" + value for i , v := range * e { env := strings . SplitN ( v , "=" , 2 ) if len ( env ) < 2 { continue } if env [ 0 ] == key { ( * e ) [ i ] = keyVal return } } * e = append ( * e , keyVal ) }
3769	func ( client * Client ) GetAPIKeys ( ) ( [ ] APIKey , error ) { var out reqAPIKeys if err := client . doJsonRequest ( "GET" , "/v1/api_key" , nil , & out ) ; err != nil { return nil , err } return out . APIKeys , nil }
4697	func ( e * htmlTag ) noCloseTag ( ) bool { for _ , name := range e . opts . NoCloseTagNames { if e . tagName == name { return true } } return false }
3925	func ForArch ( arch string ) * Sizes { wordSize := int64 ( 8 ) maxAlign := int64 ( 8 ) switch build . Default . GOARCH { case "386" , "arm" : wordSize , maxAlign = 4 , 4 case "amd64p32" : wordSize = 4 } return & Sizes { WordSize : wordSize , MaxAlign : maxAlign } }
6972	func Load ( ) ( * GConfig , error ) { flag . Parse ( ) gc := new ( GConfig ) gc . Profile = loadProfile ( ) p , err := loadPath ( ) if err != nil { return configError ( err , "Error reading config directory path %s" , p ) } files , err := ioutil . ReadDir ( p ) if err != nil { return configError ( err , "Error reading config directory in path %s" , cpath ) } if len ( files ) == 0 { return configError ( ErrConfigFileRequired , "Config file not found in path %s" , cpath ) } for _ , f := range files { cfpath := filepath . Join ( p , f . Name ( ) ) pf := fmt . Sprintf ( "application-%s.properties" , gc . Profile ) if f . Name ( ) == StandardPropFileName || pf == f . Name ( ) { cf , err := readPropertyFile ( f , cfpath ) if err != nil { return configError ( err , "Error opening config file %s" , f ) } gc . addConfigFile ( cf ) } } Gcg = gc if gc . isEmpty ( ) { log . Printf ( "Configuration loaded, but empty for profile: '%s'\n" , \n ) } else Gcg . Profile { log . Printf ( "Configuration loaded for profile %s\n" , \n ) } }
7285	func ( s NetworkSettings ) PortAt ( index int ) ( string , * HostPublish ) { counter := 0 for k , v := range s . Ports { if counter != index { counter ++ continue } return k , v } return "" , nil }
693	func ( p * dnsimpleProvider ) GetRecordID ( zone string , recordName string ) ( recordID int , err error ) { page := 1 listOptions := & dnsimple . ZoneRecordListOptions { Name : recordName } for { listOptions . Page = page records , err := p . client . ListRecords ( p . accountID , zone , listOptions ) if err != nil { return 0 , err } for _ , record := range records . Data { if record . Name == recordName { return record . ID , nil } } page ++ if page > records . Pagination . TotalPages { break } } return 0 , fmt . Errorf ( "No record id found" ) }
3210	func ( client * Client ) DeleteBoard ( id string ) error { return client . doJsonRequest ( "DELETE" , fmt . Sprintf ( "/v1/dashboard/%s" , id ) , nil , nil ) }
6264	func ( s * Server ) Mux ( ) * http . ServeMux { return s . srv . Handler . ( * http . ServeMux ) }
5826	func ( a * API ) FetchRuleSetGroup ( cid CIDType ) ( * RuleSetGroup , error ) { if cid == nil || * cid == "" { return nil , fmt . Errorf ( "Invalid rule set group CID [none]" ) } groupCID := string ( * cid ) matched , err := regexp . MatchString ( config . RuleSetGroupCIDRegex , groupCID ) if err != nil { return nil , err } if ! matched { return nil , fmt . Errorf ( "Invalid rule set group CID [%s]" , groupCID ) } result , err := a . Get ( groupCID ) if err != nil { return nil , err } if a . Debug { a . Log . Printf ( "[DEBUG] fetch rule set group, received JSON: %s" , string ( result ) ) } rulesetGroup := & RuleSetGroup { } if err := json . Unmarshal ( result , rulesetGroup ) ; err != nil { return nil , err } return rulesetGroup , nil }
5268	func OptQueryShards ( shards ... uint64 ) QueryOption { return func ( options * QueryOptions ) error { options . Shards = append ( options . Shards , shards ... ) return nil } }
6954	func ( s * Set ) Add ( value interface { } ) { s . Lock ( ) defer s . Unlock ( ) s . m [ value ] = struct { } { } }
3674	func ( w * Widget ) GetLegendOk ( ) ( bool , bool ) { if w == nil || w . Legend == nil { return false , false } return * w . Legend , true }
1888	func ( engine * DockerTaskEngine ) Init ( ctx context . Context ) error { derivedCtx , cancel := context . WithCancel ( ctx ) engine . stopEngine = cancel engine . ctx = derivedCtx err := engine . openEventstream ( derivedCtx ) if err != nil { return err } engine . synchronizeState ( ) go engine . handleDockerEvents ( derivedCtx ) engine . initialized = true return nil }
912	func ( d * Driver ) waitForIP ( ) ( string , error ) { log . Infof ( "Waiting for host to start..." ) for { ip , _ := d . GetIP ( ) if ip != "" { return ip , nil } time . Sleep ( 1 * time . Second ) } }
2627	func SetStringPolicy ( d * schema . ResourceData , key string , val * types . StringPolicy ) error { if val == nil { return nil } err := d . Set ( key , val . Value ) return err }
969	func ( c * AuthConfig ) String ( ) string { if ! BoolVal ( c . Enabled ) { return "" } if c . Password != nil { return fmt . Sprintf ( "%s:%s" , StringVal ( c . Username ) , StringVal ( c . Password ) ) } return StringVal ( c . Username ) }
1342	func ( manager * basicStateManager ) Save ( ) error { defer metrics . MetricsEngineGlobal . RecordStateManagerMetric ( "SAVE" ) ( ) manager . saveTimesLock . Lock ( ) defer manager . saveTimesLock . Unlock ( ) if time . Since ( manager . lastSave ) >= minSaveInterval { err := manager . ForceSave ( ) manager . lastSave = time . Now ( ) manager . nextPlannedSave = time . Time { } return err } else if manager . nextPlannedSave . IsZero ( ) { next := manager . lastSave . Add ( minSaveInterval ) manager . nextPlannedSave = next go func ( ) { time . Sleep ( next . Sub ( time . Now ( ) ) ) manager . Save ( ) } ( ) } return nil }
22	func dateWrapper ( vals [ ] Value , enh * EvalNodeHelper , f func ( time . Time ) float64 ) Vector { if len ( vals ) == 0 { return append ( enh . out , Sample { Metric : labels . Labels { } , Point : Point { V : f ( time . Unix ( enh . ts / 1000 , 0 ) . UTC ( ) ) } , } ) } for _ , el := range vals [ 0 ] . ( Vector ) { t := time . Unix ( int64 ( el . V ) , 0 ) . UTC ( ) enh . out = append ( enh . out , Sample { Metric : enh . dropMetricName ( el . Metric ) , Point : Point { V : f ( t ) } , } ) } return enh . out }
4273	func createDeviceNode ( rootfs string , node * configs . Device , bind bool ) error { dest := filepath . Join ( rootfs , node . Path ) if err := os . MkdirAll ( filepath . Dir ( dest ) , 0755 ) ; err != nil { return err } if bind { f , err := os . Create ( dest ) if err != nil && ! os . IsExist ( err ) { return err } if f != nil { f . Close ( ) } return syscall . Mount ( node . Path , dest , "bind" , syscall . MS_BIND , "" ) } if err := mknodDevice ( dest , node ) ; err != nil { if os . IsExist ( err ) { return nil } return err } return nil }
4713	func newLine ( no int , str string , opts * Options , f * File ) * line { return & line { no : no , str : str , indent : indent ( str ) , tokens : strings . Split ( strings . TrimLeft ( str , space ) , space ) , opts : opts , file : f , } }
5643	func BTCAddrFromPubKeyBytes ( pubKeyBytes [ ] byte ) string { versionPrefix := btcPrefixPubKeyHash h160 := CalcHash160 ( pubKeyBytes ) h160 = append ( [ ] byte { versionPrefix } , h160 ... ) checksum := CalcHash256 ( h160 ) b := append ( h160 , checksum [ : 4 ] ... ) return base58 . Encode ( b ) }
1510	func ( secret * ASMSecretResource ) MarshalJSON ( ) ( [ ] byte , error ) { if secret == nil { return nil , errors . New ( "asmsecret resource is nil" ) } createdAt := secret . GetCreatedAt ( ) return json . Marshal ( ASMSecretResourceJSON { TaskARN : secret . taskARN , CreatedAt : & createdAt , DesiredStatus : func ( ) * ASMSecretStatus { desiredState := secret . GetDesiredStatus ( ) s := ASMSecretStatus ( desiredState ) return & s } ( ) , KnownStatus : func ( ) * ASMSecretStatus { knownState := secret . GetKnownStatus ( ) s := ASMSecretStatus ( knownState ) return & s } ( ) , RequiredSecrets : secret . getRequiredSecrets ( ) , ExecutionCredentialsID : secret . getExecutionCredentialsID ( ) , } ) }
6823	func DumpMetrics ( ctx context . Context , task string ) ( string , error ) { gatherer := prometheus . DefaultGatherer mfs , err := gatherer . Gather ( ) if err != nil { return "" , errors . Wrap ( err , "gathering metrics" ) } buf := & bytes . Buffer { } enc := expfmt . NewEncoder ( buf , expfmt . FmtText ) for _ , mf := range mfs { if err := enc . Encode ( mf ) ; err != nil { return buf . String ( ) , errors . Wrap ( err , "encoding metrics" ) } } return buf . String ( ) , nil }
3620	func ( t * ToggleStatus ) GetNewStatusOk ( ) ( string , bool ) { if t == nil || t . NewStatus == nil { return "" , false } return * t . NewStatus , true }
1225	func ( ts * TaskStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == "null" { * ts = TaskStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * ts = TaskStatusNone return errors . New ( "TaskStatus must be a string or null" ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) if strStatus == "UNKNOWN" { * ts = TaskStatusNone return nil } if strStatus == "DEAD" { * ts = TaskStopped return nil } stat , ok := taskStatusMap [ strStatus ] if ! ok { * ts = TaskStatusNone return errors . New ( "Unrecognized TaskStatus" ) } * ts = stat return nil }
789	func CreateTLSConfig ( prefix string ) ( * tls . Config , error ) { caFile := os . Getenv ( fmt . Sprintf ( "%s_CA_FILE" , prefix ) ) certFile := os . Getenv ( fmt . Sprintf ( "%s_CERT_FILE" , prefix ) ) keyFile := os . Getenv ( fmt . Sprintf ( "%s_KEY_FILE" , prefix ) ) serverName := os . Getenv ( fmt . Sprintf ( "%s_TLS_SERVER_NAME" , prefix ) ) isInsecureStr := strings . ToLower ( os . Getenv ( fmt . Sprintf ( "%s_TLS_INSECURE" , prefix ) ) ) isInsecure := isInsecureStr == "true" || isInsecureStr == "yes" || isInsecureStr == "1" tlsConfig , err := NewTLSConfig ( certFile , keyFile , caFile , serverName , isInsecure , defaultMinVersion ) if err != nil { return nil , err } return tlsConfig , nil }
6452	func ( m * modulePat ) match ( file string ) bool { if m . literal { return file == m . pattern } match , _ := filepath . Match ( m . pattern , file ) return match }
5243	func ( c * Client ) Query ( query PQLQuery , options ... interface { } ) ( * QueryResponse , error ) { span := c . tracer . StartSpan ( "Client.Query" ) defer span . Finish ( ) if err := query . Error ( ) ; err != nil { return nil , err } queryOptions := & QueryOptions { } err := queryOptions . addOptions ( options ... ) if err != nil { return nil , err } serializedQuery := query . Serialize ( ) data , err := makeRequestData ( serializedQuery . String ( ) , queryOptions ) if err != nil { return nil , errors . Wrap ( err , "making request data" ) } useCoordinator := serializedQuery . HasWriteKeys ( ) path := fmt . Sprintf ( "/index/%s/query" , query . Index ( ) . name ) _ , buf , err := c . httpRequest ( "POST" , path , data , defaultProtobufHeaders ( ) , useCoordinator ) if err != nil { return nil , err } iqr := & pbuf . QueryResponse { } err = proto . Unmarshal ( buf , iqr ) if err != nil { return nil , err } queryResponse , err := newQueryResponseFromInternal ( iqr ) if err != nil { return nil , err } return queryResponse , nil }
1313	func ( err CannotStopContainerError ) IsRetriableError ( ) bool { if _ , ok := err . FromError . ( NoSuchContainerError ) ; ok { return false } return true }
1219	func ( imageState * ImageState ) RemoveImageName ( containerImageName string ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) for i , imageName := range imageState . Image . Names { if imageName == containerImageName { imageState . Image . Names = append ( imageState . Image . Names [ : i ] , imageState . Image . Names [ i + 1 : ] ... ) } } }
1346	func onSteadyStateIsResolved ( target * apicontainer . Container , run * apicontainer . Container ) bool { return target . GetDesiredStatus ( ) >= apicontainerstatus . ContainerCreated && run . GetKnownStatus ( ) >= run . GetSteadyStateStatus ( ) }
101	func ( t * Target ) LastScrapeDuration ( ) time . Duration { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . lastScrapeDuration }
4647	func NewClusteringIndex ( ) * ClusteringIndex { index := & ClusteringIndex { } index . streetLevel = NewPointsIndex ( Km ( 0.5 ) ) index . cityLevel = NewCountIndex ( Km ( 10 ) ) index . worldLevel = NewCountIndex ( Km ( 500 ) ) return index }
6744	func ( c * MConnection ) TrySend ( chID byte , msg interface { } ) bool { if ! c . IsRunning ( ) { return false } log . Debug ( "TrySend" , "channel" , chID , "conn" , c , "msg" , msg ) channel , ok := c . channelsIdx [ chID ] if ! ok { log . Error ( cmn . Fmt ( "Cannot send bytes, unknown channel %X" , chID ) ) return false } ok = channel . trySendBytes ( wire . BinaryBytes ( msg ) ) if ok { select { case c . send <- struct { } { } : default : } } return ok }
5610	func ( o * GetVMByCidParams ) WithTimeout ( timeout time . Duration ) * GetVMByCidParams { o . SetTimeout ( timeout ) return o }
4621	func stacks ( ) [ ] byte { buf := make ( [ ] byte , 1024 * 16 ) for { n := runtime . Stack ( buf , true ) if n < len ( buf ) { return buf [ : n ] } buf = make ( [ ] byte , 2 * len ( buf ) ) } }
5873	func countNewTags ( currTags [ ] string , newTags [ ] string ) int { if len ( newTags ) == 0 { return 0 } if len ( currTags ) == 0 { return len ( newTags ) } newTagCount := 0 for _ , newTag := range newTags { found := false for _ , currTag := range currTags { if newTag == currTag { found = true break } } if ! found { newTagCount ++ } } return newTagCount }
6577	func DisablePassiveSvcChecks ( host_name string , service_description string , ) * livestatus . Command { return livestatus . NewCommand ( "DISABLE_PASSIVE_SVC_CHECKS" , stringifyArg ( "host_name" , "string" , host_name ) , stringifyArg ( "service_description" , "string" , service_description ) , ) }
5350	func _MSet ( filename string , keys , values [ ] string ) error { if len ( keys ) != len ( values ) { return fmt . Errorf ( "number of keys is different to number of values" ) } conf , err := shconf . ParseFile ( filename ) if err != nil { if err != os . ErrNotExist { return err } println ( "ErrNotExist" ) } var buf bytes . Buffer for i , key := range keys { if _ , err = conf . Get ( key ) ; err != nil { continue } buf . WriteString ( key ) buf . Write ( conf . Separator ( ) ) buf . WriteString ( values [ i ] ) buf . WriteByte ( '\n' ) } return file . Append ( filename , buf . Bytes ( ) ) }
5055	func ( s * Session ) BuildInfo ( ) ( info BuildInfo , err error ) { err = s . Run ( bson . D { { "buildInfo" , "1" } } , & info ) if len ( info . VersionArray ) == 0 { for _ , a := range strings . Split ( info . Version , "." ) { i , err := strconv . Atoi ( a ) if err != nil { break } info . VersionArray = append ( info . VersionArray , i ) } } for len ( info . VersionArray ) < 4 { info . VersionArray = append ( info . VersionArray , 0 ) } if i := strings . IndexByte ( info . GitVersion , ' ' ) ; i >= 0 { info . GitVersion = info . GitVersion [ : i ] } return }
4199	func ( m * Manager ) DisablePublicServiceAccess ( serviceInfo * ServiceInfo ) error { for _ , servicePlan := range serviceInfo . AllPlans ( ) { for _ , plan := range servicePlan { if plan . Public { err := m . Client . MakeServicePlanPrivate ( plan . GUID ) if err != nil { return err } } } } return nil }
2287	func ( v * Spinner ) native ( ) * C . GtkSpinner { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSpinner ( p ) }
777	func ( in * DNSEndpointList ) DeepCopy ( ) * DNSEndpointList { if in == nil { return nil } out := new ( DNSEndpointList ) in . DeepCopyInto ( out ) return out }
5546	func ( c * Client ) KeepAlive ( ) { for _ = range time . Tick ( 60 * time . Second ) { c . connection . KeepAlive ( ) } }
1814	func ( m * MockDockerClient ) WithVersion ( arg0 dockerclient . DockerVersion ) dockerapi . DockerClient { ret := m . ctrl . Call ( m , "WithVersion" , arg0 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerClient ) return ret0 }
4395	func ( id * ObjectId ) UnmarshalEasyJSON ( in * jlexer . Lexer ) { if data := in . String ( ) ; in . Ok ( ) { * id = NewObjectId ( data ) } }
7100	func ( g GRPCLoggerV2 ) Warningf ( format string , args ... interface { } ) { g . l . Warningf ( format , args ... ) }
5084	func ( socket * mongoSocket ) Release ( ) { socket . Lock ( ) if socket . references == 0 { panic ( "socket.Release() with references == 0" ) } socket . references -- stats . socketRefs ( - 1 ) if socket . references == 0 { stats . socketsInUse ( - 1 ) server := socket . server socket . Unlock ( ) socket . LogoutAll ( ) if server != nil { server . RecycleSocket ( socket ) } } else { socket . Unlock ( ) } }
4368	func Parse ( selector string ) ( Op , error ) { segments := strings . Split ( selector , "." ) ops := make ( [ ] Op , 0 , len ( segments ) ) for _ , segment := range segments { key := strings . TrimSpace ( segment ) if key == "" { continue } if op , ok := parseArray ( key ) ; ok { ops = append ( ops , op ) continue } ops = append ( ops , Dot ( key ) ) } return Chain ( ops ... ) , nil }
4415	func ( e * Email ) DeepCopy ( ) * Email { if e == nil { return nil } out := new ( Email ) e . DeepCopyInto ( out ) return out }
1930	func NewMockTaskEngineState ( ctrl * gomock . Controller ) * MockTaskEngineState { mock := & MockTaskEngineState { ctrl : ctrl } mock . recorder = & MockTaskEngineStateMockRecorder { mock } return mock }
4492	func DateTimeValue ( v * strfmt . DateTime ) strfmt . DateTime { if v == nil { return strfmt . DateTime { } } return * v }
5819	func ( cm * CheckManager ) makeSecret ( ) ( string , error ) { hash := sha256 . New ( ) x := make ( [ ] byte , 2048 ) if _ , err := rand . Read ( x ) ; err != nil { return "" , err } hash . Write ( x ) return hex . EncodeToString ( hash . Sum ( nil ) ) [ 0 : 16 ] , nil }
2919	func createSCSIController ( l * object . VirtualDeviceList , ct string , st string ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { nc , err := l . CreateSCSIController ( ct ) if err != nil { return nil , err } nc . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus = types . VirtualSCSISharing ( st ) cspec , err := object . VirtualDeviceList { nc } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) * l = applyDeviceChange ( * l , cspec ) return cspec , err }
3096	func ( ctx * Context ) ChangeStaticPath ( oldPath , newPath string ) { if ! filepath . IsAbs ( oldPath ) { oldPath = filepath . Join ( Root , oldPath ) } dir := statics . Get ( oldPath ) if dir != nil { statics . Delete ( oldPath ) if ! filepath . IsAbs ( newPath ) { newPath = filepath . Join ( Root , newPath ) } * dir = http . Dir ( newPath ) statics . Set ( dir ) } }
3934	func NewMetricsHandler ( registry prometheus . Registerer , namespace string ) Handler { return & metricsHandler { handler : NewHandler ( ) , registry : registry , namespace : namespace , } }
6655	func ( v Vec3 ) Dot2D ( u Vec3 ) float32 { return v [ 0 ] * u [ 0 ] + v [ 2 ] * u [ 2 ] }
336	func ( d * Discovery ) refresh ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { t0 := time . Now ( ) defer func ( ) { fileSDScanDuration . Observe ( time . Since ( t0 ) . Seconds ( ) ) } ( ) ref := map [ string ] int { } for _ , p := range d . listFiles ( ) { tgroups , err := d . readFile ( p ) if err != nil { fileSDReadErrorsCount . Inc ( ) level . Error ( d . logger ) . Log ( "msg" , "Error reading file" , "path" , p , "err" , err ) ref [ p ] = d . lastRefresh [ p ] continue } select { case ch <- tgroups : case <- ctx . Done ( ) : return } ref [ p ] = len ( tgroups ) } for f , n := range d . lastRefresh { m , ok := ref [ f ] if ! ok || n > m { level . Debug ( d . logger ) . Log ( "msg" , "file_sd refresh found file that should be removed" , "file" , f ) d . deleteTimestamp ( f ) for i := m ; i < n ; i ++ { select { case ch <- [ ] * targetgroup . Group { { Source : fileSource ( f , i ) } } : case <- ctx . Done ( ) : return } } } } d . lastRefresh = ref d . watchFiles ( ) }
142	func lintMetricUnits ( mf dto . MetricFamily ) [ ] Problem { var problems problems unit , base , ok := metricUnits ( * mf . Name ) if ! ok { return nil } if unit == base { return nil } problems . Add ( mf , fmt . Sprintf ( "use base unit %q instead of %q" , base , unit ) ) return problems }
3377	func ( i * IntegrationGCPCreateRequest ) GetTokenURIOk ( ) ( string , bool ) { if i == nil || i . TokenURI == nil { return "" , false } return * i . TokenURI , true }
3396	func ( m * Monitor ) GetOverallStateOk ( ) ( string , bool ) { if m == nil || m . OverallState == nil { return "" , false } return * m . OverallState , true }
3918	func NewLinter ( name string , config LinterConfig ) ( * Linter , error ) { if p , ok := predefinedPatterns [ config . Pattern ] ; ok { config . Pattern = p } regex , err := regexp . Compile ( "(?m:" + config . Pattern + ")" ) if err != nil { return nil , err } if config . PartitionStrategy == nil { config . PartitionStrategy = partitionPathsAsDirectories } return & Linter { LinterConfig : config , Name : name , regex : regex , } , nil }
2995	func hostVSwitchFromName ( client * govmomi . Client , ns * object . HostNetworkSystem , name string ) ( * types . HostVirtualSwitch , error ) { var mns mo . HostNetworkSystem pc := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) if err := pc . RetrieveOne ( ctx , ns . Reference ( ) , [ ] string { "networkInfo.vswitch" } , & mns ) ; err != nil { return nil , fmt . Errorf ( "error fetching host network properties: %s" , err ) } for _ , sw := range mns . NetworkInfo . Vswitch { if sw . Name == name { sw . Spec . Mtu = sw . Mtu return & sw , nil } } return nil , fmt . Errorf ( "could not find virtual switch %s" , name ) }
6346	func AbsoluteUrlFor ( name string , args ... string ) * url . URL { u := UrlFor ( name , args ... ) u . Host = UrlBase . Host u . Scheme = UrlBase . Scheme return u }
776	func ( in * DNSEndpoint ) DeepCopy ( ) * DNSEndpoint { if in == nil { return nil } out := new ( DNSEndpoint ) in . DeepCopyInto ( out ) return out }
4986	func ( c * Consumer ) Close ( ) error { c . connsLock . Lock ( ) defer c . connsLock . Unlock ( ) var errStrings [ ] string if len ( c . conns ) == 0 { return errors . New ( "connection does not exist" ) } for len ( c . conns ) > 0 { if err := c . conns [ 0 ] . close ( ) ; err != nil { errStrings = append ( errStrings , err . Error ( ) ) } c . conns = c . conns [ 1 : ] } if len ( errStrings ) > 0 { return fmt . Errorf ( strings . Join ( errStrings , ", " ) ) } return nil }
5883	func Transport ( transport http . RoundTripper ) Option { return func ( gsa * GServiceAccount ) error { gsa . transport = transport return nil } }
892	func ( d * Driver ) Create ( ) error { log . Infof ( "Generating SSH Key" ) if err := ssh . GenerateSSHKey ( d . GetSSHKeyPath ( ) ) ; err != nil { return err } log . Infof ( "Creating host..." ) c , err := newComputeUtil ( d ) if err != nil { return err } if err := c . openFirewallPorts ( d ) ; err != nil { return err } if d . UseExisting { return c . configureInstance ( d ) } return c . createInstance ( d ) }
2601	func FromMOID ( client * govmomi . Client , id string ) ( * object . DistributedVirtualPortgroup , error ) { finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : "DistributedVirtualPortgroup" , Value : id , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) ds , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , err } return ds . ( * object . DistributedVirtualPortgroup ) , nil }
1873	func ( mr * MockDockerMetadataClientMockRecorder ) InspectContainer ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "InspectContainer" , reflect . TypeOf ( ( * MockDockerMetadataClient ) ( nil ) . InspectContainer ) , arg0 , arg1 , arg2 ) }
6158	func ( w * Worker ) AgentPreOfferingDelete ( job * data . Job ) error { logger := w . logger . Add ( "method" , "AgentPreOfferingDelete" , "job" , job ) offering , err := w . relatedOffering ( logger , job , data . JobAgentPreOfferingDelete ) if err != nil { return err } if offering . Status != data . OfferRegistered && offering . Status != data . OfferPoppedUp { return ErrOfferNotRegistered } jobDate , err := w . publishData ( logger , job ) if err != nil { return err } key , err := w . accountKey ( logger , offering . Agent ) if err != nil { return err } offeringHash , err := data . HexToHash ( offering . Hash ) if err != nil { logger . Error ( err . Error ( ) ) return err } err = w . checkInPeriod ( logger , offeringHash , data . SettingsPeriodRemove , ErrOfferingDeletePeriodIsNotOver ) if err != nil { return err } auth := bind . NewKeyedTransactor ( key ) auth . GasLimit = w . gasConf . PSC . RemoveServiceOffering auth . GasPrice = new ( big . Int ) . SetUint64 ( jobDate . GasPrice ) tx , err := w . ethBack . PSCRemoveServiceOffering ( auth , offeringHash ) if err != nil { logger . Add ( "GasLimit" , auth . GasLimit , "GasPrice" , auth . GasPrice ) . Error ( err . Error ( ) ) return ErrPSCRemoveOffering } offering . Status = data . OfferRemoving if err := w . saveRecord ( logger , w . db . Querier , offering ) ; err != nil { return err } return w . saveEthTX ( logger , job , tx , "RemoveServiceOffering" , job . RelatedType , job . RelatedID , offering . Agent , data . HexFromBytes ( w . pscAddr . Bytes ( ) ) ) }
3492	func ( s * Screenboard ) GetSharedOk ( ) ( bool , bool ) { if s == nil || s . Shared == nil { return false , false } return * s . Shared , true }
2417	func InternalImageSize ( x int ) int { if x <= 0 { panic ( "graphics: x must be positive" ) } if x < minInternalImageSize { return minInternalImageSize } r := 1 for r < x { r <<= 1 } return r }
3274	func ( d * DashboardList ) GetDashboardCount ( ) int { if d == nil || d . DashboardCount == nil { return 0 } return * d . DashboardCount }
4028	func ( c * RadioGroup ) SetSelected ( id int ) bool { found := false if id < 0 || id >= len ( c . items ) { return false } for idx , item := range c . items { if idx == id { found = true item . SetSelected ( true ) } else { item . SetSelected ( false ) } } return found }
158	func ( s * shards ) start ( n int ) { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) newQueues := make ( [ ] chan prompb . TimeSeries , n ) for i := 0 ; i < n ; i ++ { newQueues [ i ] = make ( chan prompb . TimeSeries , s . qm . cfg . Capacity ) } s . queues = newQueues var hardShutdownCtx context . Context hardShutdownCtx , s . hardShutdown = context . WithCancel ( context . Background ( ) ) s . softShutdown = make ( chan struct { } ) s . running = int32 ( n ) s . done = make ( chan struct { } ) for i := 0 ; i < n ; i ++ { go s . runShard ( hardShutdownCtx , i , newQueues [ i ] ) } s . qm . numShardsMetric . Set ( float64 ( n ) ) }
6426	func ( q * Queue ) Next ( ) ( interface { } , bool ) { q . key . Lock ( ) defer q . key . Unlock ( ) if q . underlyer == nil { return nil , false } return q . underlyer . RemoveFront ( ) }
3646	func ( t * TraceServiceDefinition ) GetSpanName ( ) string { if t == nil || t . SpanName == nil { return "" } return * t . SpanName }
2730	func ( p * nasDatastoreMountProcessor ) processUnmountOperations ( ) error { hosts := p . diffOldNew ( ) if len ( hosts ) < 1 || p . ds == nil { return nil } for _ , hsID := range hosts { dss , err := hostDatastoreSystemFromHostSystemID ( p . client , hsID ) if err != nil { return fmt . Errorf ( "host %q: %s" , hostsystem . NameOrID ( p . client , hsID ) , err ) } if err := removeDatastore ( dss , p . ds ) ; err != nil { return fmt . Errorf ( "host %q: %s" , hostsystem . NameOrID ( p . client , hsID ) , err ) } } return nil }
3523	func ( s * SyntheticsLocation ) GetRegion ( ) string { if s == nil || s . Region == nil { return "" } return * s . Region }
2013	func ( manager * credentialsManager ) SetTaskCredentials ( taskCredentials * TaskIAMRoleCredentials ) error { manager . taskCredentialsLock . Lock ( ) defer manager . taskCredentialsLock . Unlock ( ) credentials := taskCredentials . IAMRoleCredentials if credentials . CredentialsID == "" { return fmt . Errorf ( "CredentialsId is empty" ) } if taskCredentials . ARN == "" { return fmt . Errorf ( "task ARN is empty" ) } manager . idToTaskCredentials [ credentials . CredentialsID ] = TaskIAMRoleCredentials { ARN : taskCredentials . ARN , IAMRoleCredentials : taskCredentials . GetIAMRoleCredentials ( ) , } return nil }
3207	func ( client * Client ) UpdateUser ( user User ) error { uri := "/v1/user/" + * user . Handle return client . doJsonRequest ( "PUT" , uri , user , nil ) }
4305	func MakeDisjointSet ( forests * Forests , name string ) { newDS := & DisjointSet { } newDS . represent = name members := make ( map [ string ] struct { } ) members [ name ] = struct { } { } newDS . members = members forests . mu . Lock ( ) defer forests . mu . Unlock ( ) forests . data [ newDS ] = struct { } { } }
605	func adminRouter ( ) chi . Router { r := chi . NewRouter ( ) r . Use ( AdminOnly ) r . Get ( "/" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( "admin: index" ) ) } ) r . Get ( "/accounts" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( "admin: list accounts.." ) ) } ) r . Get ( "/users/{userId}" , func ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( fmt . Sprintf ( "admin: view user id %v" , chi . URLParam ( r , "userId" ) ) ) ) } ) return r }
3242	func ( c * ChangeRequest ) GetShowPresentOk ( ) ( bool , bool ) { if c == nil || c . ShowPresent == nil { return false , false } return * c . ShowPresent , true }
5471	func ( c * QueueService ) Get ( ctx context . Context , sid string ) ( * Queue , error ) { queue := new ( Queue ) err := c . client . GetResource ( ctx , queuePathPart , sid , queue ) return queue , err }
85	func ( c * compressedResponseWriter ) Write ( p [ ] byte ) ( int , error ) { return c . writer . Write ( p ) }
2159	func ( v * VariantIter ) native ( ) * C . GVariantIter { if v == nil || v . GVariantIter == nil { return nil } p := unsafe . Pointer ( v . GVariantIter ) return C . toGVariantIter ( p ) }
2883	func ReferenceProperties ( client * govmomi . Client , net object . NetworkReference ) ( * mo . Network , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Network nc := object . NewCommon ( client . Client , net . Reference ( ) ) if err := nc . Properties ( ctx , nc . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil }
2218	func ( v * Bin ) native ( ) * C . GtkBin { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkBin ( p ) }
656	func ( sc * serviceSource ) filterByAnnotations ( services [ ] * v1 . Service ) ( [ ] * v1 . Service , error ) { labelSelector , err := metav1 . ParseToLabelSelector ( sc . annotationFilter ) if err != nil { return nil , err } selector , err := metav1 . LabelSelectorAsSelector ( labelSelector ) if err != nil { return nil , err } if selector . Empty ( ) { return services , nil } filteredList := [ ] * v1 . Service { } for _ , service := range services { annotations := labels . Set ( service . Annotations ) if selector . Matches ( annotations ) { filteredList = append ( filteredList , service ) } } return filteredList , nil }
4718	func Asset ( name string ) ( [ ] byte , error ) { if f , ok := _bindata [ name ] ; ok { return f ( ) } return nil , fmt . Errorf ( "Asset %s not found" , name ) }
2866	func ( v VSphereVersion ) String ( ) string { return fmt . Sprintf ( "%s %d.%d.%d build-%d" , v . Product , v . Major , v . Minor , v . Patch , v . Build ) }
5737	func TickerGo ( ticker <- chan time . Time , procfunc gp . ProcessFunc ) gp . Process { return gp . Go ( goCallOnTicker ( ticker , procfunc ) ) }
4433	func ( u * UUID4 ) UnmarshalJSON ( data [ ] byte ) error { if string ( data ) == jsonNull { return nil } l := jlexer . Lexer { Data : data } u . UnmarshalEasyJSON ( & l ) return l . Error ( ) }
6932	func NewDeriveScale ( v float64 , d time . Duration ) * Derive { return & Derive { value : math . Float64bits ( v ) , rate : Rate { time : time . Now ( ) . UnixNano ( ) , unit : d . Seconds ( ) , } , } }
4259	func ptsname ( f * os . File ) ( string , error ) { var n int32 if err := ioctl ( f . Fd ( ) , syscall . TIOCGPTN , uintptr ( unsafe . Pointer ( & n ) ) ) ; err != nil { return "" , err } return fmt . Sprintf ( "/dev/pts/%d" , n ) , nil }
868	func NewKeyPair ( ) ( keyPair * KeyPair , err error ) { priv , err := rsa . GenerateKey ( rand . Reader , 2048 ) if err != nil { return nil , ErrKeyGeneration } if err := priv . Validate ( ) ; err != nil { return nil , ErrValidation } privDer := x509 . MarshalPKCS1PrivateKey ( priv ) pubSSH , err := gossh . NewPublicKey ( & priv . PublicKey ) if err != nil { return nil , ErrPublicKey } return & KeyPair { PrivateKey : privDer , PublicKey : gossh . MarshalAuthorizedKey ( pubSSH ) , } , nil }
5836	func ( a * API ) DeleteDashboard ( cfg * Dashboard ) ( bool , error ) { if cfg == nil { return false , fmt . Errorf ( "Invalid dashboard config [nil]" ) } return a . DeleteDashboardByCID ( CIDType ( & cfg . CID ) ) }
6614	func NewThrottledBucket ( opThrottle Throttle , egressThrottle Throttle , wrapped gcs . Bucket ) ( b gcs . Bucket ) { b = & throttledBucket { opThrottle : opThrottle , egressThrottle : egressThrottle , wrapped : wrapped , } return }
1503	func ( b Conditional ) MarshalJSON ( ) ( [ ] byte , error ) { switch b { case ExplicitlyEnabled : return json . Marshal ( true ) case ExplicitlyDisabled : return json . Marshal ( false ) default : return json . Marshal ( nil ) } }
6163	func ( e Error ) Error ( ) string { if msg , ok := Message ( e ) ; ok { return fmt . Sprintf ( "%s (%d)" , msg , e ) } return "unknown error" }
2544	func expandCustomizationUserData ( d * schema . ResourceData ) types . CustomizationUserData { obj := types . CustomizationUserData { FullName : d . Get ( cWindowsKeyPrefix + "." + "full_name" ) . ( string ) , OrgName : d . Get ( cWindowsKeyPrefix + "." + "organization_name" ) . ( string ) , ComputerName : & types . CustomizationFixedName { Name : d . Get ( cWindowsKeyPrefix + "." + "computer_name" ) . ( string ) , } , ProductId : d . Get ( cWindowsKeyPrefix + "." + "product_key" ) . ( string ) , } return obj }
5796	func ( a * API ) DeleteOutlierReportByCID ( cid CIDType ) ( bool , error ) { if cid == nil || * cid == "" { return false , fmt . Errorf ( "Invalid outlier report CID [none]" ) } reportCID := string ( * cid ) matched , err := regexp . MatchString ( config . OutlierReportCIDRegex , reportCID ) if err != nil { return false , err } if ! matched { return false , fmt . Errorf ( "Invalid outlier report CID [%s]" , reportCID ) } _ , err = a . Delete ( reportCID ) if err != nil { return false , err } return true , nil }
5216	func OptFieldTypeInt ( min int64 , max int64 ) FieldOption { return func ( options * FieldOptions ) { options . fieldType = FieldTypeInt options . min = min options . max = max } }
5956	func ( s Scan ) SetTCPPorts ( ports ... uint16 ) Scan { s . configTCPPorts = ports return s }
1400	func parseAuthData ( authType string , authData json . RawMessage ) dockerAuths { intermediateAuthData := make ( dockerAuths ) switch authType { case "docker" : err := json . Unmarshal ( authData , & intermediateAuthData ) if err != nil { seelog . Warn ( "Could not parse 'docker' type auth config" ) return dockerAuths { } } case "dockercfg" : var base64dAuthInfo dockercfgData err := json . Unmarshal ( authData , & base64dAuthInfo ) if err != nil { seelog . Warn ( "Could not parse 'dockercfg' type auth config" ) return dockerAuths { } } for registry , auth := range base64dAuthInfo { data , err := base64 . StdEncoding . DecodeString ( auth . Auth ) if err != nil { seelog . Warnf ( "Malformed auth data for registry %v" , registry ) continue } usernamePass := strings . SplitN ( string ( data ) , ":" , 2 ) if len ( usernamePass ) != 2 { seelog . Warnf ( "Malformed auth data for registry %v; must contain ':'" , registry ) continue } intermediateAuthData [ registry ] = types . AuthConfig { Username : usernamePass [ 0 ] , Password : usernamePass [ 1 ] , } } case "" : return dockerAuths { } default : seelog . Warnf ( "Unknown auth configuration: %v" , authType ) return dockerAuths { } } output := make ( dockerAuths ) for key , val := range intermediateAuthData { output [ stripRegistrySchema ( key ) ] = val } return output }
4010	func NewEnterpriseClient ( url string , httpClient * http . Client ) * Client { return & Client { client : graphql . NewClient ( url , httpClient ) , } }
5164	func NewTx ( name string ) * tx { return & tx { Tracer : & NRTxTracer { } , Reporter : & NRTxReporter { } , name : name , txnType : WebTransaction , ss : NewSegmentStack ( ) , mtx : & sync . Mutex { } , } }
4760	func ( pool * GzipPool ) GetWriter ( dst io . Writer ) ( writer * gzip . Writer ) { if w := pool . pool . Get ( ) ; w != nil { writer = w . ( * gzip . Writer ) writer . Reset ( dst ) } else { writer , _ = gzip . NewWriterLevel ( dst , gzip . BestCompression ) } return writer }
2442	func ( i * Image ) ReplacePixels ( pixels [ ] byte , x , y , width , height int ) { w , h := i . image . Size ( ) if width <= 0 || height <= 0 { panic ( "restorable: width/height must be positive" ) } if x < 0 || y < 0 || w <= x || h <= y || x + width <= 0 || y + height <= 0 || w < x + width || h < y + height { panic ( fmt . Sprintf ( "restorable: out of range x: %d, y: %d, width: %d, height: %d" , x , y , width , height ) ) } theImages . makeStaleIfDependingOn ( i ) if pixels == nil { pixels = make ( [ ] byte , 4 * width * height ) } i . image . ReplacePixels ( pixels , x , y , width , height ) if ! IsRestoringEnabled ( ) { i . makeStale ( ) return } if x == 0 && y == 0 && width == w && height == h { if pixels != nil { if i . basePixels == nil { i . basePixels = & Pixels { length : 4 * w * h , } } i . basePixels . CopyFrom ( pixels , 0 ) } else { i . basePixels = nil } i . drawTrianglesHistory = nil i . stale = false return } if len ( i . drawTrianglesHistory ) > 0 { panic ( "restorable: ReplacePixels for a part after DrawTriangles is forbidden" ) } if i . stale { return } idx := 4 * ( y * w + x ) if pixels != nil { if i . basePixels == nil { i . basePixels = & Pixels { length : 4 * w * h , } } for j := 0 ; j < height ; j ++ { i . basePixels . CopyFrom ( pixels [ 4 * j * width : 4 * ( j + 1 ) * width ] , idx ) idx += 4 * w } } else if i . basePixels != nil { zeros := make ( [ ] byte , 4 * width ) for j := 0 ; j < height ; j ++ { i . basePixels . CopyFrom ( zeros , idx ) idx += 4 * w } } }
2638	func diskSpecForExtend ( dss * object . HostDatastoreSystem , ds * object . Datastore , name string ) ( * types . VmfsDatastoreExtendSpec , error ) { disk , err := availableScsiDisk ( dss , name ) if err != nil { return nil , err } props , err := datastore . Properties ( ds ) if err != nil { return nil , fmt . Errorf ( "error getting properties for datastore ID %q: %s" , ds . Reference ( ) . Value , err ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) options , err := queryVmfsDatastoreExtendOptions ( ctx , dss , ds , disk . DevicePath , true ) if err != nil { return nil , fmt . Errorf ( "could not get disk extension options for %q: %s" , name , err ) } var option * types . VmfsDatastoreOption for _ , o := range options { if _ , ok := o . Info . ( * types . VmfsDatastoreAllExtentOption ) ; ok { option = & o break } } if option == nil { return nil , fmt . Errorf ( "device %q cannot be used as a new whole-disk device for datastore %q" , name , props . Summary . Name ) } return option . Spec . ( * types . VmfsDatastoreExtendSpec ) , nil }
744	func ( p * DigitalOceanProvider ) getRecordID ( records [ ] godo . DomainRecord , record godo . DomainRecord ) int { for _ , zoneRecord := range records { if zoneRecord . Name == record . Name && zoneRecord . Type == record . Type { return zoneRecord . ID } } return 0 }
7152	func ( s * Container ) HasExposedPorts ( ) bool { nodes , err := s . NetworkNodes ( ) if err != nil { return false } for _ , v := range nodes { if v . Port > 0 || len ( v . Protocol ) > 0 { return true } } return false }
5162	func doInit ( license string , appName string , language string , languageVersion string ) ( int , error ) { clicense := C . CString ( license ) defer C . free ( unsafe . Pointer ( clicense ) ) cappName := C . CString ( appName ) defer C . free ( unsafe . Pointer ( cappName ) ) clang := C . CString ( "Go" ) defer C . free ( unsafe . Pointer ( clang ) ) clangVersion := C . CString ( runtime . Version ( ) ) defer C . free ( unsafe . Pointer ( clangVersion ) ) errno := C . newrelic_init ( clicense , cappName , clang , clangVersion ) return errNo ( errno ) }
1359	func ( agent * ecsAgent ) getContainerInstanceTagsFromEC2API ( ) ( [ ] * ecs . Tag , error ) { instanceID , err := agent . ec2MetadataClient . InstanceID ( ) if err != nil { return nil , err } return agent . ec2Client . DescribeECSTagsForInstance ( instanceID ) }
3864	func ( c * Cursor ) Listen ( line [ ] rune , pos int , key rune ) ( [ ] rune , int , bool ) { if line != nil { c . Update ( string ( line ) ) } switch key { case 0 : case KeyEnter : return [ ] rune ( c . Get ( ) ) , c . Position , false case KeyBackspace : if c . erase { c . erase = false c . Replace ( "" ) } c . Backspace ( ) case KeyForward : c . erase = false c . Move ( 1 ) case KeyBackward : c . Move ( - 1 ) default : if c . erase { c . erase = false c . Replace ( "" ) c . Update ( string ( key ) ) } } return [ ] rune ( c . Get ( ) ) , c . Position , true }
6817	func ( c * Client ) Rules ( params map [ string ] string ) ( Rules , error ) { res , err := c . api . Call ( "GET" , c . Url + "/.settings/rules" , c . Auth , nil , params ) if err != nil { return nil , err } var v Rules err = json . Unmarshal ( res , & v ) if err != nil { log . Printf ( "%v\n" , \n ) err } return nil , err }
4878	func ( e * hdbErrors ) Text ( ) string { return string ( e . errors [ e . idx ] . errorText ) }
2724	func resourceVSphereDPMHostOverrideFlattenID ( cluster * object . ClusterComputeResource , host * object . HostSystem ) ( string , error ) { return strings . Join ( [ ] string { cluster . Reference ( ) . Value , host . Reference ( ) . Value } , ":" ) , nil }
5029	func ( s * Session ) Clone ( ) * Session { s . m . Lock ( ) scopy := copySession ( s , true ) s . m . Unlock ( ) return scopy }
5126	func ( h * windowsAnsiEventHandler ) effectiveSr ( window SMALL_RECT ) scrollRegion { top := addInRange ( window . Top , h . sr . top , window . Top , window . Bottom ) bottom := addInRange ( window . Top , h . sr . bottom , window . Top , window . Bottom ) if top >= bottom { top = window . Top bottom = window . Bottom } return scrollRegion { top : top , bottom : bottom } }
2167	func AddFont ( fontPath string ) { path := ( * C . uchar ) ( unsafe . Pointer ( C . CString ( fontPath ) ) ) C . addFont ( path ) }
1487	func ( c * Container ) GetNetworkMode ( ) string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . NetworkModeUnsafe }
1368	func ( handler * TaskHandler ) startDrainEventsTicker ( ) { derivedCtx , cancel := context . WithCancel ( handler . ctx ) defer cancel ( ) ticker := utils . NewJitteredTicker ( derivedCtx , handler . minDrainEventsFrequency , handler . maxDrainEventsFrequency ) for { select { case <- handler . ctx . Done ( ) : seelog . Infof ( "TaskHandler: Stopping periodic container state change submission ticker" ) return case <- ticker : for _ , taskEvent := range handler . taskStateChangesToSend ( ) { seelog . Infof ( "TaskHandler: Adding a state change event to send batched container events: %s" , taskEvent . String ( ) ) handler . AddStateChangeEvent ( taskEvent , handler . client ) } } } }
3591	func ( t * ThresholdWindows ) HasRecoveryWindow ( ) bool { if t != nil && t . RecoveryWindow != nil { return true } return false }
4344	func BuildKeypad ( ) Graph { data , err := data . Asset ( "data/Keypad.json" ) if err != nil { panic ( "Can't find asset" ) } return getAdjancencyGraphFromFile ( data , "keypad" ) }
317	func NewBufferIterator ( it SeriesIterator , delta int64 ) * BufferedSeriesIterator { bit := & BufferedSeriesIterator { buf : newSampleRing ( delta , 16 ) , delta : delta , } bit . Reset ( it ) return bit }
1696	func ( change * TaskStateChange ) ShouldBeReported ( ) bool { if change . Status == apitaskstatus . TaskRunning || change . Status == apitaskstatus . TaskStopped { return true } if len ( change . Containers ) != 0 { return true } return false }
751	func endpointsForHostname ( hostname string , targets endpoint . Targets , ttl endpoint . TTL , providerSpecific endpoint . ProviderSpecific ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint var aTargets endpoint . Targets var cnameTargets endpoint . Targets for _ , t := range targets { switch suitableType ( t ) { case endpoint . RecordTypeA : aTargets = append ( aTargets , t ) default : cnameTargets = append ( cnameTargets , t ) } } if len ( aTargets ) > 0 { epA := & endpoint . Endpoint { DNSName : strings . TrimSuffix ( hostname , "." ) , Targets : aTargets , RecordTTL : ttl , RecordType : endpoint . RecordTypeA , Labels : endpoint . NewLabels ( ) , ProviderSpecific : providerSpecific , } endpoints = append ( endpoints , epA ) } if len ( cnameTargets ) > 0 { epCNAME := & endpoint . Endpoint { DNSName : strings . TrimSuffix ( hostname , "." ) , Targets : cnameTargets , RecordTTL : ttl , RecordType : endpoint . RecordTypeCNAME , Labels : endpoint . NewLabels ( ) , ProviderSpecific : providerSpecific , } endpoints = append ( endpoints , epCNAME ) } return endpoints }
6354	func JSONFieldsFromStruct ( v reflect . Value ) [ ] string { if v . Kind ( ) != reflect . Struct { return nil } m := getType2jfm ( v . Type ( ) ) m . lock . Lock ( ) defer m . lock . Unlock ( ) l := make ( [ ] string , 0 , len ( m . fields ) ) for k := range m . fields { l = append ( l , k ) } return l }
3324	func ( g * GraphDefinitionRequest ) HasOrderDirection ( ) bool { if g != nil && g . OrderDirection != nil { return true } return false }
601	func CreateArticle ( w http . ResponseWriter , r * http . Request ) { data := & ArticleRequest { } if err := render . Bind ( r , data ) ; err != nil { render . Render ( w , r , ErrInvalidRequest ( err ) ) return } article := data . Article dbNewArticle ( article ) render . Status ( r , http . StatusCreated ) render . Render ( w , r , NewArticleResponse ( article ) ) }
6661	func ( c * Client ) Request ( req * Request ) ( * Response , error ) { buf := bytes . NewBuffer ( nil ) err := json . NewEncoder ( buf ) . Encode ( req ) if err != nil { return nil , err } reqResp := & Response { } resp , err := c . caller . Call ( "POST" , c . endpoint + "/opengdpr_requests" , buf ) return reqResp , c . json ( resp , err , true , reqResp ) }
555	func URLParamFromCtx ( ctx context . Context , key string ) string { if rctx := RouteContext ( ctx ) ; rctx != nil { return rctx . URLParam ( key ) } return "" }
2761	func flattenVirtualMachineFlagInfo ( d * schema . ResourceData , obj * types . VirtualMachineFlagInfo ) error { d . Set ( "enable_disk_uuid" , obj . DiskUuidEnabled ) d . Set ( "hv_mode" , obj . VirtualExecUsage ) d . Set ( "ept_rvi_mode" , obj . VirtualMmuUsage ) d . Set ( "enable_logging" , obj . EnableLogging ) return nil }
392	func AppendHTMLEscape ( dst [ ] byte , s string ) [ ] byte { if strings . IndexByte ( s , '<' ) < 0 && strings . IndexByte ( s , '>' ) < 0 && strings . IndexByte ( s , '"' ) < 0 && strings . IndexByte ( s , '\'' ) < 0 { return append ( dst , s ... ) } var prev int var sub string for i , n := 0 , len ( s ) ; i < n ; i ++ { sub = "" switch s [ i ] { case '<' : sub = "&lt;" case '>' : sub = "&gt;" case '"' : sub = "&quot;" case '\'' : sub = "&#39;" } if len ( sub ) > 0 { dst = append ( dst , s [ prev : i ] ... ) dst = append ( dst , sub ... ) prev = i + 1 } } return append ( dst , s [ prev : ] ... ) }
5418	func NewBasics ( amount int ) [ ] BasicEntity { entities := make ( [ ] BasicEntity , amount ) lastID := atomic . AddUint64 ( & idInc , uint64 ( amount ) ) for i := 0 ; i < amount ; i ++ { entities [ i ] . id = lastID - uint64 ( amount ) + uint64 ( i ) + 1 } return entities }
4779	func LoadBytes ( conf interface { } , src [ ] byte ) error { return loadConfigBytes ( conf , src , nil , yaml . Unmarshal ) }
2715	func resourceVSphereVirtualMachineUpdateReconfigureWithSDRS ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , spec types . VirtualMachineConfigSpec , ) error { if ! storagepod . HasDiskCreationOperations ( spec . DeviceChange ) { log . Printf ( "[DEBUG] No disk operations for reconfiguration of VM %q, deferring to standard API" , vm . InventoryPath ) return virtualmachine . Reconfigure ( vm , spec ) } client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return fmt . Errorf ( "connection ineligible to use datastore_cluster_id: %s" , err ) } log . Printf ( "[DEBUG] %s: Reconfiguring virtual machine through Storage DRS API" , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( "datastore_cluster_id" ) . ( string ) ) if err != nil { return fmt . Errorf ( "error getting datastore cluster: %s" , err ) } err = storagepod . ReconfigureVM ( client , vm , spec , pod ) if err != nil { return fmt . Errorf ( "error reconfiguring VM on datastore cluster %q: %s" , pod . Name ( ) , err ) } return nil }
1080	func NewCatalogServicesQuery ( s string ) ( * CatalogServicesQuery , error ) { if ! CatalogServicesQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "catalog.services: invalid format: %q" , s ) } m := regexpMatch ( CatalogServicesQueryRe , s ) return & CatalogServicesQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ "dc" ] , } , nil }
7143	func ( s NetworkNode ) FormatDialAddress ( ) string { return fmt . Sprintf ( "%s:%d" , s . IpAddress , s . Port ) }
6166	func ( s * Server ) RespondError ( logger log . Logger , w http . ResponseWriter , err * Error ) { s . respond ( logger , w , & Response { Error : err } ) }
5218	func OptFieldTypeMutex ( cacheType CacheType , cacheSize int ) FieldOption { return func ( options * FieldOptions ) { options . fieldType = FieldTypeMutex options . cacheType = cacheType options . cacheSize = cacheSize } }
1712	func ( task * Task ) initializeASMAuthResource ( credentialsManager credentials . Manager , resourceFields * taskresource . ResourceFields ) { asmAuthResource := asmauth . NewASMAuthResource ( task . Arn , task . getAllASMAuthDataRequirements ( ) , task . ExecutionCredentialsID , credentialsManager , resourceFields . ASMClientCreator ) task . AddResource ( asmauth . ResourceName , asmAuthResource ) for _ , container := range task . Containers { if container . ShouldPullWithASMAuth ( ) { container . BuildResourceDependency ( asmAuthResource . GetName ( ) , resourcestatus . ResourceStatus ( asmauth . ASMAuthStatusCreated ) , apicontainerstatus . ContainerPulled ) } } }
5895	func NewRSASigner ( alg Algorithm , method RSASignerVerifier ) func ( Store , crypto . Hash ) ( Signer , error ) { return func ( store Store , hash crypto . Hash ) ( Signer , error ) { var ok bool var privRaw , pubRaw interface { } var priv * rsa . PrivateKey var pub * rsa . PublicKey if privRaw , ok = store . PrivateKey ( ) ; ok { if priv , ok = privRaw . ( * rsa . PrivateKey ) ; ! ok { return nil , ErrInvalidPrivateKey } if priv . N . BitLen ( ) < RSAMinimumBitLen { return nil , ErrInvalidPrivateKeySize } } if pubRaw , ok = store . PublicKey ( ) ; ok { if pub , ok = pubRaw . ( * rsa . PublicKey ) ; ! ok { return nil , ErrInvalidPublicKey } if pub . N . BitLen ( ) < RSAMinimumBitLen { return nil , ErrInvalidPublicKeySize } } if priv == nil && pub == nil { return nil , ErrMissingPrivateOrPublicKey } return & RSASigner { alg : alg , method : method , hash : hash , priv : priv , pub : pub , } , nil } }
1467	func ( c * Container ) GetSteadyStateStatus ( ) apicontainerstatus . ContainerStatus { if c . SteadyStateStatusUnsafe == nil { return defaultContainerSteadyStateStatus } return * c . SteadyStateStatusUnsafe }
6500	func ( r rpc ) executeRequest ( req * http . Request ) ( [ ] byte , error ) { resp , err := r . auth . getClient ( ) . Do ( req ) if err != nil { return nil , err } defer resp . Body . Close ( ) buf := new ( bytes . Buffer ) buf . ReadFrom ( resp . Body ) bytes := buf . Bytes ( ) if resp . StatusCode != 200 { if len ( bytes ) == 0 { log . Printf ( "Response body was empty" ) } else { log . Printf ( "Response body:\n\t%s\n" , \n ) } \t } \n }
1946	func ( m * MockTaskEngineState ) TaskByArn ( arg0 string ) ( * task . Task , bool ) { ret := m . ctrl . Call ( m , "TaskByArn" , arg0 ) ret0 , _ := ret [ 0 ] . ( * task . Task ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 }
784	func ensureTrailingDot ( hostname string ) string { if net . ParseIP ( hostname ) != nil { return hostname } return strings . TrimSuffix ( hostname , "." ) + "." }
4660	func ( index * CountIndex ) KNearest ( point Point , k int , maxDistance Meters , accept func ( p Point ) bool ) [ ] Point { panic ( "Unsupported operation" ) }
2372	func ( d * decoder ) decode ( ) ( image . Image , error ) { r , err := zlib . NewReader ( d ) if err != nil { return nil , err } defer r . Close ( ) var img image . Image if d . interlace == itNone { img , err = d . readImagePass ( r , 0 , false ) if err != nil { return nil , err } } else if d . interlace == itAdam7 { img , err = d . readImagePass ( nil , 0 , true ) if err != nil { return nil , err } for pass := 0 ; pass < 7 ; pass ++ { imagePass , err := d . readImagePass ( r , pass , false ) if err != nil { return nil , err } if imagePass != nil { d . mergePassInto ( img , imagePass , pass ) } } } n := 0 for i := 0 ; n == 0 && err == nil ; i ++ { if i == 100 { return nil , io . ErrNoProgress } n , err = r . Read ( d . tmp [ : 1 ] ) } if err != nil && err != io . EOF { return nil , FormatError ( err . Error ( ) ) } if n != 0 || d . idatLength != 0 { return nil , FormatError ( "too much pixel data" ) } return img , nil }
1612	func ( m * MockSecretsManagerAPI ) RotateSecret ( arg0 * secretsmanager . RotateSecretInput ) ( * secretsmanager . RotateSecretOutput , error ) { ret := m . ctrl . Call ( m , "RotateSecret" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
7269	func NewCatering ( tournament uuid . UUID , ci Info ) ( * Catering , error ) { c := new ( Catering ) c . UUID , _ = uuid . V4 ( ) c . Tournament = tournament if err := mergo . MergeWithOverwrite ( & c . Info , ci ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not set initial catering info" ) } if err := storage . Store ( c ) ; err != nil { return nil , errors . New ( err . Error ( ) + " - Could not write catering to storage" ) } return c , nil }
702	func ( p * GoogleProvider ) submitChange ( change * dns . Change ) error { if len ( change . Additions ) == 0 && len ( change . Deletions ) == 0 { log . Info ( "All records are already up to date" ) return nil } zones , err := p . Zones ( ) if err != nil { return err } changes := separateChange ( zones , change ) for z , c := range changes { log . Infof ( "Change zone: %v" , z ) for _ , del := range c . Deletions { log . Infof ( "Del records: %s %s %s %d" , del . Name , del . Type , del . Rrdatas , del . Ttl ) } for _ , add := range c . Additions { log . Infof ( "Add records: %s %s %s %d" , add . Name , add . Type , add . Rrdatas , add . Ttl ) } } if p . dryRun { return nil } for z , c := range changes { if _ , err := p . changesClient . Create ( p . project , z , c ) . Do ( ) ; err != nil { return err } } return nil }
7070	func calculateLBA ( rlba [ 6 ] uint8 , is48Bit bool ) int64 { b := [ ] byte { rlba [ 0 ] , rlba [ 1 ] , rlba [ 2 ] , rlba [ 3 ] , rlba [ 4 ] , rlba [ 5 ] , 0 , 0 , } lba := binary . LittleEndian . Uint64 ( b ) if is48Bit { lba &= 0x0000ffffffffffff } else { lba &= 0x0fffffff } return int64 ( lba ) }
2641	func extendVmfsDatastore ( ctx context . Context , s * object . HostDatastoreSystem , ds * object . Datastore , spec types . VmfsDatastoreExtendSpec ) ( * object . Datastore , error ) { req := types . ExtendVmfsDatastore { This : s . Reference ( ) , Datastore : ds . Reference ( ) , Spec : spec , } res , err := methods . ExtendVmfsDatastore ( ctx , s . Client ( ) , & req ) if err != nil { return nil , err } return object . NewDatastore ( s . Client ( ) , res . Returnval ) , nil }
1615	func ( m * MockSecretsManagerAPI ) TagResource ( arg0 * secretsmanager . TagResourceInput ) ( * secretsmanager . TagResourceOutput , error ) { ret := m . ctrl . Call ( m , "TagResource" , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . TagResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
2924	func applyDeviceChange ( l object . VirtualDeviceList , cs [ ] types . BaseVirtualDeviceConfigSpec ) object . VirtualDeviceList { log . Printf ( "[DEBUG] applyDeviceChange: Applying changes: %s" , DeviceChangeString ( cs ) ) log . Printf ( "[DEBUG] applyDeviceChange: Device list before changes: %s" , DeviceListString ( l ) ) for _ , s := range cs { spec := s . GetVirtualDeviceConfigSpec ( ) switch spec . Operation { case types . VirtualDeviceConfigSpecOperationAdd : l = append ( l , spec . Device ) case types . VirtualDeviceConfigSpecOperationEdit : for n , dev := range l { if dev . GetVirtualDevice ( ) . Key == spec . Device . GetVirtualDevice ( ) . Key { l [ n ] = spec . Device } } case types . VirtualDeviceConfigSpecOperationRemove : for i := 0 ; i < len ( l ) ; i ++ { dev := l [ i ] if dev . GetVirtualDevice ( ) . Key == spec . Device . GetVirtualDevice ( ) . Key { l = append ( l [ : i ] , l [ i + 1 : ] ... ) i -- } } default : panic ( "unknown op" ) } } log . Printf ( "[DEBUG] applyDeviceChange: Device list after changes: %s" , DeviceListString ( l ) ) return l }
3345	func ( h * HostActionMute ) HasEndTime ( ) bool { if h != nil && h . EndTime != nil { return true } return false }
5637	func DerivePrivateKey ( privKeyBytes [ ] byte , chainCode [ ] byte , index uint32 , prime bool ) ( [ ] byte , [ ] byte ) { var data [ ] byte if prime { index = index | 0x80000000 data = append ( [ ] byte { byte ( 0 ) } , privKeyBytes ... ) } else { public := PubKeyBytesFromPrivKeyBytes ( privKeyBytes , true ) data = public } data = append ( data , uint32ToBytes ( index ) ... ) data2 , chainCode2 := I64 ( chainCode , data ) x := addScalars ( privKeyBytes , data2 ) return x , chainCode2 }
1009	func ( w * Watcher ) Size ( ) int { w . Lock ( ) defer w . Unlock ( ) return len ( w . depViewMap ) }
2416	func Run ( f func ( ) error ) error { if atomic . LoadInt32 ( & started ) == 0 { } ch := make ( chan struct { } ) var err error funcs <- func ( ) { err = f ( ) close ( ch ) } <- ch return err }
150	func ( r * Result ) Scalar ( ) ( Scalar , error ) { if r . Err != nil { return Scalar { } , r . Err } v , ok := r . Value . ( Scalar ) if ! ok { return Scalar { } , errors . New ( "query result is not a Scalar" ) } return v , nil }
6690	func ( c * Client ) Servers ( ) ( [ ] Server , error ) { var servers [ ] Server _ , err := c . MakeApiRequest ( "GET" , "/1.0/servers" , nil , & servers ) if err != nil { return nil , err } return servers , err }
3838	func ( s * Select ) RunCursorAt ( cursorPos , scroll int ) ( int , string , error ) { if s . Size == 0 { s . Size = 5 } l , err := list . New ( s . Items , s . Size ) if err != nil { return 0 , "" , err } l . Searcher = s . Searcher s . list = l s . setKeys ( ) err = s . prepareTemplates ( ) if err != nil { return 0 , "" , err } return s . innerRun ( cursorPos , scroll , ' ' ) }
2277	func ( v * SearchEntry ) native ( ) * C . GtkSearchEntry { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSearchEntry ( p ) }
4874	func ( e * hdbErrors ) SetIdx ( idx int ) { switch { case idx < 0 : e . idx = 0 case idx >= e . numArg : e . idx = e . numArg - 1 default : e . idx = idx } }
6289	func ( t * BTTracer ) SetPipes ( stdin io . Reader , stderr io . Writer ) { t . m . Lock ( ) defer t . m . Unlock ( ) t . p . stdin = stdin t . p . stderr = stderr }
44	func Load ( s string ) ( * Config , error ) { cfg := & Config { } * cfg = DefaultConfig err := yaml . UnmarshalStrict ( [ ] byte ( s ) , cfg ) if err != nil { return nil , err } cfg . original = s return cfg , nil }
6309	func ( handler ControllerHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { handler . getResponse ( r ) . Send ( w ) }
6794	func Publish ( channels [ ] string , msg interface { } ) error { if hubInstance == nil { return errorNohub } log . Debug ( "publish to %v" , channels ) hubInstance . Publish ( channels , msg ) return nil }
2952	func flattenStorageDrsAutomationConfig ( d * schema . ResourceData , obj * types . StorageDrsAutomationConfig ) error { attrs := map [ string ] interface { } { "sdrs_io_balance_automation_level" : obj . IoLoadBalanceAutomationMode , "sdrs_policy_enforcement_automation_level" : obj . PolicyEnforcementAutomationMode , "sdrs_rule_enforcement_automation_level" : obj . RuleEnforcementAutomationMode , "sdrs_space_balance_automation_level" : obj . SpaceLoadBalanceAutomationMode , "sdrs_vm_evacuation_automation_level" : obj . VmEvacuationAutomationMode , } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( "error setting attribute %q: %s" , k , err ) } } return nil }
4574	func ( b * Bucket ) less ( r * Bucket ) bool { if b . First || r . First { return b . First } return b . Signature . less ( & r . Signature ) }
1443	func ( state * DockerTaskEngineState ) AddImageState ( imageState * image . ImageState ) { if imageState == nil { log . Debug ( "Cannot add empty image state" ) return } if imageState . Image . ImageID == "" { log . Debug ( "Cannot add image state with empty image id" ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) state . imageStates [ imageState . Image . ImageID ] = imageState }
6167	func ( s * Server ) handlePay ( w http . ResponseWriter , r * http . Request , ctx * srv . Context ) { logger := s . logger . Add ( "method" , "handlePay" , "sender" , r . RemoteAddr ) payload := & paymentPayload { } if ! s . ParseRequest ( logger , w , r , payload ) { return } logger = logger . Add ( "payload" , * payload ) ch , ok := s . findChannel ( logger , w , payload . OfferingHash , payload . AgentAddress , payload . OpenBlockNumber ) logger = logger . Add ( "channel" , ch ) if ok && s . isServiceTerminated ( logger , w , ch ) { return } if ! ok || ! s . validateChannelForPayment ( logger , w , ch , payload ) || ! s . updateChannelWithPayment ( logger , w , ch , payload ) { return } s . RespondResult ( logger , w , struct { } { } ) logger . Info ( fmt . Sprintf ( "received payment: %d, from: %s" , payload . Balance , ch . Client ) ) }
4293	func labelIndex ( labels * bpfLabels , lb string ) uint32 { var id uint32 for id = 0 ; id < uint32 ( len ( * labels ) ) ; id ++ { if strings . EqualFold ( lb , ( * labels ) [ id ] . label ) { return id } } * labels = append ( * labels , bpfLabel { lb , 0xffffffff } ) return id }
3987	func IsIA5String ( raw [ ] byte ) bool { for _ , b := range raw { i := int ( b ) if i > 127 || i < 0 { return false } } return true }
463	func ( req * Request ) RequestURI ( ) [ ] byte { if req . parsedURI { requestURI := req . uri . RequestURI ( ) req . SetRequestURIBytes ( requestURI ) } return req . Header . RequestURI ( ) }
340	func ( rule * RecordingRule ) Eval ( ctx context . Context , ts time . Time , query QueryFunc , _ * url . URL ) ( promql . Vector , error ) { vector , err := query ( ctx , rule . vector . String ( ) , ts ) if err != nil { rule . SetHealth ( HealthBad ) rule . SetLastError ( err ) return nil , err } for i := range vector { sample := & vector [ i ] lb := labels . NewBuilder ( sample . Metric ) lb . Set ( labels . MetricName , rule . name ) for _ , l := range rule . labels { if l . Value == "" { lb . Del ( l . Name ) } else { lb . Set ( l . Name , l . Value ) } } sample . Metric = lb . Labels ( ) } rule . SetHealth ( HealthGood ) rule . SetLastError ( err ) return vector , nil }
4110	func ( b * ProgressBar ) SetSecondaryColors ( fg , bg term . Attribute ) { b . emptyFg , b . emptyBg = fg , bg }
1495	func ( c * Container ) SetASMDockerAuthConfig ( dac types . AuthConfig ) { c . RegistryAuthentication . ASMAuthData . SetDockerAuthConfig ( dac ) }
5235	func NewURIFromAddress ( address string ) ( * URI , error ) { uri , err := parseAddress ( address ) if err != nil { return & URI { error : err } , err } return uri , err }
3442	func ( o * Options ) HasThresholds ( ) bool { if o != nil && o . Thresholds != nil { return true } return false }
4061	func SysObject ( object string ) string { thememtx . RLock ( ) sch , ok := themeManager . themes [ themeManager . current ] if ! ok { sch = themeManager . themes [ defaultTheme ] } thememtx . RUnlock ( ) obj , okobj := sch . objects [ object ] if ! okobj { visited := make ( map [ string ] int , 0 ) visited [ themeManager . current ] = 1 if ! ok { visited [ defaultTheme ] = 1 } for { if sch . parent == "" { break } themeManager . loadTheme ( sch . parent ) thememtx . RLock ( ) sch = themeManager . themes [ sch . parent ] obj , okobj = sch . objects [ object ] thememtx . RUnlock ( ) if ok { break } else { if _ , okSch := visited [ sch . parent ] ; okSch { panic ( "Object: " + object + ". Theme loop detected: " + sch . title + " + sch . parent ) } else { visited [ sch . parent ] = 1 } } } } return obj }
1760	func ( task * Task ) AddResource ( resourceType string , resource taskresource . TaskResource ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . ResourcesMapUnsafe [ resourceType ] = append ( task . ResourcesMapUnsafe [ resourceType ] , resource ) }
3868	func ( p * Package ) Var ( name string ) ( g * Global ) { g , _ = p . Members [ name ] . ( * Global ) return }
956	func vaultSecretRenewable ( s * Secret ) bool { if s . Auth != nil { return s . Auth . Renewable } return s . Renewable }
5671	func parenthesize ( ps * printState , val AST ) { paren := false switch v := val . ( type ) { case * Name , * InitializerList , * FunctionParam : case * Qualified : if v . LocalName { paren = true } default : paren = true } if paren { ps . writeByte ( '(' ) } ps . print ( val ) if paren { ps . writeByte ( ')' ) } }
7294	func ( tx Tx ) CreateBucketIfNotExists ( folders [ ] [ ] byte ) ( Bucket , error ) { b , err := tx . Tx . CreateBucketIfNotExists ( folders [ 0 ] ) if err != nil { return Bucket { } , nil } if len ( folders ) == 1 { return Bucket { b } , nil } return Bucket { b } . CreateBucketIfNotExists ( folders [ 1 : ] ) }
1212	func ( dg * dockerGoClient ) ListPluginsWithFilters ( ctx context . Context , enabled bool , capabilities [ ] string , timeout time . Duration ) ( [ ] string , error ) { filterList := filters . NewArgs ( filters . Arg ( "enabled" , strconv . FormatBool ( enabled ) ) ) for _ , capability := range capabilities { filterList . Add ( "capability" , capability ) } var filteredPluginNames [ ] string response := dg . ListPlugins ( ctx , timeout , filterList ) if response . Error != nil { return nil , response . Error } for _ , plugin := range response . Plugins { filteredPluginNames = append ( filteredPluginNames , plugin . Name ) } return filteredPluginNames , nil }
1420	func ( client * APIECSClient ) CreateCluster ( clusterName string ) ( string , error ) { resp , err := client . standardClient . CreateCluster ( & ecs . CreateClusterInput { ClusterName : & clusterName } ) if err != nil { seelog . Criticalf ( "Could not create cluster: %v" , err ) return "" , err } seelog . Infof ( "Created a cluster named: %s" , clusterName ) return * resp . Cluster . ClusterName , nil }
3140	func ( c * Cache ) Pop ( key string ) ( p * points . Points , exists bool ) { shard := c . GetShard ( key ) shard . Lock ( ) p , exists = shard . items [ key ] delete ( shard . items , key ) shard . Unlock ( ) if exists { atomic . AddInt32 ( & c . stat . size , - int32 ( len ( p . Data ) ) ) } return p , exists }
538	func ( c * Cookie ) SetValueBytes ( value [ ] byte ) { c . value = append ( c . value [ : 0 ] , value ... ) }
7140	func ( pka PublicKeyAlgorithm ) CanSign ( ) bool { switch pka { case PubKeyAlgoRSA , PubKeyAlgoRSASignOnly , PubKeyAlgoDSA : return true } return false }
4545	func ParseImageName ( image string ) ( ImageName , error ) { ret := ImageName { } img , err := registry . ParseImage ( image ) if err != nil { return ret , err } ret . Registry = img . Domain ret . Name = img . Path ret . Digest = img . Digest . String ( ) ret . Tag = img . Tag return ret , nil }
6620	func selfCmder ( ) ( Cmder , error ) { pathToSelf , err := osext . Executable ( ) if err != nil { return nil , errors . Wrapf ( err , "failed to determine path for current executable" ) } return PathCmder ( pathToSelf ) , nil }
5782	func ( cm * CheckManager ) fetchCert ( ) ( [ ] byte , error ) { if ! cm . enabled { return nil , errors . New ( "check manager is not enabled" ) } response , err := cm . apih . Get ( "/pki/ca.crt" ) if err != nil { return nil , err } cadata := new ( CACert ) if err := json . Unmarshal ( response , cadata ) ; err != nil { return nil , err } if cadata . Contents == "" { return nil , fmt . Errorf ( "[ERROR] Unable to find ca cert %+v" , cadata ) } return [ ] byte ( cadata . Contents ) , nil }
1816	func ( m * MockCache ) Delete ( arg0 string ) { m . ctrl . Call ( m , "Delete" , arg0 ) }
6686	func ErrInvalidRequestSignature ( signature string , err error ) error { return ErrorResponse { Code : http . StatusForbidden , Message : fmt . Sprintf ( "could not validate request signature: %s" , signature ) , Errors : [ ] Error { Error { Message : err . Error ( ) } } , } }
6515	func ( c Client ) CreateUser ( email string , password string ) ( * user , error ) { params := map [ string ] interface { } { "user[email]" : email , "user[password]" : password , } holder := userHolder { } if err := c . Post ( "users" , params , & holder ) ; err != nil { return nil , err } if err := checkApiErrors ( holder . response , "CreateUser" ) ; err != nil { return nil , err } return & holder . User , nil }
3932	func DNSResolveCheck ( host string , timeout time . Duration ) Check { resolver := net . Resolver { } return func ( ) error { ctx , cancel := context . WithTimeout ( context . Background ( ) , timeout ) defer cancel ( ) addrs , err := resolver . LookupHost ( ctx , host ) if err != nil { return err } if len ( addrs ) < 1 { return fmt . Errorf ( "could not resolve host" ) } return nil } }
1263	func ( vol * VolumeResource ) Create ( ) error { seelog . Debugf ( "Creating volume with name %s using driver %s" , vol . VolumeConfig . DockerVolumeName , vol . VolumeConfig . Driver ) volumeResponse := vol . client . CreateVolume ( vol . ctx , vol . VolumeConfig . DockerVolumeName , vol . VolumeConfig . Driver , vol . VolumeConfig . DriverOpts , vol . VolumeConfig . Labels , dockerclient . CreateVolumeTimeout ) if volumeResponse . Error != nil { return volumeResponse . Error } vol . setMountPoint ( volumeResponse . DockerVolume . Name ) return nil }
2907	func ( r * Subresource ) Hash ( ) int { hf := schema . HashResource ( & schema . Resource { Schema : r . schema } ) return hf ( r . data ) }
5792	func ( a * API ) FetchOutlierReports ( ) ( * [ ] OutlierReport , error ) { result , err := a . Get ( config . OutlierReportPrefix ) if err != nil { return nil , err } var reports [ ] OutlierReport if err := json . Unmarshal ( result , & reports ) ; err != nil { return nil , err } return & reports , nil }
2902	func ( r * Subresource ) HasChange ( key string ) bool { o , n := r . GetChange ( key ) return ! reflect . DeepEqual ( o , n ) }
2991	func ( r * DiskSubresource ) findVirtualDisk ( l object . VirtualDeviceList , fallback bool ) ( * types . VirtualDisk , error ) { device , err := r . findVirtualDiskByUUIDOrAddress ( l , fallback ) if err != nil { return nil , err } return device . ( * types . VirtualDisk ) , nil }
2032	func ( task * Task ) overrideCgroupParent ( hostConfig * dockercontainer . HostConfig ) error { task . lock . RLock ( ) defer task . lock . RUnlock ( ) if task . MemoryCPULimitsEnabled { cgroupRoot , err := task . BuildCgroupRoot ( ) if err != nil { return errors . Wrapf ( err , "task cgroup override: unable to obtain cgroup root for task: %s" , task . Arn ) } hostConfig . CgroupParent = cgroupRoot } return nil }
1156	func ( c * ec2MetadataClientImpl ) GetMetadata ( path string ) ( string , error ) { return c . client . GetMetadata ( path ) }
2009	func ExtractVersion ( input string ) string { versionNumberRegex := regexp . MustCompile ( ` v(\d+\.\d+\.\d+(\-[\S\.\-]+)?(\+[\S\.\-]+)?)` ) versionNumberStr := versionNumberRegex . FindStringSubmatch ( input ) if len ( versionNumberStr ) >= 2 { return string ( versionNumberStr [ 1 ] ) } return "UNKNOWN" }
5876	func ( rs * Ruleset ) Capitalize ( word string ) string { return strings . ToUpper ( word [ : 1 ] ) + word [ 1 : ] }
3443	func ( o * Options ) GetThresholdWindows ( ) ThresholdWindows { if o == nil || o . ThresholdWindows == nil { return ThresholdWindows { } } return * o . ThresholdWindows }
3002	func resourceVSphereVAppContainerApplyTags ( d * schema . ResourceData , meta interface { } , va * object . VirtualApp ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } if tagsClient == nil { log . Printf ( "[DEBUG] %s: Tags unsupported on this connection, skipping" , resourceVSphereComputeClusterIDString ( d ) ) return nil } log . Printf ( "[DEBUG] %s: Applying any pending tags" , resourceVSphereVAppContainerIDString ( d ) ) return processTagDiff ( tagsClient , d , va ) }
5028	func ( s * Session ) Copy ( ) * Session { s . m . Lock ( ) scopy := copySession ( s , true ) s . m . Unlock ( ) scopy . Refresh ( ) return scopy }
5927	func PostCount ( statKey , userKey string , count int ) error { return DefaultReporter . PostCount ( statKey , userKey , count ) }
1020	func NewKVListQuery ( s string ) ( * KVListQuery , error ) { if s != "" && ! KVListQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( "kv.list: invalid format: %q" , s ) } m := regexpMatch ( KVListQueryRe , s ) return & KVListQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ "dc" ] , prefix : m [ "prefix" ] , } , nil }
4157	func ParseMessage ( line string ) Message { ircMessage , err := parseIRCMessage ( line ) if err != nil { return parseRawMessage ( ircMessage ) } if mt , ok := messageTypeMap [ ircMessage . Command ] ; ok { return mt . Parser ( ircMessage ) } return parseRawMessage ( ircMessage ) }
201	func ( g * Group ) evalTimestamp ( ) time . Time { var ( offset = int64 ( g . hash ( ) % uint64 ( g . interval ) ) now = time . Now ( ) . UnixNano ( ) adjNow = now - offset base = adjNow - ( adjNow % int64 ( g . interval ) ) ) return time . Unix ( 0 , base + offset ) }
5922	func isSameArray ( val1 , val2 [ ] byte ) bool { if len ( val1 ) == len ( val2 ) && len ( val1 ) > 0 { return & val1 [ 0 ] == & val2 [ 0 ] } return false }
6311	func ( handler ControllerHandler ) isValid ( ) bool { controller := handler . factory ( ) rController := reflect . ValueOf ( controller ) method := rController . MethodByName ( handler . methodName ) if ( method == reflect . Value { } ) { panic ( "No such method: " + handler . methodName ) } typeOfMethod := method . Type ( ) var r * Response responseType := reflect . TypeOf ( r ) . Elem ( ) return ( method . Kind ( ) == reflect . Func ) && ( typeOfMethod . NumMethod ( ) == 0 ) && ( typeOfMethod . NumOut ( ) == 1 ) && typeOfMethod . Out ( 0 ) == responseType }
1416	func NewMockSaveableOption ( ctrl * gomock . Controller ) * MockSaveableOption { mock := & MockSaveableOption { ctrl : ctrl } mock . recorder = & MockSaveableOptionMockRecorder { mock } return mock }
2059	func NewPortBindingsResponse ( dockerContainer * apicontainer . DockerContainer , eni * apieni . ENI ) [ ] PortResponse { container := dockerContainer . Container resp := [ ] PortResponse { } bindings := container . GetKnownPortBindings ( ) if len ( bindings ) == 0 { bindings = container . Ports } for _ , binding := range bindings { port := PortResponse { ContainerPort : binding . ContainerPort , Protocol : binding . Protocol . String ( ) , } if eni == nil { port . HostPort = binding . HostPort } else { port . HostPort = port . ContainerPort } resp = append ( resp , port ) } return resp }
6233	func ( s * Server ) RequireHTTPMethods ( logger log . Logger , handler HandlerFunc , methods ... string ) HandlerFunc { l := logger . Add ( "method" , "RequireHTTPMethods" ) return func ( w http . ResponseWriter , r * http . Request , ctx * Context ) { for _ , v := range methods { if v == r . Method { handler ( w , r , ctx ) return } } l . Add ( "sender" , r . RemoteAddr ) . Warn ( "not allowed HTTP method" ) s . RespondError ( logger , w , ErrMethodNotAllowed ) } }
1912	func ( mr * MockSSMClientMockRecorder ) GetParameters ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , "GetParameters" , reflect . TypeOf ( ( * MockSSMClient ) ( nil ) . GetParameters ) , arg0 ) }
3308	func ( e * Event ) GetSourceTypeOk ( ) ( string , bool ) { if e == nil || e . SourceType == nil { return "" , false } return * e . SourceType , true }
687	func NewDnsimpleProvider ( domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , dryRun bool ) ( Provider , error ) { oauthToken := os . Getenv ( "DNSIMPLE_OAUTH" ) if len ( oauthToken ) == 0 { return nil , fmt . Errorf ( "No dnsimple oauth token provided" ) } client := dnsimple . NewClient ( dnsimple . NewOauthTokenCredentials ( oauthToken ) ) provider := & dnsimpleProvider { client : dnsimpleZoneService { service : client . Zones } , identity : identityService { service : client . Identity } , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , dryRun : dryRun , } whoamiResponse , err := provider . identity . service . Whoami ( ) if err != nil { return nil , err } provider . accountID = strconv . Itoa ( whoamiResponse . Data . Account . ID ) return provider , nil }
1520	func ( imageManager * dockerImageManager ) getImageState ( containerImageID string ) ( * image . ImageState , bool ) { for _ , imageState := range imageManager . getAllImageStates ( ) { if imageState . Image . ImageID == containerImageID { return imageState , true } } return nil , false }
5949	func ( h Host ) Diff ( altHost Host ) ( added [ ] Port , removed [ ] Port ) { targetPorts := h . Ports altPorts := altHost . Ports addedWithClosed := array . Except ( altPorts , targetPorts ) . ( [ ] Port ) for _ , add := range addedWithClosed { if add . State != "closed" { added = append ( added , add ) } } removedWithClosed := array . Except ( targetPorts , altPorts ) . ( [ ] Port ) for _ , remove := range removedWithClosed { if remove . State != "closed" { removed = append ( removed , remove ) } } return }
1436	func ( state * DockerTaskEngineState ) ContainerByID ( id string ) ( * apicontainer . DockerContainer , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) c , ok := state . idToContainer [ id ] return c , ok }
205	func ( m * Manager ) Update ( interval time . Duration , files [ ] string , externalLabels labels . Labels ) error { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) groups , errs := m . LoadGroups ( interval , externalLabels , files ... ) if errs != nil { for _ , e := range errs { level . Error ( m . logger ) . Log ( "msg" , "loading groups failed" , "err" , e ) } return errors . New ( "error loading rules, previous rule set restored" ) } m . restored = true var wg sync . WaitGroup for _ , newg := range groups { wg . Add ( 1 ) gn := groupKey ( newg . name , newg . file ) oldg , ok := m . groups [ gn ] delete ( m . groups , gn ) go func ( newg * Group ) { if ok { oldg . stop ( ) newg . CopyState ( oldg ) } go func ( ) { <- m . block newg . run ( m . opts . Context ) } ( ) wg . Done ( ) } ( newg ) } for _ , oldg := range m . groups { oldg . stop ( ) } wg . Wait ( ) m . groups = groups return nil }
4927	func ( w * Writer ) WriteInt16 ( i int16 ) { if w . err != nil { return } binary . LittleEndian . PutUint16 ( w . b [ : 2 ] , uint16 ( i ) ) w . wr . Write ( w . b [ : 2 ] ) }
5885	func Expiration ( expiration time . Duration ) Option { return func ( gsa * GServiceAccount ) error { gsa . expiration = expiration return nil } }
3158	func oldPlain ( body [ ] byte ) ( [ ] * points . Points , error ) { result := make ( [ ] * points . Points , 4 ) reader := bytes . NewBuffer ( body ) for { line , err := reader . ReadBytes ( '\n' ) if err != nil && err != io . EOF { return result , err } if len ( line ) == 0 { break } if line [ len ( line ) - 1 ] != '\n' { return result , errors . New ( "unfinished line in file" ) } p , err := points . ParseText ( string ( line ) ) if err != nil { return result , err } result = append ( result , p ) } return result , nil }
4832	func ( h hookIgnoredError ) Error ( ) string { return fmt . Sprintf ( "%s webhook ignored. Error: %v" , h . hookType , h . err ) }
7062	func GetErrorHandler ( ctx context . Context , status int ) ErrorHandler { key := fmt . Sprintf ( "error_handler_%d" , status ) if h , ok := ctx . Value ( key ) . ( ErrorHandler ) ; ok { return h } key = fmt . Sprintf ( "error_handler_%d" , AllStatusCodes ) if h , ok := ctx . Value ( key ) . ( ErrorHandler ) ; ok { return h } return DefaultErrorHandler }
5477	func ( pn PhoneNumber ) Friendly ( ) string { num , err := libphonenumber . Parse ( string ( pn ) , "US" ) if err != nil { return string ( pn ) } return libphonenumber . Format ( num , libphonenumber . INTERNATIONAL ) }
539	func ( c * Cookie ) SetKey ( key string ) { c . key = append ( c . key [ : 0 ] , key ... ) }
213	func ( w * WALWatcher ) Stop ( ) { close ( w . quit ) <- w . done watcherRecordsRead . DeleteLabelValues ( w . name , "series" ) watcherRecordsRead . DeleteLabelValues ( w . name , "samples" ) watcherRecordDecodeFails . DeleteLabelValues ( w . name ) watcherSamplesSentPreTailing . DeleteLabelValues ( w . name ) watcherCurrentSegment . DeleteLabelValues ( w . name ) level . Info ( w . logger ) . Log ( "msg" , "WAL watcher stopped" , "queue" , w . name ) }
6835	func ( d * Device ) PushNote ( title , body string ) error { return d . Client . PushNote ( d . Iden , title , body ) }
1371	func ( handler * TaskHandler ) flushBatchUnsafe ( taskStateChange * api . TaskStateChange , client api . ECSClient ) { taskStateChange . Containers = append ( taskStateChange . Containers , handler . tasksToContainerStates [ taskStateChange . TaskARN ] ... ) delete ( handler . tasksToContainerStates , taskStateChange . TaskARN ) event := newSendableTaskEvent ( * taskStateChange ) taskEvents := handler . getTaskEventsUnsafe ( event ) taskEvents . sendChange ( event , client , handler ) }
2986	func ( l virtualDeviceListSorter ) Less ( i , j int ) bool { li := l . Sort [ i ] lj := l . Sort [ j ] liCtlr := l . DeviceList . FindByKey ( li . GetVirtualDevice ( ) . ControllerKey ) ljCtlr := l . DeviceList . FindByKey ( lj . GetVirtualDevice ( ) . ControllerKey ) if liCtlr == nil || ljCtlr == nil { panic ( errors . New ( "virtualDeviceListSorter cannot be used with devices that are not assigned to a controller" ) ) } if liCtlr . ( types . BaseVirtualController ) . GetVirtualController ( ) . BusNumber < liCtlr . ( types . BaseVirtualController ) . GetVirtualController ( ) . BusNumber { return true } liUnit := li . GetVirtualDevice ( ) . UnitNumber ljUnit := lj . GetVirtualDevice ( ) . UnitNumber if liUnit == nil || ljUnit == nil { panic ( errors . New ( "virtualDeviceListSorter cannot be used with devices that do not have unit numbers set" ) ) } return * liUnit < * ljUnit }
795	func newRecordOperation ( ep * endpoint . Endpoint , opType dns . RecordOperationOperationEnum ) dns . RecordOperation { targets := make ( [ ] string , len ( ep . Targets ) ) copy ( targets , [ ] string ( ep . Targets ) ) if ep . RecordType == endpoint . RecordTypeCNAME { targets [ 0 ] = ensureTrailingDot ( targets [ 0 ] ) } rdata := strings . Join ( targets , " " ) ttl := ociRecordTTL if ep . RecordTTL . IsConfigured ( ) { ttl = int ( ep . RecordTTL ) } return dns . RecordOperation { Domain : & ep . DNSName , Rdata : & rdata , Ttl : & ttl , Rtype : & ep . RecordType , Operation : opType , } }
2624	func SetBoolPolicy ( d * schema . ResourceData , key string , val * types . BoolPolicy ) error { if val == nil { return nil } err := d . Set ( key , val . Value ) return err }
2671	func expandClusterVMComponentProtectionSettings ( d * schema . ResourceData ) * types . ClusterVmComponentProtectionSettings { obj := & types . ClusterVmComponentProtectionSettings { VmReactionOnAPDCleared : d . Get ( "ha_datastore_apd_recovery_action" ) . ( string ) , VmStorageProtectionForAPD : d . Get ( "ha_datastore_apd_response" ) . ( string ) , VmStorageProtectionForPDL : d . Get ( "ha_datastore_pdl_response" ) . ( string ) , VmTerminateDelayForAPDSec : int32 ( d . Get ( "ha_datastore_apd_response_delay" ) . ( int ) ) , } if d . Get ( "ha_datastore_apd_response" ) . ( string ) != string ( types . ClusterVmComponentProtectionSettingsStorageVmReactionDisabled ) { obj . EnableAPDTimeoutForHosts = structure . BoolPtr ( true ) } return obj }
4486	func ( d Date ) Value ( ) ( driver . Value , error ) { return driver . Value ( d . String ( ) ) , nil }
4671	func setCache ( name string , tpl template . Template ) { cacheMutex . Lock ( ) cache [ name ] = tpl cacheMutex . Unlock ( ) }
3703	func ( w * Widget ) GetMustShowLatency ( ) bool { if w == nil || w . MustShowLatency == nil { return false } return * w . MustShowLatency }
5182	func ( c * LRU ) RemoveOldest ( ) ( key string , value uint64 , ok bool ) { ent := c . evictList . Back ( ) if ent != nil { c . removeElement ( ent ) kv := ent . Value . ( * entry ) return kv . key , kv . value , true } return "" , 0 , false }
1573	func ( m * MockSecretsManagerAPI ) CancelRotateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . CancelRotateSecretInput , arg2 ... request . Option ) ( * secretsmanager . CancelRotateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , "CancelRotateSecretWithContext" , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CancelRotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 }
